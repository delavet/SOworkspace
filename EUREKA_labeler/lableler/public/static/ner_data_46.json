[{"text": "If you want to transfer the whole content of the input stream, without even looking at it, you could even set the BLOB column directly to the data from that stream using CallableStatement.setBlob(String,InputStream)", "label": {"api": {"CallableStatement.setBlob(String,InputStream)": [[170, 214]]}}}, {"text": "Make the components transparent by calling setOpaque(false)", "label": {"api": {"setOpaque": [[43, 51]]}}}, {"text": "Have you looked at CountDownLatch from the java.util.concurrent package", "label": {"api": {"CountDownLatch": [[19, 32]]}}}, {"text": "Instances of javax.swing.Timer use \"a single, shared thread (created by the first Timer object that executes).\" Dozens or even scores are perfectly fine, but hundreds typically start to become sluggish", "label": {"api": {"javax.swing.Timer": [[13, 29]]}}}, {"text": "Check the class MimeMessage to help you", "label": {"api": {"MimeMessage": [[16, 26]]}}}, {"text": "For large amounts of UPDATEs, it is best to use Statement.executeBatch()", "label": {"api": {"Statement.executeBatch()": [[48, 71]]}}}, {"text": "Make use of HTML 5's Geolocation API, interfacing with it via the ScriptEngine API", "label": {"api": {"ScriptEngine API": [[66, 81]]}}}, {"text": "I'd like to display the content of a HashSet in a JList", "label": {"api": {"HashSet": [[37, 43]], "JList": [[50, 54]]}}}, {"text": "As I understood from the tutorial, I need to extend/implement a ListModel", "label": {"api": {"ListModel": [[64, 72]]}}}, {"text": "Please provide an appropriate example of overloading ListModel, if it is applicable to my intentions", "label": {"api": {"ListModel": [[53, 61]]}}}, {"text": "Integer, but these are immutable by design", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "I would use the built-in XMLStreamReader, which is the interface implemented by the streaming XML parser (get to it from the XMLInputFactory class)", "label": {"api": {"XMLStreamReader": [[25, 39]]}}}, {"text": "It is also worth looking at an ExecutorService or a ForkJoinPool", "label": {"api": {"an ExecutorService": [[28, 45]], "ForkJoinPool": [[52, 63]]}}}, {"text": "Also, read through the javadocs they are pretty decent", "label": {"api": {"read through the javadocs": [[6, 30]]}}}, {"text": "Java enums have a built-in ordinal, which is 0 for the first enum member, 1 for the second, etc", "label": {"api": {"ordinal": [[27, 33]]}}}, {"text": "You could use some sort of combination of java.util.Properties and Java serialization", "label": {"api": {"java.util.Properties": [[42, 61]]}}}, {"text": "I have implemented java.sql.SQLData in order to bind UDT objects to prepared statements using ojdbc6", "label": {"api": {"java.sql.SQLData": [[19, 34]]}}}, {"text": "I was thinking in mark the associated objects as Cloneable and build a new entity and  make changes there as all the operation in this particular UI are read-only", "label": {"api": {"Cloneable": [[49, 57]]}}}, {"text": "Just use the regular split(String, int) method inside the String class", "label": {"api": {"split(String, int)": [[21, 38]]}}}, {"text": "Once you get the BufferedImage, you can just call the properties getWidth() and getHeight() on it", "label": {"api": {"getWidth()": [[65, 74]], "getHeight()": [[80, 90]]}}}, {"text": "You should use PreparedStatement primarily because it prevents SQL injection attacks", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "@John Moses has posted a tutorial to use PreparedStatement from the Java official documentation, here is another good link", "label": {"api": {"PreparedStatement": [[41, 57]]}}}, {"text": "Moving your code to PreparedStatement, it should be like this", "label": {"api": {"PreparedStatement": [[20, 36]]}}}, {"text": "You can read about them in the javadoc for Pattern", "label": {"api": {"Pattern": [[43, 49]]}}}, {"text": "Anything located inside of parentheses in a Pattern is a capture group", "label": {"api": {"Pattern": [[44, 50]]}}}, {"text": "If you're not confident, see the documentation on arraycopy arraycopy", "label": {"api": {"arraycopy": [[50, 58], [60, 68]]}}}, {"text": "Or if you need an actual number, System.identityHashCode is probably a safe bet", "label": {"api": {"System.identityHashCode": [[33, 55]]}}}, {"text": "There's a giant list of exceptions, all subclasses of Exception", "label": {"api": {"giant list of exceptions": [[10, 33]]}}}, {"text": "You can do it easily with the Robot class", "label": {"api": {"Robot": [[30, 34]]}}}, {"text": "How can I retrieve the type of the field, which is here a javax.lang.model.element.Element", "label": {"api": {"javax.lang.model.element.Element": [[58, 89]]}}}, {"text": "If you want to also check that the other class is a real class (and not an interface) add in a call to isInterface()", "label": {"api": {"isInterface()": [[103, 115]]}}}, {"text": "Excerpt from Javadoc for Class.isAssignableFrom", "label": {"api": {"Class.isAssignableFrom": [[25, 46]]}}}, {"text": "Infinity is a special reserved value in the Double class used when you have exceed the maximum number the a double can hold", "label": {"api": {"Infinity": [[0, 7]], "Double": [[44, 49]]}}}, {"text": "According the java documentation of Float.ParseFloat, it doesn't mention anything about the input being greater than the Float.MAX_VALUE", "label": {"api": {"java documentation of Float.ParseFloat": [[14, 51]]}}}, {"text": "You just need (a) a URLClassLoader that is constructed with the URLs of all the JAR files in those directories, and (b) call ServiceLoader.load(Class service, ClassLoader loader)", "label": {"api": {"ServiceLoader.load(Class service, ClassLoader loader)": [[125, 177]]}}}, {"text": "Why you dont use a Set and later", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "Read more about SimpleDateFormat here", "label": {"api": {"SimpleDateFormat here": [[16, 36]]}}}, {"text": "Firstly, that's not how you use Runtime.exec()", "label": {"api": {"Runtime.exec()": [[32, 45]]}}}, {"text": "String.replaceAll expects an RegEx", "label": {"api": {"String.replaceAll": [[0, 16]]}}}, {"text": "All the special characters for are listed on the API reference page for java.util.regex.Pattern", "label": {"api": {"java.util.regex.Pattern": [[72, 94]]}}}, {"text": "Check out java.security.MessageDigest", "label": {"api": {"java.security.MessageDigest": [[10, 36]]}}}, {"text": "The problem is that String#split receives a regular expression, the dot (.) symbol is a special character in regular expressions, so you need to escape it for it to be interpreted as a plain dot, also as the backslash is an escape character in Java, you have to escape it too", "label": {"api": {"String#split": [[20, 31]]}}}, {"text": "Pattern.quote(String) can also be used to quote the whole string", "label": {"api": {"Pattern.quote(String)": [[0, 20]]}}}, {"text": "The LinkedBlockingQueue is a good class to use if you want your queue to not be limited", "label": {"api": {"LinkedBlockingQueue": [[4, 22]]}}}, {"text": "The ArrayBlockingQueue can be used when you want a limited number of items to be stored in the queue (or LinkedBlockingQueue with an integer passed to the constructor)", "label": {"api": {"LinkedBlockingQueue": [[105, 123]], "ArrayBlockingQueue": [[4, 21]]}}}, {"text": "Use a BlockingQueue<E> for your commands", "label": {"api": {"BlockingQueue<E>": [[6, 21]]}}}, {"text": "You are calculating the differences for March, not February, and you have engulfed the onset of Daylight Saving Time", "label": {"api": {"March": [[40, 44]]}}}, {"text": "Implement a ServletContextListener", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "You should start by reading the javadoc for Pattern", "label": {"api": {"Pattern": [[44, 50]]}}}, {"text": "I'd advise using a Task to execute your startup tasks and message progress back to your splash screen (similar to the approach in this sample created for a prior stackoverflow question on splash screens)", "label": {"api": {"Task": [[19, 22]]}}}, {"text": "From the API", "label": {"api": {"From the API": [[0, 11]]}}}, {"text": "OverlayLayout, shown here, may meet your needs", "label": {"api": {"OverlayLayout": [[0, 12]]}}}, {"text": "See the SocketChannel Documentation and an example", "label": {"api": {"SocketChannel Documentation": [[8, 34]]}}}, {"text": "You'd better start with an ExecutorService instead of going directly with raw threads", "label": {"api": {"ExecutorService": [[27, 41]]}}}, {"text": "You can submit as many asynchronous tasks to the ExecutorService as you like; they will be executed in parallel, or sequentially, depending on the implementation you choose, on the number of threads in the backing thread pool, etc", "label": {"api": {"ExecutorService": [[49, 63]]}}}, {"text": "What you want to do is convert the string to an array using the String class' charAt() method, and then use Character.toUpperCase() to change the character to upper case (obviously)", "label": {"api": {"charAt()": [[78, 85]]}}}, {"text": "You can use the addTab or insertTab methods to add a tab", "label": {"api": {"addTab": [[16, 21]], "insertTab": [[26, 34]]}}}, {"text": "The FileWriter class has a constructor for that with the append parameter", "label": {"api": {"FileWriter": [[4, 13]]}}}, {"text": "I would also recommend Path2D", "label": {"api": {"Path2D": [[23, 28]]}}}, {"text": "GeneralPath is a legacy class; don't use it", "label": {"api": {"GeneralPath": [[0, 10]]}}}, {"text": "Path2D does provide access to the vertex values, albeit it a roundabout fashion", "label": {"api": {"Path2D": [[0, 5]]}}}, {"text": "You need to use a PathIterator", "label": {"api": {"PathIterator": [[18, 29]]}}}, {"text": "Also, Path2D has some handy static methods for testing whether the path intersects a rectangle and whether the path contains a rectangle or point", "label": {"api": {"Path2D": [[6, 11]], "intersects": [[72, 81]], "contains": [[116, 123]]}}}, {"text": "You need to loop the read as long as it returns data (or use something like Files.copy()", "label": {"api": {"Files.copy()": [[76, 87]]}}}, {"text": "I suggest you have a look at ZipFile.entries()", "label": {"api": {"ZipFile.entries()": [[29, 45]]}}}, {"text": "If you need to know whether an entry is a directory or not, you could use ZipEntry.isDirectory", "label": {"api": {"ZipEntry.isDirectory": [[74, 93]]}}}, {"text": "If you want to avoid extracting all files, you can extract one file at a time using ZipFile.getInputStream for each ZipEntry", "label": {"api": {"ZipFile.getInputStream": [[84, 105]]}}}, {"text": "For handling ZIP files you can use class ZipFile", "label": {"api": {"ZipFile": [[41, 47]]}}}, {"text": "It has method entries() which returns list of entries contained within ZIP file", "label": {"api": {"entries()": [[14, 22]]}}}, {"text": "Why not use the Random class, which has a method nextBoolean", "label": {"api": {"Random": [[16, 21]]}}}, {"text": "If you really want to put the jasper files in the webapp, then you need to load the resource using ServletContext.getResource()", "label": {"api": {"ServletContext.getResource()": [[99, 126]]}}}, {"text": "For example you can check out DecimalFormatSymbols", "label": {"api": {"DecimalFormatSymbols": [[30, 49]]}}}, {"text": "Or you could simply use a UUID, or a sequence number returned from a database sequence", "label": {"api": {"UUID": [[26, 29]]}}}, {"text": "Use the Future#get(long, TimeUnit)", "label": {"api": {"Future#get(long, TimeUnit)": [[8, 33]]}}}, {"text": "This will wait for some time for an answer, and throw a TimeoutException if there is no return value in the given period", "label": {"api": {"TimeoutException": [[56, 71]]}}}, {"text": "For example, you can use CountDownLatch", "label": {"api": {"CountDownLatch": [[25, 38]]}}}, {"text": "String.CASE_INSENSITIVE_ORDER is a comparator class that disregards the case when comparing strings", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[0, 28]]}}}, {"text": "Let's start with the documentation for Collections.sort", "label": {"api": {"the documentation for Collections.sort": [[17, 54]]}}}, {"text": "String can tell us", "label": {"api": {"String can tell us": [[0, 17]]}}}, {"text": "If you want a case-insensitive sort, there's a form of sort that takes a Comparator, and String helpfully provides a pre-made CASE_INSENSITIVE_ORDER comparator", "label": {"api": {"a form of sort": [[45, 58]], "CASE_INSENSITIVE_ORDER": [[126, 147]]}}}, {"text": "You can use Collections.synchronizedMap to synchronize access to the Map", "label": {"api": {"Collections.synchronizedMap": [[12, 38]]}}}, {"text": "You should use ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[15, 31]]}}}, {"text": "Use getResourceAsStream (docs), you can do whatever you want with it after that", "label": {"api": {"getResourceAsStream (docs)": [[4, 29]]}}}, {"text": "When opening a file with a reader, you have to specify the encoding", "label": {"api": {"specify the encoding": [[47, 66]]}}}, {"text": "If you look at the javadoc for String specifically", "label": {"api": {"String": [[31, 36]]}}}, {"text": "If you don't want to use regex then try http://docs.oracle.com/javase/1.4.2/docs/api/java/util/StringTokenizer.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/util/StringTokenizer.html": [[40, 114]]}}}, {"text": "You could implement a generic synchronous Future, but that might be misleading", "label": {"api": {"Future": [[42, 47]]}}}, {"text": "Check out ExecutorService", "label": {"api": {"ExecutorService": [[10, 24]]}}}, {"text": "Create a new SwingWorker and invoke that method within it", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "setTitle is what you need, not setName", "label": {"api": {"setTitle": [[0, 7]]}}}, {"text": "You can use Frame#setTitle(String) to set the title of your JFrame", "label": {"api": {"Frame#setTitle(String)": [[12, 33]]}}}, {"text": "If you have an unknown number of integers separated by a ' ' space, you could take them in as a String and use the String.split function - you can find documentation at http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#split(java.lang.String) - which will give you an array which is as large as you need it to be, and whose length is stored in the length field of the array", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#split(java.lang.String": [[169, 257]]}}}, {"text": "However, your collection, ArrayList, is not a thread-safe collection", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "Consider using Collections.synchronizedList() method to instantiate your ArrayList", "label": {"api": {"ArrayList": [[73, 81]], "Collections.synchronizedList()": [[15, 44]]}}}, {"text": "You should take a look at the documentation for clone() method", "label": {"api": {"documentation for clone()": [[30, 54]]}}}, {"text": "In my library's code, I load class names from an XML file using JAXB, in order to instanciate them later on using Class.forName()", "label": {"api": {"Class.forName()": [[114, 128]]}}}, {"text": "Just use a java.util.BitSet for each set, adding integers to the set with the set(int bitIndex) method, you don't have to sort anything, and check a HashMap for already existing BitSet before adding a new BitSet to it, it will be really very fast", "label": {"api": {"java.util.BitSet": [[11, 26]]}}}, {"text": "In this particular case AtomicInteger is much better since it is lock-free using CAS CPU operations while synchronized is a mutex", "label": {"api": {"AtomicInteger": [[24, 36]]}}}, {"text": "You need to use getResourceAsStream(String name), to get a stream to the file", "label": {"api": {"getResourceAsStream(String name)": [[16, 47]]}}}, {"text": "You simply need to use jTextFieldObject.setColumns(int columnSize)", "label": {"api": {"jTextFieldObject.setColumns(int columnSize)": [[23, 65]]}}}, {"text": "For absolute positioning you need to call setSize() on the JTextField in order to attain the result, though you should always keep in mind the reason why this approach is discouraged, as given in the Java Doc's first paragraph", "label": {"api": {"setSize()": [[42, 50]]}}}, {"text": "It's because 9,999,999,999 is considered as an int by the compiler and is larger than Integer.MAX_VALUE (2,147,483,647)", "label": {"api": {"Integer.MAX_VALUE": [[86, 102]]}}}, {"text": "What you need is a Dialog which can be achieved by the class JOptionPane", "label": {"api": {"JOptionPane": [[61, 71]]}}}, {"text": "It is intentional; the image is loaded asynchroneously in a background process and getWidth(ImageObserver) in effect asks whether the image already can give a width", "label": {"api": {"getWidth(ImageObserver)": [[83, 105]], "ImageObserver": [[92, 104]]}}}, {"text": "Better is using the ImageObserver callbacks", "label": {"api": {"ImageObserver": [[20, 32]]}}}, {"text": "You need to use a PreparedStatement to build your sql so that b gets escaped properly", "label": {"api": {"PreparedStatement": [[18, 34]]}}}, {"text": "Take a look at TimeZone.getTimeZone(String id)", "label": {"api": {"TimeZone.getTimeZone(String id)": [[15, 45]]}}}, {"text": "If you want to make stopwatch in Swing, you best take a look at the javax.swing.Timer class", "label": {"api": {"javax.swing.Timer": [[68, 84]]}}}, {"text": "BTW Vector is quite ancient, there are better alternatives", "label": {"api": {"Vector": [[4, 9]]}}}, {"text": "JavaDoc for java.io.FileDescriptor.FileDescriptor() says", "label": {"api": {"java.io.FileDescriptor.FileDescriptor()": [[12, 50]]}}}, {"text": "Something that you can do is create a class that validates input and implement KeyListener and then create JOptionPanes and call addKeyListener() and pass it your listener", "label": {"api": {"KeyListener": [[79, 89], [132, 142]]}}}, {"text": "PropertyChangeListener) if you need other events to be handled", "label": {"api": {"PropertyChangeListener": [[0, 21]]}}}, {"text": "You need to override the method paintComponent(Graphics g) of JPanel and use drawImage() on the Graphics object g as in this example", "label": {"api": {"paintComponent(Graphics g)": [[32, 57]], "JPanel": [[62, 67]], "drawImage()": [[77, 87]], "Graphics": [[47, 54], [96, 103]]}}}, {"text": "Pass the File object to the constructor PrintWriter(File file)", "label": {"api": {"PrintWriter(File file)": [[40, 61]]}}}, {"text": "The PrintWriter class can actually create the file for you", "label": {"api": {"PrintWriter class": [[4, 20]]}}}, {"text": "Alternatively, you can just pass the file path to the PrintWriter class without declaring the encoding", "label": {"api": {"PrintWriter class": [[54, 70]]}}}, {"text": "So you can but you'll need to use the version that takes an Object( thanks hovercraft) , look at the Java 6 JOptionPage , there are variants that take more than one", "label": {"api": {"look at the Java 6 JOptionPage": [[89, 118]]}}}, {"text": "You can use the subList http://docs.oracle.com/javase/6/docs/api/java/util/List.html#subList  from List to split your ArrayList", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/List.html#subList": [[24, 91]]}}}, {"text": "Ideally I need some way for Jackson to map values to something like a NameValuePair", "label": {"api": {"NameValuePair": [[70, 82]]}}}, {"text": "You're looking for Class#forNameand Class#newInstance methods", "label": {"api": {"Class#forName": [[19, 31]], "Class#newInstance": [[36, 52]]}}}, {"text": "You really want to use a PathIterator (via GeneralPath.getPath) to walk along the (slightly flattened) segments that compose your arc", "label": {"api": {"PathIterator": [[25, 36]], "getPath": [[55, 61]]}}}, {"text": "See the API docs", "label": {"api": {"API docs": [[8, 15]]}}}, {"text": "A case I ran into was with Collections.max() where they wanted the type erasure to be Object but still enforce it to be a Comparable", "label": {"api": {"Collections.max()": [[27, 43]]}}}, {"text": "Java 7 introduced a much simpler way for doing zip archive manipulations - FileSystems API, which allows to access contents of a file as a file system", "label": {"api": {"FileSystems": [[75, 85]]}}}, {"text": "Note that the protocol used is determined later on using SSLSocket.setEnabledProtocols(...) or its SSLEngine equivalent", "label": {"api": {"SSLSocket.setEnabledProtocols(...)": [[57, 90]]}}}, {"text": "The equivalent function signature using String would look like this; we use charAt to access the 15th character", "label": {"api": {"charAt": [[76, 81]]}}}, {"text": "An abstract superclass implements the methods common to several classes, in the case of lists, it's AbstractList, with each concrete class (say, ArrayList or LinkedList) providing the specific implementation details", "label": {"api": {"AbstractList": [[100, 111]]}}}, {"text": "Use writer.flush() to make sure the output will not be buffered", "label": {"api": {"writer.flush()": [[4, 17]]}}}, {"text": "Starting with Java-5, java.util.Vector<E> is a generic container, meaning (in very plain terms) that you can specify the type of the element that you are planing to store, and have the compiler check that type for you automatically", "label": {"api": {"java.util.Vector<E>": [[22, 40]]}}}, {"text": "If you are not planning to use the fact that they are synchronized, you may be better off with ArrayList<E> containers", "label": {"api": {"ArrayList<E>": [[95, 106]]}}}, {"text": "Add a custom TableCellRenderer to your table", "label": {"api": {"TableCellRenderer": [[13, 29]]}}}, {"text": "If all you're doing is changing row color, subclass your JTable and override the prepareRenderer method", "label": {"api": {"prepareRenderer": [[81, 95]]}}}, {"text": "Naive approach for this would be to set an uncaught exception handler for every thread and check whether the raised exception is instance of OutOfMemoryError and set a relevant flag", "label": {"api": {"uncaught exception handler": [[43, 68]]}}}, {"text": "Libraries can spawn their own threads and I have no way of enforcing uncaught exception handlers for these threads", "label": {"api": {"uncaught exception handler": [[69, 94]]}}}, {"text": "An alternative is using Cloneable, which unfortunately is kind of broken", "label": {"api": {"Cloneable": [[24, 32]]}}}, {"text": "Cloneable doesn't declare clone(), but it is declared as protected in Object, so you have to invoke it by means of reflection", "label": {"api": {"Cloneable": [[0, 8]], "declared as protected in Object": [[45, 75]]}}}, {"text": "Take a look to the Date and Time Patterns", "label": {"api": {"Date and Time Patterns": [[19, 40]]}}}, {"text": "As told in API documentation java.sql.Date does not have time component (all time related field are set to 0)", "label": {"api": {"java.sql.Date": [[29, 41]]}}}, {"text": "Use java.sql.Timestamp instead", "label": {"api": {"java.sql.Timestamp": [[4, 21]]}}}, {"text": "You could also use a StringBuilder which is mutable", "label": {"api": {"StringBuilder": [[21, 33]]}}}, {"text": "Your result is not unexpected, as the default Graphics2D composite is AlphaComposite.SRC_OVER", "label": {"api": {"AlphaComposite.SRC_OVER": [[70, 92]], "AlphaComposite.SRC": [[70, 87]]}}}, {"text": "If you want a different result, you'll need to use a different mode; AlphaComposite.SRC, for example, is not additive", "label": {"api": {"AlphaComposite.SRC": [[69, 86]]}}}, {"text": "In this case, you would probably want to be using AlphaComposite.SRC_OVER to be able to overlay your transparent image and see behind it, unless your going for something else (if so, you can easily see all available constants and their explanations on the first link provided)", "label": {"api": {"AlphaComposite.SRC_OVER": [[50, 72]]}}}, {"text": "The RetentionPolicy of annotations (which itself is declared as a meta-annotation) shows you that annotations are not only used by reflection, but also at compile or build time (like with the annotation processing tool)", "label": {"api": {"RetentionPolicy": [[4, 18]]}}}, {"text": "Look into SwingWorker for such tasks", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "The JWS splash, unlike the AWT based SplashScreen, does not provide any programmer control", "label": {"api": {"SplashScreen": [[37, 48]]}}}, {"text": "Maybe you can use Class.forName(\"classname\") to load it", "label": {"api": {"Class.forName(\"classname\")": [[18, 43]]}}}, {"text": "On a Swing / AWT Java platform, you could use a FontMetrics object to measure the width of the particular characters you are trying to display", "label": {"api": {"FontMetrics": [[48, 58]]}}}, {"text": "If you are using interface-based proxies (default), Spring uses Proxy class to create proxy dynamically and in-memory", "label": {"api": {"Proxy": [[64, 68]]}}}, {"text": "I would recommend using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "I suspect you are looking for Map.containsValue() (if the email is the value in the map) or Map.containsKey() (if the email is the key of the map), depending on what exactly map is mapping, if the mapping is to/from the string value", "label": {"api": {"Map.containsValue()": [[30, 48]], "Map.containsKey()": [[92, 108]]}}}, {"text": "Did you try using Window.getIconImages", "label": {"api": {"Window.getIconImages": [[18, 37]]}}}, {"text": "Use equals() instead", "label": {"api": {"equals()": [[4, 11]]}}}, {"text": "If your data really is characters, then you want to look at various serialization techniques, such as using new String(char[]) to create a string and then using getBytes(Charset) to get the bytes as encoded by a given Charset (because, of course, the same characters result in different bytes when encoded in ASCII or UTF-8 or UTF-16, etc.)", "label": {"api": {"new String(char[])": [[108, 125]], "getBytes(Charset)": [[161, 177]], "Charset": [[170, 176], [218, 224]]}}}, {"text": "substring() is a method of String, should be", "label": {"api": {"substring()": [[0, 10]]}}}, {"text": "Implement your own URLStreamHandlerFactory using this tutorial as a guide and cache the incoming documents for later display via a view source function", "label": {"api": {"URLStreamHandlerFactory": [[19, 41]]}}}, {"text": "You should look into Key Bindings, using classes KeyStroke and InputMap", "label": {"api": {"KeyStroke": [[49, 57]], "InputMap": [[63, 70]]}}}, {"text": "From Oracle's TextComponentDemo (slightly modified, but still using DefaultEditorKit as example)", "label": {"api": {"DefaultEditorKit": [[68, 83]]}}}, {"text": "For instance, String.substring() says it may throw an IndexOutOfBoundsException", "label": {"api": {"String.substring()": [[14, 31]]}}}, {"text": "The first question is easy, use System.getProperty to get java.version", "label": {"api": {"System.getProperty": [[32, 49]]}}}, {"text": "javax.servlet.Servlet is interface, it defines methods for all the implementations - that's what interfaces usually do", "label": {"api": {"javax.servlet.Servlet": [[0, 20]]}}}, {"text": "javax.servlet.GenericServlet is protocol independent", "label": {"api": {"javax.servlet.GenericServlet": [[0, 27]]}}}, {"text": "javax.servlet.http.HttpServlet is abstract class to be extended if you want to communicate over HTTP protocol", "label": {"api": {"javax.servlet.http.HttpServlet": [[0, 29]]}}}, {"text": "Using the String.format() method", "label": {"api": {"String.format()": [[10, 24]]}}}, {"text": "Here's the basic idea; write each line, followed by an explicit \\n (rather than .newLine() which is platform-dependent)", "label": {"api": {".newLine()": [[80, 89]]}}}, {"text": "I had the same issue, but I looked at the ImageIO, and found this link", "label": {"api": {"ImageIO": [[42, 48]]}}}, {"text": "Java's Date(long date) constructor and getTime() method operate with unix time milliseconds", "label": {"api": {"Date(long date) constructor": [[7, 33]], "getTime() method": [[39, 54]]}}}, {"text": "If not, then no, you have to go via reflection", "label": {"api": {"reflection": [[36, 45]]}}}, {"text": "Further note that there is ConcurrentHashMap, which does provide for a snapshot iterator, that you can iterate while modifying the Map (modifications are not reflected in the iterator)", "label": {"api": {"ConcurrentHashMap": [[27, 43]]}}}, {"text": "But even with ConcurrentHashMap, the Collection of values() is not a snapshot, it works just like for the normal HashMap", "label": {"api": {"ConcurrentHashMap": [[14, 30]]}}}, {"text": "See this page", "label": {"api": {"page": [[9, 12]]}}}, {"text": "See setRolloverIcon(Icon) (no need for the MouseListener)", "label": {"api": {"setRolloverIcon(Icon)": [[4, 24]]}}}, {"text": "For example, hashCode is used by HashMap to store and retrieve the keys efficiently", "label": {"api": {"HashMap": [[33, 39]]}}}, {"text": "if the hashCode of an object used in a HashMap was not the same during a run of your application, the HashMap would not be able to retrieve the key consistently", "label": {"api": {"HashMap": [[39, 45], [102, 108]]}}}, {"text": "After enabling debugging (session.setDebug(true)) I noticed that I was receiving a ClassNotFoundException before the Tempory System Error was being shown", "label": {"api": {"ClassNotFoundException": [[83, 104]]}}}, {"text": "You can use the java.text.Normalizer class to convert your text into normal Latin characters followed by diacritic marks (accents), where possible", "label": {"api": {"java.text.Normalizer": [[16, 35]]}}}, {"text": "Or more directly, ThreadGroup#activeCount", "label": {"api": {"ThreadGroup#activeCount": [[18, 40]]}}}, {"text": "The Robot class, it allows you to \"press\" programatically anything on the keyboard (or clicking blindly) and therefore getting rid of the dialog by, say, pressing Enter or Esc", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "You will most likely have to use the SwingUtilities.invokeLater(Runnable run) to update the text", "label": {"api": {"SwingUtilities.invokeLater(Runnable run)": [[37, 76]]}}}, {"text": "That being said, most Swing applications (in my knowledge) usually tend to use JOptionPanes to display error message and/or any other notifications to the user", "label": {"api": {"JOptionPane": [[79, 89]]}}}, {"text": "Consider also that in the Swing framework exists diferent ways to get the hierarchy of components like  getParent() or getRoot()", "label": {"api": {"getParent()": [[104, 114]], "getRoot()": [[119, 127]]}}}, {"text": "You could simply iterate on the Entry set that is held in the Map, it will reduce the total time consumed considerably (given the fact that the ArrayList is relatively small)", "label": {"api": {"Entry": [[32, 36]]}}}, {"text": "You want to use Enum.valueOf", "label": {"api": {"Enum.valueOf": [[16, 27]]}}}, {"text": "Option three does the same as two, but using the reflection API", "label": {"api": {"reflection API": [[49, 62]]}}}, {"text": "Some research brought up this interesting little nugget which mentions", "label": {"api": {"nugget": [[49, 54]]}}}, {"text": "You might want to use the java.util.concurrent.CyclicBarrier class for this", "label": {"api": {"java.util.concurrent.CyclicBarrier": [[26, 59]]}}}, {"text": "You need RandomAccessFile for the job", "label": {"api": {"RandomAccessFile": [[9, 24]]}}}, {"text": "You can set the offset by the seek() method", "label": {"api": {"seek()": [[30, 35]]}}}, {"text": "Use a RandomAccessFile - see this question", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "Best choice you can use is SwingWorker", "label": {"api": {"SwingWorker": [[27, 37]]}}}, {"text": "Override doInBackground(), and put any long operations inside this method so that it will be run on a separate thread rather than the EDT", "label": {"api": {"doInBackground()": [[9, 24]]}}}, {"text": "For any GUI creation or changing states of GUI components within doInBackground(), use publish(V..", "label": {"api": {"doInBackground()": [[65, 80]]}}}, {"text": "chunks) to send data to process(List<V> chunks)", "label": {"api": {"process(List<V> chunks)": [[24, 46]]}}}, {"text": "You need to override process(List<V> chunks)", "label": {"api": {"process(List<V> chunks)": [[21, 43]]}}}, {"text": "Also note that process(List<V> chunks) is executed on EDT", "label": {"api": {"process(List<V> chunks)": [[15, 37]]}}}, {"text": "After doInBackground() returns, done() executes on EDT and you can override it to use it for any GUI updates", "label": {"api": {"doInBackground()": [[6, 21]], "done()": [[32, 37]]}}}, {"text": "You can also retrieve the value returned from doInBackground() by using get()", "label": {"api": {"doInBackground()": [[46, 61]], "get()": [[72, 76]]}}}, {"text": "Note that SwingWorker<T,V> is generic, and you need to specify the types", "label": {"api": {"SwingWorker": [[10, 20]], "SwingWorker<T,V>": [[10, 25]]}}}, {"text": "T is the type of object returned from doInBackground() and get(), while V is the type of elements you passed to process(List<V> chunks) via publish(V..", "label": {"api": {"doInBackground()": [[38, 53]], "process(List<V> chunks)": [[112, 134]], "get()": [[59, 63]]}}}, {"text": "execute() method starts the swing worker by invoking doInBackground() first", "label": {"api": {"doInBackground()": [[53, 68]], "execute()": [[0, 8]]}}}, {"text": "One method that may be of interest is Character.getType(char) which returns an int which will match one of the constant values of Character such as Character.LOWERCASE_LETTER or Character.CURRENCY_SYMBOL", "label": {"api": {"Character.getType(char)": [[38, 60]]}}}, {"text": "See the Character.isSupplementaryCodepoint(int) and Character.codepointAt(char[], int) methods", "label": {"api": {"Character.isSupplementaryCodepoint(int)": [[8, 46]], "Character.codepointAt(char[], int)": [[52, 85]]}}}, {"text": "You can call list = list.subList(21, list.size()) to get a sublist from 21 to the end of the list", "label": {"api": {"sublist": [[59, 65]]}}}, {"text": "The operation is O(1), but you do not get a LinkedList back, you get an AbstractList.SubList which acts like a wrapper class for the original LinkedList, delegating methods with the sublist's offsets", "label": {"api": {"sublist": [[182, 188]]}}}, {"text": "Java's java.util.List defines the API listIterator()", "label": {"api": {"listIterator()": [[38, 51]]}}}, {"text": "ListIterator has previous()", "label": {"api": {"previous()": [[17, 26]]}}}, {"text": "I can't say for sure if it is faster, but take a look at the ColorConvertOp class", "label": {"api": {"ColorConvertOp": [[61, 74]]}}}, {"text": "You'll need to use the methods from HttpServletRequest class to get this information, for example getRequestURI()", "label": {"api": {"getRequestURI()": [[98, 112]]}}}, {"text": "You have to annotate the BeanToInject class as @Singleton to use same instance in both injection points", "label": {"api": {"@Singleton": [[47, 56]]}}}, {"text": "Use the Executors class to create an ExecutorService with the characteristics that you desire", "label": {"api": {"Executors": [[8, 16]]}}}, {"text": "As vainolo said, a ConcurrentSkipListMap is the basic data structure you want, because it is both sorted and concurrent", "label": {"api": {"ConcurrentSkipListMap": [[19, 39]]}}}, {"text": "You can safely add new things to the map using ConcurrentMap's putIfAbsent method", "label": {"api": {"putIfAbsent": [[63, 73]]}}}, {"text": "The easiest thing to do is to use a sort of double-checked locking pattern, where you first simply try to get an existing value, then if you find there isn't one, add a new one with putIfAbsent (you can't simply call put, because there could be a race between two threads putting at the same time)", "label": {"api": {"putIfAbsent": [[182, 192]]}}}, {"text": "AtomicInteger seems like a good candidate for this", "label": {"api": {"AtomicInteger": [[0, 12]]}}}, {"text": "Use the \"built-in\" auto delay feature that the Robot class already provides", "label": {"api": {"auto delay": [[19, 28]]}}}, {"text": "Have you call repaint() after you set the message", "label": {"api": {"repaint()": [[14, 22]]}}}, {"text": "Legacy Toolkit methods such as createImage and getImage are known to be more lenient than ImageIO", "label": {"api": {"Toolkit": [[7, 13]], "createImage": [[31, 41]], "getImage": [[47, 54]]}}}, {"text": "By combining both approaches (try every possible ImageReader and then fallback to Toolkit) you will be able to handle a reasonable number of JPEG Images", "label": {"api": {"Toolkit": [[82, 88]]}}}, {"text": "You need to use method size() to get the number of objects in a list", "label": {"api": {"size()": [[23, 28]]}}}, {"text": "Or override DefaultTreeModel.valueForPathChanged() if you're using DefaultTreeModel", "label": {"api": {"TreeModel.valueForPathChanged()": [[19, 49]], "DefaultTreeModel.valueForPathChanged()": [[12, 49]]}}}, {"text": "I have confirmed my dateString parameter comes through correctly, my position object starts at 0 and I have reviewed the SimpleDateFormat numerous times against http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html": [[161, 236]]}}}, {"text": "If the date string is always in English, you should specify Locale.US in the SimpleDateFormat constructor", "label": {"api": {"SimpleDateFormat constructor": [[77, 104]]}}}, {"text": "You can use the readLine method in BufferedReader class", "label": {"api": {"readLine": [[16, 23]], "BufferedReader": [[35, 48]]}}}, {"text": "Wrap the InputStream under InputStreamReader, and wrap it under BufferedReader", "label": {"api": {"BufferedReader": [[64, 77]]}}}, {"text": "I would suggest using a ReadWriteLock for this", "label": {"api": {"ReadWriteLock": [[24, 36]]}}}, {"text": "Take a look at the split and the compareTo methods of the string class", "label": {"api": {"split": [[19, 23]], "compareTo": [[33, 41]]}}}, {"text": "This splits the string into the fragments that are seperated by a space", "label": {"api": {"split": [[5, 9]]}}}, {"text": "You need to implement your own ListCellRenderer", "label": {"api": {"ListCellRenderer": [[31, 46]]}}}, {"text": "No since setMaximumSize has a return of void", "label": {"api": {"setMaximumSize": [[9, 22]]}}}, {"text": "ByteBuffer for a major, well-known example -- have provided chaining behavior and the like, where it makes sense", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "If yes, you could implement ServletContextListener and override contextInitialized method to print information you need in logs", "label": {"api": {"ServletContextListener": [[28, 49]]}}}, {"text": "You can try to requestFocusInWindow() or requestFocus() in combination with toFront()", "label": {"api": {"requestFocusInWindow()": [[15, 36]], "requestFocus()": [[41, 54]]}}}, {"text": "The way to do this is with an explicit Iterator (no school like the old school!)", "label": {"api": {"Iterator": [[39, 46]]}}}, {"text": "Unlike the remove method on a list, the remove method on the iterator doesn't cause a concurrent modification", "label": {"api": {"remove method on the iterator": [[40, 68]]}}}, {"text": "How about using proper Iterator and its remove method", "label": {"api": {"Iterator": [[23, 30]]}}}, {"text": "Measure the used memory (See Runtime)", "label": {"api": {"Runtime": [[29, 35]]}}}, {"text": "If I had to do this again today, I'd rely on a ScheduledThreadPoolExecutor to manage the 'micro-scheduling'", "label": {"api": {"ScheduledThreadPoolExecutor": [[47, 73]]}}}, {"text": "Notice the usage of String.concat(java.lang.String) method as factory-method", "label": {"api": {"String.concat(java.lang.String)": [[20, 50]]}}}, {"text": "Java provides an interface to invoke the compilers from programs", "label": {"api": {"interface": [[17, 25]]}}}, {"text": "First thing is that an iteration is executed in much less than a second, so you gonna have \"a bad time\"", "label": {"api": {"time": [[98, 101]]}}}, {"text": "You'll probably need to use method like System.currentTimeMillis() to accurate your program,  libraries that know better how to handle time, or even maybe a simple sleep of 1 second in your program (but it won't be really precise)", "label": {"api": {"time": [[135, 138]]}}}, {"text": "You can read the documentation for the timer class for more information", "label": {"api": {"documentation for the timer class": [[17, 49]]}}}, {"text": "In order to ensure full compatibilty, you'll want to use the separator in File", "label": {"api": {"separator in File": [[61, 77]]}}}, {"text": "In Java 8 you can use the allMatch method of a stream to achieve this", "label": {"api": {"allMatch": [[26, 33]]}}}, {"text": "your keyboard handling could easily be done with a KeyListener you write, attached to an event handler on the window or other component, and then will be called whenever the user presses the key - i.e", "label": {"api": {"KeyListener": [[51, 61]]}}}, {"text": "Use setExtendedState(int state), where state would be JFrame.MAXIMIZED_BOTH", "label": {"api": {"setExtendedState(int state)": [[4, 30]], "JFrame.MAXIMIZED_BOTH": [[54, 74]]}}}, {"text": "Take a look at ImageIO api it has out of the box support for JPEG, PNG, BMP, WBMP & GIF", "label": {"api": {"ImageIO": [[15, 21]]}}}, {"text": "I think Affe idea myght be the good one, but I wanna suggest you to try to use Timer in the future instead of while(true) loop", "label": {"api": {"Timer": [[79, 83]]}}}, {"text": "So, once you've completed the upload (and you're sure that it was sucessful, simply use File.delete() to remove the file from the local disk", "label": {"api": {"File.delete()": [[88, 100]]}}}, {"text": "See the Pattern documentation on how to formulate regular expressions", "label": {"api": {"Pattern documentation": [[8, 28]]}}}, {"text": "You can use the generic Array class to iterate any array like this", "label": {"api": {"Array": [[24, 28]]}}}, {"text": "You can implement that interface by defining what its actionPerformed() method does (assuming you refer to this ActionListener)", "label": {"api": {"this ActionListener": [[107, 125]]}}}, {"text": "An implementation and example of this good practice, is just precisely the MouseListener", "label": {"api": {"MouseListener": [[75, 87]]}}}, {"text": "This is known as the Object Contract", "label": {"api": {"Object Contract": [[21, 35]]}}}, {"text": "Wouldn't the simple ServletContextListener solve the problem for you", "label": {"api": {"ServletContextListener": [[20, 41]]}}}, {"text": "Another option in Java is to use the java.util.BitSet object", "label": {"api": {"java.util.BitSet": [[37, 52]]}}}, {"text": "If you have a long running process that is fetching rows, then I suggest using a SwingWorker to grab those rows and add them to your TableModel", "label": {"api": {"SwingWorker": [[81, 91]]}}}, {"text": "See this javadoc for more information about Files", "label": {"api": {"this javadoc": [[4, 15]]}}}, {"text": "From Oracle's javadoc (v7) http://docs.oracle.com/javase/7/docs/api/", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[27, 67]]}}}, {"text": "You should make your client implement javax.jmsExceptionListener", "label": {"api": {"implement javax.jmsExceptionListener": [[28, 63]]}}}, {"text": "After creating the Connection, connecting and starting it, call connection.setExceptionListener(myListener)", "label": {"api": {"Connection": [[19, 28]]}}}, {"text": "See also the Javadoc for Connection", "label": {"api": {"Connection": [[25, 34]]}}}, {"text": "For example, perhaps Callable is a better fit", "label": {"api": {"Callable": [[21, 28]]}}}, {"text": "Better yet, make use of one of the data structures in the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[58, 77]]}}}, {"text": "I'd use the method remainder of the class BigInteger in this way", "label": {"api": {"remainder": [[19, 27]]}}}, {"text": "Comparator must follow a contract, in particular, if compare(A, B) < 0, then it has to be that compare(B, A) > 0", "label": {"api": {"contract": [[25, 32]]}}}, {"text": "If you were using a result set you could use ResultSet.getString()", "label": {"api": {"ResultSet.getString()": [[45, 65]]}}}, {"text": "You can change the delimiter to something that should not occur in your input data by using Scanner.useDelimiter()", "label": {"api": {"Scanner.useDelimiter()": [[92, 113]]}}}, {"text": "This way it is possible to represent time with an integer data type like, Integer or BigInteger, depending on the maximum time to represent", "label": {"api": {"BigInteger": [[85, 94]]}}}, {"text": "Why not use java.util.UUID", "label": {"api": {"java.util.UUID": [[12, 25]]}}}, {"text": "Not sure what you're looking for, but you can add JMenuBar to JFrame - JFrame.setJMenuBar()", "label": {"api": {"JFrame.setJMenuBar()": [[71, 90]]}}}, {"text": "Use java.lang.Runtime.addShutdownHook and send a SIGTERM, SIGINT or SIGHUP", "label": {"api": {"java.lang.Runtime.addShutdownHook": [[4, 36]]}}}, {"text": "I think what you want is to use a Lock", "label": {"api": {"Lock": [[34, 37]]}}}, {"text": "Looking through the source code of the Java program, it appears to be using the HttpsURLConnection class to pull data from the server over SSL", "label": {"api": {"HttpsURLConnection": [[80, 97]]}}}, {"text": "Is there a specific key HttpsURLConnection uses that I can add to Wireshark", "label": {"api": {"HttpsURLConnection": [[24, 41]]}}}, {"text": "This works for any Collection that implements the Iterator interface", "label": {"api": {"Iterator": [[50, 57]]}}}, {"text": "On the Java end, use the Deflater class in java.util.zip", "label": {"api": {"Deflater": [[25, 32]]}}}, {"text": "You can do this check manually by using reference to java.lang.Class", "label": {"api": {"java.lang.Class": [[53, 67]]}}}, {"text": "See the documentation for said class", "label": {"api": {"the documentation for said class": [[4, 35]]}}}, {"text": "You can simply use Java's hashCode method (on any object)", "label": {"api": {"hashCode": [[26, 33]]}}}, {"text": "You should try Java's hashCode and see how many collisions you get", "label": {"api": {"hashCode": [[22, 29]]}}}, {"text": "According to the Javadocs for DataInputStream, the readInt() method will read exactly four bytes from the underlying input stream", "label": {"api": {"the Javadocs for DataInputStream": [[13, 44]]}}}, {"text": "Yes, it's possible, using the Class.newInstance() method", "label": {"api": {"Class.newInstance()": [[30, 48]]}}}, {"text": "You can get the names of all the primitive array classes from the Javadocs of Class.getName()", "label": {"api": {"Javadocs of Class.getName()": [[66, 92]]}}}, {"text": "Check out Class.getName() JavaDoc", "label": {"api": {"Class.getName() JavaDoc": [[10, 32]]}}}, {"text": "This is what it says for Window.setAlwaysOnTop()", "label": {"api": {"Window.setAlwaysOnTop()": [[25, 47]]}}}, {"text": "You either need thread safe ArrayList or replace(K key, V oldValue, V newValue) method", "label": {"api": {"replace(K key, V oldValue, V newValue)": [[41, 78]]}}}, {"text": "You don't provide many details but if you want to generate your keypair using the java.security.KeyPairGenerator you will have to define your own class that extends SecureRandom, but uses only the supplied password as the entropy source", "label": {"api": {"java.security.KeyPairGenerator": [[82, 111]], "SecureRandom": [[165, 176]]}}}, {"text": "You don't need to implement a SecureRandomSpi class, you can just call the protected constructor of the superclass with (null, null) arguments", "label": {"api": {"SecureRandom": [[30, 41]], "SecureRandomSpi": [[30, 44]], "protected constructor": [[75, 95]]}}}, {"text": "If you really want to do things asynchronously you can use a Future object to check the completion status of the computation, and obtain its results", "label": {"api": {"Future": [[61, 66]]}}}, {"text": "Use a SingleThreadExecutor", "label": {"api": {"SingleThreadExecutor": [[6, 25]]}}}, {"text": "You'll want to override Object.toString()", "label": {"api": {"Object.toString()": [[24, 40]]}}}, {"text": "As per the SwingWorker API documentation, SwingWorker#done() runs on the Swing event dispatch thread (EDT)", "label": {"api": {"SwingWorker API": [[11, 25]]}}}, {"text": "Put elements to collection and then you can use addAll method to add them all", "label": {"api": {"addAll": [[48, 53]]}}}, {"text": "You could use a combination of an ExecutorService to manage your threads (i.e", "label": {"api": {"ExecutorService": [[34, 48]]}}}, {"text": "you recycle your threads without having to create new ones at each cycle) and a CyclicBarrier which will synchronize all the slaves", "label": {"api": {"CyclicBarrier": [[80, 92]]}}}, {"text": "Note that you can evaluate the expression directly using XPath.evaluate()", "label": {"api": {"XPath.evaluate()": [[57, 72]]}}}, {"text": "And that these evaluate methods can also take as an additional argument a type, such as XPathConstants.BOOLEAN", "label": {"api": {"XPathConstants.BOOLEAN": [[88, 109]]}}}, {"text": "So this will work, with input as an InputSource for your XML", "label": {"api": {"InputSource": [[36, 46]]}}}, {"text": "If operations are within a single JVM, then you might be able to use their system hashcode (obtained via System.identityHashcode() to track the objects", "label": {"api": {"System.identityHashcode()": [[105, 129]]}}}, {"text": "Browse the javadoc of DefaultTableModel to know all the possible operations", "label": {"api": {"javadoc of DefaultTableModel": [[11, 38]]}}}, {"text": "The simplest way to do this would be to use the java.awt.Robot class, which allows you to directly control the mouse and keyboard", "label": {"api": {"java.awt.Robot": [[48, 61]]}}}, {"text": "Please have a look at the Scanner API and you'll see that it doesn't return null if it runs out of lines", "label": {"api": {"Scanner API": [[26, 36]]}}}, {"text": "You can either use non blocking calls or use Interrupt method on the thread", "label": {"api": {"Interrupt method": [[45, 60]]}}}, {"text": "I would suggest storing your information as a java.util.Calendar which has a compareTo ()function", "label": {"api": {"java.util.Calendar": [[46, 63]]}}}, {"text": "The closest that can match your requirement is probably a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[58, 70]]}}}, {"text": "checkMemberAccess(Class, int) and checkPackageAccess(String), which both seemed to be viable paths to my goal", "label": {"api": {"checkMemberAccess(Class, int)": [[0, 28]], "checkPackageAccess(String)": [[34, 59]]}}}, {"text": "Use the following code to check whether a String is part of the word list or not", "label": {"api": {"String": [[42, 47]]}}}, {"text": "You could use String's replaceAll() method which takes a regular expression as input, to replace everything after the space including the space, if a space does indeed exist, with the empty string", "label": {"api": {"replaceAll()": [[23, 34]]}}}, {"text": "But you will have to provide your own Comparator to handle the case when null is compared to any other contents of your set", "label": {"api": {"Comparator": [[38, 47]]}}}, {"text": "An example implementation of such a \"null-safe\" Comparator can be found in the apache commons-collections library", "label": {"api": {"Comparator": [[48, 57]]}}}, {"text": "Check out the NullComparator", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "Any alternative to Desktop.open(File), allowing me to pass a byte[] instead of a File", "label": {"api": {"Desktop.open(File)": [[19, 36]]}}}, {"text": "Just go directly to the GenerationType.TABLE, which is most portable", "label": {"api": {"GenerationType.TABLE": [[24, 43]]}}}, {"text": "You can also use it without TableGenerator, but because our goal is to have it to function exactly same way with all the databases, we are explicitly giving needed values", "label": {"api": {"TableGenerator": [[28, 41]]}}}, {"text": "Name of TableGenerator is global for persistence unit, as generator names in general are", "label": {"api": {"TableGenerator": [[8, 21]]}}}, {"text": "It is just good practice since the get() method returns null if the specified key doesn't exist in the Hashtable", "label": {"api": {"get()": [[35, 39]]}}}, {"text": "You can use a LinkedHashMap instead, which will keep the insertion order", "label": {"api": {"LinkedHashMap instead": [[14, 34]]}}}, {"text": "See the JDK documentation for the format string for more information", "label": {"api": {"JDK documentation for the format string": [[8, 46]]}}}, {"text": "In a modular project in Java 9+, you may also want to obtain a list of ModuleReference objects for visible modules in the system", "label": {"api": {"ModuleReference": [[71, 85]]}}}, {"text": "These can be obtained by calling the following (ModuleRef is a wrapper for ModuleReference that is backwards compatible, so you can compile your code on JDK 7/8 but still take advantage of module features on JDK 9+)", "label": {"api": {"ModuleReference": [[75, 89]]}}}, {"text": "If you use encodeURL to output the link to the second.jsp page, e.g.", "label": {"api": {"encodeURL": [[11, 19]]}}}, {"text": "Now, you could use encodeURL all over the place, but my guess is you'd rather use cookies", "label": {"api": {"encodeURL": [[19, 27]]}}}, {"text": "You can then iterate through the resultant array and use String.format() to output with padding/formatting etc", "label": {"api": {"String.format()": [[57, 71]]}}}, {"text": "I think you should be looking at java SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[38, 53]]}}}, {"text": "According to the documentation ThreadPoolExecutor.getActiveCount() it only gives an approximate count, which is pretty fair considering the overhead required to get an accurate value", "label": {"api": {"ThreadPoolExecutor.getActiveCount()": [[31, 65]]}}}, {"text": "You should look at the documentation for the comparable interface which defines the compareTo method", "label": {"api": {"comparable": [[45, 54]]}}}, {"text": "Execute your query periodically in your implementation of doInBackground() in a subclass of SwingWorker", "label": {"api": {"SwingWorker": [[92, 102]]}}}, {"text": "Examples may be found in the API, here and here", "label": {"api": {"API": [[29, 31]]}}}, {"text": "However, it's fairly simple to write one using a proxy", "label": {"api": {"proxy": [[49, 53]]}}}, {"text": "You would need to write an InvocationHandler that recognises getters and setters, and gets or puts on the map accordingly", "label": {"api": {"InvocationHandler": [[27, 43]]}}}, {"text": "Rather than making such a table yourself, though, consider using the ThreadLocal capability, which is essentially doing the same thing, but with specific semantics for initialization", "label": {"api": {"ThreadLocal": [[69, 79]]}}}, {"text": "You could, but there is a built in mechanism ThreadLocal for just that purpose", "label": {"api": {"ThreadLocal": [[45, 55]]}}}, {"text": "All of the operations of a synchronizedList attempt to synchronize on itself before every method, which would make your iterations completely safe as long as you keep your current synchronized(ballList)s in place", "label": {"api": {"synchronizedList": [[27, 42]]}}}, {"text": "The Java Date class allows one to compare two dates using the .compareTo() method", "label": {"api": {".compareTo()": [[62, 73]]}}}, {"text": "Alternatively, you might want to look at JEditorPane instead", "label": {"api": {"JEditorPane": [[41, 51]]}}}, {"text": "The API for Collections", "label": {"api": {"The API for Collections": [[0, 22]]}}}, {"text": "String.CASE_INSENSITIVE_ORDER is a Comparator<String> in String class", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[0, 28]]}}}, {"text": "You could use Double.parseDouble(String) or Float.parseFloat (String)", "label": {"api": {"Double.parseDouble(String)": [[14, 39]], "Float.parseFloat (String)": [[44, 68]]}}}, {"text": "I think this is a good use case for custom annotation processing (link to JDK api)", "label": {"api": {"link to JDK api": [[66, 80]]}}}, {"text": "Because scanner.next() returns a string as described in the javadoc", "label": {"api": {"scanner.next()": [[8, 21]]}}}, {"text": "If you don't want your reads to be blocking you would need to configure your channel as non-blocking", "label": {"api": {"configure your channel as non-blocking": [[62, 99]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "I am assuming that you are using ProcessBuilder to start your external application", "label": {"api": {"ProcessBuilder": [[33, 46]], "Process": [[33, 39]]}}}, {"text": "Once you have called start(), you will get a Process, on which you can call destroy() to kill the external application", "label": {"api": {"Process": [[45, 51]]}}}, {"text": "Use JDesktopPane.setComponentZOrder(java.awt.Component, int) and ensure that the iconified frames are in a layer which is above the one that is not iconified", "label": {"api": {"JDesktopPane.setComponentZOrder(java.awt.Component, int)": [[4, 59]]}}}, {"text": "I suggest that you use Comparator to define order and then some library function to do actual sorting", "label": {"api": {"Comparator": [[23, 32]]}}}, {"text": "If desktop application - it can use the API for execution processes at Java", "label": {"api": {"API": [[40, 42]]}}}, {"text": "Is it String or Number", "label": {"api": {"Number": [[16, 21]]}}}, {"text": "It cannot be String, it cannot be Number - it can only be..", "label": {"api": {"Number": [[34, 39]]}}}, {"text": "Note that Number has methods that allow you to easily extract floatValue() and intValue()", "label": {"api": {"Number": [[10, 15]]}}}, {"text": "Consider this example from the String class page", "label": {"api": {"String class page": [[31, 47]]}}}, {"text": "using java resources or explicitly defined path)", "label": {"api": {"resources": [[11, 19]]}}}, {"text": "What about implementing your own custom ClassLoader", "label": {"api": {"ClassLoader": [[40, 50]]}}}, {"text": "You can define your own annotation like @HideFromProductionCode and have your custom ClassLoader throw an exception if it loads a class that has the @HideFromProductionCode annotation", "label": {"api": {"ClassLoader": [[85, 95]]}}}, {"text": "Its always a good idea to check the API, but with an update I am not sure that barring an exception there is a clean way to tell if it was successful (other than a lack of exceptions being thrown)", "label": {"api": {"check the API": [[26, 38]]}}}, {"text": "The reason why your code is hanging until it completes, is because of the call to your Future's get method", "label": {"api": {"Future's get method": [[87, 105]]}}}, {"text": "Just loop through the objects list, check for each one to see if there's a match in the other list (see List.contains()) http://docs.oracle.com/javase/6/docs/api/java/util/List.html#contains(java.lang.Object) and remove the ones that don't match", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/List.html#contains(java.lang.Object": [[121, 206]]}}}, {"text": "I would suggest using a single PriorityBlockingQueue and using the 'depth' of the recursive tasks to compute the priority", "label": {"api": {"PriorityBlockingQueue": [[31, 51]]}}}, {"text": "You probably want to use ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[25, 42]]}}}, {"text": "Otherwise you could use some facility method like Collections.frequency(Collection<?> c, Object o) but this would be good only if you are looking for the frequency of a single element, otherwise you would need a set to check just the uniques so the first approach would be better", "label": {"api": {"Collections.frequency(Collection<?> c, Object o)": [[50, 97]]}}}, {"text": "Instead of writing your own method to start threads, why not use an Executor, which can be injected into your class", "label": {"api": {"Executor": [[68, 75]]}}}, {"text": "Then you can easily test it by passing in a dummy Executor", "label": {"api": {"Executor": [[50, 57]]}}}, {"text": "Use readLine() from BufferedReader", "label": {"api": {"BufferedReader": [[20, 33]]}}}, {"text": "I am thinking of creating a Properties file and save it then retrieve it from it when I relaunch application", "label": {"api": {"Properties": [[28, 37]]}}}, {"text": "You need to use entrySet().iterator()", "label": {"api": {"entrySet().iterator()": [[16, 36]]}}}, {"text": "That will return Map.Entry<K,V> objects on which you can call getKey() and getValue()", "label": {"api": {"Map.Entry<K,V>": [[17, 30]], "getKey()": [[62, 69]], "getValue()": [[75, 84]]}}}, {"text": "AbstractCollection, which is the base for most kind of List implementations (including ArrayList) uses contains() in its implementation of removeAll", "label": {"api": {"AbstractCollection": [[0, 17]]}}}, {"text": "Now removeAll() will work just fine", "label": {"api": {"removeAll()": [[4, 14]]}}}, {"text": "org.w3c.dom.Node is an interface", "label": {"api": {"org.w3c.dom.Node": [[0, 15]]}}}, {"text": "org.apache.xerces.dom.DeferredElementImpl is an implementation of that interface (really, an implementation of org.w3c.dom.Element, a subinterface of Node)", "label": {"api": {"org.w3c.dom.Element": [[111, 129]]}}}, {"text": "However, in Java, Iterator defines the remove operation to (optionally!) allow deleting elements", "label": {"api": {"Iterator": [[18, 25]], "remove": [[39, 44]]}}}, {"text": "remove's optionalness is an example of the refused bequest smell, but ignoring that (already discussed here) I'd be interested in the design decisions that prompted a remove event to be implemented on the interface", "label": {"api": {"remove": [[0, 5], [167, 172]]}}}, {"text": "What are the design decisions that led to remove being added to Iterator", "label": {"api": {"Iterator": [[64, 71]], "remove": [[42, 47]]}}}, {"text": "To put another way, what is the C# design decision that explicitly doesn't have remove defined on IEnumerator", "label": {"api": {"remove": [[80, 85]]}}}, {"text": "Try using waitFor so as to make the current thread wait for the process to finish its job", "label": {"api": {"waitFor": [[10, 16]]}}}, {"text": "Add an ActionListener to the TrayIcon", "label": {"api": {"Add an ActionListener": [[0, 20]]}}}, {"text": "You can then add the students to a set (typically a HashSet, which will automatically remove the duplicate", "label": {"api": {"HashSet": [[52, 58]]}}}, {"text": "Suggest to implement equals() and hashCode() in your Student class and use a HashSet to enforce uniqueness", "label": {"api": {"HashSet": [[77, 83]]}}}, {"text": "Then you can unmarshal each Node individually using Unmarshaller.unmarshal(Node node)", "label": {"api": {"Unmarshaller.unmarshal(Node node)": [[52, 84]]}}}, {"text": "As the Java Reference Docs can tell you, Arrays, Sets and Maps are all part of the Java Collections Framework", "label": {"api": {"Arrays": [[41, 46]], "Sets": [[49, 52]], "Maps": [[58, 61]]}}}, {"text": "Serializable is just a marker interface, meaning that it is just used to signal to the code that will actually do the serialization that you (the programmer) know (or hope :-)) that this class can be serialized without issues", "label": {"api": {"Serializable": [[0, 11]]}}}, {"text": "Last but not least there is the option to completely override the default serialization protocol implementing the Externalizable interface", "label": {"api": {"Externalizable": [[114, 127]]}}}, {"text": "You'll be still using the ObjectInputStream/ObjectOutputStream pair to serialize (externalise??) externalizable object instances but now the logic to transform your class into an array of bytes is no longer the one provided by the JVM but the one you wrote in your class when implementing the Externalizable class", "label": {"api": {"Externalizable": [[293, 306]]}}}, {"text": "I want to use a ConcurrentLinkedQueue in an atomic lock-free manner", "label": {"api": {"ConcurrentLinkedQueue": [[16, 36]]}}}, {"text": "Unfortunately the add() method of ConcurrentLinkedQueue always returns true", "label": {"api": {"ConcurrentLinkedQueue": [[34, 54]], "add()": [[18, 22]]}}}, {"text": "The exceptions to this rule  (huhu) are RuntimeExceptions and mostly Errors which you should not try to catch (see Error javadoc)", "label": {"api": {"Error javadoc": [[115, 127]]}}}, {"text": "If you're using java.util.zip.Inflater have a look at Inflater.finished()", "label": {"api": {"Inflater.finished()": [[54, 72]]}}}, {"text": "Oracle's tutorial on worker threads and SwingWorker, JavaDoc API documentation of the SwingWorker class", "label": {"api": {"documentation of the SwingWorker class": [[65, 102]]}}}, {"text": "I was thinking of using DatagramPacket, but didn't find any methods that would work", "label": {"api": {"DatagramPacket": [[24, 37]]}}}, {"text": "You can use System.getProperty(\"os.name\")to detect the operating system in the main method, then exit the application if it's not what you expect", "label": {"api": {"System.getProperty(\"os.name\")": [[12, 40]]}}}, {"text": "Likewise, all other u4 size values are implicitly restricted, if you consider that the only officially supported ways of getting a class file into a JVM are based on an array or on a ByteBuffer, both being restricted to a signed int representing their total size", "label": {"api": {"on an array": [[163, 173]], "on a ByteBuffer": [[178, 192]]}}}, {"text": "Even if there was a way to get bigger class files into the JVM, there are other parts, like the Instrumentation API, expecting the possibility to convert a class back into an ordinary array", "label": {"api": {"like the Instrumentation API": [[87, 114]]}}}, {"text": "Use Set for this purpose", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "Using java.nio.file.Files you can do", "label": {"api": {"java.nio.file.Files": [[6, 24]]}}}, {"text": "As the lines(path) method returns a Stream, you can take advantage of any other method of the Stream API, like reading just the first line (if one exists) with", "label": {"api": {"Stream": [[36, 41], [94, 99]]}}}, {"text": "I referred the link http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html to reach this conclusion", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html": [[20, 87]]}}}, {"text": "In newer versions of the documentation this statement has been removed", "label": {"api": {"newer versions of the documentation": [[3, 37]]}}}, {"text": "The JavaDoc of WatchService says this", "label": {"api": {"JavaDoc of WatchService": [[4, 26]]}}}, {"text": "getImportedKeys works for me", "label": {"api": {"getImportedKeys": [[0, 14]]}}}, {"text": "Testing the releasing of threads was easy, because you can ask a ThreadGroup for all threads in it, but I haven't yet found a good way to get a list of all network sockets that the current JVM is using", "label": {"api": {"ThreadGroup": [[65, 75]]}}}, {"text": "java.net.ServerSocket and java.net.Socket) on Java 7", "label": {"api": {"java.net.ServerSocket": [[0, 20]], "java.net.Socket": [[26, 40]]}}}, {"text": "The way to do that is to return a String in the normal case, and then throw a WebApplicationException in the exceptional case", "label": {"api": {"WebApplicationException": [[78, 100]]}}}, {"text": "Alternatively, you can throw a standard exception, and control how it is rendered as a response with a separate ExceptionMapper", "label": {"api": {"ExceptionMapper": [[112, 126]]}}}, {"text": "Use Sample.class.getAnnotation(annotation.class) to get your annotation instance, and call check() to get the check value", "label": {"api": {"Sample.class.getAnnotation(annotation.class)": [[4, 47]]}}}, {"text": "Use the Java URI class where you can access the individual elements", "label": {"api": {"URI class": [[13, 21]]}}}, {"text": "You could use the setAttribute() and getAttribute() methods of HttpSession", "label": {"api": {"HttpSession": [[63, 73]]}}}, {"text": "You have to read the .Net XML key representation and store the exponent and modulus in a Java RSAPrivateKeySpec", "label": {"api": {"RSAPrivateKeySpec": [[94, 110]]}}}, {"text": "Pass this instance to the generatePrivate method of a KeyFactory to generate a key", "label": {"api": {"KeyFactory": [[54, 63]]}}}, {"text": "You then need a Cipher instance obtained by the Cipher.getInstance method with the alogorithm that fits the .Net implementation", "label": {"api": {"Cipher": [[16, 21], [48, 53]]}}}, {"text": "Arrays, Collections, Executors, Files, Objects, Utilities [!] - examples from JDK", "label": {"api": {"Arrays": [[0, 5]], "Collections": [[8, 18]], "Executors": [[21, 29]], "Files": [[32, 36]], "Objects": [[39, 45]], "Utilities [!]": [[48, 60]]}}}, {"text": "According to the API docs for ResultSet#getInt(int)", "label": {"api": {"API docs for ResultSet#getInt(int)": [[17, 50]]}}}, {"text": "See more in the Scanner API documentation", "label": {"api": {"Scanner API documentation": [[16, 40]]}}}, {"text": "I am sorry to blindly point you to the Concurrent API, but if you work off of that you may not need to use some of the lower level concurrency controls", "label": {"api": {"Concurrent API": [[39, 52]]}}}, {"text": "Take a look at the ExecutorService and the ForkJoinPool classes", "label": {"api": {"ExecutorService": [[19, 33]], "ForkJoinPool": [[43, 54]]}}}, {"text": "Note that the documentation of ScheduledThreadPoolExecutor, which is what this method returns, explicitly says that the thread pool has a fixed size", "label": {"api": {"ScheduledThreadPoolExecutor": [[31, 57]]}}}, {"text": "No, EventQueue guarantees two things for queued instances of Runnable", "label": {"api": {"EventQueue": [[4, 13]]}}}, {"text": "When the user clicks the button, use the BasicService.showDocument(URL) method to launch the JWS (frame based) app", "label": {"api": {"BasicService.showDocument(URL)": [[41, 70]]}}}, {"text": "First of all, use PreparedStatement, secondly, you are missing a space character between vup and WHERE", "label": {"api": {"PreparedStatement": [[18, 34]]}}}, {"text": "For the case sensitive part, you can use String.compareToIgnoreCase()", "label": {"api": {"String.compareToIgnoreCase()": [[41, 68]]}}}, {"text": "You have to use java.text.DecimalFormat class", "label": {"api": {"java.text.DecimalFormat": [[16, 38]]}}}, {"text": "equals(String) This is a method in String class to comparing the content of two string", "label": {"api": {"method": [[25, 30]]}}}, {"text": "You can use the Java class URI function resolve to merge these URIs", "label": {"api": {"URI": [[27, 29], [63, 65]]}}}, {"text": "Either you revert to JNI or you might try and find something that uses transmitControlCommand", "label": {"api": {"transmitControlCommand": [[71, 92]]}}}, {"text": "Or more easily, use List and its add() and remove() methods", "label": {"api": {"add()": [[33, 37]], "remove()": [[43, 50]]}}}, {"text": "Or better yet, as Peter Lawrey points out elsewhere, use Character.getNumericValue, which handles a broader range of characters", "label": {"api": {"Character.getNumericValue": [[57, 81]]}}}, {"text": "BigInteger has a constructor, which does radix conversion for you", "label": {"api": {"a constructor": [[15, 27]]}}}, {"text": "If you wish to convert back to hexadecimal, you can use toString", "label": {"api": {"toString": [[56, 63]]}}}, {"text": "If possible try using a Set rather than an Array - Sets will only allow one copy of each integer", "label": {"api": {"Set": [[24, 26], [51, 53]]}}}, {"text": "You can create an array from the Set if you really need one using the toArray() method", "label": {"api": {"Set": [[33, 35]]}}}, {"text": "You can use a LinkedHashSet to eliminate duplicates and preserve the order of the list", "label": {"api": {"LinkedHashSet": [[14, 26]]}}}, {"text": "To valuate if two objects are equivalent use equals", "label": {"api": {"equals": [[45, 50]]}}}, {"text": "Note If you have to compare custom objects consider ovverriding equals in your class according to your equivalence criteria", "label": {"api": {"equals": [[64, 69]]}}}, {"text": "java.lang.Class cannot be cast to java.lang.reflect.GenericArrayType\"", "label": {"api": {"GenericArrayType": [[52, 67]]}}}, {"text": "Can someone please help me understand why this happens and how to get GenericArrayType from Vector<Integer[]> arr", "label": {"api": {"GenericArrayType": [[70, 85]]}}}, {"text": "The nodeValue() of an Element is documented as being null", "label": {"api": {"documented": [[33, 42]]}}}, {"text": "Instead, you probably want to call getTextContent()", "label": {"api": {"getTextContent()": [[35, 50]]}}}, {"text": "Please, check BigDecimal if you want 1000-digit precission(or more)", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "Create an ExecutorService using one of the Executors factory methods, and submit a new Runnable to this executor each time you need to", "label": {"api": {"Executors": [[43, 51]]}}}, {"text": "The factory class Executors can be used to create different ExecutorService with different thread management strategies", "label": {"api": {"Executors": [[18, 26]]}}}, {"text": "You can compare an array of bytes with Arrays.equals( byte[], byte[] )", "label": {"api": {"Arrays.equals( byte[], byte[] )": [[39, 69]]}}}, {"text": "That's only possible with a custom ResourceBundle wherein you override the handleGetObject() method to check if the retrieved bundle value doesn't contain some specific syntax which should be substituted with another bundle value accordingly", "label": {"api": {"ResourceBundle": [[35, 48]], "handleGetObject()": [[75, 91]]}}}, {"text": "Finally just register the custom ResourceBundle instead in the <resource-bundle> or <f:loadBundle>", "label": {"api": {"ResourceBundle": [[33, 46]]}}}, {"text": "Java does have a scripting interface called \"javax.script\" which supports \"eval\" for code written in other languages (such as JavaScript, Ruby, Python, etc.) and also a tools package called \"javax.tools\" which provides access to the Java compiler (amongst other tools)", "label": {"api": {"scripting interface called \"javax.script\"": [[17, 57]], "tools package called \"javax.tools\"": [[169, 202]]}}}, {"text": "Enclosed is a copy of the Partial Result sample from the Task javadoc (fixed for syntax errors currently embedded in the Java 8 javadoc and to add more specific Generic types)", "label": {"api": {"Task": [[57, 60]]}}}, {"text": "For your case, you don't need to return the list of exceptions from the Task, but can instead place them in some UI control which displays the exceptions (like a ListView with a CellFactory for exception display)", "label": {"api": {"Task": [[72, 75]]}}}, {"text": "When updating it's observable properties Task first checks if the update is occurring on the FX Application thread", "label": {"api": {"Task": [[41, 44]]}}}, {"text": "See the Task source code to understand how this is done", "label": {"api": {"Task": [[8, 11]]}}}, {"text": "The File has some methods that can help you", "label": {"api": {"File": [[4, 7]]}}}, {"text": "exists() && isFile() && canRead() and print a better error-message depending on the reason why you cant read the file", "label": {"api": {"File": [[14, 17]]}}}, {"text": "What you described strongly resembles a utility class, similar to Java's Collections", "label": {"api": {"Collections": [[73, 83]]}}}, {"text": "Similiar to javas MATH class API for math class", "label": {"api": {"API for math class": [[29, 46]]}}}, {"text": "Before you do your paint, make a g.clearRect(0,0,w,h) call", "label": {"api": {"g.clearRect(0,0,w,h)": [[33, 52]]}}}, {"text": "I am currently using the built-in drag support JTable offers by calling setDragEnabled(true)", "label": {"api": {"setDragEnabled(true)": [[72, 91]]}}}, {"text": "The thread pool you are looking for is the ExecutorService class", "label": {"api": {"ExecutorService": [[43, 57]]}}}, {"text": "I am looking into using a Mixer object to synchronize the TargetDataLine which is accepting data from the microphone and the Line that handles playback from the MIDI instruments", "label": {"api": {"Mixer": [[26, 30]], "TargetDataLine": [[58, 71]]}}}, {"text": "You could wait on a Condition inside the method", "label": {"api": {"Condition": [[20, 28]]}}}, {"text": "When you output the number, instead of printing an int, use a NumberFormat, or a format String with System.out.format/System.out.printf", "label": {"api": {"NumberFormat": [[62, 73]], "System.out.format": [[100, 116]], "System.out.printf": [[118, 134]]}}}, {"text": "If exists by using SessionListeners you may need to do session invalidate", "label": {"api": {"session invalidate": [[55, 72]]}}}, {"text": "Use ProcessBuilder instead of Runtime.exec()", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "No, Treemap sorting order is based on key", "label": {"api": {"Treemap": [[4, 10]]}}}, {"text": "public static  List singletonList(T o) Returns an immutable list containing only the specified object", "label": {"api": {"public static  List singletonList(T o)": [[0, 37]]}}}, {"text": "Use the removeAll method define in the Set interface", "label": {"api": {"Set interface": [[39, 51]]}}}, {"text": "Or you can use CountdownLatch", "label": {"api": {"CountdownLatch": [[15, 28]]}}}, {"text": "To check if a table exist you can use DatabaseMetaData in this way", "label": {"api": {"DatabaseMetaData": [[38, 53]]}}}, {"text": "Convert if to a GregorianCalendar, and ask every field to the GregorianCalendar", "label": {"api": {"GregorianCalendar": [[16, 32], [62, 78]]}}}, {"text": "The Java term for this is clone", "label": {"api": {"clone": [[26, 30]]}}}, {"text": "Make sure your clone is deep enough, i.e", "label": {"api": {"clone": [[15, 19]]}}}, {"text": "you clone all relevant data structures, instead of sharing them between the original and its clone", "label": {"api": {"clone": [[4, 8], [93, 97]]}}}, {"text": "What distribution does Java's Random follow", "label": {"api": {"Random": [[30, 35]]}}}, {"text": "Random Javadoc says it's a uniform distribution", "label": {"api": {"Random Javadoc": [[0, 13]]}}}, {"text": "If you use nextGaussian(), you get a Gaussian distributed double value", "label": {"api": {"nextGaussian()": [[11, 24]]}}}, {"text": "You can use a Calendar and a SimpleDateFormat", "label": {"api": {"Calendar": [[14, 21]], "SimpleDateFormat": [[29, 44]]}}}, {"text": "I have a Java 7 code, where I'm playing with MethodHanlde", "label": {"api": {"MethodHanlde": [[45, 56]]}}}, {"text": "So, either create a new Vector each time, or call reset() on the stream before sending the vector a second time", "label": {"api": {"reset()": [[50, 56]]}}}, {"text": "Or use a HashSet to store your stop words, as you probably don't care about the order in which they are stored", "label": {"api": {"HashSet": [[9, 15]]}}}, {"text": "Just costruct Line2D.Double (or Line2D.Float) objects with the desired coordinates and then call the intersectsLine(Line2D) method as needed", "label": {"api": {"intersectsLine(Line2D)": [[101, 122]]}}}, {"text": "In java you can get the next result set from the Statement using the getMoreResults function", "label": {"api": {"getMoreResults": [[69, 82]]}}}, {"text": "RegEx is usually a good solution for scraping text", "label": {"api": {"RegEx": [[0, 4]]}}}, {"text": "If you use an Executor to spawn your threads, you can save all the returned Futures and then call Future.get() on them in the same order as they were started", "label": {"api": {"Future": [[76, 81], [98, 103]]}}}, {"text": "ExecutorService and Future", "label": {"api": {"ExecutorService": [[0, 14]], "Future": [[20, 25]]}}}, {"text": "Had you tried setting Margin for the said JMenu, if I do this", "label": {"api": {"Margin": [[22, 27]]}}}, {"text": "SwingUtilities, in particulare it's invokeLater(Runnable) method", "label": {"api": {"SwingUtilities": [[0, 13]], "invokeLater(Runnable)": [[36, 56]]}}}, {"text": "SwingWorker if you want to get fancy and start even more threads", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "Then you wrap this into your own custom TableModel and let Swing take care of the rest", "label": {"api": {"TableModel": [[40, 49]]}}}, {"text": "You can also use BufferedWriter's newLine() method, that takes care of that automatically", "label": {"api": {"BufferedWriter's": [[17, 32]]}}}, {"text": "Use scanner object, instead of worrying about chars/bytes", "label": {"api": {"scanner": [[4, 10]]}}}, {"text": "You should use the version of exec() that takes multiple args via a String array", "label": {"api": {"takes multiple args": [[42, 60]]}}}, {"text": "JTable (View & Controller) + TableModel (Model)", "label": {"api": {"JTable": [[0, 5]], "TableModel": [[29, 38]]}}}, {"text": "Using Java's Observable and Observer interface is not really convenient since you need to find out what properties of the observed object have changed", "label": {"api": {"Observable": [[13, 22]], "Observer": [[28, 35]]}}}, {"text": "Method doB() will never be called is false claim, because thrown NonUniqueResultException, which is extends PersistenceException is caught and next step in flow is to call doB()", "label": {"api": {"NonUniqueResultException": [[65, 88]]}}}, {"text": "The current transaction will continue after doA() executes is true, because as documented, NonUniqueResultException does not cause transaction to be marked for rollback", "label": {"api": {"NonUniqueResultException": [[91, 114]]}}}, {"text": "The current transaction will continue after doB() executes is false, because EntityExistsException marks active transaction for rollback", "label": {"api": {"EntityExistsException": [[77, 97]]}}}, {"text": "The current transaction will be marked for rollback when doA() is called this is false because of reason told for claim B, NonUniqueResultException does not mark transaction for rollback", "label": {"api": {"NonUniqueResultException": [[123, 146]]}}}, {"text": "The current transaction will be marked for rollback when doB() is called is true, because of reason told for claim C, EntityExistsException marks transaction for rollback", "label": {"api": {"EntityExistsException": [[118, 138]]}}}, {"text": "Set's doesn't allow duplicates .Where you are adding duplicate again like 'one' it is not being added", "label": {"api": {"Set's": [[0, 4]]}}}, {"text": "Notice though there is a special class called Class<T> that can represent both classes and interfaces", "label": {"api": {"Class<T>": [[46, 53]]}}}, {"text": "The fact that an interface is represented by a Class instance where isInterface is true could give you the impression that an interface is just a special type of class", "label": {"api": {"isInterface": [[68, 78]]}}}, {"text": "when I expecting them all to return true, so it seems like TreeSet.contains is not using my equals method as the API suggests", "label": {"api": {"suggests": [[117, 124]]}}}, {"text": "Quite typical reason is usage of java.sql.Date, which sets all time fields to 0", "label": {"api": {"java.sql.Date": [[33, 45]]}}}, {"text": "If that is the case, you can use java.sql.Timestamp instead (fractions of seconds will be lost)", "label": {"api": {"java.sql.Timestamp": [[33, 50]]}}}, {"text": "Pattern.quote(String) returns a (string) regex that matches the specified string exactly", "label": {"api": {"Pattern.quote(String)": [[0, 20]]}}}, {"text": "You need to invoke System.console() to retreive the object", "label": {"api": {"System.console()": [[19, 34]]}}}, {"text": "StringTokenizer is not right tool for this task", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "Consider this demo that shows tiles based on scaled image from the question and scaled image created using Image.getScaledInstance()", "label": {"api": {"Image.getScaledInstance()": [[107, 131]]}}}, {"text": "Note that if you choose to stay with your own scaling method check out The Perils of Image.getScaledInstance() for more optimized solutions", "label": {"api": {"Image.getScaledInstance()": [[85, 109]]}}}, {"text": "Yet another method, using StringTokenizer", "label": {"api": {"StringTokenizer": [[26, 40]]}}}, {"text": "Loot at the method String.equalsIgnoreCase for a better way of testing for the words that you want", "label": {"api": {"String.equalsIgnoreCase": [[19, 41]]}}}, {"text": "I am looking for something similar to Method.getGenericReturnType()", "label": {"api": {"Method.getGenericReturnType()": [[38, 66]]}}}, {"text": "It sounds like what you want is ParameterizedType", "label": {"api": {"ParameterizedType": [[32, 48]]}}}, {"text": "However, you can't get a ParameterizedType from any old Class object; you can obtain one from a Class instance that represents a type that extends a generic class or interface", "label": {"api": {"ParameterizedType": [[25, 41]]}}}, {"text": "Rather than eliminating the character that you don't want from your array (mutation during iteration is evil unless you're using an Iterator), why don't you use the StringBuilder class to catch all the characters you do want", "label": {"api": {"StringBuilder": [[165, 177]]}}}, {"text": "Then for the removing thing, I'd suggest too the use of an ArrayList where you will be able to iterate over it and remove the specific index you want to remove very easily", "label": {"api": {"remove": [[115, 120], [153, 158]]}}}, {"text": "The collision only occurs if you use the same object as key, or different object as keys with the same hash code and equals", "label": {"api": {"hash code": [[103, 111]], "equals": [[117, 122]]}}}, {"text": "For using correctly a HashMap, you should implement correctly in your key class the hashCode and equals method", "label": {"api": {"equals": [[97, 102]]}}}, {"text": "Have a look at File, BufferedWriter and FileWriter docs", "label": {"api": {"File": [[15, 18], [40, 43]], "BufferedWriter": [[21, 34]], "FileWriter": [[40, 49]]}}}, {"text": "Use Connection.getMetaData(), and use the returned object to get the catalogs, schemas, tables and columns", "label": {"api": {"Connection.getMetaData()": [[4, 27]]}}}, {"text": "As far as Connector/J implementation of DatabaseMetadata is concerned TABLE_CAT returns the database name (as in CREATE DATABASE); TABLE_SCHEM is null and SELF_REFERENCING_COL_NAME is not returned", "label": {"api": {"DatabaseMetadata": [[40, 55]]}}}, {"text": "The best documentation I've been able to find is in the offical JVM docs, and that's pretty sparse", "label": {"api": {"the offical JVM docs": [[52, 71]]}}}, {"text": "You should look into the Calendar class", "label": {"api": {"Calendar": [[25, 32]]}}}, {"text": "It would be more efficient to show an example of the Date.compareTo() process, as the Calendar.before() and Calendar.after() require comparisons against other Calendar objects, which can be expensive to create", "label": {"api": {"Calendar": [[86, 93], [108, 115], [159, 166]]}}}, {"text": "And of course, you might also check the documentation, which will give you a hint about this handy method called \"getNodeName()\"", "label": {"api": {"this handy method": [[88, 104]]}}}, {"text": "If all what you need for this purpose it's ID generation better to use java.util.concurrent AtomicInteger", "label": {"api": {"AtomicInteger": [[92, 104]]}}}, {"text": "One option without self made synchronization at all is to use AtomicInteger", "label": {"api": {"AtomicInteger": [[62, 74]]}}}, {"text": "Method incrementAndGet incerements value by one and returns updated value", "label": {"api": {"incrementAndGet": [[7, 21]]}}}, {"text": "I have a conventional servlet, (conforms to the servlet API defined by Oracle/Sun)", "label": {"api": {"servlet API": [[48, 58]]}}}, {"text": "I had heard of FilterChains, but am not sure if this is appropriate for this situation", "label": {"api": {"FilterChains": [[15, 26]]}}}, {"text": "Other than that you'll have to maintain a map of colors/RGB values, or possibly a set of system properties, and use Color.getColor(String name)", "label": {"api": {"Color.getColor(String name)": [[116, 142]]}}}, {"text": "You should probably capture a larger area at once, using Robot.createScreenCapture(Rectangle screenRect)", "label": {"api": {"Robot.createScreenCapture(Rectangle screenRect)": [[57, 103]]}}}, {"text": "Formats can be specified by using the Java 8 DateTimeFormatter Patterns", "label": {"api": {"DateTimeFormatter Patterns": [[45, 70]]}}}, {"text": "Then you can use java.math.BigDecimal", "label": {"api": {"java.math.BigDecimal": [[17, 36]]}}}, {"text": "If you're launching the groovy script by the lowest common denominator of Runtime.exec (or similar), then you can specify the environment in one of the overloaded methods", "label": {"api": {"one of the overloaded methods": [[141, 169]]}}}, {"text": "Use the setTimeZone(...) method from the Calendar class", "label": {"api": {"setTimeZone(...)": [[8, 23]]}}}, {"text": "The java.sql.Timestamp documentation says that it is a composite of java.util.Date and a nanosecond field", "label": {"api": {"java.sql.Timestamp": [[4, 21]]}}}, {"text": "In my opinion, this is bad design because java.sql.Timestamp is a direct subclass of java.util.Date", "label": {"api": {"java.sql.Timestamp": [[42, 59]]}}}, {"text": "It uses a temporary array to hold integers being hashed, and calling Arrays.hashCode(), which is available since Java 1.5, there's also versions for other primitive types", "label": {"api": {"Arrays.hashCode()": [[69, 85]]}}}, {"text": "I will use Preferences API to store data client side", "label": {"api": {"Preferences API": [[11, 25]]}}}, {"text": "The equals method for the class Object (described here) states clearly that the references need to the refer to the same object in order to return true", "label": {"api": {"described here": [[40, 53]]}}}, {"text": "You need to check for a connectable key, e.g", "label": {"api": {"connectable": [[24, 34]]}}}, {"text": "Use SocketChannel.finishConnect to determine whether the connection was established successfully", "label": {"api": {"SocketChannel.finishConnect": [[4, 30]]}}}, {"text": "You can use synchronizedMap to wrap any Map implementation in a thread-safe container", "label": {"api": {"synchronizedMap": [[12, 26]]}}}, {"text": "You could also use a ConcurrentSkipListMap if you want to order your elements with a Comparator", "label": {"api": {"ConcurrentSkipListMap": [[21, 41]]}}}, {"text": "Judging by the OpenJDK source code, it appears to be due to the fact that each simply requests the Image via Toolkit.getImage", "label": {"api": {"Toolkit.getImage": [[109, 124]]}}}, {"text": "Instead, you should skip the ImageIcon step completely (since it's inappropriate to be using a Swing class unnecessarily in the first place), and instead call Toolkit.createImage, which states in the documentation", "label": {"api": {"Toolkit.createImage": [[159, 177]]}}}, {"text": "I suggest you use String.toCharArray instead", "label": {"api": {"String.toCharArray": [[18, 35]]}}}, {"text": "Depending on the blocking nature of the input stream, you could call available() on the stream", "label": {"api": {"available()": [[69, 79]]}}}, {"text": "If the streams are smallish, you could write them into PushbackInputStreams, count the bytes and then rewind", "label": {"api": {"PushbackInputStream": [[55, 73]]}}}, {"text": "In order to create a class Loader which ides some classes, you have to override its loadClass method", "label": {"api": {"loadClass": [[84, 92]]}}}, {"text": "5554567899 exceeds Integer.MAX_VALUE (2147483647)", "label": {"api": {"Integer.MAX_VALUE": [[19, 35]]}}}, {"text": "Use the overloaded method split(String regex, int limit)", "label": {"api": {"split(String regex, int limit)": [[26, 55]]}}}, {"text": "See documentation here", "label": {"api": {"documentation here": [[4, 21]]}}}, {"text": "You need to implement ActionListner", "label": {"api": {"ActionListner": [[22, 34]]}}}, {"text": "To get start of next day you can use Calendar", "label": {"api": {"Calendar": [[37, 44]]}}}, {"text": "You can also use infile.next()", "label": {"api": {"infile.next()": [[17, 29]]}}}, {"text": "You can use calendar implement it like", "label": {"api": {"calendar": [[12, 19]]}}}, {"text": "You could write a FileFilter and supply it to the File.listFiles() method", "label": {"api": {"FileFilter": [[18, 27]], "File.listFiles()": [[50, 65]]}}}, {"text": "In that case use the Robot to capture the image, but capture only the area of the component, rather than the entire screen", "label": {"api": {"Robot": [[21, 25]]}}}, {"text": "First of all JavaDocs explain clearly that you should implements this method", "label": {"api": {"JavaDocs explain": [[13, 28]]}}}, {"text": "Because this method is already implemented for each and every object in Java (in Object class)", "label": {"api": {"in Object class": [[78, 92]]}}}, {"text": "use the OUTPUTKEYS to set the property in the TRANSFORMER", "label": {"api": {"OUTPUTKEYS": [[8, 17]], "TRANSFORMER": [[46, 56]]}}}, {"text": "To do what you want you should use the OMIT_XML_DECLARATION output key", "label": {"api": {"OMIT_XML_DECLARATION": [[39, 58]]}}}, {"text": "Is there any problem with Math.signum()?", "label": {"api": {"Math.signum()": [[26, 38]]}}}, {"text": "in a Process and use the Robot to interact with it", "label": {"api": {"Process": [[5, 11]], "Robot": [[25, 29]]}}}, {"text": "If assigning an object to another is important you can look into the clone() method or use a copy constructor", "label": {"api": {"clone()": [[69, 75]]}}}, {"text": "you can use System.setOut() to replace the console PrintStream", "label": {"api": {"System.setOut()": [[12, 26]]}}}, {"text": "You should look at the LexicalHandler which tells you about CDATA start/ends", "label": {"api": {"LexicalHandler": [[23, 36]]}}}, {"text": "ConstraintViolation.getInvalidValue() doesn't return value you need", "label": {"api": {"ConstraintViolation.getInvalidValue()": [[0, 36]]}}}, {"text": "I'm not sure about how it affects GridBagLayout, but \"In general, when you want to set a border on a standard Swing component other than JPanel or JLabel, we recommend that you put the component in a JPanel and set the border on the JPanel.\"setBorder()", "label": {"api": {"setBorder()": [[242, 252]]}}}, {"text": "TitledPane is a Labeled, so you can set a graphic on it in a listener or a binding to the expanded property", "label": {"api": {"set a graphic": [[36, 48]], "expanded": [[90, 97]]}}}, {"text": "If you need code based access to sub-components of the TitledPane, you can use the lookup function after the TitledPane has been added to a Scene shown on a Stage", "label": {"api": {"lookup": [[83, 88]]}}}, {"text": "I'd advise trying the graphic/css stylesheet based approaches before trying a lookup", "label": {"api": {"lookup": [[78, 83]]}}}, {"text": "If you don't need the Labeled to display text then set it display a graphic only", "label": {"api": {"graphic only": [[68, 79]]}}}, {"text": "The format() method does not alter the double that you pass in, it returns a String format of the double", "label": {"api": {"format() method": [[4, 18]]}}}, {"text": "The MethodHandle is a new way to get a overloaded method using a signature (java 7)", "label": {"api": {"MethodHandle": [[4, 15]]}}}, {"text": "Even though you don't have any direct control over which objects get collected and when that process happens, you can use the reference classes from java.lang.ref to influence which objects are eligible and more likely to be garbage collected at a given time", "label": {"api": {"java.lang.ref": [[149, 161]]}}}, {"text": "I think your best approach for this would be to instantiate a ThreadPoolExecutor with a PriorityBlockingQueue", "label": {"api": {"instantiate a ThreadPoolExecutor": [[48, 79]], "PriorityBlockingQueue": [[88, 108]]}}}, {"text": "Specifically, use a PriorityBlockingQueue constructor that takes in a Comparator", "label": {"api": {"PriorityBlockingQueue": [[20, 40]], "Comparator": [[70, 79]]}}}, {"text": "Your Comparator will be what you use to implement your 'priority'", "label": {"api": {"Comparator": [[5, 14]]}}}, {"text": "It was mentioned before that certain statements won't even compile - int num1 = new Scanner() is inappropriate because an int is not an object, and an empty constructor isn't one of the choices for a new Scanner", "label": {"api": {"an int is not an object, and an empty constructor isn't one of the choices for a new Scanner": [[119, 210]]}}}, {"text": "currentTimeMillis() is defined as", "label": {"api": {"defined": [[23, 29]]}}}, {"text": "Have you seen the Robot class", "label": {"api": {"Robot": [[18, 22]]}}}, {"text": "After looking at implementing my own signal mechanism and following the bread-crumb trail left by others doing the same thing, I came across the javadoc for AbstractQueuedSynchronizer, which includes a code snippet for a \"BooleanLatch\", which perfectly meets my needs", "label": {"api": {"AbstractQueuedSynchronizer": [[157, 182]]}}}, {"text": "Assuming the variables named ct[1-5]9 reference distinct instances of JComboBox, \"problems may arise if you add duplicate String objects.\" If necessary, you can duplicate the items, as shown in the API", "label": {"api": {"API": [[198, 200]]}}}, {"text": "I would suggest you look into the documentation for the Comparable interface", "label": {"api": {"Comparable": [[56, 65]]}}}, {"text": "Possible even with the use of an PriorityQueue", "label": {"api": {"PriorityQueue": [[33, 45]]}}}, {"text": "If you want to make an \"EJB-call\" then you should use SessionContext.getBusinessMethod(...)", "label": {"api": {"SessionContext.getBusinessMethod(...)": [[54, 90]]}}}, {"text": "You could have the webRowSet write its XML to a ByteArrayOutputStream (preferably wrapped inside a BufferedOutputStream for buffering purposes)", "label": {"api": {"ByteArrayOutputStream": [[48, 68]], "BufferedOutputStream": [[99, 118]]}}}, {"text": "Next, you can instruct your Transformer to read from a ByteArrayInputStream, which you instantiate with the byte[] you obtain from the ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[135, 155]], "ByteArrayInputStream": [[55, 74]]}}}, {"text": "The getter is been called during the end of validations phase because at that moment the decision will be made whether to publish a ValueChangeEvent or not", "label": {"api": {"ValueChangeEvent": [[132, 147]]}}}, {"text": "When those values are inequal, then both will be passed as \"old\" and \"new\" value of the published ValueChangeEvent", "label": {"api": {"ValueChangeEvent": [[98, 113]]}}}, {"text": "The groupCount() method doesn't return the number of matches, it returns  the number of capturing groups in this matcher's pattern", "label": {"api": {"groupCount()": [[4, 15]]}}}, {"text": "Why not call FutureTask.get()", "label": {"api": {"FutureTask.get()": [[13, 28]]}}}, {"text": "You can achieve this using the File#exists() method", "label": {"api": {"File#exists()": [[31, 43]]}}}, {"text": "Then you can call File#exists() on the returned object", "label": {"api": {"File#exists()": [[18, 30]]}}}, {"text": "This enables the DOTALL match flag", "label": {"api": {"DOTALL": [[17, 22]]}}}, {"text": "Have a look at BlockingQueue", "label": {"api": {"BlockingQueue": [[15, 27]]}}}, {"text": "And in order to avoid creating too many threads, you might want to consider using an Executor, which can manage a thread pool for you", "label": {"api": {"Executor": [[85, 92]]}}}, {"text": "See Java's PriorityQueue class", "label": {"api": {"PriorityQueue": [[11, 23]]}}}, {"text": "Given the prohibition against creating new files, you're pretty much stuck with ZipInputStream", "label": {"api": {"ZipInputStream": [[80, 93]]}}}, {"text": "A better solution is to at least open the outer archive as a ZipFile, which memory-maps the actual file", "label": {"api": {"ZipFile": [[61, 67]]}}}, {"text": "If you can then extract the contained archives into a temporary directory and open them as ZipFiles as well, you'll probably see a big speed increase (as long as you're pulling multiple files from each embedded archive)", "label": {"api": {"ZipFile": [[91, 97]]}}}, {"text": "getEnumConstants gives you all the enum's values, and if you want names instead you can just use .name on the Enum objects", "label": {"api": {"getEnumConstants": [[0, 15]], ".name": [[97, 101]]}}}, {"text": "I would recommend to use SynchronousQueue", "label": {"api": {"SynchronousQueue": [[25, 40]]}}}, {"text": "Use the DecimalFormat class to better decouple the value and its representation", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "As you can see the documentation isn't entirely right, other attributes are also allowed (\"just one element\"), see WebServlet - but the one named value is treated differently", "label": {"api": {"WebServlet": [[115, 124]]}}}, {"text": "You might want to take a look at the Java regex documentation", "label": {"api": {"Java regex documentation": [[37, 60]]}}}, {"text": "Have you taken a look at the javadocs for the File class", "label": {"api": {"javadocs for the File class": [[29, 55]]}}}, {"text": "You can also attach some MouseMotionListener to the inner JPanel and modify the scroll bars' offset according the mouse movements (modifying the scroll bars will automatically trigger the repaint on the image) for mouse interaction with your component", "label": {"api": {"MouseMotionListener": [[25, 43]]}}}, {"text": "You may want to use a concurrent data structure adapted to you needs", "label": {"api": {"concurrent data structure": [[22, 46]]}}}, {"text": "Then I tried to load bytes to pyhsical memory by calling load method by it is no use", "label": {"api": {"load": [[16, 19], [57, 60]]}}}, {"text": "To compile Java code, you can use the Java Compiler API", "label": {"api": {"Java Compiler API": [[38, 54]]}}}, {"text": "To generate an executable JAR, create a JarOutputStream with a manifest that declares the main class", "label": {"api": {"JarOutputStream": [[40, 54]]}}}, {"text": "The JavaDoc for the File class states", "label": {"api": {"JavaDoc for the File class": [[4, 29]]}}}, {"text": "You should use the method connect(SocketAddress endpoint, int timeout) of java.net.Socket inside your Client class", "label": {"api": {"connect(SocketAddress endpoint, int timeout)": [[26, 69]], "java.net.Socket": [[74, 88]]}}}, {"text": "Typically EventListenerList is used internally, but other implementations are mentioned here", "label": {"api": {"EventListenerList": [[10, 26]]}}}, {"text": "No, each model maintains an EventListenerList internally; each corresponding view adds itself as a listener via the model's addXxxListener() method", "label": {"api": {"EventListenerList": [[28, 44]]}}}, {"text": "I would use a LinkedHashMap as it support access order and use as a LRU map", "label": {"api": {"LinkedHashMap": [[14, 26]]}}}, {"text": "The Standard Swing JOptionPane does what you want; probably best to use that instead of re-inventing the wheel", "label": {"api": {"Standard Swing JOptionPane": [[4, 29]]}}}, {"text": "You can get those (key, value) pairs as a set using the entrySet method", "label": {"api": {"entrySet": [[56, 63]]}}}, {"text": "RequestDispatcher#forward(javax.servlet.ServletRequest, javax.servlet.ServletResponse; an explanation can be found at Forward vs Redirect", "label": {"api": {"RequestDispatcher#forward(javax.servlet.ServletRequest, javax.servlet.ServletResponse": [[0, 84]]}}}, {"text": "In addition, it might be a better idea to implement authentication as a Filter instead of a Servlet; that way, the Filter can be used to intercept any URL you deem needs to be secured", "label": {"api": {"Filter": [[72, 77], [115, 120]]}}}, {"text": "From the docs it appears that you'll at least need to get a JarInputStream from an existing JarFile, iterate over the entries using getNextJarEntry, and write to a JarOutputStream with the entries, also adding your own new files using new JarEntry objects for each new file", "label": {"api": {"JarInputStream": [[60, 73]], "JarFile": [[92, 98]], "getNextJarEntry": [[132, 146]], "JarOutputStream": [[164, 178]], "JarEntry": [[139, 146], [239, 246]]}}}, {"text": "Here's sample code for writing a jar from scratch programmatically, this should extend nicely to your case, the difference being that most of the JarEntry objects will be coming from a JarInputStream", "label": {"api": {"JarInputStream": [[185, 198]], "JarEntry": [[146, 153]]}}}, {"text": "JPA providers will often use dynamic proxy classes of your concrete JPA classes, so you have no guarantee of the field names in the proxy", "label": {"api": {"dynamic proxy classes": [[29, 49]]}}}, {"text": "For example, you can use the version of Arrays.sort() which just takes an array of objects", "label": {"api": {"the version of Arrays.sort() which just takes an array of objects": [[25, 89]]}}}, {"text": "You can do this with a call to Thread.getStackTrace()", "label": {"api": {"Thread.getStackTrace()": [[31, 52]]}}}, {"text": "Just use Thread.dumpStack(), which prints out the stack (similar to when an exception is uncaught)", "label": {"api": {"Thread.dumpStack()": [[9, 26]]}}}, {"text": "You should indeed note that InputStream.available is defined as follows..", "label": {"api": {"InputStream.available": [[28, 48]]}}}, {"text": "Instead, you want to check for end-of-stream, which is indicated by InputStream.read() returning -1", "label": {"api": {"InputStream.read()": [[68, 85]]}}}, {"text": "You can use Class.forName to load classes at runtime", "label": {"api": {"Class.forName": [[12, 24]]}}}, {"text": "Without giving away the answer, you want to specify the delimiter to split such that the array of Strings returned looks like", "label": {"api": {"split": [[69, 73]]}}}, {"text": "In the documentation on String.split, it is unclear whether empty strings count as substrings", "label": {"api": {"documentation on String.split": [[7, 35]]}}}, {"text": "I'd go over the map entries and use the removeIf method to remove the relevant elements from each list", "label": {"api": {"removeIf": [[40, 47]]}}}, {"text": "The contract for hashcode states", "label": {"api": {"contract for hashcode": [[4, 24]]}}}, {"text": "To merely check that they are different (as Hunter McMillen pointed out) - http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[75, 136]]}}}, {"text": "The this keyword is a reference to the current class instance, but when you pass it into, say, addMouseListener, you are passing the implemented Interface reference, in this case would be MouseListener", "label": {"api": {"MouseListener": [[98, 110], [188, 200]]}}}, {"text": "From this example, you can see how each member is written using the RandomAccessFile object", "label": {"api": {"RandomAccessFile": [[68, 83]]}}}, {"text": "Check the Java XPath API to get more information", "label": {"api": {"Java XPath API": [[10, 23]]}}}, {"text": "Normal ThreadPoolExecutor should suffice", "label": {"api": {"ThreadPoolExecutor": [[7, 24]]}}}, {"text": "Use the javax.swing.Timer class", "label": {"api": {"javax.swing.Timer": [[8, 24]]}}}, {"text": "If you want to write your own implementation of HashMap, simply implements the Map interface and implement its methods the way you want", "label": {"api": {"Map": [[52, 54], [79, 81]]}}}, {"text": "You may also want to extend the AbtractMap abstract class that provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface", "label": {"api": {"Map": [[39, 41], [105, 107]], "AbtractMap": [[32, 41]]}}}, {"text": "To display a JLabel with an icon, you should use JLabel#setIcon(Icon)", "label": {"api": {"JLabel#setIcon(Icon)": [[49, 68]]}}}, {"text": "How about creating a custom JTable", "label": {"api": {"JTable": [[28, 33]]}}}, {"text": "Note that the newFileSystem documentation shows a memory://..", "label": {"api": {"newFileSystem documentation": [[14, 40]]}}}, {"text": "First, I advise you take KevinMangold's advice, seeing as Java provides a perfectly suitable Point class for you to use", "label": {"api": {"Point": [[93, 97]]}}}, {"text": "ThreadPoolExecutor does not spawn worker threads until necessary or if you pre-empt their creation by the methods prestartAllCoreThreads and prestartCoreThread", "label": {"api": {"prestartAllCoreThreads": [[114, 135]], "prestartCoreThread": [[141, 158]]}}}, {"text": "You could also call prestartCoreThread and receive similar behavior", "label": {"api": {"prestartCoreThread": [[20, 37]]}}}, {"text": "If you want to start all the workers, you must call prestartAllCoreThreads or submit that number of tasks via execute", "label": {"api": {"prestartAllCoreThreads": [[52, 73]]}}}, {"text": "You may want to use a Set instead of a Vector", "label": {"api": {"Set": [[22, 24]]}}}, {"text": "Sets do not contain duplicate elements", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "Or use a Map with the name property as key value and store the corresponding Person object as value", "label": {"api": {"Map": [[9, 11]]}}}, {"text": "Use the version of Runtime.exec(String[]) that takes a String[]", "label": {"api": {"Runtime.exec(String[])": [[19, 40]]}}}, {"text": "ReentrantReadWriteLock is a specialized lock whereas synchronized(this) is a general purpose lock", "label": {"api": {"ReentrantReadWriteLock": [[0, 21]]}}}, {"text": "You are right in that you could use synchronized(this) instead of ReentrantReadWriteLock but the opposite is not always true", "label": {"api": {"ReentrantReadWriteLock": [[66, 87]]}}}, {"text": "If you'd like to better understand what makes ReentrantReadWriteLock special look up some information about producer-consumer thread synchronization", "label": {"api": {"ReentrantReadWriteLock": [[46, 67]]}}}, {"text": "A ReentrantLock is unstructured, unlike synchronized constructs -- i.e", "label": {"api": {"ReentrantLock": [[2, 14]]}}}, {"text": "Aside from that, ReentrantLock supports lock polling and interruptible lock waits that support time-out", "label": {"api": {"ReentrantLock": [[17, 29]], "lock polling": [[40, 51]], "interruptible lock waits that support time-out": [[57, 102]]}}}, {"text": "ReentrantLock also has support for configurable fairness policy, allowing more flexible thread scheduling", "label": {"api": {"ReentrantLock": [[0, 12]], "configurable fairness policy": [[35, 62]]}}}, {"text": "ReentrantLock may also be more scalable, performing much better under higher contention", "label": {"api": {"ReentrantLock": [[0, 12]]}}}, {"text": "When should you use ReentrantLocks", "label": {"api": {"ReentrantLock": [[20, 32]]}}}, {"text": "The answer is pretty simple -- use it when you actually need something it provides that synchronized doesn't, like timed lock waits, interruptible lock waits, non-block-structured locks, multiple condition variables, or lock polling", "label": {"api": {"lock polling": [[220, 231]]}}}, {"text": "ReentrantLock also has scalability benefits, and you should use it if you actually have a situation that exhibits high contention, but remember that the vast majority of synchronized blocks hardly ever exhibit any contention, let alone high contention", "label": {"api": {"ReentrantLock": [[0, 12]]}}}, {"text": "I would advise developing with synchronization until synchronization has proven to be inadequate, rather than simply assuming \"the performance will be better\" if you use ReentrantLock", "label": {"api": {"ReentrantLock": [[170, 182]]}}}, {"text": "UUIDs as specified by RFC 4122 are 128 bits, as are UUID objects in Java", "label": {"api": {"UUID objects in Java": [[52, 71]]}}}, {"text": "You can catch TimeoutException  like this code", "label": {"api": {"TimeoutException": [[14, 29]]}}}, {"text": "Or in java, you can explicitly create an object that returns the same value for hashCode()", "label": {"api": {"hashCode()": [[80, 89]]}}}, {"text": "The second put() simply overwrites what the first put() wrote", "label": {"api": {"put()": [[11, 15], [50, 54]]}}}, {"text": "Class.newInstance() can only invoke the zero-argument constructor and Integer doesn't have ZERO argument constructor", "label": {"api": {"Integer": [[70, 76]]}}}, {"text": "One of the constructors of ScheduledThreadPoolExecutor allows me to pass a ThreadFactory to it", "label": {"api": {"ScheduledThreadPoolExecutor": [[27, 53]]}}}, {"text": "I suggest you use DecimalFormat and setParseBigDecimal to true", "label": {"api": {"setParseBigDecimal": [[36, 53]]}}}, {"text": "Elegance is more a subjective thing, but if you want to check whether the directories are actually created, check also the return value of File.mkdirs()", "label": {"api": {"File.mkdirs()": [[139, 151]]}}}, {"text": "Either you need to synchronize access, or use ConcurrentSkipListSet", "label": {"api": {"ConcurrentSkipListSet": [[46, 66]]}}}, {"text": "If you're actually going to have multiple threads reading/writing the data structure then you need to either use locks (synchronize) or use a concurrent data structure like java.util.concurrent.ConcurrentHashMap", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[173, 210]]}}}, {"text": "Not sure if JPQL supports union operation at all", "label": {"api": {"JPQL supports": [[12, 24]]}}}, {"text": "Or, if you use an extension of DefaultTableModel, use the addRow method", "label": {"api": {"addRow": [[58, 63]]}}}, {"text": "The fact that you issue a repaint immediately after you added the component suggests that you do so on an already visible frame", "label": {"api": {"repaint": [[26, 32]], "paint": [[28, 32]]}}}, {"text": "Perhaps you should validate the frame first", "label": {"api": {"validate": [[19, 26]]}}}, {"text": "As already stated in comments to your question, you should override paintComponent instead of paint, and you should not call dispose as you didn't create this Graphics context", "label": {"api": {"paintComponent": [[68, 81]], "paint": [[68, 72], [94, 98]], "dispose": [[125, 131]]}}}, {"text": "The calls to sync and repaint should be unneccessary as well, I guess you added them in an attempt to solve this issue here", "label": {"api": {"repaint": [[22, 28]], "paint": [[24, 28]], "sync": [[13, 16]]}}}, {"text": "The Blob.free() was introduced in JDBC 4.0 / Java 6", "label": {"api": {"Blob.free()": [[4, 14]]}}}, {"text": "I would perhaps use String.format() and you'll be able to control the formatting of the double in the string", "label": {"api": {"String.format()": [[20, 34]]}}}, {"text": "And here's the doc for the underlying Formatter, and the standard tutorial", "label": {"api": {"Formatter": [[38, 46]]}}}, {"text": "For other cases, you should use StringBuilder", "label": {"api": {"StringBuilder": [[32, 44]]}}}, {"text": "From its own documentation", "label": {"api": {"own documentation": [[9, 25]]}}}, {"text": "I think you might be looking for something like java.util.Formatter, which provides ways to format text output, specify column widths, and intelligently format common things like floating point numbers and dates, etc", "label": {"api": {"java.util.Formatter": [[48, 66]]}}}, {"text": "For example, java.util.List, where the relevant characteristics equality is defined, and the formula for calculating the hash code is explicitly documented", "label": {"api": {"java.util.List": [[13, 26]]}}}, {"text": "equals contract in List (emphasis mine)", "label": {"api": {"equals contract in List": [[0, 22]]}}}, {"text": "You could try using Java's String.Split", "label": {"api": {"String.Split": [[27, 38]]}}}, {"text": "It also shows DefaultCellEditor.setClickCountToStart() usage", "label": {"api": {"DefaultCellEditor.setClickCountToStart()": [[14, 53]]}}}, {"text": "File#listFiles() doesn't throw a FileNotFoundException either", "label": {"api": {"File#listFiles()": [[0, 15]]}}}, {"text": "You might be better of writing your own implementation with split() or indexOf() or whatever your heart desires to avoid any future bugs and/or headaches", "label": {"api": {"split()": [[60, 66]], "indexOf()": [[71, 79]]}}}, {"text": "Below, Thread.interrupt is used to implement the coordination", "label": {"api": {"Thread.interrupt": [[7, 22]]}}}, {"text": "Alternatively, you could also use a volatile boolean (or AtomicBoolean) as means of communicating", "label": {"api": {"AtomicBoolean": [[57, 69]]}}}, {"text": "Similarly, you could opt to, rather than use AtomicBoolean, use a field such as", "label": {"api": {"AtomicBoolean": [[45, 57]]}}}, {"text": "Better yet, if you take advantage of ExecutorServices, you can also program similar code as follows", "label": {"api": {"ExecutorService": [[37, 51]]}}}, {"text": "This takes advantage of the fact that ThreadPoolExecutor.shutdownNow interrupts its worker threads in an attempt to signal shutdown", "label": {"api": {"ThreadPoolExecutor.shutdownNow": [[38, 67]]}}}, {"text": "You could try to locate the root window containing the applet, either by iterating over parent links yourself or using SwingUtilities.getRoot or SwingUtilities.getWindowAncestor", "label": {"api": {"parent links": [[88, 99]], "SwingUtilities.getRoot": [[119, 140]], "SwingUtilities.getWindowAncestor": [[145, 176]]}}}, {"text": "JavaCompiler - How to pass -X options programmatically to the JavaCompiler class", "label": {"api": {"JavaCompiler": [[0, 11], [62, 73]]}}}, {"text": "The JavaCompiler page you linked to has some nice examples", "label": {"api": {"JavaCompiler": [[4, 15]]}}}, {"text": "What you seem to want is an insertion-order Set with average-case performance comparable to HashMap.contains, so I suggest you look at LinkedHashSet", "label": {"api": {"LinkedHashSet": [[135, 147]]}}}, {"text": "From your updated question I reckon that you are actually after  JComponent.setBorder, example screenshot", "label": {"api": {"JComponent.setBorder": [[65, 84]]}}}, {"text": "Original answer, if you want a border around the view port, use JScrollPane.setViewportBorder", "label": {"api": {"JScrollPane.setViewportBorder": [[64, 92]]}}}, {"text": "Instead, the Process will return a non-zero exitValue, and there will probably be some output on the process' console", "label": {"api": {"return a non-zero exitValue": [[26, 52]]}}}, {"text": "What you need to do is to take the InputStream of your Process, and log it somehow (for example, dump it into the console), so you can see what the sqlldr output is", "label": {"api": {"take the InputStream of your Process": [[26, 61]]}}}, {"text": "If you just want to sort the array, use the following", "label": {"api": {"sort": [[20, 23]]}}}, {"text": "If you want to sort it manually, I would recommend reading this page, where you can find pseudo-code for a variety of sorting algorithms", "label": {"api": {"sort": [[15, 18], [118, 121]]}}}, {"text": "However, if you are searching for a way to sort the array based on number frequency, I would recommend this page", "label": {"api": {"sort": [[43, 46]]}}}, {"text": "You would have to inverse the sorting order, sonce you want them in ascending order", "label": {"api": {"sort": [[30, 33]]}}}, {"text": "What about Arrays.sort(int[])", "label": {"api": {"Arrays.sort(int[])": [[11, 28]]}}}, {"text": "When you want to manipulate an image, javax.imageio.ImageIO can be of great use", "label": {"api": {"javax.imageio.ImageIO": [[38, 58]]}}}, {"text": "You can use that to load the image from the stream, apply some operation like a ColorConvertOp, and write the result back to a stream", "label": {"api": {"ColorConvertOp": [[80, 93]]}}}, {"text": "To make primitive variable as Object java has introduced wrapper classed like Integer, Boolean etc", "label": {"api": {"Integer": [[78, 84]], "Boolean": [[87, 93]]}}}, {"text": "You should implement your custom TableCellRenderer and TableCellEditor", "label": {"api": {"TableCellRenderer": [[33, 49]], "TableCellEditor": [[55, 69]]}}}, {"text": "If you are on Java 8, you can use the Java Time API, specifically Calendar::toInstant(), followed by Instant::truncatedTo()", "label": {"api": {"Calendar::toInstant()": [[66, 86]], "Instant::truncatedTo()": [[101, 122]]}}}, {"text": "Specify the granularity of truncation using ChronoUnit enum", "label": {"api": {"ChronoUnit": [[44, 53]]}}}, {"text": "If your TableModel for example extends from AbstractTableModel, you can call the fireTableRowsUpdated method after you have made the changes", "label": {"api": {"fireTableRowsUpdated": [[81, 100]]}}}, {"text": "A more efficient model may be to use a thread pool (via ThreadPoolExecutor) and tune it for the optimal number of simultaneous threads on your system (e.g", "label": {"api": {"ThreadPoolExecutor": [[56, 73]]}}}, {"text": "list.add(pos, new HashSet<Integer>()); is going to add a new set at that position and shift the existing one to pos+1", "label": {"api": {"add a new set at that position and shift the existing one": [[51, 107]]}}}, {"text": "Take a look at the XmlSeeAlso annotation as this might help", "label": {"api": {"XmlSeeAlso": [[19, 28]]}}}, {"text": "Using the constructor of ScheduledThreadPoolExecutor", "label": {"api": {"constructor of ScheduledThreadPoolExecutor": [[10, 51]]}}}, {"text": "You use TimeZone.getTimeZone(String) to get the time zone, then you can set that as the default", "label": {"api": {"TimeZone.getTimeZone(String)": [[8, 35]]}}}, {"text": "Call Dialog.getOwner() from within the dialog", "label": {"api": {"Dialog.getOwner()": [[5, 21]]}}}, {"text": "This will encode the data to the system encoding, which may be a lossy conversion and may cause corruption if the device being written to doesn't use a matching encoding", "label": {"api": {"system encoding": [[33, 47]]}}}, {"text": "Use SimpleDateFormat for formatting a date", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "However a better solution would be to use the NumberFormat class", "label": {"api": {"NumberFormat class": [[46, 63]]}}}, {"text": "All collections I can find are either blocking (LinkedBlockingQueue) or of unlimited size (ArrayDeque)", "label": {"api": {"LinkedBlockingQueue": [[48, 66]], "ArrayDeque": [[91, 100]]}}}, {"text": "For example JFormattedTextFiled.AbstractFormatter", "label": {"api": {"JFormattedTextFiled.AbstractFormatter": [[12, 48]]}}}, {"text": "But you can format the Integer, if you want (DecimalFormat)", "label": {"api": {"DecimalFormat": [[45, 57]]}}}, {"text": "DecimalFormat builds a String that represents the quantity in a particular format", "label": {"api": {"DecimalFormat": [[0, 12]]}}}, {"text": "Here's the values of the constants in Pattern which you'll notice are all powers of two", "label": {"api": {"values of the constants in Pattern": [[11, 44]]}}}, {"text": "You can use a dynamic ByteArrayOutputStream which grows an internal buffer to accommodate all the data", "label": {"api": {"ByteArrayOutputStream": [[22, 42]]}}}, {"text": "Instead, tell the tree model to reload() the affected node, as shown here", "label": {"api": {"reload()": [[32, 39]]}}}, {"text": "See http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html#BigDecimal(java.lang.String) for a constructor that will take a string like \"1.123E-4\"", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html#BigDecimal(java.lang.String": [[4, 101]]}}}, {"text": "If high-precision is what you're striving for, indeed use BigDecimal", "label": {"api": {"BigDecimal": [[58, 67]]}}}, {"text": "Please check out the BufferedImage API, the getSubImage() method", "label": {"api": {"BufferedImage API": [[21, 37]]}}}, {"text": "Take a look at the DecimalFormat class", "label": {"api": {"DecimalFormat": [[19, 31]]}}}, {"text": "Alternatively you can setScale method from the BigDecimal Class", "label": {"api": {"setScale": [[22, 29]]}}}, {"text": "If you are after precision, I would recommend you use the setScale method, using the .doubleValue() method will yield a double which can cause loss of precision", "label": {"api": {"setScale": [[58, 65]]}}}, {"text": "A thread may only cause itself to sleep using Thread.sleep", "label": {"api": {"Thread.sleep": [[46, 57]]}}}, {"text": "If you want to have more control over when each thread runs you'll want to look into semaphores and other locking/scheduling mechanisms in the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[143, 162]]}}}, {"text": "Why not throw them all into an Executor, and call get() on each resultant Future in turn", "label": {"api": {"Executor": [[31, 38]], "Future": [[74, 79]]}}}, {"text": "You can compress it with ZIP very easily by using GZIPInputStream and its output counterpart on the other end of the socket", "label": {"api": {"GZIPInputStream": [[50, 64]]}}}, {"text": "You can use ByteBuffer http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html for that task", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html": [[23, 87]]}}}, {"text": "I think you need to submit each Runnable, get a Future back, and then call get() on each Future", "label": {"api": {"Future": [[48, 53], [89, 94]], "get()": [[75, 79]]}}}, {"text": "When you call get(), you'll either get the result of the Runnable, or the exception that it encountered", "label": {"api": {"get()": [[14, 18]]}}}, {"text": "You can split with  the following regex", "label": {"api": {"split": [[8, 12]]}}}, {"text": "Force session invalidation using HttpSession.invalidate() and you can see that the sys out is printed or wait for the session to auto-expire by specifying as shown below in web.xml", "label": {"api": {"HttpSession.invalidate()": [[33, 56]]}}}, {"text": "Use Character.isWhitespace() rather than creating your own", "label": {"api": {"Character.isWhitespace()": [[4, 27]]}}}, {"text": "You can then use Java regexps with one of the following Patterns representing character codes", "label": {"api": {"Patterns": [[56, 63]]}}}, {"text": "This would be pretty easy to do with a Scanner", "label": {"api": {"Scanner": [[39, 45]]}}}, {"text": "Since Java 8, you can create a PKCS#12 keystore and pass an explicit PasswordProtection parameter when storing a key to specify the encryption algorithm to use", "label": {"api": {"PasswordProtection": [[69, 86]]}}}, {"text": "You should be able to do this fairly easy using Properties.stringPropertyNames and Hashtable.remove, as Properties is a subclass of Hashtable", "label": {"api": {"Properties.stringPropertyNames": [[48, 77]], "Hashtable.remove": [[83, 98]]}}}, {"text": "Currently I'm checking SMTPAddressFailedExceptions with getAddress() and AddressExceptions with getRef()", "label": {"api": {"AddressException": [[73, 88]], "getRef()": [[96, 103]]}}}, {"text": "You can use RandomAccessFile to overwrite the relevant chunk of the file", "label": {"api": {"RandomAccessFile": [[12, 27]]}}}, {"text": "See the API documentation", "label": {"api": {"See the API documentation": [[0, 24]]}}}, {"text": "Use getModifiers(), you can read the flags using the utility functions in Modifier", "label": {"api": {"getModifiers()": [[4, 17]], "Modifier": [[7, 14], [74, 81]]}}}, {"text": "I don't know about Play-framework, but if it's possible to create JPQL-queries, how about building a Query-object and using it to insert the collection instead..", "label": {"api": {"Query": [[101, 105]]}}}, {"text": "Although such an anonymous class is technically a subclass, the beauty of this is shown when comparing using this technique with a more traditional one in creating an unmodifiable map", "label": {"api": {"unmodifiable": [[167, 178]]}}}, {"text": "Also note that with the mess version, the two statements need not be adjacent, so it can become less obvious what the contents of the unmodifiable map is", "label": {"api": {"unmodifiable": [[134, 145]]}}}, {"text": "First convert from float to integer, by computing both exponents using Math.getExponent and taking the maximum of these", "label": {"api": {"Math.getExponent": [[71, 86]], "maximum": [[103, 109]]}}}, {"text": "Then you can scale the numbers such that the larger of these numbers has 32 bits before the decimal point", "label": {"api": {"scale": [[13, 17]]}}}, {"text": "Then you'll have to combine those two integers into a single long using bit-interleaving, and finally you can scale the result again using the stored exponent", "label": {"api": {"scale": [[110, 114]]}}}, {"text": "Also (according to Oracle), you can use \"execute\" for any SQL statement", "label": {"api": {"Oracle": [[19, 24]]}}}, {"text": "If we use an ExecutorCompletionService we can submit a series of tasks as Callables and get the result interacting with the CompletionService as a queue", "label": {"api": {"ExecutorCompletionService": [[13, 37]]}}}, {"text": "This will run until hasNextInt() returns false, which occurs when the next item the scanner sees isn't an integer", "label": {"api": {"hasNextInt()": [[20, 31]]}}}, {"text": "Please use writer.write(String.valueOf(score)); otherwise it writes score as a character", "label": {"api": {"writes score as a character": [[61, 87]]}}}, {"text": "What you want to use is Writer.write(String); convert score to a String using String.valueOf or Integer.toString", "label": {"api": {"Writer.write(String)": [[24, 43]]}}}, {"text": "If you check the javadoc of ObjectInputStream", "label": {"api": {"javadoc of ObjectInputStream": [[17, 44]]}}}, {"text": "You can create a new one (using a constructor or possible one of the replaceXXX functions) and assign it back to displayWord, or take a look at the StringBuffer class which is more efficient for this type of thing", "label": {"api": {"StringBuffer": [[148, 159]]}}}, {"text": "It sounds like you want to use a Set implementation", "label": {"api": {"Set": [[33, 35]]}}}, {"text": "If order doesn't matter, just use HashSet", "label": {"api": {"Set": [[38, 40]], "HashSet": [[34, 40]]}}}, {"text": "If you want to keep insertion-order, use LinkedHashSet", "label": {"api": {"Set": [[51, 53]], "HashSet": [[47, 53]], "LinkedHashSet": [[41, 53]]}}}, {"text": "Or, to maintain natural ordering, use TreeSet", "label": {"api": {"Set": [[42, 44]], "TreeSet": [[38, 44]]}}}, {"text": "If you use TreeSet (or some other SortedSet implementation), your element object should either implement Comparable or else you should provide the SortedSet with a Comparator", "label": {"api": {"Set": [[15, 17], [40, 42], [153, 155]], "TreeSet": [[11, 17]], "Comparable": [[105, 114]], "Comparator": [[164, 173]]}}}, {"text": "Then by using the Class.getDeclaredMethods() or Class.getMethods() you can get the list of methods", "label": {"api": {"Class.getDeclaredMethods()": [[18, 43]], "Class.getMethods()": [[48, 65]]}}}, {"text": "Then you can read the data by calling getInputStream() on the Process object that you used to start the script", "label": {"api": {"getInputStream()": [[38, 53]]}}}, {"text": "Have you considered the Map.putAll() method", "label": {"api": {"Map.putAll()": [[24, 35]]}}}, {"text": "See Pattern for the regexp metacharacters", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "You may find that StringTokenizer is more appropriate for your needs", "label": {"api": {"StringTokenizer": [[18, 32]]}}}, {"text": "See Pattern documentation for more information on regexes", "label": {"api": {"Pattern documentation": [[4, 24]]}}}, {"text": "Yes you can use the subList method", "label": {"api": {"subList method": [[20, 33]]}}}, {"text": "If you want to use one of the existing java collections instead, you can use a TreeSet, and its floor() method to get the element before the needed prefix - and then start iterating the set while it still matches", "label": {"api": {"TreeSet": [[79, 85]], "floor()": [[96, 102]], "Set": [[83, 85]]}}}, {"text": "An (inefficient) alternative that uses java's existing containers - is to store all substrings of your keys in a Set or a Map, but it will require quadric amount of space", "label": {"api": {"Set": [[113, 115]], "Map": [[122, 124]]}}}, {"text": "Try using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[10, 23]]}}}, {"text": "It's unclear from the docs, but ProcessBuilder appears to locate things in a way that's similar to the system, e.g", "label": {"api": {"ProcessBuilder": [[32, 45]]}}}, {"text": "If daveSetBit needs the value of a (after any potential modifications in daveWriteBits, then making a an Integer may help", "label": {"api": {"Integer": [[105, 111]]}}}, {"text": "Use a long and nextLong, your number is larger than Integer.MAX_INT", "label": {"api": {"nextLong": [[15, 22]], "Integer.MAX_INT": [[52, 66]]}}}, {"text": "Also note that you can anticipate this error if you first test the stream using hasNextInt()", "label": {"api": {"hasNextInt()": [[80, 91]]}}}, {"text": "Once you need values over that, you can either look into BigInteger (Scanner#nextBigInteger()) or just use a floating point number like double (Scanner#nextDouble())", "label": {"api": {"BigInteger": [[57, 66], [81, 90]]}}}, {"text": "Check out the CountDownLatch class", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "If you want data equality then correctly implement equals() and hashCode() and then you can use Collection.containsAll(...)", "label": {"api": {"Collection.containsAll(...)": [[96, 122]]}}}, {"text": "I personally use and recommend using ImageIO instead of Toolkit to load images", "label": {"api": {"ImageIO": [[37, 43]]}}}, {"text": "Since Java 7, you can have the child process inherit its I/O channels from your Java application using ProcessBuilder.inheritIO", "label": {"api": {"ProcessBuilder.inheritIO": [[103, 126]]}}}, {"text": "Use the JFormattedTextField class", "label": {"api": {"JFormattedTextField": [[8, 26]]}}}, {"text": "Use a StringBuilder to construct the new string and StringBuilder#toString to obtain it", "label": {"api": {"StringBuilder": [[6, 18], [52, 64]], "StringBuilder#toString": [[52, 73]]}}}, {"text": "You could use String.format, something like", "label": {"api": {"String.format": [[14, 26]]}}}, {"text": "I dont think that this is possible, there maybe some things that can be done to run native commands using the RunTime, class", "label": {"api": {"RunTime": [[110, 116]]}}}, {"text": "Start by extending Runnable, then using Thread to run and manage your Jobs", "label": {"api": {"Runnable": [[19, 26]], "Thread": [[40, 45]]}}}, {"text": "Not too inefficient, as System.arraycopy() is highly optimized", "label": {"api": {"System.arraycopy()": [[24, 41]]}}}, {"text": "Internally I reuse the same ByteBuffer which means I'll repeatedly return the same byte[] instance most of the time", "label": {"api": {"ByteBuffer": [[28, 37]]}}}, {"text": "I'm considering writing cautionary javadoc and exposing this to the user as a Iterator<byte[]>", "label": {"api": {"Iterator<byte[]>": [[78, 93]]}}}, {"text": "To execute a command on the local host (for server-side application), use Runtime class and its exec() method", "label": {"api": {"Runtime class": [[74, 86]]}}}, {"text": "From the API of BufferedImage.getRGB", "label": {"api": {"BufferedImage.getRGB": [[16, 35]]}}}, {"text": "...and from the API of BufferedImage.setRGB", "label": {"api": {"BufferedImage.setRGB": [[23, 42]]}}}, {"text": "So, if you want to ignore this exception you need to catch it inside getLatestPatchForPackage() and produce appropriate result (for example, return null or throw an application exception)", "label": {"api": {"application exception": [[165, 185]]}}}, {"text": "I think you are writing HashMap<Player, Location> to file", "label": {"api": {"HashMap": [[24, 30]]}}}, {"text": "HashMap is already serializable", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "The second case talks about Java Instrumentation API - this link points to a Javadoc which is rather descriptive", "label": {"api": {"Java Instrumentation API": [[28, 51]]}}}, {"text": "Have you looked at Pattern groups", "label": {"api": {"group": [[27, 31]]}}}, {"text": "Matcher.group(0) is the complete expression", "label": {"api": {"group": [[8, 12]]}}}, {"text": "I guess you need to read Mathcer docs http://docs.oracle.com/javase/7/docs/api/index.html?java/util/regex/Matcher.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/index.html?java/util/regex/Matcher.html": [[38, 117]]}}}, {"text": "You can treat it as a string and split it using substring(), or as an integer", "label": {"api": {"substring()": [[48, 58]]}}}, {"text": "Take a look at LineBreakMeasurer", "label": {"api": {"LineBreakMeasurer": [[15, 31]]}}}, {"text": "Either the ExecutorServices created by the library should be shutdown, or some other means of stopping those threads should be enacted", "label": {"api": {"ExecutorService": [[11, 25]]}}}, {"text": "JDO most probably uses Enum.valueOf(class, string) to instantiate enums", "label": {"api": {"Enum.valueOf(class, string)": [[23, 49]]}}}, {"text": "it is similar to what the javadoc of HashSet says", "label": {"api": {"javadoc of HashSet": [[26, 43]]}}}, {"text": "This is a direct pass-through to the backlog parameter of ServerSocket's constructor", "label": {"api": {"ServerSocket": [[58, 69]]}}}, {"text": "If this is the case you could use File.mkdirs to build the path", "label": {"api": {"File.mkdirs": [[34, 44]], "File": [[34, 37]]}}}, {"text": "Also, rather than building the file from strings, would suggest allowing File handle all this, e.g.", "label": {"api": {"File": [[73, 76]]}}}, {"text": "Make your business object Comparable and use a sorted collection (like TreeSet which is a SortedSet)", "label": {"api": {"Comparable": [[26, 35]], "TreeSet": [[71, 77]], "SortedSet": [[90, 98]]}}}, {"text": "Then use a TreeSet, you won't need sort the collection on each insertion with that implementation", "label": {"api": {"TreeSet": [[11, 17]]}}}, {"text": "Be aware that your object elements have to implement the Comparable interface in order to be sortable", "label": {"api": {"Comparable": [[57, 66]]}}}, {"text": "According to the MemoryMXBean documentation, memory usage is reported in two categories, \"Heap\" and \"Non-Heap\" memory", "label": {"api": {"MemoryMXBean": [[17, 28]]}}}, {"text": "You need a Worker Thread", "label": {"api": {"Worker Thread": [[11, 23]]}}}, {"text": "String is immutable and concat() will return a new String (check the linked doc), which you're not collecting", "label": {"api": {"concat()": [[24, 31]]}}}, {"text": "String is immutable, so just calling concat on a String doesn't change it", "label": {"api": {"String": [[0, 5], [49, 54]]}}}, {"text": "it returns a new String with the result", "label": {"api": {"String": [[17, 22]]}}}, {"text": "fileText = fileText.concat(inputLine);, but since you're in a loop, potentially doing lots of concatenation, it's better to use StringBuilder to do the concatenations, and get a String from the StringBuilder", "label": {"api": {"String": [[128, 133], [178, 183], [194, 199]], "StringBuilder": [[128, 140], [194, 206]]}}}, {"text": "To keep your Java side collection ordered, you don't need to keep calling the sort method, but just use a ordered collection like TreeSet or TreeMap, or any collection that implements SortedSet or SortedMap, to store your data", "label": {"api": {"TreeSet": [[130, 136]], "TreeMap": [[141, 147]], "SortedSet": [[184, 192]], "SortedMap": [[197, 205]]}}}, {"text": "You still need to implement Comparable or Comparator as @AdelBoutros said", "label": {"api": {"Comparable": [[28, 37]], "Comparator": [[42, 51]]}}}, {"text": "If you want to generate random bits all at once, rather than looping, take a look at the java.util.Random method nextBytes(byte[]) which fills the specified byte array with random bytes", "label": {"api": {"java.util.Random method nextBytes(byte[])": [[89, 129]]}}}, {"text": "See Java SE 8 doc TimeZone#getDefault, TimeZone#setDefault", "label": {"api": {"TimeZone#getDefault": [[18, 36]], "TimeZone#setDefault": [[39, 57]]}}}, {"text": "The Integer class provides a version of parseInt() that allows you to specify the radix, and similarly the toString() method also allows you to specify the radix", "label": {"api": {"Integer": [[4, 10]], "parseInt()": [[40, 49]], "toString()": [[107, 116]]}}}, {"text": "The other two methods just use parts of this one line, or you may call your methods as thin wrappers around the Integer methods", "label": {"api": {"Integer": [[112, 118]]}}}, {"text": "StringBuffer has been around since JDK 1.0", "label": {"api": {"JDK 1.0": [[35, 41]]}}}, {"text": "Field came around pre-1.4.2", "label": {"api": {"pre-1.4.2": [[18, 26]]}}}, {"text": "Finally StringBuilder made its way in Java 1.5", "label": {"api": {"Java 1.5": [[38, 45]]}}}, {"text": "From the API", "label": {"api": {"the API": [[5, 11]]}}}, {"text": "More can be read in the offical documentation", "label": {"api": {"offical documentation": [[24, 44]]}}}, {"text": "Perhaps a look at the java.util.Timer or Quartz Scheduler would be helpful", "label": {"api": {"java.util.Timer": [[22, 36]]}}}, {"text": "A ScheduledThreadPoolExecutor might also be helpful", "label": {"api": {"ScheduledThreadPoolExecutor": [[2, 28]]}}}, {"text": "I believe LinkedHashMap is exactly what you need", "label": {"api": {"LinkedHashMap": [[10, 22]]}}}, {"text": "You just need to override removeEldestEntry(...) method, and it will automatically remove old entries for you if the maximum capacity is reached", "label": {"api": {"removeEldestEntry(...)": [[26, 47]]}}}, {"text": "If synchronizing atomic map operations is enough for you, you can just wrap the map into Collections.synchronizedMap(...)", "label": {"api": {"Collections.synchronizedMap(...)": [[89, 120]]}}}, {"text": "If you want to dive more into it, you can look at the Java Cryptography architectre and the javax.crypto java docs", "label": {"api": {"javax.crypto java docs": [[92, 113]]}}}, {"text": "We used JPA's @Enumerated(EnumType.Ordinal) to map enums to numbers when persisting to a database", "label": {"api": {"@Enumerated": [[14, 24]], "Ordinal": [[35, 41]]}}}, {"text": "The numbers in the database are ordinal numbers of the enum", "label": {"api": {"ordinal numbers": [[32, 46]]}}}, {"text": "Take a look at the Character.UnicodeBlock class, which provides the static method of(char) and of(int) to detect the Unicode block of a character", "label": {"api": {"Character.UnicodeBlock": [[19, 40]]}}}, {"text": "A new class MathContext was added and limits the precision to which the operations are calculated", "label": {"api": {"new class MathContext": [[2, 22]]}}}, {"text": "You can use  setVisible(boolean) to change visibility, here is an example based on posted code", "label": {"api": {"setVisible(boolean)": [[13, 31]]}}}, {"text": "java.util.Collection declares a retainAll() method that might be useful", "label": {"api": {"retainAll()": [[32, 42]]}}}, {"text": "I strongly suggest you familiarize yourself with that java.util package, especially the Collection interface", "label": {"api": {"java.util package": [[54, 70]], "Collection interface": [[88, 107]]}}}, {"text": "In fact, learning how to navigate and use the Java APIs is a critical skill for every Java programmer", "label": {"api": {"Java APIs": [[46, 54]]}}}, {"text": "You could alternatively use the Scanner class", "label": {"api": {"Scanner": [[32, 38]]}}}, {"text": "You don't have to worry about \\n, since Scanner.nextLine() will skip the newline", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "The solution is to always use something like BigInteger if you have to deal with large integers", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "Please, take a look at documentation on String.split first", "label": {"api": {"documentation on String.split": [[23, 51]]}}}, {"text": "To embed an applet into a Java application, I'd advise against using HTML", "label": {"api": {"applet": [[12, 17]]}}}, {"text": "Instead, treat the applet as a simple component, and try to behave like a browser plugin towards the applet", "label": {"api": {"applet": [[19, 24], [101, 106]], "component": [[38, 46]]}}}, {"text": "In particular, make sure to set a stub and call the init and start methods appropriately", "label": {"api": {"set a stub": [[28, 37]], "init": [[52, 55]], "start": [[61, 65]], "stub": [[34, 37]]}}}, {"text": "It is that stub which provides parameters to the applet, so by implementing the getParameter method appropriately, you can pass whatever parameters you desire", "label": {"api": {"applet": [[49, 54]], "stub": [[11, 14]], "provides parameters": [[22, 40]], "getParameter": [[80, 91]]}}}, {"text": "You might have to create a separate class loader for the jar of the plugin, and instantiate the plugin class through that class loader", "label": {"api": {"class loader": [[36, 47], [122, 133]]}}}, {"text": "If your environment doesn't allow your plugin the creation of new class loaders, then you should list the applet jar as a dependency of your plugin, so that its classes are available in the same class path your plugin uses", "label": {"api": {"applet": [[106, 111]], "class loader": [[66, 77]]}}}, {"text": "Doing so might be the easier route even if you're allowed custom class loaders, so choose whatever approach you prefer", "label": {"api": {"class loader": [[65, 76]]}}}, {"text": "You can use JFrame.setIconImage", "label": {"api": {"JFrame.setIconImage": [[12, 30]]}}}, {"text": "Java allows you to install a thread-level uncaught exception handler", "label": {"api": {"thread-level uncaught exception handler": [[29, 67]]}}}, {"text": "If you inherit from AbstractTableModel, I think that it's a convenient way to use the observer design pattern", "label": {"api": {"AbstractTableModel": [[20, 37]]}}}, {"text": "it is important to note that this holds for the fair mode only", "label": {"api": {"fair mode only": [[48, 61]]}}}, {"text": "The Field.get(Object) method docs say", "label": {"api": {"Field.get(Object) method docs say": [[4, 36]]}}}, {"text": "And the Class.getField(String) method docs say", "label": {"api": {"Class.getField(String) method docs say": [[8, 45]]}}}, {"text": "You can use Class#getField or Class#getDeclaredField to access the map, like this", "label": {"api": {"Class#getField": [[12, 25]], "Class#getDeclaredField": [[30, 51]]}}}, {"text": "So reading parts of it isn't going to work in most cases, even though you can achieve similar effects on some input streams using a combination of reset and skip", "label": {"api": {"reset": [[147, 151]], "skip": [[157, 160]]}}}, {"text": "But not all streams support reset, and skipping bytes is often as expensive as reading bytes", "label": {"api": {"reset": [[28, 32]], "skip": [[39, 42]]}}}, {"text": "No matter how you implement the random access (and seeing your comment, you'll likely do so using an InputStream with reset and skip), you can create your own class to represent a part of that stream", "label": {"api": {"reset": [[118, 122]], "skip": [[128, 131]]}}}, {"text": "You can let that class itself be an instance of InputStream by subclassing FilterInputStream", "label": {"api": {"FilterInputStream": [[75, 91]]}}}, {"text": "You'd have to ensure that any operation using one of these streams calls reset first", "label": {"api": {"reset": [[73, 77]]}}}, {"text": "But when you need to save a blob, you can use hibernate's save() to create the row, then use a jdbc PreparedStatement and the setBinaryStream() method", "label": {"api": {"jdbc PreparedStatement": [[95, 116]]}}}, {"text": "See the java tutorial on threads for more info on multithreading", "label": {"api": {"java tutorial on threads": [[8, 31]]}}}, {"text": "Note that an Error is not an Exception; it's a Throwable", "label": {"api": {"Error": [[13, 17]], "Exception": [[29, 37]], "Throwable": [[47, 55]]}}}, {"text": "So, if you catch Exception, Errors will still get through", "label": {"api": {"Error": [[28, 32]], "Exception": [[17, 25]]}}}, {"text": "Note that there might be little you can do if an Error occurs", "label": {"api": {"Error": [[49, 53]]}}}, {"text": "Excerpt from javadoc for Error", "label": {"api": {"Error": [[25, 29]]}}}, {"text": "An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch", "label": {"api": {"Error": [[3, 7]], "Throwable": [[26, 34]]}}}, {"text": "The ThreadDeath error, though a \"normal\" condition, is also a subclass of Error because most applications should not try to catch it", "label": {"api": {"Error": [[74, 78]]}}}, {"text": "Well, \\Q and \\E have a special meaning in Java regular expressions..", "label": {"api": {"regular expressions": [[47, 65]]}}}, {"text": "You could use something like a SwingWorker to do this", "label": {"api": {"SwingWorker": [[31, 41]]}}}, {"text": "In java.net.url there is a getFile() method and a getPath() method", "label": {"api": {"getFile()": [[27, 35]], "getPath()": [[50, 58]]}}}, {"text": "Java EE has a WorkManager API", "label": {"api": {"Java EE has a WorkManager API": [[0, 28]]}}}, {"text": "Why not use a TreeMap instead of HashMap, then you could specify a Comparator with a case insensitive order (String.CASE_INSENSITIVE_ORDER)", "label": {"api": {"TreeMap": [[14, 20]], "String.CASE_INSENSITIVE_ORDER": [[109, 137]]}}}, {"text": "Use the setSelectionMode() method from ListSelectionModel interface, and set the selection mode to ListSelectionModel.SINGLE_SELECTION", "label": {"api": {"setSelectionMode()": [[8, 25]], "ListSelectionModel.SINGLE_SELECTION": [[99, 133]]}}}, {"text": "To select single cells, combine the above with setColumnSelectionAllowed(true) on TableColumnModel, and you should get what you need", "label": {"api": {"setColumnSelectionAllowed(true)": [[47, 77]]}}}, {"text": "If you want to close the connection after 30 seconds, then I would recommend using Timer and doing a threadsafe close of the connection there", "label": {"api": {"Timer": [[83, 87]]}}}, {"text": "There is CopyOnWriteArraySet which is a set backed by an array", "label": {"api": {"CopyOnWriteArraySet": [[9, 27]]}}}, {"text": "Consider using ArrayList, using it's add method and then calling toArray on it", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "You should use String.equals when comparing two Strings", "label": {"api": {"String.equals": [[15, 27]]}}}, {"text": "You should use a PreparedStatement to escape your special characters", "label": {"api": {"PreparedStatement": [[17, 33]]}}}, {"text": "I need some Java collection which holds String values and has synchronized method for adding an element if it doesn't exist already (something like addIfAbsent is for ArrayList)", "label": {"api": {"addIfAbsent": [[148, 158]]}}}, {"text": "You want to use the getErrorStream() method if the getResponseCode() == 404", "label": {"api": {"getErrorStream() method": [[20, 42]]}}}, {"text": "Java lists define a toArray() method you can call", "label": {"api": {"toArray()": [[20, 28]]}}}, {"text": "Make sure if you are passing the same object reference to a single instance of ObjectOutputStream repeatatly that you are using ObjectOutputStream.writeUnshared(Object) to do it OR calling ObjectOutputStream.reset() between writes of that object", "label": {"api": {"ObjectOutputStream.writeUnshared(Object)": [[128, 167]], "ObjectOutputStream.reset()": [[189, 214]]}}}, {"text": "In the comments of the linked answer about using Unsafe, @bestsss points out a much simpler trick using the deprecated method Thread.stop(Throwable)", "label": {"api": {"Thread.stop(Throwable)": [[126, 147]]}}}, {"text": "For an example of this, look at PrintStream.format", "label": {"api": {"PrintStream.format": [[32, 49]]}}}, {"text": "If the file does not exist (!File.exists()), an exception will be thrown when you try to access it", "label": {"api": {"!File.exists()": [[28, 41]]}}}, {"text": "If you want to create the file, you can use File.createNewFile()", "label": {"api": {"File.createNewFile()": [[44, 63]]}}}, {"text": "What you seem to be trying to implement sounds like a good match for an ExecutorService", "label": {"api": {"ExecutorService": [[72, 86]]}}}, {"text": "It can deal with all of the low-level details of creating and managing threads, and allows the application to get the results of each computation back via a Future", "label": {"api": {"Future": [[157, 162]]}}}, {"text": "the ExecutorService and Future implementations take care of that", "label": {"api": {"ExecutorService": [[4, 18]], "Future": [[24, 29]]}}}, {"text": "So, my recommendation would be to read the Javadocs for ExecutorService, etcetera and figure out how to do what you are trying to do using that", "label": {"api": {"ExecutorService": [[56, 70]]}}}, {"text": "Take a look at the java.util.concurrent package, in particular the BlockingQueue interface and the classes that implement it", "label": {"api": {"java.util.concurrent": [[19, 38]], "BlockingQueue": [[67, 79]]}}}, {"text": "The SynchronousQueue is exactly what you're trying to implement", "label": {"api": {"SynchronousQueue": [[4, 19]]}}}, {"text": "And your if (flag == false) and if (flag == true) tests should actually be while loops, because wait() can wake up spuriously when notify() hasn't actually been called", "label": {"api": {"wake up spuriously": [[107, 124]]}}}, {"text": "You can use the BitSet class", "label": {"api": {"BitSet": [[16, 21]]}}}, {"text": "doc.getElementsByTagName(\"method\") returns a NodeList", "label": {"api": {"NodeList": [[45, 52]], "Node": [[45, 48]]}}}, {"text": "You want the first one of these, so you should use doc.getElementsByTagName(\"method\").item(0) - which returns a Node", "label": {"api": {"Node": [[112, 115]]}}}, {"text": "The default implementation found in Object.toString() prints not very useful first.Book@c2ea3f", "label": {"api": {"Object.toString()": [[36, 52]]}}}, {"text": "Implement your own ServletContextListener", "label": {"api": {"ServletContextListener": [[19, 40]]}}}, {"text": "See this Javadoc for all the encoding schemes", "label": {"api": {"this Javadoc": [[4, 15]]}}}, {"text": "Because @AroundInvoke interceptor method is executed in same transaction as intercepted business method, you can check transaction type with following", "label": {"api": {"@AroundInvoke": [[8, 20]]}}}, {"text": "Both known subclasses include the required addTableModelListener() implementation", "label": {"api": {"known subclasses": [[5, 20]]}}}, {"text": "This is the sort of case AtomicReference was made for", "label": {"api": {"AtomicReference": [[25, 39]]}}}, {"text": "If you are just using this to outline states, consider using the GeneralPath class", "label": {"api": {"GeneralPath class": [[65, 81]]}}}, {"text": "I am using an AffineTransform (with setScaleTo(x,y)) on my Graphics2D object, and everything is working swimmingly", "label": {"api": {"AffineTransform": [[14, 28]]}}}, {"text": "You should have a look at LinkedHashMap", "label": {"api": {"LinkedHashMap": [[26, 38]]}}}, {"text": "For example, there are new classes created, EnumSet and EnumMap, which implement an enum-keyed set or map using a bitset and an array, respectively (which are probably the fastest possible implementations for those abstract data types)", "label": {"api": {"EnumSet": [[44, 50]], "EnumMap": [[56, 62]]}}}, {"text": "I noticed while using an LDAP connect pool that calling close() on the context did not appear to return it to the pool, despite the documentation saying otherwise", "label": {"api": {"otherwise": [[153, 161]]}}}, {"text": "if I comment out (3) - a call to SearchResults.next() - it works fine", "label": {"api": {"SearchResult": [[33, 44]]}}}, {"text": "However, the method results.next() returns a SearchResult in this case, which has no close method and no guidance in its documentation on how to close it cleanly", "label": {"api": {"SearchResult": [[45, 56]]}}}, {"text": "You may have to either copy all of the code from the SimpleResolver (lots of private methods that you'll need and licensing allows for it), or, you could create your own version and simply load it ahead of the jared one in your classpath, or, your could reflect your way to the methods in question and set them accessible", "label": {"api": {"set them accessible": [[302, 320]]}}}, {"text": "The pure JDBC way to interrogate the database about this sort of thing is to use the DatabaseMetaData class in your Java application", "label": {"api": {"DatabaseMetaData class": [[85, 106]]}}}, {"text": "DatabaseMetaData.getSchemas will give you the set of schemas in the database", "label": {"api": {"DatabaseMetaData.getSchemas": [[0, 26]]}}}, {"text": "DatabaseMetaData.getTables will give you a listing of the tables", "label": {"api": {"DatabaseMetaData.getTables": [[0, 25]]}}}, {"text": "Use Arrays.sort and then take the middle element (in case the number n of elements in the array is odd) or take the average of the two middle elements (in case n is even)", "label": {"api": {"Arrays.sort": [[4, 14]]}}}, {"text": "You could try RandomAccessFile - it allows to seek file to a random position and read needed amount of characters", "label": {"api": {"RandomAccessFile": [[14, 29]]}}}, {"text": "The InterruptedException may be raised in a thread after another thread calls its interrupt() method", "label": {"api": {"interrupt()": [[82, 92]]}}}, {"text": "On the other hand SSLContext.init() is very sparsely documented and just say that I must pass \"the sources of authentication keys\" and \"the sources of peer authentication trust decisions\", and I have no idea what that is", "label": {"api": {"SSLContext.init()": [[18, 34]]}}}, {"text": "I suppose I need to load them into either the SSLContext or the SSLEngine somehow, but am not sure whether SSLContext.init() is even the right place to to that (though there doesn't seem to be many other places it could be)", "label": {"api": {"SSLContext.init()": [[107, 123]]}}}, {"text": "For correct preparation, see the Buffers flip() method or use position(int) together with limit(int) to specify the remaining contents to be written", "label": {"api": {"flip()": [[41, 46]], "position(int)": [[62, 74]], "limit(int)": [[90, 99]]}}}, {"text": "I noticed that the type returned by img.getType() is equal to TYPE_3BYTE_BGR so I guess it's a decoding issue happening behind the scene but I can't figure out how to workaround it (or get a clearer understanding of what's happening)", "label": {"api": {"TYPE_3BYTE_BGR": [[62, 75]]}}}, {"text": "the apache commons-lang library has the StringUtils.join() method, which does exactly what you want", "label": {"api": {"join()": [[52, 57]]}}}, {"text": "In java 8, the String class has the join() method that does what you want", "label": {"api": {"join()": [[36, 41]]}}}, {"text": "Try using URLConnection.setDefaultUseCaches(false) when your application starts up (maybe only in dev environment for performance reasons)", "label": {"api": {"URLConnection.setDefaultUseCaches": [[10, 42]]}}}, {"text": "According to the documentation for executeUpdate, this function can execute only one statement at a time", "label": {"api": {"executeUpdate": [[35, 47]]}}}, {"text": "Then you need to make two separate calls to executeUpdate", "label": {"api": {"executeUpdate": [[44, 56]]}}}, {"text": "Use an AncestorListener as described in dialog focus", "label": {"api": {"AncestorListener": [[7, 22]]}}}, {"text": "When using DataOutput.writeUTF/DataInput.readUTF, the first 2 bytes form an unsigned 16-bit big-endian integer denoting the size of the string", "label": {"api": {"DataOutput.writeUTF": [[11, 29]], "DataInput.readUTF": [[31, 47]]}}}, {"text": "If you are curious as to how Spring does all this I would encourage you to look at the DisposableBeanAdapter which Spring registers as a HttpSessionBindingListener with the Session", "label": {"api": {"HttpSessionBindingListener": [[137, 162]]}}}, {"text": "You could also try to call System.runFinalization() but no guarantee is given by the JVM that all finalizers will be called", "label": {"api": {"System.runFinalization()": [[27, 50]]}}}, {"text": "Start off from DocumentBuilderFactory, create a DocumentBuilder and from this create a new Document object", "label": {"api": {"DocumentBuilderFactory": [[15, 36]]}}}, {"text": "which pointed me to getGeneric...() methods", "label": {"api": {"getGeneric...()": [[20, 34]]}}}, {"text": "Yes you could use a ComponentListener to do that", "label": {"api": {"ComponentListener": [[20, 36]]}}}, {"text": "So implement ComponentListener interface and add it to the desired Component through addComponentListener() method", "label": {"api": {"ComponentListener": [[13, 29], [88, 104]], "addComponentListener()": [[85, 106]]}}}, {"text": "I can obtain Font instance easily, and it seems that GlyphVector class is able to give me the required Shape", "label": {"api": {"Font": [[13, 16]], "GlyphVector": [[53, 63]], "Shape": [[103, 107]]}}}, {"text": "But to create GlyphVector from Font, I need to have some FontRenderContex", "label": {"api": {"Font": [[31, 34], [57, 60]], "GlyphVector": [[14, 24]], "FontRenderContex": [[57, 72]]}}}, {"text": "I perform this operation not while rendering something, thus I can't see the way to get that FontRenderContex", "label": {"api": {"Font": [[93, 96]], "FontRenderContex": [[93, 108]]}}}, {"text": "Is it possible to create some default FontRenderContex or bypass it", "label": {"api": {"Font": [[38, 41]], "FontRenderContex": [[38, 53]]}}}, {"text": "Is there anything in your application that extends Graphics2D", "label": {"api": {"Graphics2D": [[51, 60]]}}}, {"text": "That way, you have access to the getFontRenderContext method", "label": {"api": {"FontRenderContext": [[36, 52]]}}}, {"text": "I mean you can just use one of the constructors, but I saw this in the docs for FontRenderContext", "label": {"api": {"FontRenderContext": [[80, 96]]}}}, {"text": "What's the difference between Component.isShowing() and Component.isDisplayable()", "label": {"api": {"Component.isShowing()": [[30, 50]], "Component.isDisplayable()": [[56, 80]]}}}, {"text": "The split method takes a regular expression - and", "label": {"api": {"split": [[4, 8]]}}}, {"text": "You could use \"\\\\.\" as the split value - but I would personally use Guava and its Splitter type", "label": {"api": {"split": [[27, 31]]}}}, {"text": "If your PseudoTCPSocket extends java.net.Socket (and doesn't break its API), you should be able to upgrade it to an SSLSocket using SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose)", "label": {"api": {"SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose)": [[132, 212]]}}}, {"text": "You can read and write zip and jar files with java.util.zip, jar files are really just zip files", "label": {"api": {"java.util.zi": [[46, 57]]}}}, {"text": "If you're able to get a pcap file, you should be able to use the native DatagramPacket class for your needs", "label": {"api": {"DatagramPacket": [[72, 85]]}}}, {"text": "DatagramPacket has a method called getSocketAddress() that will get you the IP address and the port number", "label": {"api": {"DatagramPacket": [[0, 13]], "getSocketAddress()": [[35, 52]]}}}, {"text": "Take a look at ArryList", "label": {"api": {"ArryList": [[15, 22]]}}}, {"text": "There are also many other collection classes in the util package that are also worth looking at", "label": {"api": {"the util package": [[48, 63]]}}}, {"text": "However, if you do not need a List and would like to be able to retrieve your Object by a known key a HashMap would be a better choice", "label": {"api": {"HashMap": [[102, 108]]}}}, {"text": "Do you mean ArrayList", "label": {"api": {"ArrayList": [[12, 20]]}}}, {"text": "You could also use a Map to have a key and then the JPanel as an instance", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "It sounds like an ArrayList is better and then you generate a new JPanel biased on the Object/String in the ArrayList when it is clicked on", "label": {"api": {"ArrayList": [[18, 26], [108, 116]]}}}, {"text": "Java infrastructure provides a mechanism (ClassLoader) to build classpath hierarchies and Tomcat (as many other servlet containers/application servers) use that to isolate the different JARs/class folders being used in a specific application", "label": {"api": {"ClassLoader": [[42, 52]]}}}, {"text": "I know that it's the right thing to create the PreparedStatement outside the loop", "label": {"api": {"PreparedStatement": [[47, 63]]}}}, {"text": "Let's assume that I'm creating a PreparedStatement inside a loop with always the same SQL query", "label": {"api": {"PreparedStatement": [[33, 49]]}}}, {"text": "Is this useless since the PreparedStatement object is always created anew", "label": {"api": {"PreparedStatement": [[26, 42]]}}}, {"text": "Or does the underlying database recognise that it's always the same SQL query with which the PreparedStatement is created and reuses it", "label": {"api": {"PreparedStatement": [[93, 109]]}}}, {"text": "I would go for a specific Document instead, especially if you want your mapping to be valid just for an instance and not globally", "label": {"api": {"Document": [[26, 33]]}}}, {"text": "In the first case you must provide Locale to NumberFormat class that uses comma as decimal separator", "label": {"api": {"Locale": [[35, 40]], "NumberFormat": [[45, 56]]}}}, {"text": "Just use String.intern()", "label": {"api": {"String.intern()": [[9, 23]]}}}, {"text": "Insert the value at the current index to the beginning of a StringBuilder instance", "label": {"api": {"StringBuilder": [[60, 72]]}}}, {"text": "If needed, use the \"toString()\" method of your StringBuilder instance to get a string", "label": {"api": {"StringBuilder": [[47, 59]]}}}, {"text": "Also have a look at Inet6Address class which will make your life easier", "label": {"api": {"Inet6Address class": [[20, 37]]}}}, {"text": "Why use regex when you can use Inet6Address.getHostAddress", "label": {"api": {"Inet6Address.getHostAddress": [[31, 57]]}}}, {"text": "As you mention, if you want the locking to be robust and have the file locked from other programs too, you should use FileLock (see the docs, on some systems it is not guaranteed that all programs must respect the lock)", "label": {"api": {"FileLock": [[118, 125]]}}}, {"text": "It's not widely documented, but you can use the Dispatch interface to implement JAXWS clients which work directly w/ the XML", "label": {"api": {"Dispatch": [[48, 55]]}}}, {"text": "For numbers that are larger, use the BigInteger class", "label": {"api": {"BigInteger": [[37, 46]]}}}, {"text": "Use the BigInteger class", "label": {"api": {"BigInteger": [[8, 17]]}}}, {"text": "I modified a bit your code to use DataInputStream and DataOutputStream instead of RandomAccessFile and it works like a charm", "label": {"api": {"DataInputStream": [[34, 48]], "DataOutputStream": [[54, 69]]}}}, {"text": "I can't figure out how JEditorPane.scrollToReference() is meant to be used with a dynamically-generated HTML page", "label": {"api": {"JEditorPane.scrollToReference()": [[23, 53]]}}}, {"text": "Use a JApplet rather than a JFrame", "label": {"api": {"JApplet": [[6, 12]]}}}, {"text": "You may refer JDBC API doc", "label": {"api": {"JDBC API doc": [[14, 25]]}}}, {"text": "What is the .NET equivalent of java.lang.StringBuffer", "label": {"api": {"java.lang.StringBuffer": [[31, 52]]}}}, {"text": "If you follow the information here (http://docs.oracle.com/javase/7/docs/api/?javax/script/package-summary.html) to make it 'discoverable' by placing a file called javax.script.ScriptEngineFactory under META-INF/services, then it can work without relying on the AppleScriptEngine.jar in /System/Library/Java/Extensions/", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/?javax/script/package-summary.html": [[36, 110]]}}}, {"text": "The standard Exception has no default constructor (or a way to set the message after instantiation)", "label": {"api": {"Exception": [[13, 21]]}}}, {"text": "Use \"\\\\.\" or \"[.]\" if a regular expression split delimiter is required (as with String.split)", "label": {"api": {"String.split": [[80, 91]]}}}, {"text": "in a Java regular expression means \"match any character\" (roughly, depending on options); the two forms above escape/prevent this meaning so it matches a literal period", "label": {"api": {"Java regular expression": [[5, 27]]}}}, {"text": "If you want to set a specific locale you can pass an instance of Locale to getInstance()", "label": {"api": {"Locale": [[65, 70]]}}}, {"text": "There are a bunch of static instances available in the Locale class for your convenience", "label": {"api": {"Locale": [[55, 60]]}}}, {"text": "If reversing is your only important task, you can replace it with a java linked list, and get better performance both time-wise and space-wise", "label": {"api": {"java linked list": [[68, 83]]}}}]