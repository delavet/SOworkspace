[{"text": "The short answer is that it's not how ZipOutputStream works", "label": {"api": {"ZipOutputStream": [[38, 52]]}}}, {"text": "Use the methods of java.net.URI to get everything about an URL", "label": {"api": {"java.net.URI": [[19, 30]]}}}, {"text": "Take a look at java.lang.Double.toString() and  java.lang.Double.valueOf(String s)", "label": {"api": {"java.lang.Double.toString()": [[15, 41]], "java.lang.Double.valueOf(String s)": [[48, 81]]}}}, {"text": "Take a look at Runtime.addShutdownHook", "label": {"api": {"Runtime.addShutdownHook": [[15, 37]]}}}, {"text": "See particularly the SwingWorker", "label": {"api": {"SwingWorker": [[21, 31]]}}}, {"text": "See Arrays.fill method", "label": {"api": {"Arrays.fill": [[4, 14]]}}}, {"text": "Instead of using the modified for loop, you can use an Iterator", "label": {"api": {"Iterator": [[55, 62]]}}}, {"text": "Iterators have a remove method that lets you remove the last element returned by Iterator.next()", "label": {"api": {"Iterator": [[0, 7], [81, 88]]}}}, {"text": "BufferedImage is a subclass of Image", "label": {"api": {"BufferedImage": [[0, 12]], "Image": [[8, 12], [31, 35]]}}}, {"text": "The StringTokenizer is used to split every line in the file into words", "label": {"api": {"StringTokenizer": [[4, 18]]}}}, {"text": "An ArrayList is an implementation of List, a collection of items that preserves their order", "label": {"api": {"ArrayList": [[3, 11]], "List": [[8, 11], [37, 40]]}}}, {"text": "I highly recommend to read the Java 6 API documentation for questions like this", "label": {"api": {"Java 6 API documentation": [[31, 54]]}}}, {"text": "In my opinion, the single biggest advantage of a ProcessBuilder is that you can redirect the standard error of the process into its standard output", "label": {"api": {"ProcessBuilder": [[49, 62]]}}}, {"text": "Use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[6, 18]]}}}, {"text": "I would recommend taking a look at the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[39, 58]]}}}, {"text": "If you would like to double-check your mulch-trilion calculation against something that is known to work, use BigInteger to compute the expected results, and check your results against theirs", "label": {"api": {"BigInteger": [[110, 119]]}}}, {"text": "Both of these varags methods simply delegate to Arrays.hashCode(Object[] a), so there is a slight impact on performance because of the autoboxing of ints and creating an array of object references, but it should be far less significant than using reflection", "label": {"api": {"Arrays.hashCode(Object[] a)": [[48, 74]]}}}, {"text": "And the readability is just great, since you simply see, which fields are used for the hashcode computation and all the multiply and add syntax is just hidden under the hood of Arrays.hashCode(Object[] a)", "label": {"api": {"Arrays.hashCode(Object[] a)": [[177, 203]]}}}, {"text": "Using System.getProperties() gives you a listing of JVM properties including the different version ids of the JRE, JVM and specification", "label": {"api": {"System.getProperties()": [[6, 27]]}}}, {"text": "Comparable is typed, but you're using the raw type", "label": {"api": {"Comparable": [[0, 9]]}}}, {"text": "Just for reference, since Java 11, there is a new method CharSequence.compare()", "label": {"api": {"CharSequence.compare()": [[57, 78]]}}}, {"text": "Sound like you need to use a HashMap<YourClass, Integer> (link)", "label": {"api": {"link": [[58, 61]]}}}, {"text": "Let Java know it will be HTML using setContentType method", "label": {"api": {"setContentType": [[36, 49]]}}}, {"text": "While others have already pointed out arithmetic overflow, you can also try TimeUnit to solve the problem", "label": {"api": {"TimeUnit": [[76, 83]]}}}, {"text": "You can get the text using the getSelectedItem() function in JComboBox", "label": {"api": {"getSelectedItem() function in JComboBox": [[31, 69]]}}}, {"text": "LinkedHashMap can satisfy all your requirements at once, with good performance characteristics", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "Either way, byte[] is going to be the way forward - or possibly BitSet", "label": {"api": {"BitSet": [[64, 69]]}}}, {"text": "If you want to draw curves between two points and control points (what you probably want) you need to look into QuadCurve2D or CubicCurve2D and drawShape", "label": {"api": {"QuadCurve2D": [[112, 122]], "CubicCurve2D": [[127, 138]]}}}, {"text": "You might be able to set up a DelayQueue to keep track of which elements have expired and remove them", "label": {"api": {"DelayQueue": [[30, 39]]}}}, {"text": "Call setMinimumSize(Dimension) on the top-level container when there is enough text in the center label", "label": {"api": {"setMinimumSize(Dimension)": [[5, 29]]}}}, {"text": "Try a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[6, 32]]}}}, {"text": "Reading the docs, the String implmentation uses the CharsetDecoder to convert the incoming byte array into unicode", "label": {"api": {"CharsetDecoder": [[52, 65]]}}}, {"text": "The first and last bytes in your input byte array must not map to a valid unicode character, thus it replaces it with some replacement string", "label": {"api": {"replacement string": [[123, 140]]}}}, {"text": "You can read more about those methods and some other methods of doing custom serialization (writeReplace and readResolve) in the Serializable javadoc", "label": {"api": {"Serializable": [[129, 140]]}}}, {"text": "The Java regular expressions are explained very well in the API documentation of the Pattern class", "label": {"api": {"API documentation of the Pattern class": [[60, 97]]}}}, {"text": "Use the getSource() method of the event", "label": {"api": {"getSource()": [[8, 18]]}}}, {"text": "You also need to synchronize the two threads, for example using a CountDownLatch", "label": {"api": {"CountDownLatch": [[66, 79]]}}}, {"text": "You can also use an Executor and a Callable like this", "label": {"api": {"Executor": [[20, 27]], "Callable": [[35, 42]]}}}, {"text": "Look at java.sql.PreparedStatement.addBatch", "label": {"api": {"java.sql.PreparedStatement.addBatch": [[8, 42]]}}}, {"text": "You could find the beginning of the last line by scanning the file and then truncate it using FileChannel.truncate or RandomAccessFile.setLength", "label": {"api": {"FileChannel.truncate": [[94, 113]], "RandomAccessFile.setLength": [[118, 143]]}}}, {"text": "At that point you'll have an integer and the date in string form", "label": {"api": {"date": [[45, 48]]}}}, {"text": "From there you can parse the date string", "label": {"api": {"date": [[29, 32]]}}}, {"text": "String.split takes a regex to split on, so you can simply", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "You can use the String.split(String regex) method with parameter \"[!.?:;]\"", "label": {"api": {"String.split(String regex)": [[16, 41]]}}}, {"text": "Use Integer.compare(int, int)", "label": {"api": {"Integer.compare(int, int)": [[4, 28]]}}}, {"text": "Try marshalling to an instance of ByteArrayOutputStream and then invoking toByteArray on it", "label": {"api": {"ByteArrayOutputStream": [[34, 54]], "toByteArray": [[74, 84]]}}}, {"text": "Check the documentation for SynchronousQueue", "label": {"api": {"SynchronousQueue": [[28, 43]]}}}, {"text": "For purposes of other Collection methods (for example contains), a SynchronousQueue acts as an empty collection", "label": {"api": {"SynchronousQueue": [[67, 82]]}}}, {"text": "In Java, one approach you might use is to use the getSubImage(int,int,int,int) method of BufferedImage to extract all the individual icons with quick, in-memory access and then create ImageIcons of those and put them on your buttons", "label": {"api": {"getSubImage(int,int,int,int)": [[50, 77]]}}}, {"text": "Use the next() method", "label": {"api": {"next()": [[8, 13]]}}}, {"text": "The for each loop can be used over all elements, that implements interface Iterable, so improved version of your code would look like", "label": {"api": {"Iterable": [[75, 82]]}}}, {"text": "The managed objects will become detached when the EntityManager that is used to load that object is close(), clear() or detach()", "label": {"api": {"close()": [[100, 106]], "clear()": [[109, 115]], "detach()": [[120, 127]]}}}, {"text": "A WeakReference will be necessary", "label": {"api": {"WeakReference": [[2, 14]]}}}, {"text": "If you just want to strip out non-ASCII letter characters, then a quick approach is to use String.replaceAll() and Regex", "label": {"api": {"String.replaceAll()": [[91, 109]]}}}, {"text": "The UI default or the actual Font for a given logical family are fairly reliable", "label": {"api": {"Font": [[29, 32]]}}}, {"text": "As @Hovercraft comments, you can then leverage all the considerable benefits of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[80, 95]]}}}, {"text": "Take a look at the ScheduledThreadPoolExecutor class, it allows you to schedule a piece of code to be run at regular intervals", "label": {"api": {"ScheduledThreadPoolExecutor": [[19, 45]]}}}, {"text": "the hashtable (btw, HashMap is the newer, more recommended class) uses hashCode() to find a bucket to put your object in", "label": {"api": {"HashMap": [[20, 26]]}}}, {"text": "In Java 8, you can use the ZonedDateTime.now(ZoneId zone) method", "label": {"api": {"ZonedDateTime.now(ZoneId zone)": [[27, 56]]}}}, {"text": "The writeUTF call is also problematic since it prefixes the output with a two-byte length and mangles '\\0' bytes using javas modified utf encoding", "label": {"api": {"writeUTF": [[4, 11]]}}}, {"text": "If this were for debugging, I would look at using the JPDA's StepRequest type", "label": {"api": {"StepRequest": [[61, 71]]}}}, {"text": "What's wrong with JComboBox.getItemCount()", "label": {"api": {"JComboBox.getItemCount()": [[18, 41]]}}}, {"text": "You can use System.getProperty(\"user.dir\")", "label": {"api": {"System.getProperty(\"user.dir\")": [[12, 41]]}}}, {"text": "The FileSystemView class from Swing has some functionality to support detecting the type of the drive (cf isFloppyDrive, isComputerNode)", "label": {"api": {"FileSystemView": [[4, 17]]}}}, {"text": "Looking at the OpenJDK 7, update 2, build 21 DefaultMBeanServerInterceptor.java source, line 898 creates a DynamicMBean for regular objects", "label": {"api": {"DynamicMBean": [[107, 118]]}}}, {"text": "I haven't debugged it, but I bet mbeanServer.registerMBean(dh, new ObjectName(\"bean:name=dH1\")) eventually calls DefaultMBeanServerInterceptor.registerObject(), which creates a DynamicMBean for you and properly registers your standard JavaBean properties' setters and getters", "label": {"api": {"DynamicMBean": [[177, 188]]}}}, {"text": "clone() is a protected method on the Object class", "label": {"api": {"clone()": [[0, 6]]}}}, {"text": "If you want a class to be cloneable the general pattern is to implement Cloneable and make that method public", "label": {"api": {"Cloneable": [[72, 80]]}}}, {"text": "If a file is treated as a resource, you can load it with the getResourceAsStream() method of Class", "label": {"api": {"getResourceAsStream()": [[61, 81]]}}}, {"text": "If performance is not a concern, you can build the stack trace (Thread.currentThread.getStackTrace()) in your utility class' constructor", "label": {"api": {"Thread.currentThread.getStackTrace()": [[64, 99]]}}}, {"text": "You must use a @MapKeyJoinColumn annotation to do that", "label": {"api": {"@MapKeyJoinColumn": [[15, 31]]}}}, {"text": "Have a look at the FileVisitor http://docs.oracle.com/javase/7/docs/api/java/nio/file/FileVisitor.html that will greatly help you", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/file/FileVisitor.html": [[31, 101]]}}}, {"text": "Use an ExecutorService that uses a fixed thread pool of size 2, and submit all the tasks to that ExecutorService", "label": {"api": {"ExecutorService": [[7, 21], [97, 111]], "fixed thread pool": [[35, 51]], "submit": [[68, 73]]}}}, {"text": "Just to provide an alternative solution, since your jobs is to \"extract\" the month of a Date, I think Calendar best fits the job", "label": {"api": {"Calendar": [[102, 109]]}}}, {"text": "In your specific case the DefaultHandler class is a helper class that implements several interfaces (EntityResolver, DTDHandler, ContentHandler, ErrorHandler) by providing methods that do nothing", "label": {"api": {"DefaultHandler": [[26, 39]]}}}, {"text": "I have a Double which I created like this", "label": {"api": {"Double": [[9, 14]]}}}, {"text": "Instead use javax.swing.Timer to mark time, as shown here", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "The method addActionListener does not exist for JLabel,find the appropriate listener method you're supposed to use", "label": {"api": {"JLabel": [[48, 53]]}}}, {"text": "As is spelled out in the JFrame API, both do the same thing", "label": {"api": {"JFrame API": [[25, 34]]}}}, {"text": "As per javadoc for wait()", "label": {"api": {"wait()": [[19, 24]]}}}, {"text": "When you call wait(), you are invoking it on the Runnable instance", "label": {"api": {"wait()": [[14, 19]]}}}, {"text": "I recommend that you study the Comparator interface documentation again to see which part of the contract you're missing out on here", "label": {"api": {"the Comparator interface documentation": [[27, 64]]}}}, {"text": "Try using java.util.concurrent.Callable", "label": {"api": {"java.util.concurrent.Callable": [[10, 38]]}}}, {"text": "In your case, you are not reading any of the data until you have written all of it, so the solution is to use a ByteArrayOutputStream and ByteArrayInputStream instead", "label": {"api": {"ByteArrayOutputStream": [[112, 132]], "ByteArrayInputStream": [[138, 157]]}}}, {"text": "Write all the data to a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[24, 44]]}}}, {"text": "(Optional) Create a ByteArrayInputStream with the byte data to read from it as an InputStream", "label": {"api": {"ByteArrayInputStream": [[20, 39]]}}}, {"text": "I have seen http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/font/GlyphVector.html but I don't know how you would use it to display a glyph on the screen", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/font/GlyphVector.html": [[12, 86]]}}}, {"text": "i have successfully set the httpServletResponse().setHeader(\"custtype\", \"permanent\") but when i try to retrieve it httpServletResponse().getHeader(\"custtype\")  i do not see getheader method when i do control + soace in eclipse but as per doc at http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html its there", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html": [[245, 323]]}}}, {"text": "Take a look at ByteBuffer", "label": {"api": {"ByteBuffer": [[15, 24]]}}}, {"text": "Use ScheduledExecutorService instead", "label": {"api": {"ScheduledExecutorService": [[4, 27]]}}}, {"text": "The setEntry() method adds another entry to the keystore", "label": {"api": {"setEntry()": [[4, 13]]}}}, {"text": "The keystore has a store()-method, which writes the keystore to a Stream", "label": {"api": {"store()-method": [[19, 32]]}}}, {"text": "The simplest way is to iterate over the string in your array, and use replace(CharSequence, CharSequence) on each, assigning the results back into the array", "label": {"api": {"replace(CharSequence, CharSequence)": [[70, 104]]}}}, {"text": "Short of more useful code, I suggest using a SwingWorker", "label": {"api": {"SwingWorker": [[45, 55]]}}}, {"text": "Given the nature of the task, you might also look at ProgressMonitorInputStream", "label": {"api": {"ProgressMonitorInputStream": [[53, 78]]}}}, {"text": "To call back the actual activity (if it's running, you could use different methods like subscribing via the Observer Pattern or send around Intents using the LocalBroadcastManager and then update the UI in it's own thread", "label": {"api": {"Observer Pattern": [[108, 123]]}}}, {"text": "If you only need to store preferences, you don't need a file at all and should use the Preferences API", "label": {"api": {"Preferences API": [[87, 101]]}}}, {"text": "Save your time and use StringBuilder or StringBuffer (if you need thread safety)", "label": {"api": {"StringBuilder": [[23, 35]], "StringBuffer": [[40, 51]]}}}, {"text": "Does http://docs.oracle.com/javase/6/docs/api/java/nio/channels/FileLock.html get you there", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/nio/channels/FileLock.html": [[5, 76]]}}}, {"text": "From the documentation of SpinnerNumberModel and SpinnerDateModel it would seem you're generally not allowed to have null as a value", "label": {"api": {"SpinnerNumberModel": [[26, 43]], "SpinnerDateModel": [[49, 64]]}}}, {"text": "You could create your own SpinnerModel and handle the condition yourself", "label": {"api": {"SpinnerModel": [[26, 37]]}}}, {"text": "As skaffman indicated, you cannot directly acquire a direct instance of the thread pool, but using a MBeanServerInvocationHandler will get you pretty close", "label": {"api": {"MBeanServerInvocationHandler": [[101, 128]]}}}, {"text": "The easiest way to implement a custom popup is just to use a Tooltip, style it the way you need using css and use the Tooltip's setGraphic method to add any custom Node content you want", "label": {"api": {"using css": [[96, 104]], "setGraphic method": [[128, 144]]}}}, {"text": "You should also consider whether you should do a straight subclass of Popup or PopupControl, though using Popup as you have is likely more straightforward", "label": {"api": {"Popup": [[70, 74], [79, 83], [106, 110]], "PopupControl": [[79, 90]]}}}, {"text": "Generally, you want to work using the ListIterator where possible", "label": {"api": {"ListIterator": [[38, 49]]}}}, {"text": "The Java standard library does not have a separate linked list node structure, so I think ListIterator is the best option", "label": {"api": {"ListIterator": [[90, 101]]}}}, {"text": "You should take a look at the LinkedHashSet class", "label": {"api": {"LinkedHashSet": [[30, 42]]}}}, {"text": "What you can do is define a shutdown hook", "label": {"api": {"shutdown hook": [[28, 40]]}}}, {"text": "However, you can use the Process and Runtime classes to mimic the desired behaviour and interface with your native system, and use JTextArea + JTextField for showing and issuing commands in your GUI console", "label": {"api": {"Process": [[25, 31]], "Runtime": [[37, 43]]}}}, {"text": "See java.util for details", "label": {"api": {"java.util": [[4, 12]]}}}, {"text": "Note that some of the data structures in java.util may require you to provide your own version of hashCode() (e.g", "label": {"api": {"java.util": [[41, 49]], "hashCode()": [[98, 107]]}}}, {"text": "HashSet) and some may require you to implement Comparable interface or provide a Comparator (e.g", "label": {"api": {"HashSet": [[0, 6]], "Comparable": [[47, 56]], "Comparator": [[81, 90]]}}}, {"text": "If you provide your own version of hashCode() make sure it is consistent with your equals() (see the javadoc for equals())", "label": {"api": {"equals()": [[83, 90], [113, 120]], "hashCode()": [[35, 44]]}}}, {"text": "If you really must use an array, then consider one of the versions of Arrays.binarySearch()", "label": {"api": {"Arrays.binarySearch()": [[70, 90]]}}}, {"text": "Your best bet is to use ScheduledThreadExecutor", "label": {"api": {"ScheduledThreadExecutor": [[24, 46]]}}}, {"text": "Use load(InputStream) to read your properties again", "label": {"api": {"load(InputStream)": [[4, 20]]}}}, {"text": "Check out properties javadoc, it's correct behaviour", "label": {"api": {"properties javadoc": [[10, 27]]}}}, {"text": "Check out BufferedReader for reading lines", "label": {"api": {"BufferedReader": [[10, 23]]}}}, {"text": "You'll have to explode the line afterwards using something like StringTokenizer or String's split", "label": {"api": {"StringTokenizer": [[64, 78]]}}}, {"text": "For storing w-shingling you could create immutable class and implement equals() and hashCode() to improve comparison performance", "label": {"api": {"equals()": [[71, 78]], "hashCode()": [[84, 93]]}}}, {"text": "Use MessageDigest class http://docs.oracle.com/javase/6/docs/api/java/security/MessageDigest.html to create hashes in Java", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/security/MessageDigest.html": [[24, 96]]}}}, {"text": "Use java.util.Timer for simple scheduling work", "label": {"api": {"java.util.Timer": [[4, 18]]}}}, {"text": "If somehow you run out of memory in Java you will get OutOfMemoryError exception", "label": {"api": {"OutOfMemoryError": [[54, 69]]}}}, {"text": "You can use the write method of HTMLEditorKit class", "label": {"api": {"write method": [[16, 27]]}}}, {"text": "To check for methods on a JTextArea, the Java API is your friend", "label": {"api": {"Java API": [[41, 48]]}}}, {"text": "The output looks like the default j.u.l.SimpleFormatter", "label": {"api": {"SimpleFormatter": [[40, 54]]}}}, {"text": "Change the format of the SimpleFormatter using the system property", "label": {"api": {"SimpleFormatter": [[25, 39]], "format": [[11, 16]]}}}, {"text": "or in the logging.properties", "label": {"api": {"logging.properties": [[10, 27]]}}}, {"text": "The L conversion pattern is millisecond within the second formatted as three digits", "label": {"api": {"format": [[58, 63]]}}}, {"text": "or in the logging.properties", "label": {"api": {"logging.properties": [[10, 27]]}}}, {"text": "All of these properties are documented in the format method and in the java.util.Formatter class", "label": {"api": {"format": [[46, 51]], "java.util.Formatter": [[71, 89]]}}}, {"text": "Use Desktop.browse(URI) (which has a chance of working on *nix and OS X as well as Windows)", "label": {"api": {"Desktop.browse(URI)": [[4, 22]]}}}, {"text": "You can look at StringTokenizer", "label": {"api": {"StringTokenizer": [[16, 30]]}}}, {"text": "Maybe it is just me but seems like HashMap is your friend", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "Take look at KeyEvent class in java", "label": {"api": {"KeyEvent": [[13, 20]]}}}, {"text": "It has methods getKeyText(int) and getKeyModifiersText(int)", "label": {"api": {"getKeyText(int)": [[15, 29]], "getKeyModifiersText(int)": [[35, 58]]}}}, {"text": "call waitFor for each Process", "label": {"api": {"waitFor": [[5, 11]]}}}, {"text": "Have a look at Process.waitFor, which will block until the spawned subprocess has terminated", "label": {"api": {"Process.waitFor": [[15, 29]]}}}, {"text": "Although it seems like a reasonable assumption, barring the documentation explicitly saying that it's cleared (and I don't see anything on executeBatch saying that), I'd use clearBatch explicitly on the theory that if an implementation does clear the batch, clearBatch will be a quick no-op; and if it doesn't, well, then I needed to do it", "label": {"api": {"executeBatch": [[139, 150]], "clearBatch": [[174, 183], [258, 267]]}}}, {"text": "While the executeBatch documentation doesn't say so, see Bogdan Calmac's answer", "label": {"api": {"executeBatch": [[10, 21]]}}}, {"text": "You can use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Better yet, you should use a PreparedStatement, to execute the query", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "You need to use something such as URLDecoder on your server side so that you can convert the %40 back to @", "label": {"api": {"URLDecoder": [[34, 43]]}}}, {"text": "I think that OperatingSystemMXBean's getSystemLoadAverage() is what you need", "label": {"api": {"getSystemLoadAverage()": [[37, 58]]}}}, {"text": "With respect to the ResultSet and the second query you are performing, you must take into account that a ResultSet maintains a cursor pointing to its current row of data", "label": {"api": {"ResultSet": [[20, 28], [105, 113]]}}}, {"text": "Check ResultSet's javadoc, especially this sentence", "label": {"api": {"ResultSet": [[6, 14]]}}}, {"text": "A ResultSet object is automatically closed when the Statement object that generated it is closed, re-executed, or used to retrieve the next result from a sequence of multiple results", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "and How can I avoid ResultSet is closed exception in Java?", "label": {"api": {"ResultSet": [[20, 28]]}}}, {"text": "You can use one data structure which holds all the numbers and then, create two SortedSets, one for odd and one for even", "label": {"api": {"SortedSet": [[80, 88]]}}}, {"text": "The answers to this question recommend a Queue or CircularFifoBuffer for this type of situation", "label": {"api": {"Queue": [[41, 45]]}}}, {"text": "getElementsByTagName() returns a NodeList, but every item of the node list is an instance of Element", "label": {"api": {"Element": [[3, 9], [93, 99]]}}}, {"text": "And Element also has a getElementsByTagName() method", "label": {"api": {"Element": [[4, 10], [26, 32]]}}}, {"text": "Just cast the nodes from the node list to Element", "label": {"api": {"Element": [[42, 48]]}}}, {"text": "The X509Certificate getNotBefore() and getNotAfter() methods should return those dates", "label": {"api": {"getNotBefore()": [[20, 33]], "getNotAfter()": [[39, 51]]}}}, {"text": "I would recommend using the built in Java session objects HttpSession, which GAE/J has support for", "label": {"api": {"HttpSession": [[58, 68]]}}}, {"text": "Starting from Java 7, you can use java.nio.file.Files.setAttribute and the creationTime attribute", "label": {"api": {"java.nio.file.Files.setAttribute": [[34, 65]]}}}, {"text": "Read the JavaDoc for the java.util.Queue interface and pick an appropriate implementing class from the list shown", "label": {"api": {"java.util.Queue": [[25, 39]]}}}, {"text": "LinkedList is as good as any for just basic FIFO operations, but there are others there that implement the Queue interface in case you need something more advanced", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "Both the Arrays and Collections utility classes have binary-search methods", "label": {"api": {"Arrays": [[9, 14]], "Collections": [[20, 30]]}}}, {"text": "javax.el.ELException is introduced in JSP/EL 2.1 which goes hand in hand with Servlet 2.5 which is part of Java EE 5", "label": {"api": {"javax.el.ELException": [[0, 19]]}}}, {"text": "You can use Map<String, Object> to represent a \"dynamic\" row, which is iterable in <c:forEach>", "label": {"api": {"Map<String, Object>": [[12, 30]]}}}, {"text": "You can use ResultSetMetaData to collect information about the columns such as the column count and the column labels", "label": {"api": {"ResultSetMetaData": [[12, 28]], "column count": [[83, 94]], "column labels": [[104, 116]]}}}, {"text": "I would recommend that your DataGenerator extend SwingWorker and by that doing the work in a background thread, implemented in doInBackground", "label": {"api": {"SwingWorker": [[49, 59]]}}}, {"text": "The SwingWorker could then publish intermediate results to the GUI, while you have a process method that receives the last few published chunks on the EDT and update your GUI", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "The SwingWorkers process method does coalesce the published chunks, so it will not run once for every published intermediate result", "label": {"api": {"SwingWorker": [[4, 14]], "coalesce": [[37, 44]]}}}, {"text": "Read more on SwingWorker", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "It's odd to see that the documentation for the Date(long) constructor differs from the implementation", "label": {"api": {"Date(long) constructor": [[47, 68]]}}}, {"text": "Looks like you can change the delimiters of the scanner - see the example at Scanner Class", "label": {"api": {"Scanner Class": [[77, 89]]}}}, {"text": "Alternatively, java.util.Preferences is fine for modest needs; RCPrefs is an example", "label": {"api": {"java.util.Preferences": [[15, 35]]}}}, {"text": "In Java when using DatagramPacket suppose you have a byte[1024*1024] buffer", "label": {"api": {"DatagramPacket": [[19, 32]]}}}, {"text": "If you just pass that for the DatagramPacket when sending/receiving will a Java receive call for the DatagramPacket block until it has read the entire megabyte", "label": {"api": {"DatagramPacket": [[30, 43], [101, 114]]}}}, {"text": "I've heard that IPv6 also has jumbo frames, but does DatagramPacket (or DatagramSocket) support that since UDP defines the header spec", "label": {"api": {"DatagramPacket": [[53, 66]], "DatagramSocket": [[72, 85]]}}}, {"text": "Utilities.getRowStart() / getRowEnd() passing the offsets", "label": {"api": {"Utilities.getRowStart() / getRowEnd()": [[0, 36]]}}}, {"text": "next() is an instance method, so you must call it on an instance of the class Scanner", "label": {"api": {"next()": [[0, 5]]}}}, {"text": "the split() method returns a string array", "label": {"api": {"split()": [[4, 10]]}}}, {"text": "java.beans.Introspector is useful for getting that information", "label": {"api": {"java.beans.Introspector": [[0, 22]]}}}, {"text": "Prepare the query, but rather than executing it, just call getMetaData on the prepared statement", "label": {"api": {"getMetaData": [[59, 69]]}}}, {"text": "Class has a method called getMethod, which takes a string argument, the method's name (also some optional arguments for the parameter types), then you can call it by calling invoke on it", "label": {"api": {"Class": [[0, 4]]}}}, {"text": "The behaviour of getNodeValue() depends on the subclass of Node", "label": {"api": {"Node": [[20, 23], [59, 62]]}}}, {"text": "In the case of an Element, getNodeValue() will always return null (see the table in the Node javadoc for behaviour of other subclasses)", "label": {"api": {"Node": [[30, 33], [88, 91]]}}}, {"text": "When the disconnect happens, catch whatever exception was thrown (and don't forget to also log the cause via a call to .getCause() - making as many calls to .getCause() as necessary until you've logged all the way back to the root cause), as well as any relevant data you need to match up the client log with the server-side logs", "label": {"api": {"cause": [[99, 103], [231, 235]]}}}, {"text": "Read the java docs for parseInt() and valueOf which clearly states that a NumberFormatException is thrown if the String does not contain a parsable integer", "label": {"api": {"parseInt() and valueOf": [[23, 44]]}}}, {"text": "See here for the Java doc of the canDisplay function which is a member of the Font class", "label": {"api": {"See here for the Java doc of the canDisplay": [[0, 42]], "the Font class": [[74, 87]]}}}, {"text": "HashSet has no HashSet(HashSet) constructor, so naturally you don't get one when you ask for it", "label": {"api": {"HashSet": [[0, 6], [15, 21], [23, 29]]}}}, {"text": "The standard library defines IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[29, 52]]}}}, {"text": "Use the javax.swing.Timer class to execute events at a specified interval", "label": {"api": {"javax.swing.Timer": [[8, 24]]}}}, {"text": "You need to use the right Charset when reading the file", "label": {"api": {"Charset": [[26, 32]]}}}, {"text": "You could use a ConcurrentSkipListMap and provide your own comparator that sorts the entries based on a timestamp", "label": {"api": {"ConcurrentSkipListMap": [[16, 36]]}}}, {"text": "For the ship() method just use a ReadWriteLock that has fair mode turned on", "label": {"api": {"ReadWriteLock": [[33, 45]]}}}, {"text": "Hiding files in Swing JFileChooser", "label": {"api": {"JFileChooser": [[22, 33]]}}}, {"text": "Instead give the GridBagConstraints for the navigation panel a weighty of 0 and the empty panel a weighty of 1 (or any positive number)", "label": {"api": {"weighty": [[63, 69], [98, 104]]}}}, {"text": "HashSet will not guarantee order but LinedHashSet will", "label": {"api": {"HashSet": [[0, 6], [42, 48]], "LinedHashSet": [[37, 48]]}}}, {"text": "replaceAll() takes a regular expression and returns the replaced String", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "$ is a regular expression meta character that matches the end of a line", "label": {"api": {"meta character": [[26, 39]]}}}, {"text": "For now, I decided to grow my own ItemReader bean that na√Øvely queries its DataSource property via the JDBC API", "label": {"api": {"DataSource": [[75, 84]]}}}, {"text": "2) Date.getTime() returns milliseconds since the epoch, not seconds", "label": {"api": {"Date.getTime()": [[3, 16]]}}}, {"text": "Use GridBagLayout instead", "label": {"api": {"GridBagLayout": [[4, 16]]}}}, {"text": "If that's the case, you can use an AtomicInteger to do this in one shot via getAndSet", "label": {"api": {"AtomicInteger": [[35, 47]]}}}, {"text": "From the javadoc for ClassLoader", "label": {"api": {"javadoc for ClassLoader": [[9, 31]]}}}, {"text": "You can return the java.awt.Point with the x and y values or use an int array if that would be fine", "label": {"api": {"java.awt.Point": [[19, 32]]}}}, {"text": "Pass true into the FileWriter constructor like so", "label": {"api": {"constructor": [[30, 40]]}}}, {"text": "Anyway, if you have any performance problem, make sure you use JDBC batch inserts", "label": {"api": {"JDBC batch inserts": [[63, 80]]}}}, {"text": "In the case when task hasn't executed yet, method  scheduledExecutionTime is undefined", "label": {"api": {"scheduledExecutionTime": [[51, 72]]}}}, {"text": "Why not use StringWriter instead", "label": {"api": {"StringWriter": [[12, 23]]}}}, {"text": "Note that the default composite mode for a platform's concrete implementation of Graphics2D is AlphaComposite.SRC_OVER, which may or may not be what you want", "label": {"api": {"Graphics2D": [[81, 90]], "AlphaComposite.SRC_OVER": [[95, 117]]}}}, {"text": "This sounds like you need a Timer", "label": {"api": {"Timer": [[28, 32]]}}}, {"text": "Timer executes the method at a background thread - why is it important to execute the method within your main thread", "label": {"api": {"Timer": [[0, 4]]}}}, {"text": "Lastly, your pattern might not do what you think it does as \\p{Z} only catches letters 'Z' judging by the documentation for Pattern", "label": {"api": {"documentation for Pattern": [[106, 130]]}}}, {"text": "You have to set this through the .setInterface of the MulticastSocket associated with your channel", "label": {"api": {".setInterface": [[33, 45]]}}}, {"text": "The .setOption() on a DatagramChannel is only available since JDK 7", "label": {"api": {".setOption": [[4, 13]]}}}, {"text": "You are trying to set the content type after committing the response by calling getWriter", "label": {"api": {"getWriter": [[80, 88]]}}}, {"text": "See the documentation on getWriter and setCharacterEncoding for details", "label": {"api": {"getWriter": [[25, 33]], "setCharacterEncoding": [[39, 58]]}}}, {"text": "The obvious problem is that Random.nextInt generates a number 0 (inclusive) and n (exclusive)", "label": {"api": {"Random.nextInt": [[28, 41]]}}}, {"text": "Or, if the check itself is some long-running task that must not be done in the GUI thread (because it would freeze it), then use a SwingWorker and submit it to a ScheduledExecutorService created by the Executors class", "label": {"api": {"SwingWorker": [[131, 141]], "ScheduledExecutorService": [[162, 185]], "Executors": [[202, 210]]}}}, {"text": "Specifically, if you use HashMap, it will also be O(1) - though it will be slower than ArrayList", "label": {"api": {"HashMap": [[25, 31]]}}}, {"text": "No, they really do mean (and very correctly so) the classpath, which is a collection of directories or JAR files in which the JVM searches for classes and also for resources like image and configuration files to be accessed via mechanisms like Class.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[244, 270]]}}}, {"text": "Are you closing the writer", "label": {"api": {"closing": [[8, 14]]}}}, {"text": "I am aware that I could call Locale.setDefault(), but I would like to avoid this because there are other parts of the application where I need this to be the system default locale, instead of the locale of my choosing", "label": {"api": {"Locale.setDefault()": [[29, 47]]}}}, {"text": "Have you tried JDialog", "label": {"api": {"JDialog": [[15, 21]]}}}, {"text": "See the documentation of the Java HashMap", "label": {"api": {"Java HashMap": [[29, 40]]}}}, {"text": "Refer this link for equals/hashcode contract", "label": {"api": {"equals/hashcode contract": [[20, 43]]}}}, {"text": "Also, see the Javadoc on Cookie", "label": {"api": {"Cookie": [[25, 30]]}}}, {"text": "You have to write one method per primitive type, as in java.util.Arrays", "label": {"api": {"java.util.Arrays": [[55, 70]]}}}, {"text": "You can use getAbsolutePath() function", "label": {"api": {"getAbsolutePath()": [[12, 28]]}}}, {"text": "The class that does the trick is URIResolver, which can be installed to a Transformer by means of", "label": {"api": {"URIResolver": [[33, 43]]}}}, {"text": "One solution is to do the work in a SwingWorker", "label": {"api": {"SwingWorker": [[36, 46]]}}}, {"text": "According to Java Oracle Docs", "label": {"api": {"Java Oracle Docs": [[13, 28]]}}}, {"text": "Unless recursion is specified in the homework, you would be best served by looking into String.split", "label": {"api": {"String.split": [[88, 99]]}}}, {"text": "A simple option is to use a java.util.concurrent.atomic.AtomicReference (or one of the other Atomic..", "label": {"api": {"java.util.concurrent.atomic.AtomicReference": [[28, 70]]}}}, {"text": "The java.util.concurrent -package contains many helpful interfaces and classes for safely communicating between threads", "label": {"api": {"java.util.concurrent": [[4, 23]]}}}, {"text": "I'm not sure I understand your use-case here, but if your player (producer) is supposed to pass tasks to the receiver (consumer), you could for example use a BlockingQueue -implementation", "label": {"api": {"BlockingQueue": [[158, 170]]}}}, {"text": "You need to use indexOf instead of charAt, like so", "label": {"api": {"indexOf": [[16, 22]]}}}, {"text": "In other words, check if your checker string contains (indexOf != -1) the first character of s (s.charAt(0))", "label": {"api": {"indexOf": [[55, 61]]}}}, {"text": "To make it compatible with versions back to 1.3, use the direct LineBorder(Color,int,boolean) constructor", "label": {"api": {"LineBorder(Color,int,boolean)": [[64, 92]]}}}, {"text": "Here is a reference for ArrayList", "label": {"api": {"Here is a reference for ArrayList": [[0, 32]]}}}, {"text": "For example, if we create a java.lang.Thread specifying a stack size of 64*1024, the JVM is free to give us a thread with any stack size", "label": {"api": {"java.lang.Thread": [[28, 43]]}}}, {"text": "Scanner constructor that you call on line 28 is declared to potentially throw a FileNotFoundException", "label": {"api": {"Scanner constructor": [[0, 18]]}}}, {"text": "With double checked non-blocking locking", "label": {"api": {"non-blocking": [[20, 31]]}}}, {"text": "BigInteger.toString(radix) will do what you want", "label": {"api": {"BigInteger.toString(radix)": [[0, 25]]}}}, {"text": "Just to make it clear, it says here http://docs.oracle.com/javase/7/docs/api/java/io/InvalidClassException.html that this exception is thrown when there is no constructor that accepts no parameters", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/InvalidClassException.html": [[36, 110]]}}}, {"text": "Date is one possiblility, though I'd use the currentTimeMillis()", "label": {"api": {"Date": [[0, 3]], "currentTimeMillis()": [[45, 63]]}}}, {"text": "Have a look at CascadeType", "label": {"api": {"CascadeType": [[15, 25]]}}}, {"text": "You can set the behaviour for save/update operations directly by using the CascadeType in the relationship annotation", "label": {"api": {"CascadeType": [[75, 85]]}}}, {"text": "Have a look at JOptionPane, which handles most of this stuff for you, e.g", "label": {"api": {"JOptionPane": [[15, 25]]}}}, {"text": "You need to explicitly close the ServerSocket by calling the close -method of the socket", "label": {"api": {"close": [[23, 27], [61, 65]]}}}, {"text": "The best place to do this is in your Worldwide-class's run-method, in a finally-block (so the socket gets closed even if an exception occurs)", "label": {"api": {"close": [[106, 110]]}}}, {"text": "One can be obtained from a BI using either getGraphics() or createGraphics()", "label": {"api": {"getGraphics()": [[43, 55]], "createGraphics()": [[60, 75]]}}}, {"text": "I know the technical differences between StringBuffer and StringBuilder", "label": {"api": {"StringBuffer": [[41, 52]], "StringBuilder": [[58, 70]]}}}, {"text": "Sure, implement a custom renderer", "label": {"api": {"renderer": [[25, 32]]}}}, {"text": "Another way is to shove HTML into the default renderer (a JLabel), using an HTML table that stretches across 100% of the width", "label": {"api": {"renderer": [[46, 53]]}}}, {"text": "Though the custom renderer would be a better choice for a number of reasons (e.g", "label": {"api": {"renderer": [[18, 25]]}}}, {"text": "not presuming the type of the default renderer is a label)", "label": {"api": {"renderer": [[38, 45]]}}}, {"text": "See AbstractButton.setPressedIcon(Icon) (and related methods that accept an Icon)", "label": {"api": {"AbstractButton.setPressedIcon(Icon)": [[4, 38]]}}}, {"text": "Character type 16 corresponds to Unicode DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING (U+202B)", "label": {"api": {"DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING": [[41, 78]]}}}, {"text": "Use String.split() with comma and white-spae as a delimiter and than split the resultant array element with = as a delimiter", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "Than, add the resultant array elements into an ArrayList", "label": {"api": {"ArrayList": [[47, 55]]}}}, {"text": "It looks like you've answered your own question - use a regex (Pattern) to extract the values from each line and store it in a data structure that is appropriate for your situation", "label": {"api": {"Pattern": [[63, 69]]}}}, {"text": "http://docs.oracle.com/javase/1.4.2/docs/api/java/util/StringTokenizer.html You can use nextToken()", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/util/StringTokenizer.html": [[0, 74]]}}}, {"text": "It uses an ArrayBlockingQueue queue as a FIFO buffer and its main loop is something along these lines", "label": {"api": {"ArrayBlockingQueue": [[11, 28]]}}}, {"text": "Since there is no direct control channel, the shutdown method uses the Thread interface to interrupt() the feeder thread", "label": {"api": {"Thread": [[71, 76]], "interrupt()": [[91, 101]]}}}, {"text": "Unfortunately, in most cases the feeder thread remains blocked in put(), despite being interrupted - no exception is thrown", "label": {"api": {"put()": [[66, 70]]}}}, {"text": "From a brief perusal of the interrupt() documentation and the queue implementation source code, it seems to me that quite often put() blocks without using any of the interruptible facilities of the JVM", "label": {"api": {"interrupt()": [[28, 38]], "put()": [[128, 132]]}}}, {"text": "Perhaps it uses a spinlock or something else, but in any case, this seems to fall under the following case", "label": {"api": {"the following case": [[88, 105]]}}}, {"text": "A status flag is set, but the thread is still blocked in put() and does not iterate further so that the flag can be checked", "label": {"api": {"put()": [[57, 61]]}}}, {"text": "Use the offer() method with a timeout instead of put() to allow the thread to check its interrupt status within an acceptable time frame", "label": {"api": {"put()": [[49, 53]]}}}, {"text": "You can use the Date class in Java", "label": {"api": {"Date": [[16, 19]]}}}, {"text": "This answer provides a simple example of using javax.xml.parsers.DocumentBuilder to generate a DOM", "label": {"api": {"javax.xml.parsers.DocumentBuilder": [[47, 79]]}}}, {"text": "Java provides SAXParser for parsing XML", "label": {"api": {"SAXParser": [[14, 22]]}}}, {"text": "Ever since JDK 7 there is a javax.json package in the standard lib", "label": {"api": {"javax.json": [[28, 37]]}}}, {"text": "javax.json is the Java package - note also that there is an extremely light-weight Java alternative to SAX, called StAX (Streaming API for XML)", "label": {"api": {"StAX (Streaming API for XML)": [[115, 142]]}}}, {"text": "connectionFactory property is of type javax.jms.ConnectionFactory (see", "label": {"api": {"javax.jms.ConnectionFactory": [[38, 64]]}}}, {"text": "You should use BoxLayout.Y_AXIS instead of X_AXIS", "label": {"api": {"BoxLayout.Y_AXIS": [[15, 30]]}}}, {"text": "Use the JarFile.getInputStream(ZipEntry) method, read all the bytes from the input stream, and write them to a FileOutputStream", "label": {"api": {"JarFile.getInputStream(ZipEntry)": [[8, 39]]}}}, {"text": "You'll need a reference to those components and perform a comparison to the component returned by getSource()", "label": {"api": {"getSource()": [[98, 108]]}}}, {"text": "When will a StackOverError be thrown", "label": {"api": {"StackOverError": [[12, 25]]}}}, {"text": "What if bar is an java.lang.Integer", "label": {"api": {"java.lang.Integer": [[18, 34]]}}}, {"text": "You can use Collator to do locale sensitive String comparisions", "label": {"api": {"Collator": [[12, 19]]}}}, {"text": "I found SecurityManager.checkExec but I don't think it helps..", "label": {"api": {"SecurityManager.checkExec": [[8, 32]]}}}, {"text": "Use the ICU4J library, or http://docs.oracle.com/javase/6/docs/api/java/text/Normalizer.html in Java 1.6 or newer", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/Normalizer.html": [[26, 91]]}}}, {"text": "Follow the javadoc Random.nextInt(int) to understand it better", "label": {"api": {"Random.nextInt(int)": [[19, 37]]}}}, {"text": "You need to set it as a fullworthy ValueExpression instead of as a plain vanilla String", "label": {"api": {"ValueExpression": [[35, 49]]}}}, {"text": "You can create one by ExpressionFactory#createValueExpression()", "label": {"api": {"ValueExpression": [[46, 60]], "ExpressionFactory#createValueExpression()": [[22, 62]]}}}, {"text": "You can obtain the expression factory in JSF context by Application#getExpressionFactory()", "label": {"api": {"Application#getExpressionFactory()": [[56, 89]]}}}, {"text": "The TableCellEditor.getTableCellEditorComponent() method takes a row as argument", "label": {"api": {"TableCellEditor.getTableCellEditorComponent()": [[4, 48]]}}}, {"text": "A Socket instance has methods to detect this state", "label": {"api": {"methods to detect": [[22, 38]]}}}, {"text": "Hmm...sounds like you'll want to make use of the JToggleButton class", "label": {"api": {"JToggleButton": [[49, 61]]}}}, {"text": "This should give you what you want, but if you want it to be a little better, I would look into using a String Builder", "label": {"api": {"String Builder": [[104, 117]]}}}, {"text": "Some enterprise and Dependency Injection frameworks use reflection Class.newInstance() to create a new instance of your classes", "label": {"api": {"Class.newInstance()": [[67, 85]]}}}, {"text": "You could (amongst other things) use the Timer API in the JDK, for example", "label": {"api": {"Timer API": [[41, 49]]}}}, {"text": "Create JAAS config files for each target platform or create entries for each platform in a single JAAS config", "label": {"api": {"entries": [[60, 66]]}}}, {"text": "See the com.sun.security.auth.login.ConfigFile for details on the load order", "label": {"api": {"com.sun.security.auth.login.ConfigFile": [[8, 45]]}}}, {"text": "this request is of type multipart/form-data, but does not contain the requested Part.\" (ref)", "label": {"api": {"ref": [[88, 90]]}}}, {"text": "Your form is defined as using POST, so you want to handle it in your doPost function, not your doGet function", "label": {"api": {"doPost": [[69, 74]], "doGet": [[95, 99]]}}}, {"text": "You can write a class which extends AbstractTableModel to handle display, validation, etc", "label": {"api": {"AbstractTableModel": [[36, 53]]}}}, {"text": "You need to get it by ServletContext#getInitParameter()", "label": {"api": {"ServletContext#getInitParameter()": [[22, 54]]}}}, {"text": "Use the Graphics#setColor method to set the current color", "label": {"api": {"Graphics#setColor": [[8, 24]]}}}, {"text": "Also, you will want to use the Graphics#fillOval method to draw solid circles with the current color", "label": {"api": {"Graphics#fillOval": [[31, 47]]}}}, {"text": "Use fillOval()javadoc to fill the oval instead of just drawing an outline", "label": {"api": {"fillOval()javadoc": [[4, 20]]}}}, {"text": "Seems like your test file contains less data than what you're trying to read, because that's why this exception is thrown", "label": {"api": {"this exception is thrown": [[97, 120]]}}}, {"text": "It's always better to check if the input has any next element using hasNext() method", "label": {"api": {"hasNext()": [[68, 76]]}}}, {"text": "Have you considered starting lots of java Threads instead", "label": {"api": {"Threads": [[42, 48]]}}}, {"text": "You can use java.nio.charset.CharsetDecoder to do that", "label": {"api": {"java.nio.charset.CharsetDecoder": [[12, 42]]}}}, {"text": "Otherwise you could use CharsetDecoder (as mentioned by Malcolm)", "label": {"api": {"CharsetDecoder": [[24, 37]]}}}, {"text": "If the SomeException extends RuntimeException", "label": {"api": {"RuntimeException": [[29, 44]]}}}, {"text": "Read documentation for XmlAdapter", "label": {"api": {"XmlAdapter": [[23, 32]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html which would require a separate application to perform the job you need", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html": [[0, 69]]}}}, {"text": "You can use substring to extract the date only", "label": {"api": {"substring": [[12, 20]]}}}, {"text": "From addShutdownHook documentation", "label": {"api": {"addShutdownHook": [[5, 19]]}}}, {"text": "The best ideia is implement ServantManager with some timeout policy", "label": {"api": {"ServantManager": [[28, 41]]}}}, {"text": "Then, in the real JDBC implementation, you could use PreparedStatement#addBatch() to create a batch of statements and PreparedStatement#executeBatch() to execute it", "label": {"api": {"PreparedStatement#addBatch()": [[53, 80]], "PreparedStatement#executeBatch()": [[118, 149]]}}}, {"text": "You're already passing the Class object into the method, just use Class.cast()", "label": {"api": {"Class.cast()": [[66, 77]]}}}, {"text": "implement Highlighter.HighlightPainter, getting its paint(..) method to go outside of the bounds that it is given, painting a rectangle of the same height and full width", "label": {"api": {"Highlighter.HighlightPainter": [[10, 37]]}}}, {"text": "String.replaceAll() works on regexps", "label": {"api": {"String.replaceAll()": [[0, 18]]}}}, {"text": "Indeed, the way how PrimeFaces locates components by relative client ID has been changed in PrimeFaces 3.1 to adhere the UIComponent#findComponent() javadoc", "label": {"api": {"UIComponent#findComponent() javadoc": [[121, 155]]}}}, {"text": "Take a look at JarInputStream, JarOutputStream, ZipInputStream, and ZipOutputStream", "label": {"api": {"JarInputStream": [[15, 28]], "JarOutputStream": [[31, 45]], "ZipInputStream": [[48, 61]], "ZipOutputStream": [[68, 82]]}}}, {"text": "In order to do this, you need to submit() a task to an ExecutorService, rather than calling execute()", "label": {"api": {"submit()": [[33, 40]]}}}, {"text": "In particular, you can call cancel(true) on the associated Future to interrupt a task that is currently executing (or skip execution altogether if the task hasn't started running yet)", "label": {"api": {"cancel(true)": [[28, 39]]}}}, {"text": "By the way, the object returned by Executors.newSingleThreadExecutor() is actually an ExecutorService", "label": {"api": {"Executors.newSingleThreadExecutor()": [[35, 69]]}}}, {"text": "One useful defensive measure is to use java.util.prefs.Preferences to record clean-up information", "label": {"api": {"java.util.prefs.Preferences": [[39, 65]]}}}, {"text": "The following is from the somewhat more detailed http://docs.oracle.com/javase/7/docs/api/java/io/BufferedOutputStream.html (emphasis my own)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedOutputStream.html": [[49, 122]]}}}, {"text": "Take a look at JComponent.revalidate() and its related methods", "label": {"api": {"JComponent.revalidate()": [[15, 37]]}}}, {"text": "using LinkedHashMap.removeEldestEntry() and see how that goes", "label": {"api": {"LinkedHashMap.removeEldestEntry()": [[6, 38]]}}}, {"text": "Sounds like you may need to use regular expressions (http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/package-summary.html) instead of StringTokenizer", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/package-summary.html": [[53, 133]]}}}, {"text": "Here is java documentation on FileWriter API", "label": {"api": {"FileWriter API": [[30, 43]]}}}, {"text": "Use equals() instead of == to compare strings", "label": {"api": {"equals()": [[4, 11]]}}}, {"text": "JLabels can't do that by default", "label": {"api": {"JLabel": [[0, 5]]}}}, {"text": "But JLabels have some support for html, so a JLabel with the text <html>First Line<br />Second Line</html> would show up on two lines", "label": {"api": {"JLabel": [[4, 9], [45, 50]]}}}, {"text": "If you want a component that can split the lines by itself, take a look at JTextArea", "label": {"api": {"JTextArea": [[75, 83]]}}}, {"text": "If you're bent on using a FileInputStream, you can always use the mark and reset methods (if they're supported, that is)", "label": {"api": {"FileInputStream": [[26, 40]], "mark": [[66, 69]], "reset": [[75, 79]]}}}, {"text": "However, you could also get a FileChannel from FileInputStream#getChannel (or a SeekableByteChannel from Files#newByteChannel if you want to use Java 7) and use position to get the position of the stream before process A and position(long) to reset the position of the stream after process A", "label": {"api": {"FileInputStream": [[47, 61]], "reset": [[243, 247]], "FileChannel": [[30, 40]], "FileInputStream#getChannel": [[47, 72]], "SeekableByteChannel": [[80, 98]], "Files#newByteChannel": [[105, 124]], "position": [[161, 168], [181, 188], [225, 232], [253, 260]], "position(long)": [[225, 238]]}}}, {"text": "Instead of dropDownList being a String list, make it a SelectItem list", "label": {"api": {"SelectItem": [[55, 64]]}}}, {"text": "Using an AtomicBoolean (much like I suggested here) would be safer and allows for repeat attempts at instantiation on failure", "label": {"api": {"AtomicBoolean": [[9, 21]]}}}, {"text": "The Oracle JVM accepts -Djava.compiler=NONE to disable the JIT (-D sets the system property, java.compiler is the property name, NONE is the value)", "label": {"api": {"java.compiler is the property name": [[93, 126]]}}}, {"text": "Another option is to use one of the methods defined in the Math utility class", "label": {"api": {"Math": [[59, 62]]}}}, {"text": "Quoted from the API documentation for Collection.toArray(T[] a)", "label": {"api": {"the API documentation for Collection.toArray(T[] a)": [[12, 62]]}}}, {"text": "Use  T[] toArray(T[] a) from Collection instead", "label": {"api": {"Collection": [[29, 38]]}}}, {"text": "Use a regular expression (Pattern) to get a Matcher to match your string", "label": {"api": {"Pattern": [[26, 32]], "Matcher": [[44, 50]]}}}, {"text": "You can work with ProcessBuilder, and then you can set the working directory of the process using ProcessBuilder#directory(File dir)", "label": {"api": {"ProcessBuilder": [[18, 31], [98, 111]], "ProcessBuilder#directory(File dir)": [[98, 131]]}}}, {"text": "Maps are great for caches, where you need to look something up based on a key; usually they're not ordered, but LinkedHashMap retains insertion order like a List", "label": {"api": {"LinkedHashMap": [[112, 124]]}}}, {"text": "If you've got a reference to a Session instance, you could do the following", "label": {"api": {"Session": [[31, 37]]}}}, {"text": "Have a look at java.text.MessageFormat", "label": {"api": {"java.text.MessageFormat": [[15, 37]]}}}, {"text": "The only reason I can see for you getting a NullPointerException would be if you'd tried to use that variable you assigned the result to (returnValue) later, since invoke returns null if the method's return type is void", "label": {"api": {"invoke": [[164, 169]]}}}, {"text": "You can get the current gc(s) in use using the GarbageCollectorMXBeans", "label": {"api": {"GarbageCollectorMXBeans": [[47, 69]]}}}, {"text": "Try using a CountDownLatch", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "First, your loop is incorrect, since read is not guaranteed to read the length you requested", "label": {"api": {"read": [[37, 40], [63, 66]]}}}, {"text": "Rather than converting from your InputStream to bytes to a String, see if you can use an InputStreamReader to handle all that tricky stuff for you", "label": {"api": {"InputStreamReader": [[89, 105]]}}}, {"text": "In Java, you can use Math.max like this", "label": {"api": {"Math.max": [[21, 28]]}}}, {"text": "The simples way to do this is by catching the FileNotFoundException thrown by the FileReader if a file does not exist or is a directory or for some other reason cannot be opened for reading", "label": {"api": {"FileReader": [[82, 91]]}}}, {"text": "For more info see the Java Docs on FileReader", "label": {"api": {"FileReader": [[35, 44]]}}}, {"text": "Use the List's retainAll method", "label": {"api": {"retainAll": [[15, 23]]}}}, {"text": "CoffeeScript compiles into plain old JavaScript, which can be executed by modern JVMs (v6+)", "label": {"api": {"can be executed by modern JVMs (v6+)": [[55, 90]]}}}, {"text": "You can use Calendar.setFirstDayOfWeek to indicate whether a week is Monday-Sunday or Sunday-Saturday; I believe setting the day of the week will stay within the current week - but test it", "label": {"api": {"Calendar.setFirstDayOfWeek": [[12, 37]]}}}, {"text": "You should probably rather use the roll method..", "label": {"api": {"roll": [[35, 38]]}}}, {"text": "Check out SwingWorker", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html may avoid overhead of synchronization", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html": [[0, 88]]}}}, {"text": "When in doubt about generics usage, look for the collection interfaces in java.util, they have lots of examples, what you want to do is the same as what Collection.addAll() does", "label": {"api": {"Collection.addAll()": [[153, 171]]}}}, {"text": "Use System#nanoTime() for measurements", "label": {"api": {"System#nanoTime()": [[4, 20]]}}}, {"text": "You want to look at the Timer class", "label": {"api": {"Timer": [[24, 28]]}}}, {"text": "You could use a shutdown hook", "label": {"api": {"shutdown hook": [[16, 28]]}}}, {"text": "Do you only want to check the URI for correct syntax", "label": {"api": {"URI": [[30, 32]]}}}, {"text": "If so, simply create an instance of URI class", "label": {"api": {"URI": [[36, 38]]}}}, {"text": "This throws an java.net.URISyntaxException when URI is not syntactically correct", "label": {"api": {"URI": [[24, 26], [48, 50]]}}}, {"text": "If you need to check the URI for AMQ-specific options, you might have two have a look at AMQ source code and find a class that validates/parses this", "label": {"api": {"URI": [[25, 27]]}}}, {"text": "I think the more modern way to do this is use a ThreadPoolExecutor and submit a Runnable that's doing your indexing", "label": {"api": {"ThreadPoolExecutor": [[48, 65]], "Runnable": [[80, 87]]}}}, {"text": "If you are using a Swing JTextArea, use JTextArea.getCaretPosition()", "label": {"api": {"JTextArea": [[25, 33], [40, 48]], "JTextArea.getCaretPosition()": [[40, 67]], "TextArea": [[26, 33], [41, 48]]}}}, {"text": "If you are using an AWT TextArea, see Jarrod Roberson's answer", "label": {"api": {"TextArea": [[24, 31]]}}}, {"text": "The problem is you are creating your lists with Arrays.asList", "label": {"api": {"Arrays.asList": [[48, 60]]}}}, {"text": "I found in an old thread, that mentions the usage of the property EndOfLineStringProperty, which makes sense, since the JTextPane extends JEditorPane which uses a document", "label": {"api": {"EndOfLineStringProperty": [[66, 88]]}}}, {"text": "Also, in the JTextPane docs, is written", "label": {"api": {"JTextPane docs": [[13, 26]]}}}, {"text": "Yes, there is a built-in command, intBitsToFloat converts a 32-bit int to a float", "label": {"api": {"intBitsToFloat": [[34, 47]]}}}, {"text": "You only have to parse your input as an int, the easier way - if your input is in hexadecimal format - would be to directly use base 16 in Integer.parseInt(), then intBitsToFloat converts that bit pattern to a float", "label": {"api": {"intBitsToFloat": [[164, 177]]}}}, {"text": "The Integer.ParseInteger(str, radix) will convert a binary digit string to an int ..", "label": {"api": {"Integer.ParseInteger(str, radix)": [[4, 35]]}}}, {"text": "If you are really concerned about converting a String to a byte[], then what you're looking for is a Java method (click me), and not something unique to Android", "label": {"api": {"click me": [[114, 121]]}}}, {"text": "You'll need to set the dash attributes in your Stroke; DEFAULT_GRIDLINE_STROKE is an example", "label": {"api": {"Stroke": [[47, 52]]}}}, {"text": "You should look into system.out", "label": {"api": {"in": [[16, 17]], "out": [[28, 30]]}}}, {"text": "I think you are confused the in and out, please read the link before and this", "label": {"api": {"in": [[4, 5], [29, 30], [58, 59]], "out": [[36, 38]]}}}, {"text": "Once this happens, you can then use the SwingUtilities.invokeLater() to update your JTextArea", "label": {"api": {"SwingUtilities.invokeLater()": [[40, 67]]}}}, {"text": "Best bets are to use getResource from the class loader, which will return things in the class path (the WEB-INF/lib directory, etc), or to use the getResource() method of ServletContext to find things in the web application itself", "label": {"api": {"getResource()": [[147, 159]]}}}, {"text": "Math.ceil() will return a double that is equal to an integer", "label": {"api": {"Math.ceil()": [[0, 10]]}}}, {"text": "Do the Android libraries include java.util package", "label": {"api": {"java.util package": [[33, 49]]}}}, {"text": "If yes, you could use the java.util.Random class (see this link for details)", "label": {"api": {"this link": [[54, 62]]}}}, {"text": "I've got a ByteBuffer in java, and want to read, then conditionally modify that byte, e.g", "label": {"api": {"ByteBuffer": [[11, 20]]}}}, {"text": "I don't want to synchronize the entire ByteBuffer or updateByte method, since I want multiple threads to be able to read/write different bytes of the buffer at the same time (i.e", "label": {"api": {"ByteBuffer": [[39, 48]]}}}, {"text": "The ByteBuffer I'm using isn't backed by a byte[], so bb.hasArray() == false in the above example", "label": {"api": {"ByteBuffer": [[4, 13]]}}}, {"text": "Instead, call the other toArray method", "label": {"api": {"toArray": [[24, 30]]}}}, {"text": "You should use the other toArray(T[] a) method", "label": {"api": {"toArray(T[] a)": [[25, 38]]}}}, {"text": "I believe you are looking for a JFileChooser", "label": {"api": {"JFileChooser": [[32, 43]]}}}, {"text": "It is saying that if some other thread calls interrupt() on the thread that is executing the code you posted before or during its call of waitFor(), an InterruptedException will be thrown", "label": {"api": {"interrupt()": [[45, 55]]}}}, {"text": "Does your program explicitly call interrupt() anywhere", "label": {"api": {"interrupt()": [[34, 44]]}}}, {"text": "Use ServletContext.getResourceAsStream() to load a file from the webapp's context", "label": {"api": {"ServletContext.getResourceAsStream()": [[4, 39]]}}}, {"text": "Get an instance of your Method, which is retrieved from the Class like you're doing, then call Method.invoke() with the instance of the class you wish to call the method on", "label": {"api": {"Method.invoke()": [[95, 109]]}}}, {"text": "Sounds like you want a HashSet<String>", "label": {"api": {"HashSet<String>": [[23, 37]]}}}, {"text": "Java functions always return a single value, so your only option is to return a \"collection\" object which contains multiple values, such as an Array or a proper Collection", "label": {"api": {"Collection": [[161, 170]]}}}, {"text": "If the managed bean is request scoped, then you can use @ManagedProperty for this", "label": {"api": {"@ManagedProperty": [[56, 71]]}}}, {"text": "If the managed bean is in a broader scope, then you can't use @ManagedProperty for this", "label": {"api": {"@ManagedProperty": [[62, 77]]}}}, {"text": "See also ViewParam vs @ManagedProperty(value = \"#{param.id}\")", "label": {"api": {"@ManagedProperty": [[22, 37]]}}}, {"text": "Or maybe a better idea is to stick with the API that the JDK provides and try Callable", "label": {"api": {"Callable": [[78, 85]]}}}, {"text": "Use descendingKeySet or descendingMap", "label": {"api": {"descendingKeySet": [[4, 19]], "descendingMap": [[24, 36]]}}}, {"text": "However, when using descendingKeySet, you won't need to create a new TreeMap", "label": {"api": {"descendingKeySet": [[20, 35]]}}}, {"text": "You can also create a new Map in reverse order using descendingMap as well as Collections.reverseOrder()", "label": {"api": {"descendingMap": [[53, 65]]}}}, {"text": "Note that descendingMap returns NavigableMap", "label": {"api": {"descendingMap": [[10, 22]]}}}, {"text": "Parsing libraries such as Jsoup and NekoHTML don't seem to provide this information, even XMLLocator doesn't seem to apply, since it only provides the end of the current document event", "label": {"api": {"XMLLocator": [[90, 99]]}}}, {"text": "Make the dialog modal", "label": {"api": {"modal": [[16, 20]]}}}, {"text": "There is a utility constructor which does this for you", "label": {"api": {"constructor": [[19, 29]]}}}, {"text": "Have you tried to InetAddress.toString() method", "label": {"api": {"InetAddress.toString()": [[18, 39]]}}}, {"text": "Use a List (such as an ArrayList)", "label": {"api": {"List": [[6, 9], [28, 31]], "ArrayList": [[23, 31]]}}}, {"text": "Java has a number of collections (List, Set, Map, Queue, etc.), with various implementations", "label": {"api": {"List": [[34, 37]]}}}, {"text": "Try using ArrayList, resizable-array implementation of the List interface in Java", "label": {"api": {"ArrayList": [[10, 18]]}}}, {"text": "Use ArrayList in java", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "By using a SecretKeySpec", "label": {"api": {"SecretKeySpec": [[11, 23]]}}}, {"text": "this interface has the isEmpty() method; then, each specific type of list provides its implementation of isEmpty() method", "label": {"api": {"this interface": [[0, 13]]}}}, {"text": "Or just use Math object or RandomUtils", "label": {"api": {"Math": [[12, 15]]}}}, {"text": "You might want to use ArrayList.contains() to check if the element is in the ArrayList or not", "label": {"api": {"ArrayList.contains()": [[22, 41]]}}}, {"text": "JMenuBar is added to the JFrame by using setJMenuBar(...) method", "label": {"api": {"setJMenuBar(...)": [[41, 56]]}}}, {"text": "You might be able to leverage setDefaultButton, which is bound the Enter key by default", "label": {"api": {"setDefaultButton": [[30, 45]]}}}, {"text": "I suspect a JSpinner using a SpinnerNumberModel would be a better component for selecting an integer based age or Y.O.B", "label": {"api": {"JSpinner": [[12, 19]], "SpinnerNumberModel": [[29, 46]]}}}, {"text": "since you'll probably need to redraw your lines each frame (if you want a set of lines and not just a single line to be drawn each frame), use Point to save your coordinates and some kind of list like ArrayList", "label": {"api": {"Point": [[143, 147]], "ArrayList": [[201, 209]]}}}, {"text": "Save the full set of tracked points in an ArrayList<Point> and then draw each frame iterating over this list", "label": {"api": {"Point": [[52, 56]], "ArrayList": [[42, 50]]}}}, {"text": "The String class provides a static method  to dereference possibly null values but there doesn't seem to be much use of this pattern apart from the Objects class", "label": {"api": {"static method": [[28, 40]], "Objects": [[148, 154]]}}}, {"text": "But consider something like ConcurrentHashMap if you expect there to be many threads working with the map simultaneously; it's thread safe but still allows concurrent access, unlike Hashtable or Collections.synchronizedMap()", "label": {"api": {"ConcurrentHashMap": [[28, 44]]}}}, {"text": "A better idea though might be to use a ConcurrentHashMap - this was designed for concurrency from the start and should perform better in a highly concurrent situation", "label": {"api": {"ConcurrentHashMap": [[39, 55]]}}}, {"text": "I was wondering do we require external synchronization to use the methods in java.lang.Thread", "label": {"api": {"java.lang.Thread": [[77, 92]]}}}, {"text": "For example, can we call the method t1.isAlive() from any thread without external synchronization and expect that it return", "label": {"api": {"t1.isAlive()": [[36, 47]]}}}, {"text": "Or is external synchronization required to call the methods in java.lang.Thread", "label": {"api": {"java.lang.Thread": [[63, 78]]}}}, {"text": "JPanel is double buffered by default, so selecting and dragging are typically quite smooth", "label": {"api": {"JPanel": [[0, 5]]}}}, {"text": "Instead, check out the BlockingQueue interface and use the example in the comments as a guide", "label": {"api": {"BlockingQueue": [[23, 35]]}}}, {"text": "If it is required that no more than one frame is generated in advance, then use an ArrayBlockingQueue with a capacity of 1", "label": {"api": {"BlockingQueue": [[88, 100]], "ArrayBlockingQueue": [[83, 100]]}}}, {"text": "I should also mention that in both your example and the BlockingQueue example in the link above, semantics for shutting down the producer and consumer threads are not explained", "label": {"api": {"BlockingQueue": [[56, 68]]}}}, {"text": "You can take advatage of String.substring() method", "label": {"api": {"String.substring()": [[25, 42]]}}}, {"text": "You might find Line2D.relativeCCW(Point2D) to be very useful in determining whether a point is clockwise or counterclockwise from a given vector", "label": {"api": {"Line2D.relativeCCW(Point2D)": [[15, 41]]}}}, {"text": "Because Java has a pool of unique interned instances, and that String literals are stored in this pool", "label": {"api": {"interned": [[34, 41]]}}}, {"text": "Perhaps you want to call Thread.currentThread(), which returns a Thread", "label": {"api": {"Thread.currentThread()": [[25, 46]]}}}, {"text": "In this particular case it's really easy using asReadOnlyBuffer", "label": {"api": {"asReadOnlyBuffer": [[47, 62]]}}}, {"text": "I would simply make a BigInteger from the hash bytes, modulus 36^3, and return the string in base 36", "label": {"api": {"BigInteger": [[22, 31]]}}}, {"text": "Try showSaveDialog method", "label": {"api": {"showSaveDialog": [[4, 17]]}}}, {"text": "It's called floor", "label": {"api": {"floor": [[12, 16]]}}}, {"text": "For general purpose context information you can use TransactionSynchronizationRegistry", "label": {"api": {"TransactionSynchronizationRegistry": [[52, 85]]}}}, {"text": "I believe it is usually implemented using ThreadLocal variables as normally each transaction maps to a sigle thread in application servers", "label": {"api": {"ThreadLocal": [[42, 52]]}}}, {"text": "So if TransactionSynchronizationRegistry is not implemented in your AS (like e.g", "label": {"api": {"TransactionSynchronizationRegistry": [[6, 39]]}}}, {"text": "in JBoss 4.2.3) or you need lower level tool, you could use ThreadLocal variables directly", "label": {"api": {"ThreadLocal": [[60, 70]]}}}, {"text": "Refer to the documentation for KeyEvent", "label": {"api": {"the documentation for KeyEvent": [[9, 38]]}}}, {"text": "Although javax.swing.Timer will coalesce events by default, the timer thread will tend to saturate quickly with such a short period (high frequency)", "label": {"api": {"javax.swing.Timer": [[9, 25]]}}}, {"text": "You can use the Calendar class to get timestamps for the required dates such as today and yesterday", "label": {"api": {"Calendar": [[16, 23]]}}}, {"text": "Every Component has this method Component.isShowing()", "label": {"api": {"Component.isShowing()": [[32, 52]]}}}, {"text": "WebView does not implement a selection management API similar to TextInputControl for fine grained programmatic management of selections", "label": {"api": {"TextInputControl": [[65, 80]]}}}, {"text": "You could try stuff such as capturing keypress events using an eventfilter, then generating mouse events to initiate the selection and copy process, but that sounds difficult to me, and even then, there is currently no public API in JavaFX to generate mouse events, only an unstable com.sun api", "label": {"api": {"eventfilter": [[63, 73]]}}}, {"text": "WebView does expose a document object model, and the document is scriptable by JavaScript", "label": {"api": {"document object model": [[22, 42]], "scriptable by JavaScript": [[65, 88]]}}}, {"text": "Try capturing key events with an eventfilter, listening to the document property for changes and executing JavaScript against the WebView at appropriate times to get and set the current selection", "label": {"api": {"eventfilter": [[33, 43]]}}}, {"text": "If you don't know the page encoding beforehand you may be able to use the URLConnection.getContentEncoding() method to find out", "label": {"api": {"URLConnection.getContentEncoding()": [[74, 107]]}}}, {"text": "If you insist on doing this (don't?), then you could use a Map", "label": {"api": {"Map": [[59, 61]]}}}, {"text": "You'd be iterating your parameter - value pairs once, then iterating your Map once to rebuild the URI", "label": {"api": {"Map": [[74, 76]]}}}, {"text": "You could stick the key/value pairs into a Map<String,String>", "label": {"api": {"Map<String,String>": [[43, 60]]}}}, {"text": "To verify that parameters with identical keys have identical values, you could check the return value of put()", "label": {"api": {"put()": [[105, 109]]}}}, {"text": "Fairly easy, implement a HttpSessionListener", "label": {"api": {"HttpSessionListener": [[25, 43]]}}}, {"text": "The container will trigger sessionDestroyed() if it decides to remove a session from its cache", "label": {"api": {"sessionDestroyed()": [[27, 44]]}}}, {"text": "You need to provide a NamespaceContext and namespace your expression", "label": {"api": {"NamespaceContext": [[22, 37]]}}}, {"text": "See JavaDoc of the remove() method", "label": {"api": {"JavaDoc of the remove() method": [[4, 33]]}}}, {"text": "Yes, you're calling sendRedirect which is documented like this (emphasis mine)", "label": {"api": {"sendRedirect": [[20, 31]]}}}, {"text": "In other words, your first line is completely irrelevant when you explicitly call sendRedirect", "label": {"api": {"sendRedirect": [[82, 93]]}}}, {"text": "There are a lot of useful metrics in the java.lang.management package, such as the MemoryPoolMXBean", "label": {"api": {"MemoryPoolMXBean": [[83, 98]]}}}, {"text": "Place the examiners in a List and use Collections.shuffle() to shuffle it", "label": {"api": {"Collections.shuffle()": [[38, 58]]}}}, {"text": "Shuffle the list of routes (using Collections.shuffle())", "label": {"api": {"Collections.shuffle()": [[34, 54]]}}}, {"text": "The CardLayout is well suited for this", "label": {"api": {"CardLayout": [[4, 13]]}}}, {"text": "Since Java 8 this can be simplified with use of updateAndGet", "label": {"api": {"updateAndGet": [[48, 59]]}}}, {"text": "Override the JPanel's paintComponent() Method and paint the content into a BufferedImage image first", "label": {"api": {"BufferedImage": [[75, 87]]}}}, {"text": "Once done, copy the content of the BufferedImage into the graphics context you get from paintComponent()", "label": {"api": {"BufferedImage": [[35, 47]]}}}, {"text": "SwingLabs has SwingX project which provides suite of components including JXDatePicker (API) works with Date class, which supports dates starting from January 1, 1970, 00:00:00 GMT", "label": {"api": {"Date": [[76, 79], [104, 107]]}}}, {"text": "In Java, the typical way to build up a String piece-by-piece is to use a StringBuilder", "label": {"api": {"StringBuilder": [[73, 85]]}}}, {"text": "FileSystemView has some useful platform-dependent icons; FileBrowser is an example", "label": {"api": {"FileSystemView": [[0, 13]]}}}, {"text": "The Java properties file format dictates that the backslash character (\"\\\") escapes the character that follow it, so to get a literal windows path you must have", "label": {"api": {"properties file format": [[9, 30]]}}}, {"text": "In Java, checked exceptions are Throwables that are not RuntimeException, Error, or one of their subclasses", "label": {"api": {"Throwable": [[32, 40]], "RuntimeException": [[56, 71]], "Error": [[74, 78]]}}}, {"text": "A classic example is IOException", "label": {"api": {"IOException": [[21, 31]]}}}, {"text": "For instance, why doesn't File.delete (a new Java 7 API does this differently) throw IOException", "label": {"api": {"IOException": [[85, 95]], "File.delete": [[26, 36]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "It returns a Future which can be used to cancel the execution if you want to, or to obtain a value returned by MyCommand", "label": {"api": {"Future": [[13, 18]]}}}, {"text": "If you need to reschedule on some condition only, or with different rates or intervals, one technique I've used is to pass the ScheduledExecutorService to your command (ie, new MyCommand(ses)) and let it rescheduled itself or a new command with the appropriate delay", "label": {"api": {"ScheduledExecutorService": [[127, 150]]}}}, {"text": "The component identifier message is not going to change; the client identifier (e.g", "label": {"api": {"client identifier": [[61, 77]]}}}, {"text": "Try using HttpURLConnection", "label": {"api": {"HttpURLConnection": [[10, 26]]}}}, {"text": "In Java it can be done with String.replaceAll()", "label": {"api": {"String.replaceAll()": [[28, 46]]}}}, {"text": "Give a try to String#format() - its format string should let you do what you need", "label": {"api": {"String#format()": [[14, 28]]}}}, {"text": "If, however, the intention is that the instance variables should be unique to each thread, you should look at ThreadLocal instead", "label": {"api": {"ThreadLocal": [[110, 120]]}}}, {"text": "I'm far from a REST expert, but javax.ws.rs.core.Application is not a servlet", "label": {"api": {"javax.ws.rs.core.Application": [[32, 59]]}}}, {"text": "The MemCached.ObjectTransCoder decode method rely on the java.io.ObjectInputStream to deserialize the cached Java objects from the cache", "label": {"api": {"java.io.ObjectInputStream": [[57, 81]]}}}, {"text": "Wrapping that in an ObjectInputStream would seem to give you just about the same functionality", "label": {"api": {"ObjectInputStream": [[20, 36]]}}}, {"text": "ObjectInputStream's available() method returns available() from the underlying input stream without doing any processing", "label": {"api": {"ObjectInputStream": [[0, 16]]}}}, {"text": "Use @DependsOn annotation or depends-on attribute if you're using xml configuration", "label": {"api": {"@DependsOn": [[4, 13]]}}}, {"text": "Objects that implement the Comparable interface (like Strings) have a natural ordering (as defined by its compareTo method) so you can just use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[144, 156]]}}}, {"text": "The rules for Comparators and Comparables (where the first object is the object itself) is", "label": {"api": {"Comparators": [[14, 24]], "Comparables": [[30, 40]]}}}, {"text": "If you're asking how your three classes should access the fields from Frame1 which presumably is their container - then you should use getParent() to get reference to the parent class, check if it is Frame1 and if yes - access its fields", "label": {"api": {"getParent()": [[135, 145]]}}}, {"text": "(It's not in DocumentBuilder or DocumentBuilderFactory) If not, what do I have to do to make it work out OK for different encodings", "label": {"api": {"DocumentBuilder": [[13, 27], [32, 46]], "DocumentBuilderFactory": [[32, 53]]}}}, {"text": "Bind the component to the view (which will in case of <h:selectOneMenu> resolve to an instance of HtmlSelectOneMenu) and use UIInput#getValue() as action method argument and fix your invalid EL syntax", "label": {"api": {"HtmlSelectOneMenu": [[98, 114]], "UIInput#getValue()": [[125, 142]]}}}, {"text": "and then use Double.parseDouble() on each match", "label": {"api": {"Double.parseDouble()": [[13, 32]]}}}, {"text": "But what is the canonical path of a file that doesn't exist", "label": {"api": {"a file that doesn't exist": [[34, 58]]}}}, {"text": "Instead, use getPixel() on the underlying Raster, clear the alpha byte, and update the image using setPixel() and the updated array", "label": {"api": {"getPixel()": [[13, 22]], "setPixel()": [[99, 108]]}}}, {"text": "Implement Pageable, not Printable", "label": {"api": {"Pageable": [[10, 17]]}}}, {"text": "From its API doc", "label": {"api": {"API doc": [[9, 15]]}}}, {"text": "If i sort the data collections using Collator with strength \"SECONDARY\" it works fine", "label": {"api": {"Collator": [[37, 44]]}}}, {"text": "Math.random() will give you a random double between 0 and 1", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "Alternatively you can apply the same transformation to a call to the nextDouble() method from java.util.Random, but this requires an explicit instance of Random whereas that is done behind the scenes with Math.random()", "label": {"api": {"Math.random()": [[205, 217]], "nextDouble()": [[69, 80]]}}}, {"text": "You can use the Random class's nextDouble() method", "label": {"api": {"Random": [[16, 21]]}}}, {"text": "If you chose SAX you should extend the DefaultHandler class, just like that example", "label": {"api": {"DefaultHandler": [[39, 52]]}}}, {"text": "The ListSelectionListener provides a ListSelectionEvent", "label": {"api": {"ListSelectionListener": [[4, 24]], "ListSelectionEvent": [[37, 54]]}}}, {"text": "See the methods of the event to get access to the 1st and last indices of the user's selection", "label": {"api": {"methods of the event": [[8, 27]]}}}, {"text": "The closest I know of is System.loadLibrary", "label": {"api": {"System.loadLibrary": [[25, 42]]}}}, {"text": "Use String's split method with a negated character class", "label": {"api": {"split method": [[13, 24]]}}}, {"text": "For example, look at ServletContext.getRealPath", "label": {"api": {"ServletContext.getRealPath": [[21, 46]]}}}, {"text": "Have you turned off auto-commit but forgotten to explicitly call commit() by any chance", "label": {"api": {"commit()": [[65, 72]]}}}, {"text": "You need to wrap the problematic code (the code that throws the exception because of lack of permissions) in a PrivilegedAction or a PrivilegedExceptionAction, and then call it using the doPrivileged methods of AccessController", "label": {"api": {"PrivilegedAction": [[111, 126]], "PrivilegedExceptionAction": [[133, 157]], "AccessController": [[211, 226]]}}}, {"text": "You will probably want some thing like the Calendar for the time addition", "label": {"api": {"Calendar": [[43, 50]]}}}, {"text": "As for entering the time, one possibility is to enter it as a text, and then use a DateFormatter to get a Date from it", "label": {"api": {"DateFormatter": [[83, 95]], "Date": [[83, 86], [106, 109]]}}}, {"text": "You can get all those from the HttpServletRequest object, if you can get a hold of it", "label": {"api": {"HttpServletRequest": [[31, 48]]}}}, {"text": "String.split() works for you", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "You can also use Scanner class", "label": {"api": {"Scanner": [[17, 23]]}}}, {"text": "The best way (which isn't to say a super easy way) to do what you want is to write your own implementation of Iterator", "label": {"api": {"Iterator": [[110, 117]]}}}, {"text": "You may also want/need be more specific, and write a lazy loading wrapper of Collection, or List", "label": {"api": {"Collection": [[77, 86]], "List": [[92, 95]]}}}, {"text": "The technique would be similar, but would generally be more work (a lazy loaded List might need a lazy loded Iterator, and you might have to be concerned with thread safety, just to think of a few things)", "label": {"api": {"Iterator": [[109, 116]], "List": [[80, 83]]}}}, {"text": "Take a look at the source code of java.util.Map", "label": {"api": {"java.util.Map": [[34, 46]]}}}, {"text": "I would like to implement the java Arrays.binarySearch method for binarySearch(double[], double), but in C language", "label": {"api": {"Arrays.binarySearch": [[35, 53]]}}}, {"text": "If you need a specific order, you have to use the @OrderColumn annotation", "label": {"api": {"@OrderColumn annotation": [[50, 72]]}}}, {"text": "Beside that you can store a BigDecimal with a large, but limited number of digits as plain String value", "label": {"api": {"BigDecimal": [[28, 37]]}}}, {"text": "To set the precision of your number you can use BigDecimal.setScale()", "label": {"api": {"BigDecimal": [[48, 57]], "BigDecimal.setScale()": [[48, 68]]}}}, {"text": "This takes the number of digits and a RoundingMode", "label": {"api": {"RoundingMode": [[38, 49]]}}}, {"text": "I would recommend using BigDecimal.toPlainString() instead of BigDecimal.toString()", "label": {"api": {"BigDecimal": [[24, 33], [62, 71]], "BigDecimal.toPlainString()": [[24, 49]], "BigDecimal.toString()": [[62, 82]]}}}, {"text": "Returns a string representation of this BigDecimal without an exponent field", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "Returns the string representation of this BigDecimal, using scientific notation if an exponent is needed", "label": {"api": {"BigDecimal": [[42, 51]]}}}, {"text": "Create a new BigDecimal from the file you can just pass the String value to the constructor", "label": {"api": {"BigDecimal": [[13, 22]]}}}, {"text": "Since Java 8 the List has a sort method inherited by Collection", "label": {"api": {"sort": [[28, 31]]}}}, {"text": "Additionally you can use the Comparator class to create a comparator very easy", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "If you want to use multiple Parameters for your sort you can easily append them", "label": {"api": {"sort": [[48, 51]]}}}, {"text": "If you are using a Java Version below Java 8 you have to implement the sort logic yourself in an Comparator or use an external library", "label": {"api": {"sort": [[71, 74]], "Comparator": [[97, 106]]}}}, {"text": "You can use java.net.InetAddress.getByAddress(byte[])", "label": {"api": {"java.net.InetAddress.getByAddress(byte[])": [[12, 52]]}}}, {"text": "If you are printing an Object to System.out Java uses the Object.toString() method to get a string representation of your Object", "label": {"api": {"Object.toString()": [[58, 74]]}}}, {"text": "To format the int values you can use the String.format() method", "label": {"api": {"String.format()": [[41, 55]]}}}, {"text": "A TreeMap is sorted by keys", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "So using a TreeMap would not be the best choice in your case", "label": {"api": {"TreeMap": [[11, 17]]}}}, {"text": "You could either use a LinkedHashMap or changing your map to a List", "label": {"api": {"LinkedHashMap": [[23, 35]]}}}, {"text": "A LinkedHashMap is sorted by insertion order", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "To improve this I would recommend to implement the Comparable interface in your Object class", "label": {"api": {"Comparable": [[51, 60]]}}}, {"text": "In this case, you could just use a shared blocking queue (a synchronous queue looks appropriate to me) between both threads", "label": {"api": {"synchronous queue": [[60, 76]]}}}, {"text": "A Set is defined to be \"A collection that contains no duplicate elements\"", "label": {"api": {"defined": [[9, 15]]}}}, {"text": "You can just use the Stream.filter() method", "label": {"api": {"Stream.filter()": [[21, 35]]}}}, {"text": "First of all a TreeMap does not work for you, because it is sorted by keys, not by values", "label": {"api": {"TreeMap": [[15, 21]]}}}, {"text": "Another alternative would be a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[31, 43]]}}}, {"text": "Next you can sort that, by using another stream and migrating it to a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[70, 82]]}}}, {"text": "The \"Unable to obtain LocalDateTime\" exception is because the parsed text only has time values, no date values, so it is impossible to construct a Local‚ÄãDate‚ÄãTime object", "label": {"api": {"LocalDateTime": [[22, 34]]}}}, {"text": "Parse to a LocalTime instead", "label": {"api": {"LocalTime": [[11, 19]]}}}, {"text": "The \"HH:mm:ss\" pattern is the default for a LocalTime, so there is no need to specify it (see", "label": {"api": {"LocalTime": [[44, 52]]}}}, {"text": "If you want/need a LocalDateTime object, parsed similarly to how SimpleDateFormat did it, i.e", "label": {"api": {"LocalDateTime": [[19, 31]], "SimpleDateFormat": [[65, 80]]}}}, {"text": "For comparison, that is equivalent to the old SimpleDateFormat result", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "To improve it and get better accuracy you could use BigDecimal class", "label": {"api": {"BigDecimal": [[52, 61]]}}}, {"text": "The javadoc of CallableStatement says", "label": {"api": {"CallableStatement": [[15, 31]]}}}, {"text": "If you read the javadoc of @ForeignKey, you'll find", "label": {"api": {"@ForeignKey": [[27, 37]]}}}, {"text": "Here's a set of inputs and outputs for Math.floorMod(x, 5) as an example", "label": {"api": {"Math.floorMod(x, 5)": [[39, 57]]}}}, {"text": "The equals method is a better fit for your requirement", "label": {"api": {"equals": [[4, 9]]}}}, {"text": "Use LocalTime to represent a time-of-day without date and without time zone", "label": {"api": {"LocalTime": [[4, 12]]}}}, {"text": "You can use the methods Node.setOnMouseEntered() and Node.setOnMouseExited() to register event handlers, which start or stop your animation", "label": {"api": {"Node.setOnMouseEntered()": [[24, 47]], "Node.setOnMouseExited()": [[53, 75]]}}}, {"text": "Use Optional.ofNullable and Optional.map", "label": {"api": {"Optional.ofNullable": [[4, 22]], "Optional.map": [[28, 39]]}}}, {"text": "See javadoc for Optional.map", "label": {"api": {"Optional.map": [[16, 27]]}}}, {"text": "From Stream javadoc", "label": {"api": {"Stream javadoc": [[5, 18]]}}}, {"text": "You could use collect with Collectors.summarizingInt", "label": {"api": {"Collectors.summarizingInt": [[27, 51]]}}}, {"text": "And to sum it all up I created a working example using a slighty different way for the implementation of the caesar encryption and using Files.lines(...) to read the files content and Files.write(...) to write the encrypted content to a new file", "label": {"api": {"Files.lines(...)": [[137, 152]], "Files.write(...)": [[184, 199]]}}}, {"text": "Basically, you need to use the collect function instead of using toMap wrapper", "label": {"api": {"collect": [[31, 37]]}}}, {"text": "You could use flatMap of streams and combine all entries from all maps recieved from transform method as", "label": {"api": {"flatMap": [[14, 20]]}}}, {"text": "You should use RowSetProvider to get a factory", "label": {"api": {"RowSetProvider": [[15, 28]], "RowSet": [[15, 20]]}}}, {"text": "A factory API that enables applications to obtain a RowSetFactory implementation that can be used to create different types of RowSet implementations", "label": {"api": {"RowSetFactory": [[52, 64]], "RowSet": [[52, 57], [127, 132]]}}}, {"text": "You could create a custom comparator for your sorting logics", "label": {"api": {"comparator": [[26, 35]]}}}, {"text": "I took the code from this UCLA tutorial and used it for javagent instrumentation using java.lang.instrument", "label": {"api": {"java.lang.instrument": [[87, 106]]}}}, {"text": "You can use AtomicBoolean for thread safety Round Robin", "label": {"api": {"AtomicBoolean": [[12, 24]]}}}, {"text": "From here and this answer, I understand I can use RolesAllowed annotation to give required permission to a method, which will be checked when RolesAllowedDynamicFeature is registered with an Authorizer implementation", "label": {"api": {"RolesAllowed": [[50, 61], [142, 153]]}}}, {"text": "I'd rather use Arrays and Streams, available since Java 8", "label": {"api": {"Arrays": [[15, 20]], "Streams": [[26, 32]]}}}, {"text": "Introspector gets crazy (in different ways depending on the Java version) when he finds a get without its respective attribute", "label": {"api": {"Introspector": [[0, 11]]}}}, {"text": "The most performant solution is to use Java's   ConcurrentHashMap.computeIfAbsent() method", "label": {"api": {"ConcurrentHashMap.computeIfAbsent()": [[48, 82]]}}}, {"text": "As Holger pointed out in the comments using Stream.reduce() for this purpose is not correct", "label": {"api": {"Stream.reduce()": [[44, 58]]}}}, {"text": "See Reduction and Mutable Reduction or Java 8 Streams - collect vs reduce for more information", "label": {"api": {"Reduction": [[4, 12], [26, 34]], "Mutable Reduction": [[18, 34]]}}}, {"text": "You can use Java Stream.collect() instead to generate your list with sums", "label": {"api": {"Stream.collect()": [[17, 32]]}}}, {"text": "You can use Arrays#parallelPrefix to accomplish your goal", "label": {"api": {"Arrays#parallelPrefix": [[12, 32]]}}}, {"text": "To get the current time in US Eastern time zone, in that format, using Java 8 Time API", "label": {"api": {"Java 8 Time API": [[71, 85]]}}}, {"text": "If you want to return something, change the return type from void to Response", "label": {"api": {"Response": [[69, 76]]}}}, {"text": "The ThreadDeath error, though a \"normal\" condition, is also a subclass of Error because most applications should not try to catch it", "label": {"api": {"ThreadDeath": [[4, 14]]}}}, {"text": "But I still have hope because Java uses something like this in Serializable interface with the serialVersionUID", "label": {"api": {"Serializable interface": [[63, 84]]}}}, {"text": "One example is JDK  java.io.ObjectStreamClass.getSerialVersionUID() methods that loads the serialVersionUID value with reflection", "label": {"api": {"java.io.ObjectStreamClass.getSerialVersionUID()": [[20, 66]]}}}, {"text": "JDK provides a few java.util.concurrent.BlockingQueue implementations", "label": {"api": {"java.util.concurrent.BlockingQueue": [[19, 52]]}}}, {"text": "Look at the Node class and then especially setTranslateX", "label": {"api": {"Node": [[12, 15]], "setTranslateX": [[43, 55]]}}}, {"text": "Regarding the Java 9 Stream iterate method, I am unsure about the order of execution of the Predicate and UnaryOperator methods", "label": {"api": {"Java 9 Stream iterate method": [[14, 41]]}}}, {"text": "Using Java 8, if I have this TYPE_USE annotation", "label": {"api": {"TYPE_USE": [[29, 36]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner(java.lang.String), which creates Scanner which has the string as the input stream", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner(java.lang.String)": [[0, 89]]}}}, {"text": "One solution is to have your Flight class implement the comparable interface", "label": {"api": {"comparable": [[56, 65]]}}}, {"text": "Probably only if you used System.setIn() to override the standard input", "label": {"api": {"System.setIn()": [[26, 39]]}}}, {"text": "You can use sublist to sum up until the current index from start", "label": {"api": {"sublist": [[12, 18]]}}}, {"text": "Class<WorkDays>, you can use the getDeclaringClass method", "label": {"api": {"the getDeclaringClass method": [[29, 56]]}}}, {"text": "You can take it a step further by switching to ExecutorService to spawn your worker threads and call ExecutorService.shutdown() on the application shutdown", "label": {"api": {"ExecutorService.shutdown()": [[101, 126]]}}}, {"text": "If you don't require a graceful shutdown you can use ExecutorService.shutdownNow() and set Thread.setDaemon(true) flag when creating threads", "label": {"api": {"ExecutorService.shutdownNow()": [[53, 81]], "Thread.setDaemon(true)": [[91, 112]]}}}, {"text": "If you don't create too many temporary files use File.deleteOnExit()", "label": {"api": {"File.deleteOnExit()": [[49, 67]]}}}, {"text": "You can achieve that by setting a TextFormatter via TextField.setTextFormatter which will ensure that the value is a valid integer", "label": {"api": {"TextFormatter": [[34, 46], [65, 77]], "TextField.setTextFormatter": [[52, 77]]}}}, {"text": "I think a better alternative to handle request routing would be using some similar to the  WebServlet annotation", "label": {"api": {"WebServlet": [[91, 100]]}}}, {"text": "You can use the new methods in Java 8 like putIfAbsent to add new entry if key is not present and computeIfPresent to append values to an existing key of a map", "label": {"api": {"putIfAbsent": [[43, 53]], "computeIfPresent": [[98, 113]]}}}, {"text": "Here the putIfAbsent tests if the key is present, if not adds a new key-value entry", "label": {"api": {"putIfAbsent": [[9, 19]]}}}, {"text": "In the second operation the method computeIfPresent checked that the key Department was already in the map so it appended the new String Test3 to existing value array of [Test1, Test2]", "label": {"api": {"computeIfPresent": [[35, 50]]}}}, {"text": "I would, however, define the constants in a final class with a private constructor throwing an AssertionError to enforce noninstantiability", "label": {"api": {"AssertionError": [[95, 108]]}}}, {"text": "The AssertionError isn‚Äôt strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class", "label": {"api": {"AssertionError": [[4, 17]]}}}, {"text": "use an AtomicBoolean so you are sure to not have a side effect setting and checking the value of running variable in a multithread environment", "label": {"api": {"AtomicBoolean": [[7, 19]]}}}, {"text": "The code to read in the entire contents of a file can be simplified using Files.readAllBytes", "label": {"api": {"Files.readAllBytes": [[74, 91]]}}}, {"text": "So, put that code in a Runnable and pass it to SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[47, 72]]}}}, {"text": "How can we implement such a thread-pool in way that, when a task sleeps (or waits on a monitor/condition), the thread1 can be used effectively to run another task", "label": {"api": {"waits": [[76, 80]], "condition": [[95, 103]]}}}, {"text": "If a thread waits on a resource, the resource can be used by another thread", "label": {"api": {"waits": [[12, 16]]}}}, {"text": "Using ScheduledExecutorService to run the task after a delay would be preferable to using Thread.sleep() inside a thread", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "To read the complete file you can use the Files.lines() method and use Java Streams", "label": {"api": {"Files.lines()": [[42, 54]]}}}, {"text": "If you want you result to be an array you can use the Stream.toArray() method instead of Stream.collect()", "label": {"api": {"Stream.toArray()": [[54, 69]], "Stream.collect()": [[89, 104]]}}}, {"text": "If you want to read the file without the Files.lines() method you can use the following", "label": {"api": {"Files.lines()": [[41, 53]]}}}, {"text": "See MouseEvent and MouseEventListener", "label": {"api": {"MouseEvent": [[4, 13], [19, 28]], "MouseEventListener": [[19, 36]]}}}, {"text": "From the output it looks like flogger is using SimpleFormatter from JUL", "label": {"api": {"SimpleFormatter": [[47, 61]]}}}, {"text": "The formatter arguments are described in SimpleFormatter::format method", "label": {"api": {"SimpleFormatter": [[41, 55]], "SimpleFormatter::format": [[41, 63]]}}}, {"text": "The syntax of the date formatting is described in java.util.Formatter", "label": {"api": {"java.util.Formatter": [[50, 68]]}}}, {"text": "You forgot to set the node onto which the transition should be applied", "label": {"api": {"set the node": [[14, 25]]}}}, {"text": "The documentation of ReentrantLock uses the following example", "label": {"api": {"documentation of ReentrantLock": [[4, 33]]}}}, {"text": "You can use the Comparator chain assuming Book class has getters", "label": {"api": {"Comparator": [[16, 25]]}}}, {"text": "Use Arrays.equals instead", "label": {"api": {"Arrays.equals": [[4, 16]]}}}, {"text": "My suggestion is based the official documentation", "label": {"api": {"the official documentation": [[23, 48]]}}}, {"text": "To control the interpretation of 2-digit year you may use one of the overloaded variants of DateTimeFormatterBuilder.appendValueReduced()", "label": {"api": {"DateTimeFormatterBuilder.appendValueReduced()": [[92, 136]]}}}, {"text": "You can use one of the queues from java.util.concurrent package, ArrayBlockingQueue for example", "label": {"api": {"ArrayBlockingQueue": [[65, 82]]}}}, {"text": "Take a look at ScheduledExecutorService#scheduleAtFixedRate()", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate()": [[15, 60]]}}}, {"text": "It sounds like you need Map::computeIfAbsent instead, which", "label": {"api": {"Map::computeIfAbsent": [[24, 43]]}}}, {"text": "You can pretty easily compose a Comparator for data objects, using Comparator.comparing(...) and Comparator.thenComparing(...) like so", "label": {"api": {"Comparator.comparing(...)": [[67, 91]], "Comparator.thenComparing(...)": [[97, 125]]}}}, {"text": "If you just want to get some limit number of map values, you could use stream api with limit", "label": {"api": {"limit": [[29, 33], [87, 91]]}}}, {"text": "If want to work with that large numbers you probably need BigDecimal", "label": {"api": {"BigDecimal": [[58, 67]]}}}, {"text": "You should also have a look at RoundingModes to select the rounding you need", "label": {"api": {"RoundingModes": [[31, 43]]}}}, {"text": "You can do it simply with ArrayDeque", "label": {"api": {"ArrayDeque": [[26, 35]]}}}, {"text": "You can use a DropShadow to draw a border around your space ship image", "label": {"api": {"DropShadow": [[14, 23]]}}}, {"text": "As others suggested, implementing the Comparable interface in Person if possible can also help create a cleaner implementation", "label": {"api": {"Comparable": [[38, 47]]}}}, {"text": "The largest Java primitive data type long is too small (64bit), therefore we have to use BigInteger", "label": {"api": {"BigInteger": [[89, 98]]}}}, {"text": "From the JDK javadocs..", "label": {"api": {"JDK javadocs": [[9, 20]]}}}, {"text": "ArrayList is a much easier array type to deal with", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Try using TextField.setText(java.lang.String)", "label": {"api": {"TextField.setText(java.lang.String)": [[10, 44]]}}}, {"text": "The rs = ps.executeQuery(String.valueOf(ps)); is incorrect in the context of PreparedStatement", "label": {"api": {"PreparedStatement": [[77, 93]]}}}, {"text": "Since you already created PreparedStatement use", "label": {"api": {"PreparedStatement": [[26, 42]]}}}, {"text": "Close PreparedStatement after it was processed if you don't plan to reuse it, use try-with-resources syntax", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "You haven't imported List and ArrayList", "label": {"api": {"List": [[21, 24], [35, 38]], "ArrayList": [[30, 38]]}}}, {"text": "The simplest you can do - wrap it in synchronized counterpart and synchronize access to it", "label": {"api": {"synchronized counterpart": [[37, 60]]}}}, {"text": "However, typically, the most useful data-structure for producer-consumer problems is BlockingQueue", "label": {"api": {"BlockingQueue": [[85, 97]]}}}, {"text": "ArrayBlockingQueue or LinkedBlockingQueue", "label": {"api": {"BlockingQueue": [[5, 17], [28, 40]], "ArrayBlockingQueue": [[0, 17]], "LinkedBlockingQueue": [[22, 40]]}}}, {"text": "As far as I'm aware of, the only Map implementation in the Java Collections API that orders its entries by insertion order is the LinkedHashMap, which maintians a linked list", "label": {"api": {"LinkedHashMap": [[130, 142]]}}}, {"text": "And if that is the case, is LinkedHashMap my only option for Map implementation within the Java standard library if I want insertion order", "label": {"api": {"LinkedHashMap": [[28, 40]]}}}, {"text": "All accesses to UI component should be made in the \"Event Dispatch Thread\" (EDT) so you might want to check SwingUtilities.invokeLater() et.al", "label": {"api": {"SwingUtilities.invokeLater()": [[108, 135]]}}}, {"text": "Use the removeAll() method provided with Lists to get difference between the arrays", "label": {"api": {"removeAll()": [[8, 18]]}}}, {"text": "call it contains) that will determine whether a value from array1 is present in array2 using an IntStream", "label": {"api": {"IntStream": [[96, 104]]}}}, {"text": "Use BigDecimal.compareTo(BigDecimal) which already does all the logic for you", "label": {"api": {"BigDecimal.compareTo(BigDecimal)": [[4, 35]]}}}, {"text": "The default Java Util Logging configuration is stored in", "label": {"api": {"Java Util Logging": [[12, 28]]}}}, {"text": "If you change Java code to use getBytes(\"ASCII\") or getBytes(StandardCharsets.US_ASCII), then you get same result as C#", "label": {"api": {"getBytes(\"ASCII\")": [[31, 47]], "getBytes(StandardCharsets.US_ASCII)": [[52, 86]]}}}, {"text": "Use the findFirst() method to get the first value of the list if present", "label": {"api": {"findFirst()": [[8, 18]]}}}, {"text": "Map isAvailable and return false if the list is empty", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "A WAR file expects the Servlet API, not the Jetty Handler API", "label": {"api": {"Servlet API": [[23, 33]]}}}, {"text": "Migrate your code to using the Servlet API, and add a reference to it in your Web Descriptor (WEB-INF/web.xml)", "label": {"api": {"Servlet API": [[31, 41]]}}}, {"text": "You can optionally, you can use the Servlet API Annotations instead of the WEB-INF/web.xml, but know that you'll want your ${jetty.base} instance directory configured to have the annotations module enabled", "label": {"api": {"Servlet API": [[36, 46]], "Servlet API Annotations": [[36, 58]]}}}, {"text": "I'll recommend LocaDate, as you need only date part", "label": {"api": {"LocaDate": [[15, 22]]}}}, {"text": "You can use the static Modifier.toString() method to get a textual representation", "label": {"api": {"Modifier.toString()": [[23, 41]]}}}, {"text": "Looking up these values in the Modifier Javadoc, it will tell you that 1 stands for public and 64 stands for volatile", "label": {"api": {"Modifier Javadoc": [[31, 46]]}}}, {"text": "I would consider using an executor service, unless I have misunderstood your requirements", "label": {"api": {"executor service": [[26, 41]]}}}, {"text": "The ServletConfig does not contain only init params but also a reference to the ServletContext and the servlet name, so it makes sense even if no init param has been specified", "label": {"api": {"ServletConfig": [[4, 16]]}}}, {"text": "One way would be by using the newest JDK12's Collector.teeing", "label": {"api": {"Collector.teeing": [[45, 60]]}}}, {"text": "So, the above code collects to a map by first name and also to a map by last name and then merges both maps into a final map by iterating the byLast map and merging each one of its entries into the byFirst map by means of the Map.computeIfAbsent method", "label": {"api": {"Map.computeIfAbsent": [[226, 244]]}}}, {"text": "You could use sum from IntStream", "label": {"api": {"sum": [[14, 16]]}}}, {"text": "Maybe you're thinking of List.get(int)", "label": {"api": {"List.get(int)": [[25, 37]]}}}, {"text": "Collections#reverse does not return anything", "label": {"api": {"Collections#reverse": [[0, 18]]}}}, {"text": "Also, be aware of the following warning in the javadoc of Map", "label": {"api": {"Map": [[58, 60]]}}}, {"text": "You can use regexMatcher like this (\\Q/\\E helps to avoid treating the content in Reference column as a regular expression (except when it contains \\E))", "label": {"api": {"\\Q/\\E": [[36, 40]]}}}, {"text": "I would suggest using java.time classes instead", "label": {"api": {"java.time": [[22, 30]]}}}, {"text": "The javadoc of inflate", "label": {"api": {"inflate": [[15, 21]]}}}, {"text": "If you get input from System.in, then for testing you can change it with System.setIn() method", "label": {"api": {"System.setIn()": [[73, 86]]}}}, {"text": "An elegant solution would be using StringJoiner(\" \") and then add the numbers on each iteration", "label": {"api": {"StringJoiner(\" \")": [[35, 51]]}}}, {"text": "A resource is read with the getResourceAsStream method, which is specifically designed to retrieve static data bundled with an application", "label": {"api": {"getResourceAsStream": [[28, 46]]}}}, {"text": "The official Java documentation is always a great place to start", "label": {"api": {"official Java documentation": [[4, 30]]}}}, {"text": "Another possibility is to use  PrintWriter", "label": {"api": {"PrintWriter": [[31, 41]]}}}, {"text": "You could use Map.computeIfPresent() but the improvement is questionable", "label": {"api": {"Map.computeIfPresent()": [[14, 35]]}}}, {"text": "If you don't have some extra hard requirements, you could just use a resizable ArrayList<Integer>, and add() stuff in there", "label": {"api": {"ArrayList<Integer>": [[79, 96]]}}}, {"text": "java.util.Date does not capture time zone data", "label": {"api": {"java.util.Date": [[0, 13]]}}}, {"text": "You could try using one of the modules in jackson-modules-java8 and deserialize into an instance of ZonedDateTime instead, which is time-zone aware", "label": {"api": {"ZonedDateTime": [[100, 112]]}}}, {"text": "Your peek operation has the side-effect of modifying the position property of each Employee allowed through by filter", "label": {"api": {"side-effect": [[28, 38]]}}}, {"text": "The reason you didn't see any changes until you added a call to collect is because collect is a terminal operation, whereas filter and peek are not", "label": {"api": {"terminal operation": [[96, 113]]}}}, {"text": "A Stream will not be executed until a terminal operation is invoked", "label": {"api": {"terminal operation": [[38, 55]]}}}, {"text": "You can catch BatchUpdateException which has method int[] getUpdateCounts() that returns an array of number of rows affected by each batched statement in the order they were added to the batch", "label": {"api": {"BatchUpdateException": [[14, 33]]}}}, {"text": "Cookie.setHttpOnly() is available since Servlet 3.0", "label": {"api": {"Cookie.setHttpOnly()": [[0, 19]]}}}, {"text": "A Security Manager in the JVM would be expected to be the primary use case for a SecurityException, however there's nothing to prevent applications choosing to throw this exception should they feel it suits their need", "label": {"api": {"SecurityException": [[81, 97]]}}}, {"text": "You can use LinkedBlockingDeque", "label": {"api": {"LinkedBlockingDeque": [[12, 30]]}}}, {"text": "You can use ReadWriteLock to do you work.when the message type is 'B',try acquire write lockÔºåother type message acquire read lock.one simple code like this", "label": {"api": {"ReadWriteLock": [[12, 24]]}}}, {"text": "You can use the parallelStream() method (since java 8)", "label": {"api": {"parallelStream()": [[16, 31]]}}}, {"text": "More informations about streams", "label": {"api": {"streams": [[24, 30]]}}}, {"text": "But if we are doing the same without using Apache POI's ZipPackage but instead using FileSystem for getting the XML out of the Office Open XML ZIP package using following code", "label": {"api": {"FileSystem": [[85, 94]]}}}, {"text": "This creates an IntStream and maps the calculated distance for the neighbor cities", "label": {"api": {"IntStream": [[16, 24]]}}}, {"text": "Because each Business can have multiple parents and it seems to be preferred to be able to navigate directly to the childrens as well, solution is to use bidirectional ManyToMany", "label": {"api": {"ManyToMany": [[168, 177]]}}}, {"text": "When necessary, name of the join table and columns can be controlled via JoinTable", "label": {"api": {"JoinTable": [[73, 81]]}}}, {"text": "Use the addAll method of Collection and List", "label": {"api": {"addAll": [[8, 13]]}}}, {"text": "You can use the Stream.collect() method to achieve this", "label": {"api": {"Stream.collect()": [[16, 31]]}}}, {"text": "If you need to be more flexible you should use the Stream.flatMap() solution", "label": {"api": {"Stream.flatMap()": [[51, 66]]}}}, {"text": "Instead, you create a URLClassLoader and use it to obtain the relevant class", "label": {"api": {"URLClassLoader": [[22, 35]]}}}, {"text": "URLClassLoader uses JarURLConnection internally, but you don‚Äôt need to use it directly", "label": {"api": {"URLClassLoader": [[0, 13]]}}}, {"text": "Since the java.util.Stack class is actually a Vector, you can easily do that without modifying the stack", "label": {"api": {"java.util.Stack": [[10, 24]], "Vector": [[46, 51]]}}}, {"text": "How about using java.util.Properties", "label": {"api": {"java.util.Properties": [[16, 35]]}}}, {"text": "You should read the javadoc of WeakHashMap", "label": {"api": {"WeakHashMap": [[31, 41]]}}}, {"text": "The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class", "label": {"api": {"WeakHashMap": [[20, 30]]}}}, {"text": "Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries", "label": {"api": {"WeakHashMap": [[62, 72]]}}}, {"text": "In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements", "label": {"api": {"WeakHashMap": [[44, 54]]}}}, {"text": "You can use Optional.map() and Optional.orElse() or Optional.orElseThrow()", "label": {"api": {"Optional.map()": [[12, 25]], "Optional.orElse()": [[31, 47]], "Optional.orElseThrow()": [[52, 73]]}}}, {"text": "For more, see", "label": {"api": {"see": [[10, 12]]}}}, {"text": "it reuses threads and let you choose what to do when you reach the limit by definining a RejectedExecutionHandler", "label": {"api": {"RejectedExecutionHandler": [[89, 112]]}}}, {"text": "Using NIO2 you can load the file (if you have the read permissions) and convert it to InputStream like", "label": {"api": {"InputStream": [[86, 96]]}}}, {"text": "You can use a nested Optional", "label": {"api": {"Optional": [[21, 28]]}}}, {"text": "If you are using Java 9 or higher you can use Optional.or()", "label": {"api": {"Optional": [[46, 53]], "Optional.or()": [[46, 58]]}}}, {"text": "I also added setExtendedState(JFrame.MAXIMIZED_BOTH) to fill the screen, and setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE) as you didn't want the screen to be closable", "label": {"api": {"setExtendedState(JFrame.MAXIMIZED_BOTH)": [[13, 51]], "setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE)": [[77, 128]]}}}, {"text": "You can use a String#split on [A-Z] which keeps the delimiter as separated item", "label": {"api": {"String#split": [[14, 25]]}}}, {"text": "The reason why it is stuck in an infinite loop is because nextInt does not read the end of line to get a new input - so it is an infinite loop with the previous input", "label": {"api": {"nextInt": [[58, 64]]}}}, {"text": "Study the Java AWT class hierarchy", "label": {"api": {"Java AWT class hierarchy": [[10, 33]]}}}, {"text": "If you know the GIF animation length you can use SwingUtils.invokeLater() to run an async thread with that will fire the event after a fixed delay", "label": {"api": {"SwingUtils.invokeLater()": [[49, 72]]}}}, {"text": "In this Swing example, a JSpinner and a JSlider each listen for change events, and each updates the other's model to match", "label": {"api": {"Spinner": [[26, 32]], "Slider": [[41, 46]]}}}, {"text": "A similar JavaFX program, shown below, connects a Spinner and a Slider, and these listeners keep the controls coordinated", "label": {"api": {"Spinner": [[50, 56]], "Slider": [[64, 69]]}}}, {"text": "Unfortunately, when I added a StringConverter to the spinner's SpinnerValueFactory, the initial value was unformatted until either control was changed‚Äîeven when setting the initial value explicitly again, after adding the converter", "label": {"api": {"Spinner": [[63, 69]]}}}, {"text": "Internally, the spinner's concrete SpinnerValueFactory is a DoubleSpinnerValueFactory that adds a ChangeListener to its value property; when the initial value is set again, the value hasn't really changed", "label": {"api": {"SpinnerValueFactory": [[35, 53], [66, 84]]}}}, {"text": "Construct a SpinnerValueFactory with the desired initial value and use it to construct the spinner", "label": {"api": {"SpinnerValueFactory": [[12, 30]]}}}, {"text": "The estimateSize method", "label": {"api": {"estimateSize": [[4, 15]]}}}, {"text": "super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute", "label": {"api": {"Long.MAX_VALUE": [[32, 45]]}}}, {"text": "If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal", "label": {"api": {"SIZED": [[23, 27], [106, 110]], "SUBSIZED": [[103, 110]], "Spliterator": [[8, 18], [88, 98]]}}}, {"text": "Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit()", "label": {"api": {"trySplit()": [[109, 118]]}}}, {"text": "For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth", "label": {"api": {"Spliterator": [[175, 185]]}}}, {"text": "And the getExactSizeIfKnown method is a", "label": {"api": {"getExactSizeIfKnown": [[8, 26]]}}}, {"text": "Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1", "label": {"api": {"estimateSize": [[32, 43]], "SIZED": [[70, 74]], "estimateSize()": [[32, 45]], "Spliterator": [[55, 65]]}}}, {"text": "The default implementation returns the result of estimateSize() if the Spliterator reports a characteristic of SIZED, and -1 otherwise", "label": {"api": {"estimateSize": [[49, 60]], "SIZED": [[111, 115]], "estimateSize()": [[49, 62]], "characteristic": [[93, 106]], "Spliterator": [[71, 81]]}}}, {"text": "Both of those methods reference SIZED, which is a", "label": {"api": {"SIZED": [[32, 36]]}}}, {"text": "Characteristic value signifying that the value returned from estimateSize() prior to traversal or splitting represents a finite size that, in the absence of structural source modification, represents an exact count of the number of elements that would be encountered by a complete traversal", "label": {"api": {"estimateSize": [[61, 72]], "estimateSize()": [[61, 74]]}}}, {"text": "Most Spliterators for Collections, that cover all elements of a Collection report this characteristic", "label": {"api": {"characteristic": [[87, 100]], "Spliterator": [[5, 15]]}}}, {"text": "Sub-spliterators, such as those for HashSet, that cover a sub-set of elements and approximate their reported size do not", "label": {"api": {"HashSet": [[36, 42]]}}}, {"text": "Based on all of this, the two methods will only ever return different values if the Spliterator does not have the SIZED characteristic", "label": {"api": {"SIZED": [[114, 118]], "characteristic": [[120, 133]], "Spliterator": [[84, 94]]}}}, {"text": "In your example, the source of the Spliterator is an ArrayList", "label": {"api": {"Spliterator": [[35, 45]]}}}, {"text": "If we take a look at the documentation of ArrayList.spliterator()", "label": {"api": {"ArrayList.spliterator()": [[42, 64]]}}}, {"text": "Creates a late-binding and fail-fast Spliterator over the elements in this list", "label": {"api": {"late-binding": [[10, 21]], "Spliterator": [[37, 47]]}}}, {"text": "The Spliterator reports Spliterator.SIZED, Spliterator.SUBSIZED, and Spliterator.ORDERED", "label": {"api": {"SIZED": [[36, 40], [58, 62]], "SUBSIZED": [[55, 62]], "Spliterator": [[4, 14], [24, 34], [43, 53], [69, 79]], "Spliterator.SIZED": [[24, 40]], "Spliterator.SUBSIZED": [[43, 62]], "Spliterator.ORDERED": [[69, 87]]}}}, {"text": "Overriding implementations should document the reporting of additional characteristic values", "label": {"api": {"characteristic": [[71, 84]]}}}, {"text": "Due to the SUBSIZED characteristic, a Spliterator created from an ArrayList‚Äîincluding those resulting from trySplit‚Äîwill never have estimateSize and getExactSizeIfKnown return different values", "label": {"api": {"estimateSize": [[132, 143]], "SIZED": [[14, 18]], "SUBSIZED": [[11, 18]], "getExactSizeIfKnown": [[149, 167]], "characteristic": [[20, 33]], "Spliterator": [[38, 48]]}}}, {"text": "Really, you don't need the decal method at all, you can simply use the String.replace() method to replace the character you need with an empty character", "label": {"api": {"String.replace()": [[71, 86]]}}}, {"text": "Go one abstraction level higher and use ExecutorService (e.g", "label": {"api": {"ExecutorService": [[40, 54]]}}}, {"text": "As mentioned in the comments read and accept operations typically block on a Socket", "label": {"api": {"Socket": [[77, 82]]}}}, {"text": "You could create an own Thread which is waiting for Message from your Socket and then modify the GUI", "label": {"api": {"Thread": [[24, 29]], "Socket": [[70, 75]]}}}, {"text": "Keep in mind that Swing is not Thread safe", "label": {"api": {"Thread": [[31, 36]]}}}, {"text": "If I need to create an own Thread, I use the Runnable interface", "label": {"api": {"Thread": [[27, 32]]}}}, {"text": "The Thread can then be started easily", "label": {"api": {"Thread": [[4, 9]]}}}, {"text": "For more information have a look at the Thread and Socket documentation", "label": {"api": {"Thread": [[40, 45]], "Socket": [[51, 56]]}}}, {"text": "You could also use IntStream, map that to a Stream using mapToObj, and then collect that stream using Collectors.joining(\",\")", "label": {"api": {"IntStream": [[19, 27]], "Collectors.joining(\",\")": [[102, 124]]}}}, {"text": "But the easiest way is probably to use Arrays.toString(int[])", "label": {"api": {"Arrays.toString(int[])": [[39, 60]]}}}, {"text": "Build that string using a StringJoiner", "label": {"api": {"StringJoiner": [[26, 37]]}}}, {"text": "if you can use at least Java 8, then I would suggest to use the  java.nio.file libraries to read the file as a stream of lines", "label": {"api": {"java.nio.file": [[65, 77]], "read the file as a stream of lines": [[92, 125]]}}}, {"text": "Then depending on what you need to do, you could use either forEach that will loop on each line of the stream", "label": {"api": {"forEach": [[60, 66]]}}}, {"text": "Or Java Collectors to execute the calculation that you need to", "label": {"api": {"Java Collectors": [[3, 17]]}}}, {"text": "You just implement apply method from Function which is functional interface", "label": {"api": {"functional interface": [[55, 74]]}}}, {"text": "Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references", "label": {"api": {"functional interface": [[23, 42]]}}}, {"text": "Very basically and without explaining the advantages of using Functions  you can imagine your function to be an analogy of", "label": {"api": {"Function": [[62, 69]]}}}, {"text": "However, unless you are forced to use array as your data structure, consider using ArrayList", "label": {"api": {"ArrayList": [[83, 91]]}}}, {"text": "The whole purpose of ArrayList is to be re-sizable array", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "Also, if you know expected size and want to minimize resizings, you have an option to create ArrayList with initial capacity", "label": {"api": {"ArrayList": [[93, 101]]}}}, {"text": "Possibly through the terms static wait and static pause you meant Thread.sleep() which is still useful in many ways", "label": {"api": {"Thread.sleep()": [[66, 79]]}}}, {"text": "If you supply this to the Integer#parseInt() method (as you've done in the above code) or anything other than an integer value then a NumberFormatException is generated", "label": {"api": {"NumberFormatException": [[134, 154]]}}}, {"text": "If you want to initialize a List with elements you can use Arrays.asList()", "label": {"api": {"Arrays.asList()": [[59, 73]]}}}, {"text": "If you have only one element use Collections.singletonList() (this returns an immutable list, so you can not add any elements afterwards)", "label": {"api": {"Collections.singletonList()": [[33, 59]]}}}, {"text": "Utilize the MouseInfo Class within the TimerTask's run() method to track the Mouse Pointer location", "label": {"api": {"MouseInfo Class": [[12, 26]]}}}, {"text": "Here is an example using CountDownLatch", "label": {"api": {"CountDownLatch": [[25, 38]]}}}, {"text": "You can pass true for an autoFlush parameter when constructing the PrintStream to fix the problem, e.g", "label": {"api": {"autoFlush parameter": [[25, 43]]}}}, {"text": "According to https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html, NumberFormat.getInstance() will get you a NumberFormat instance in the current locale", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html": [[13, 81]]}}}, {"text": "In java, you can take a look at ZoneOffset class, but I'm not sure if you can incorporate all the identifiers form Trifacta", "label": {"api": {"ZoneOffset class": [[32, 47]]}}}, {"text": "Use Socket.connect(SocketAddress endpoint, int timeout) method to specify timeout", "label": {"api": {"Socket.connect(SocketAddress endpoint, int timeout)": [[4, 54]]}}}, {"text": "By definition, by assigning each object a Universally unique identifier (UUID) (or a Globally unique identifier, (GUID)) as it's identity property, the UUID is comparable, and consistent with equals", "label": {"api": {"UUID": [[73, 76], [152, 155]]}}}, {"text": "Java already has a UUID class, and once generated, you can just use the string representation for persistence", "label": {"api": {"UUID": [[19, 22]]}}}, {"text": "You could also just use an incrementing ID if you have a method of insuring everything gets a unique ID, but using a standard UUID implementation will protect you from issues from set merges and parallel systems generating data at the same time", "label": {"api": {"UUID": [[126, 129]]}}}, {"text": "Use max with comparator", "label": {"api": {"max": [[4, 6]]}}}, {"text": "You should look for concrete child classes of java.net.SocketImpl like DualStackPlainSocketImpl", "label": {"api": {"java.net.SocketImpl": [[46, 64]]}}}, {"text": "You are using a LocalDateTime, which does not contain a timezone - see API", "label": {"api": {"API": [[71, 73]]}}}, {"text": "You want to use a ZonedDateTime instead", "label": {"api": {"ZonedDateTime": [[18, 30]]}}}, {"text": "There is also an String.indexOf(int c) method that does exactly what you need and would let you write the method like this", "label": {"api": {"String.indexOf(int c)": [[17, 37]]}}}, {"text": "Beside all of that you can just use the native String.indexOf() method, which does exactly what you want", "label": {"api": {"String.indexOf()": [[47, 62]]}}}, {"text": "Alternatively you can use the native String.contains() method to achieve that", "label": {"api": {"String.contains()": [[37, 53]]}}}, {"text": "You could use BufferedReader which gives you readLine() method similar to Scanner.nextLine()", "label": {"api": {"BufferedReader": [[14, 27]]}}}, {"text": "Instead of using a Date object, I suggest using a LocalDate which is easier to use", "label": {"api": {"a LocalDate": [[48, 58]]}}}, {"text": "As suggested here, don't create a new dataset and chart with each change; instead, \"update the chart's data model, PieDataset, and the listening view will follow.\" An implementation of the Observer interface can update the chart's model in its update() method, just as well as the action handler of a JButton can", "label": {"api": {"Observer": [[189, 196]]}}}, {"text": "ImageIO.read(File) method is using file IO which is not suitable for reading resources from the classpath", "label": {"api": {"ImageIO.read(File)": [[0, 17]]}}}, {"text": "Assuming that Schiebepuzzle.jar is on the classpath you can use ImageIO.read(InputStream) method", "label": {"api": {"ImageIO.read(InputStream)": [[64, 88]]}}}, {"text": "There is an indent() method from the latest java12 release", "label": {"api": {"indent()": [[12, 19]]}}}, {"text": "The ServiceLoader class was introduced with Java 6, but the ‚ÄúSPI jar‚Äù concept is actually as old as Java 1.3", "label": {"api": {"ServiceLoader": [[4, 16]]}}}, {"text": "An additional advantage of using ServiceLoader is that your code will be capable of working with modules, a more complete form of code encapsulation introduced with Java 9 which offers increased security", "label": {"api": {"ServiceLoader": [[33, 45]]}}}, {"text": "If you want to make the wrapping consistent, use the Base64.getMimeEncoder(int lineLength, byte[] lineSeparator) overloaded method that lets you specify the line length and pass 64 as the lineLength parameter", "label": {"api": {"Base64.getMimeEncoder(int lineLength, byte[] lineSeparator)": [[53, 111]]}}}, {"text": "As an aside, consider returning Optional or null from your method - having to compare your String to the special hardcoded value to detect the null case is going to get tiresome..", "label": {"api": {"Optional": [[32, 39]]}}}, {"text": "To quote the String#indexOf(int ch) java doc", "label": {"api": {"String#indexOf(int ch) java doc": [[13, 43]]}}}, {"text": "One reason for a apparently slow startup is the default implementation of SecureRandom which scans network interfaces to provide an additional source of system entropy", "label": {"api": {"SecureRandom": [[74, 85]]}}}, {"text": "One can avoid this by registering an own java.security.Provider or by using the SecureRandomSpi", "label": {"api": {"SecureRandom": [[80, 91]], "java.security.Provider": [[41, 62]], "SecureRandomSpi": [[80, 94]]}}}, {"text": "At runtime, read the embedded font files with Class.getResourceAsStream", "label": {"api": {"Class.getResourceAsStream": [[46, 70]]}}}, {"text": "Pass the returned InputStream to Font.createFont", "label": {"api": {"Font.createFont": [[33, 47]]}}}, {"text": "Use deriveFont to obtain the size you want", "label": {"api": {"deriveFont": [[4, 13]]}}}, {"text": "When you're using @Transactional it's already taken care of", "label": {"api": {"Transaction": [[19, 29]]}}}, {"text": "You would have to rollback transaction, when using explicitly Transaction in finally clause of try", "label": {"api": {"Transaction": [[62, 72]]}}}, {"text": "As suggested by jonathan Heindl in another answer, you can simplify the code by using removeIf(...)", "label": {"api": {"removeIf(...)": [[86, 98]]}}}, {"text": "You can also use CountDownLatch for the same purpose, though read/write lock is the easiest one", "label": {"api": {"CountDownLatch": [[17, 30]]}}}, {"text": "You can add a check to see if the list is empty", "label": {"api": {"if the list is empty": [[27, 46]]}}}, {"text": "See the Java documentation for the Format class for conversion options, and pick the one that is appropriate for how you want the value (nCurrentSpeed) to be formatted", "label": {"api": {"Java documentation for the Format class": [[8, 46]]}}}, {"text": "If you want to submit a bunch of tasks to a thread pool and wait until they are all complete, then you can use the invokeAll method and loop over the resulting Futures, calling get on each", "label": {"api": {"invokeAll": [[115, 123]]}}}, {"text": "Submit them all at once with invokeAll and let the executor service do what it was built to do", "label": {"api": {"invokeAll": [[29, 37]]}}}, {"text": "You should either synchronize these operations or use a thread-safe map implementation, such as ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[96, 112]]}}}, {"text": "In the context of Collections class (and some other class of the Java Collections Framework) it means that a Collection is a \"wrapper\" of another Collection", "label": {"api": {"Collections": [[18, 28], [70, 80]]}}}, {"text": "An example are the methods of Collections whose name starts with synchronized or unmodifiable", "label": {"api": {"Collections": [[30, 40]]}}}, {"text": "the method synchronizedList(List) adds synchronization to any given List, the method unmodifiableList(List) makes any given List unmodifiable and so on", "label": {"api": {"synchronizedList(List)": [[11, 32]], "unmodifiableList(List)": [[85, 106]]}}}, {"text": "Otherwise, I don't see a better solution than wrapping the IntIterator as a PrimitiveIterator.OfInt and building a stream out of that", "label": {"api": {"PrimitiveIterator.OfInt": [[76, 98]]}}}, {"text": "If you're just starting with Sockets you probably don't know this but SocketChannel is a lot more efficient than the Socket class which is extremely old", "label": {"api": {"SocketChannel": [[70, 82]]}}}, {"text": "For example, I could use Java Executors", "label": {"api": {"Executors": [[30, 38]]}}}, {"text": "the subList method", "label": {"api": {"subList": [[4, 10]]}}}, {"text": "One way to achieve such data structure in Java 8+, is by using the Map.computeIfAbsent and Map.computeIfPresent methods for insertions and removals, respectively", "label": {"api": {"Map.computeIfAbsent": [[67, 85]], "Map.computeIfPresent": [[91, 110]]}}}, {"text": "I am not sure I got the question right, but what you need seems to be a Semaphore for each API key", "label": {"api": {"Semaphore": [[72, 80]]}}}, {"text": "You can check if the key1Semaphore has permits and acquire one if available by calling key1Semaphore.tryAcquire()", "label": {"api": {"Semaphore": [[25, 33], [91, 99]]}}}, {"text": "More about SimpleDateFormat can be found on https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[44, 116]]}}}, {"text": "You can just use List.replaceAll() and List.removeIf() to solve this with a simple if statement", "label": {"api": {"List.replaceAll()": [[17, 33]], "List.removeIf()": [[39, 53]]}}}, {"text": "If you override the equals method for your objects you can use contains on your ArrayList instances", "label": {"api": {"equals": [[20, 25]], "contains": [[63, 70]]}}}, {"text": "Use @MappedSupperclass annotation on Auditable class", "label": {"api": {"@MappedSupperclass": [[4, 21]]}}}, {"text": "A LinkedHashMap will preserve the order in which the keys are added into the map", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "If you want to use regexes and Matchers, you can make use of Matcher's replaceAll() method", "label": {"api": {"replaceAll()": [[71, 82]]}}}, {"text": "Basically, replaceAll() replaces the matched text in its Matcher and replaces it with whatever is in the string passed to replaceAll(str)", "label": {"api": {"replaceAll()": [[11, 22]]}}}, {"text": "First of all I would recommend using Matcher.replaceAll() instead of building the string yourself", "label": {"api": {"Matcher.replaceAll()": [[37, 56]]}}}, {"text": "If you already use Jackson try to implement custom JsonDeserializer instead of custom XmlAdapter", "label": {"api": {"XmlAdapter": [[86, 95]]}}}, {"text": "The construction of a single B instance is not a task suitable for ‚ÄúClasses to support functional-style operations on streams of elements, such as map-reduce transformations on collections.‚Äù", "label": {"api": {"Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections.": [[68, 188]]}}}, {"text": "Because varargs in Java is syntactic sugar around passing in an array, yu can create an array with the rest of the params (perhaps using Arrays.copyOfRange) and pass that in as the second argument", "label": {"api": {"Arrays.copyOfRange": [[137, 154]]}}}, {"text": "Mathematically spoken your relation \"compareTo\" does not define an order and thus violates the API contract", "label": {"api": {"API": [[95, 97]]}}}, {"text": "If you already have the domain parameters (p, g) and just the integer value of the public key then a DHPublicKeySpec rather than an X509EncodedKeySpec is the way to go", "label": {"api": {"DHPublicKeySpec": [[101, 115]]}}}, {"text": "You can iterate your getters and setters as paired Suppliers and Consumers", "label": {"api": {"Supplier": [[51, 58]], "Consumer": [[65, 72]]}}}, {"text": "If I understand you correctly, you can use Timeline to change the circle's color and stop the Timeline when the button is pressed", "label": {"api": {"Timeline": [[43, 50], [94, 101]]}}}, {"text": "I believe the issue is you are trying to use a BorderLayout incorrectly", "label": {"api": {"BorderLayout": [[47, 58]]}}}, {"text": "Is adding your \"NodeContainers\" to the same region of the BorderLayout each time", "label": {"api": {"BorderLayout": [[58, 69]]}}}, {"text": "Since you're new to Java I assume you haven't come across the Stream API Another interesting way of doing this", "label": {"api": {"Stream API": [[62, 71]]}}}, {"text": "Assuming you only want to return the first occurrence, you could modify your for loop to iterate over the whole words in the sentence rather than individual chars by using str.split(), and making use of str.contains():", "label": {"api": {"str.split()": [[172, 182]], "str.contains():": [[203, 217]]}}}, {"text": "If you do need to deal with more than one match then using an ArrayList like what you are currently doing would be appropriate", "label": {"api": {"ArrayList": [[62, 70]]}}}, {"text": "Regarding your followup question about finding the words in the sentence that have all the characters in the subString you can maintain a Map of Characters and their counts to achieve your desired your result", "label": {"api": {"Map": [[138, 140]]}}}, {"text": "Use the Deprecated annotation", "label": {"api": {"Deprecated": [[8, 17]]}}}, {"text": "Use flatMap for that", "label": {"api": {"flatMap": [[4, 10]]}}}, {"text": "Therefore you can use a TreeMap collecting all the results and getting the list of the last entry", "label": {"api": {"TreeMap": [[24, 30]]}}}, {"text": "You can also use a TreeMap the get the max value, should have a better performance", "label": {"api": {"TreeMap": [[19, 25]]}}}, {"text": "Remove just those two buttons, and re-add them using the add method which takes an index", "label": {"api": {"add method which takes an index": [[57, 87]]}}}, {"text": "You can use Random::nextInt for generating random integer", "label": {"api": {"Random::nextInt": [[12, 26]]}}}, {"text": "A CountDownLatch is usually useful if you want to wait for one or more task to complete before starting another", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "From the MouseAdapter docs", "label": {"api": {"MouseAdapter docs": [[9, 25]]}}}, {"text": "You can't exactly do that in Java, what you are looking for is reducing a stream of values", "label": {"api": {"reducing": [[63, 70]]}}}, {"text": "You can use Collections::reverseOrder to sort in desc order", "label": {"api": {"Collections::reverseOrder": [[12, 36]]}}}, {"text": "In order to avoid this, use a Scanner, and get the first character of the returned Scanner string using charAt(0)", "label": {"api": {"Scanner": [[30, 36], [83, 89]]}}}, {"text": "You can try Flux#generate and Queue#peek", "label": {"api": {"Queue#peek": [[30, 39]]}}}, {"text": "You can use InputStreamReader to read the multipart InputStream", "label": {"api": {"InputStreamReader": [[12, 28]]}}}, {"text": "str.indexOf('z') == 1 returns false because indexOf \"returns the index within this string of the first occurrence of the specified character\"", "label": {"api": {"indexOf": [[4, 10], [44, 50]]}}}, {"text": "In your case, str.indexOf('z') is zero because zero is the first occurrence", "label": {"api": {"indexOf": [[18, 24]]}}}, {"text": "There is a version of this method which takes an additional argument that defines which index to start from, so you could use the following to check whether Z is the second character", "label": {"api": {"a version of this method which takes an additional argument": [[9, 67]]}}}, {"text": "That said, a better approach to this problem is probably to use charAt", "label": {"api": {"charAt": [[64, 69]]}}}, {"text": "An straight forward and easy way of formatting a string in java is using the static method String.format()", "label": {"api": {"String.format()": [[91, 105]]}}}, {"text": "You can supply a format string and the coresponding arguments", "label": {"api": {"format string": [[17, 29]]}}}, {"text": "See ExecutorService like Executors.newSingleThreadExecutor() and Future.cancel() for more flexibility", "label": {"api": {"ExecutorService": [[4, 18]], "Executors.newSingleThreadExecutor()": [[25, 59]], "Future.cancel()": [[65, 79]]}}}, {"text": "You can use Stream.noneMatch() to do this", "label": {"api": {"Stream.noneMatch()": [[12, 29]]}}}, {"text": "Additionally I would recommend to take a look at Stream.allMatch(), which returns true, if all elements of the list match the given predicate", "label": {"api": {"Stream.allMatch()": [[49, 65]]}}}, {"text": "To complete this, you also can take a look at Stream.anyMatch(), which returns true, if one of the elements matches the given predicate", "label": {"api": {"Stream.anyMatch()": [[46, 62]]}}}, {"text": "Create an explicit CharsetDecoder, and set CodingErrorAction.IGNORE on it", "label": {"api": {"CharsetDecoder": [[19, 32]], "CodingErrorAction.IGNORE": [[43, 66]]}}}, {"text": "Since a CharsetDecoder works with ByteBuffers, applying the length limit is as easy as calling the ByteBuffer‚Äôs limit method", "label": {"api": {"CharsetDecoder": [[8, 21]], "limit": [[67, 71], [112, 116]]}}}, {"text": "Now, according to SimpleDateFormat docs if parsing fails, the function returns null", "label": {"api": {"SimpleDateFormat docs": [[18, 38]]}}}, {"text": "Hash codes in Java have to meet the following requirement", "label": {"api": {"the following requirement": [[32, 56]]}}}, {"text": "The default JPA mapping of enum field is int column (see EnumType.ORDINAL)", "label": {"api": {"EnumType.ORDINAL": [[57, 72]]}}}, {"text": "If your column is string you need to use EnumType.STRING", "label": {"api": {"EnumType.STRING": [[41, 55]]}}}, {"text": "You can throw in a call to distinct() to only get unique values", "label": {"api": {"distinct()": [[27, 36]]}}}, {"text": "Using Future.get(timeout) from an ExecutorService should handle this quite cleanly", "label": {"api": {"Future.get(timeout)": [[6, 24]], "ExecutorService": [[34, 48]]}}}, {"text": "The choice of ExecutorService could be tuned to fit, or equally be a shared thread pool elsewhere in the application", "label": {"api": {"ExecutorService": [[14, 28]]}}}, {"text": "It is also good practice to override hashCode so that is is consistent with equals, according to the hashCode contract", "label": {"api": {"hashCode contract": [[101, 117]]}}}, {"text": "Here is a solution using LocalTime that also correctly handles current and closing time being after midnight", "label": {"api": {"LocalTime": [[25, 33]]}}}, {"text": "To complete that you can use Arrays.stream() to find the longest string with even length", "label": {"api": {"Arrays.stream()": [[29, 43]]}}}, {"text": "The second one does not work, because you are using an IntStream which contains primitive int types", "label": {"api": {"IntStream": [[55, 63]]}}}, {"text": "You have to call boxed() before map()", "label": {"api": {"boxed()": [[17, 23]]}}}, {"text": "But a better solution would be to use mapToObj() instead of map()", "label": {"api": {"mapToObj()": [[38, 47]]}}}, {"text": "Alternatively I would recommend using Random.ints() to generate a Stream of ints", "label": {"api": {"Random.ints()": [[38, 50]]}}}, {"text": "There is such a sample code in the javase document", "label": {"api": {"javase document": [[35, 49]]}}}, {"text": "If you can use Java 9 or higher, you can use Collectors.flatMapping() to achieve that", "label": {"api": {"Collectors.flatMapping()": [[45, 68]]}}}, {"text": "We can deduct the internal behavior from the entrySet() and values() method definitions", "label": {"api": {"entrySet()": [[45, 54]], "values()": [[60, 67]]}}}, {"text": "The method entrySet() returns new LinkedEntrySet() on the line 627 which uses new LinkedEntryIterator() as the iterator as of line 634", "label": {"api": {"entrySet()": [[11, 20]]}}}, {"text": "The method values() returns new LinkedValues() on the line 581 which uses new LinkedValueIterator() as the iterator as of line 588", "label": {"api": {"values()": [[11, 18]]}}}, {"text": "They both extend LinkedHashIterator which implies the accessing of values of the map would be treated the same way using both entrySet() and values()", "label": {"api": {"entrySet()": [[126, 135]], "values()": [[141, 148]]}}}, {"text": "Check the @TransactionAttribute annotation docs or look for a tutorial that explains transaction propagation", "label": {"api": {"@TransactionAttribute": [[10, 30]]}}}, {"text": "Use Platform.runLater to invoke it on the javafx thread", "label": {"api": {"Platform.runLater": [[4, 20]]}}}, {"text": "You are looking for java.net.URLDecoder and java.net.URLEncoder", "label": {"api": {"java.net.URLDecoder": [[20, 38]], "java.net.URLEncoder": [[44, 62]]}}}, {"text": "It uses the substract method from java.awt.geom.Area", "label": {"api": {"substract": [[12, 20]]}}}, {"text": "A date is not an integer, but you can use the method getTime() on the Date object to get", "label": {"api": {"getTime()": [[53, 61]]}}}, {"text": "You can use IntStream.iterate() to achieve that", "label": {"api": {"IntStream.iterate()": [[12, 30]]}}}, {"text": "You can use java.util.Optional in this way", "label": {"api": {"java.util.Optional": [[12, 29]]}}}, {"text": "inside a jar, in the WEB-INF/lib folder, a folder passed with -cp to java command, etc..) you can read the file using the getResourceAsStream method of the Class class", "label": {"api": {"getResourceAsStream": [[122, 140]]}}}, {"text": "Don‚Äôt assume a charset;  use the charset MIME type parameter from the response‚Äôs Content-Type header", "label": {"api": {"Content-Type": [[81, 92]]}}}, {"text": "If you‚Äôre using a version of Java older than 11, you can parse the Content-Type value with the javax.activation.MimeType class, but be aware that the javax.activation package has been removed from Java SE as of Java 11", "label": {"api": {"Content-Type": [[67, 78]], "javax.activation.MimeType": [[95, 119]]}}}, {"text": "Another option is to use the JavaMail library, specifically its ContentType class, for parsing", "label": {"api": {"ContentType": [[64, 74]]}}}, {"text": "If you‚Äôre using Java 10 or later, you can use Reader.transferTo with a StringWriter", "label": {"api": {"Reader.transferTo": [[46, 62]]}}}, {"text": "The provided code uses an ArrayList over a classic String[] (String array) because ArrayLists have a dynamic size as well as convenient methods for appending, changing, and removing elements without having to worry about exceeding the size of the array", "label": {"api": {"ArrayLists": [[83, 92]]}}}, {"text": "If you'd like to learn more, here is the Java documentation for ArrayLists", "label": {"api": {"ArrayLists": [[64, 73]]}}}, {"text": "You would use the FloatControl.Type (https://docs.oracle.com/javase/7/docs/api/javax/sound/sampled/FloatControl.Type.html) to set either the volume or the master gain", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/sound/sampled/FloatControl.Type.html": [[37, 120]]}}}, {"text": "Using the Thread#getAllStackTraces you can obtain all the threads", "label": {"api": {"Thread#getAllStackTraces": [[10, 33]]}}}, {"text": "First, you could use an ArrayList", "label": {"api": {"ArrayList": [[24, 32]]}}}, {"text": "The other option (which doesn't require ArrayLists) would be to not create the array until you know how long (or how short) it needs to be", "label": {"api": {"ArrayList": [[40, 48]]}}}, {"text": "Here is the java-8 compliant way using java-stream, the key method is Stream::anyMatch which returns true whether any elements of the stream match the provided predicate", "label": {"api": {"Stream::anyMatch": [[70, 85]]}}}, {"text": "To find an element in the Set use Set::contains", "label": {"api": {"Set::contains": [[34, 46]]}}}, {"text": "The constructor of Timestamp take a millisecond value, not a second value (for nanosecond precision, you need to use the separate setNanos with the sub-second nanoseconds)", "label": {"api": {"constructor of Timestamp": [[4, 27]]}}}, {"text": "The Runnable doesn't return anything", "label": {"api": {"Runnable": [[4, 11]]}}}, {"text": "Although the lambda expression seems the same, the BiFunction is not the Comparator therefore you cannot interchange them", "label": {"api": {"BiFunction": [[51, 60]], "Comparator": [[73, 82]]}}}, {"text": "TreeMap expects Comparator in its constructor because its internal implementation will call compare according to the contract with Comparator", "label": {"api": {"Comparator": [[16, 25], [131, 140]], "TreeMap": [[0, 6]]}}}, {"text": "By the way, the BinaryOperator<T> results in the same lambda expression as well", "label": {"api": {"BinaryOperator<T>": [[16, 32]]}}}, {"text": "The first argument to Collectors.groupingBy is a Function<T,R>, so you can use a variable of that type", "label": {"api": {"Collectors.groupingBy": [[22, 42]], "Function<T,R>": [[49, 61]]}}}, {"text": "Firstly, I suggest you avoid the collection.stream().forEach() construct since the Stream-API should follow the non-interference principle", "label": {"api": {"non-interference": [[112, 127]]}}}, {"text": "The only way I am aware of that doesn't violate the non-interference principle and doesn't cause side-effects (the password generation is rather still questionable) is", "label": {"api": {"non-interference": [[52, 67]]}}}, {"text": "Provide a DoubleFunction<T> to your class as a constructor parameter", "label": {"api": {"DoubleFunction<T>": [[10, 26]]}}}, {"text": "You should eilter use Map.keySet() or Map.entrySet()", "label": {"api": {"Map.keySet()": [[22, 33]], "Map.entrySet()": [[38, 51]]}}}, {"text": "Map.keySet() returns a set containing all keys of your map", "label": {"api": {"Map.keySet()": [[0, 11]]}}}, {"text": "You then can use Map.get() to get the value for a given key", "label": {"api": {"Map.get()": [[17, 25]]}}}, {"text": "Map.entrySet() returns a set of all pairs in your map, so there is no need to use Map.get() with this", "label": {"api": {"Map.entrySet()": [[0, 13]], "Map.get()": [[82, 90]]}}}, {"text": "There are several constructors for ThreadPoolExecutor that accept a BlockingQueue", "label": {"api": {"ThreadPoolExecutor": [[35, 52]], "BlockingQueue": [[68, 80]]}}}, {"text": "BlockingQueue is an interface", "label": {"api": {"BlockingQueue": [[0, 12]]}}}, {"text": "One implementation is ArrayBlockingQueue, which has a bounded size", "label": {"api": {"BlockingQueue": [[27, 39]], "ArrayBlockingQueue": [[22, 39]]}}}, {"text": "The documentation for ThreadPoolExecutor mentions this explicitly", "label": {"api": {"ThreadPoolExecutor": [[22, 39]]}}}, {"text": "A bounded queue (for example, an ArrayBlockingQueue) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control", "label": {"api": {"BlockingQueue": [[38, 50]], "ArrayBlockingQueue": [[33, 50]]}}}, {"text": "Use MidiSystem.write and MidiSystem.getSequence instead of ObjectOutputStream and ObjectInputStream", "label": {"api": {"MidiSystem.write": [[4, 19]], "MidiSystem.getSequence": [[25, 46]]}}}, {"text": "Generation of non-repeatable numbers is not an easy task compared to a simple shuffling the array or a collection using Collections::shuffle", "label": {"api": {"Collections::shuffle": [[120, 139]]}}}, {"text": "Reference Handler thread is responsible for adding Weak, Soft and Phantom references discovered by Garbage Collector into their registered ReferenceQueues", "label": {"api": {"ReferenceQueues": [[139, 153]]}}}, {"text": "Common-Cleaner runs cleaning actions of java.lang.ref.Cleaner instances", "label": {"api": {"java.lang.ref.Cleaner": [[40, 60]]}}}, {"text": "The key to this is Timeline", "label": {"api": {"Timeline": [[19, 26]]}}}, {"text": "Basically, use a counter and make sure to stop the Timeline when the counter is greater than or equal to the size of the List that holds the person objects", "label": {"api": {"Timeline": [[51, 58]]}}}, {"text": "String.format or System.out.printf have a lot of nice formatting abilities which can help in simple cases (java.util.Formatter)", "label": {"api": {"java.util.Formatter": [[107, 125]]}}}, {"text": "The correct way to do this is to use a subclass of JTextField, JFormattedTextField, instead of a plain JTextField", "label": {"api": {"JFormattedTextField": [[63, 81]]}}}, {"text": "But if you insist on restricting every typed character, you can use a DocumentFilter", "label": {"api": {"DocumentFilter": [[70, 83]]}}}, {"text": "You would then use the Properties class to access it (again, as a resource)", "label": {"api": {"Properties": [[23, 32]]}}}, {"text": "The method SecureRandom.getInstanceStrong() declares that it can throw a NoSuchAlgorithmException, however the doc says", "label": {"api": {"SecureRandom.getInstanceStrong()": [[11, 42]]}}}, {"text": "You could use Locks and Conditions which are more flexible than sychronized statements", "label": {"api": {"Lock": [[14, 17]], "Condition": [[24, 32]]}}}, {"text": "For your example you could replace obj2 with a ReentrantLock", "label": {"api": {"Lock": [[56, 59]]}}}, {"text": "If this is not desired you could replace obj1 with a Lock instead and wait for obj2", "label": {"api": {"Lock": [[53, 56]]}}}, {"text": "I hope you‚Äôre already using LocalDate in Java (you should), then look into either WeekFields or TemporalAdjusters, which you find more convenient and appropriate", "label": {"api": {"WeekFields": [[82, 91]], "TemporalAdjusters": [[96, 112]]}}}, {"text": "Here are links to documentation of WeekFields and TemporalAdjusters", "label": {"api": {"WeekFields": [[35, 44]], "TemporalAdjusters": [[50, 66]]}}}, {"text": "Use ArrayList.isEmpty() or ArrayList.size() > 0", "label": {"api": {"ArrayList.isEmpty()": [[4, 22]], "ArrayList.size() > 0": [[27, 46]]}}}, {"text": "You could use a ReadWriteLock to perform thread-safe read/write operations on some shared object", "label": {"api": {"ReadWriteLock": [[16, 28]]}}}, {"text": "You can use Java's Observables", "label": {"api": {"Observable": [[19, 28]]}}}, {"text": "The object you want to monitor should extend Observable, and the monitoring class should implement Observer", "label": {"api": {"Observable": [[45, 54]], "Observer": [[99, 106]]}}}, {"text": "See the documentation for Observable and Observer", "label": {"api": {"Observable": [[26, 35]], "Observer": [[41, 48]]}}}, {"text": "You can compare it to the java.util.Collections which consists only of static methods", "label": {"api": {"java.util.Collections": [[26, 46]]}}}, {"text": "Predicate functional interface has test() method, not apply()", "label": {"api": {"Predicate": [[0, 8]], "test()": [[35, 40]]}}}, {"text": "Java documentation for FilePermission, clearly states that, this java class is used to represent the actions (i.e read/write/delete/execute/readlink)", "label": {"api": {"FilePermission": [[23, 36]]}}}, {"text": "FilePermission class helps to resolve crucial file access decisions (using implies method) which if implemented manually can lead to errors or security breaches like any other permission class", "label": {"api": {"FilePermission": [[0, 13]]}}}, {"text": "This is documented in a somewhat unobvious place, the superinterface Key", "label": {"api": {"the superinterface Key": [[50, 71]]}}}, {"text": "If getTrace() is suppose to return the call site of the logger statement you can create a new Throwable and convert a stack trace to a string or choose a single frame and convert that to a string", "label": {"api": {"single frame and convert that to a string": [[154, 194]]}}}, {"text": "If you are using JUL you simply have to use Logger::logp method to pass the call site information", "label": {"api": {"Logger::logp": [[44, 55]]}}}, {"text": "The JavaDoc for String.substring() states", "label": {"api": {"String.substring()": [[16, 33]]}}}, {"text": "Alternative solution using Collection.shuffle()", "label": {"api": {"Collection.shuffle()": [[27, 46]]}}}, {"text": "To print the List of id attribute of the element you need to induce WebDriverWait for the visibilityOfAllElementsLocatedBy() and you can use Java8 stream() and map() and you can use either of the following Locator Strategies", "label": {"api": {"stream()": [[147, 154]], "map()": [[160, 164]]}}}, {"text": "You can do this with PipedReader and PipedWriter", "label": {"api": {"PipedReader": [[21, 31]], "PipedWriter": [[37, 47]]}}}, {"text": "FileChannel class have map method that does some implicit copy operations with file descriptors, so be careful when use it", "label": {"api": {"FileChannel": [[0, 10]]}}}, {"text": "Use LocalDate.ofYearDay(int year, int dayOfYear)", "label": {"api": {"LocalDate.ofYearDay(int year, int dayOfYear)": [[4, 47]]}}}, {"text": "Mentioned operations cannot be directly achieved by Java String but can be achieved by StringBuilder", "label": {"api": {"StringBuilder": [[87, 99]]}}}, {"text": "I learned that I can't directly use replaceAll() on a RichTextString as it is not of Type String which is why I used the method getString() and tried this", "label": {"api": {"replaceAll()": [[36, 47]]}}}, {"text": "The ZipEntry class has getMethod to get the compression method of an entry", "label": {"api": {"getMethod": [[23, 31]]}}}, {"text": "One of the options is STORED (e.g., not compressed)", "label": {"api": {"STORED": [[22, 27]]}}}, {"text": "Starting from this complete example, I constructed a TabPane with three new tabs", "label": {"api": {"TabPane": [[53, 59]]}}}, {"text": "Finally I set the Stage by creating a Scene using the TabPane as its root node", "label": {"api": {"TabPane": [[54, 60]]}}}, {"text": "You'll note from the javadoc that Scanner#nextLine() is the only thing in your example that can throw a NoSuchElementException", "label": {"api": {"from the javadoc": [[12, 27]]}}}, {"text": "You could use BodyHandlers.ofPublisher() to obtain a Publisher<List<ByteBuffer>>", "label": {"api": {"BodyHandlers.ofPublisher()": [[14, 39]]}}}, {"text": "You can use flatMap for that", "label": {"api": {"flatMap": [[12, 18]]}}}, {"text": "Instead of just returning a single object, you‚Äôre returning a single-element stream whose onClose action does the necessary cleanup", "label": {"api": {"onClose": [[90, 96]]}}}, {"text": "This is relying on the guaranty made for flatMap", "label": {"api": {"flatMap": [[41, 47]]}}}, {"text": "Each mapped stream is closed after its contents have been placed into this stream", "label": {"api": {"closed": [[22, 27]]}}}, {"text": "The passage you quote only applies when the UNICODE_CHARACTER_CLASS flag is used", "label": {"api": {"UNICODE_CHARACTER_CLASS": [[44, 66]]}}}, {"text": "This task is a canonical use case for the regex Matcher‚Äôs appendReplacement/appendTail loop, which you can always use when the intended replacement logic is too complex for a simple replaceAll(String regex, String replacement) on a String", "label": {"api": {"Matcher": [[48, 54]], "replaceAll(String regex, String replacement)": [[182, 225]]}}}, {"text": "Try using Pattern.quote, discussed here", "label": {"api": {"Pattern.quote": [[10, 22]]}}}, {"text": "As @Benson99 pointed out, a HashMap would do the trick", "label": {"api": {"HashMap": [[28, 34]]}}}, {"text": "There is count() method that returns long type", "label": {"api": {"count()": [[9, 15]]}}}, {"text": "As you can find in the documentation here you can pass to the constructor any URL supported by the URL class, which is the case in your example", "label": {"api": {"URL": [[78, 80], [99, 101]]}}}, {"text": "If the passed string is not a valid URL, but a path instead, the Image is searched on the classpath in that case", "label": {"api": {"URL": [[36, 38]]}}}, {"text": "One way to enforce generics at runtime is by keeping a Class object in each MyStack instance", "label": {"api": {"Class": [[55, 59]]}}}, {"text": "You can then use the cast method to provide type safety in the pop method", "label": {"api": {"cast": [[21, 24]]}}}, {"text": "File.getName() returns a String", "label": {"api": {"File.getName()": [[0, 13]]}}}, {"text": "But if you really want to hide some exception, it's preferable that you do not, you can use Thread.UncaughtExceptionHandler doing something like that", "label": {"api": {"Thread.UncaughtExceptionHandler": [[92, 122]]}}}, {"text": "Ask if each File object represents a file versus a directory by calling File::isFile", "label": {"api": {"File": [[12, 15], [72, 75], [80, 83]], "File::isFile": [[72, 83]]}}}, {"text": "Call File::getName to produce a String with the text of the file name", "label": {"api": {"File": [[5, 8]], "File::getName": [[5, 17]]}}}, {"text": "Then use String::startsWith and String::substring to analyze the file name", "label": {"api": {"String::startsWith": [[9, 26]], "String::substring": [[32, 48]]}}}, {"text": "Validate by attempting to parse the text as a LocalDate", "label": {"api": {"LocalDate": [[46, 54]]}}}, {"text": "In Java, this is known as a Predicate", "label": {"api": {"Predicate": [[28, 36]]}}}, {"text": "You can define the following IntPredicate", "label": {"api": {"Predicate": [[32, 40]]}}}, {"text": "You can use Path.subpath and Path.getNameCount", "label": {"api": {"Path.subpath": [[12, 23]], "Path.getNameCount": [[29, 45]]}}}, {"text": "You may want to use the ConcurrentLinkedQueue since it natively handles concurrent thread accesses", "label": {"api": {"ConcurrentLinkedQueue": [[24, 44]]}}}, {"text": "You can use AtomicBoolean for your purpose", "label": {"api": {"AtomicBoolean": [[12, 24]]}}}, {"text": "By creating an AtomicBoolean object and passing it to both the Clock and Visitor objects, when Clock updates the value of the AtomicBoolean, the Visitor objects will receive the updated value too", "label": {"api": {"AtomicBoolean": [[15, 27], [126, 138]]}}}, {"text": "To access the value of the AtomicBoolean in Visitor or to update the value in Clock, you can use the get() and set(boolean) method respectively", "label": {"api": {"AtomicBoolean": [[27, 39]]}}}, {"text": "From the docs for InetAddress.getLocalHost()", "label": {"api": {"InetAddress.getLocalHost()": [[18, 43]]}}}, {"text": "For a DATE value with a time, where you'd have used JDBC type java.sql.Date, use java.time.LocalDate", "label": {"api": {"java.sql.Date": [[62, 74]], "java.time.LocalDate": [[81, 99]]}}}, {"text": "For a TIMESTAMP / DATETIME value, where you'd have used JDBC type java.sql.Timestamp, it depends on your whether you need to consider time zone", "label": {"api": {"java.sql.Timestamp": [[66, 83]]}}}, {"text": "If the application, its users, and the database are all in the same time zone, you can use java.time.LocalDateTime", "label": {"api": {"java.time.LocalDate": [[91, 109]], "java.time.LocalDateTime": [[91, 113]]}}}, {"text": "If users are in multiple time zones, you should always save values to database in UTC, so you should use java.time.Instant", "label": {"api": {"java.time.Instant": [[105, 121]]}}}, {"text": "Specifically, you will want the ScheduledExecutorService class", "label": {"api": {"ScheduledExecutorService": [[32, 55]]}}}, {"text": "Never use LocalDateTime to track a moment, as explained in the class doc", "label": {"api": {"LocalDateTime": [[10, 22]]}}}, {"text": "For a moment, use Instant, OffsetDateTime, or ZonedDateTime", "label": {"api": {"Instant": [[18, 24]], "ZonedDateTime": [[46, 58]]}}}, {"text": "For a span-of-time on the scale of hours-minutes-seconds, use Duration", "label": {"api": {"Duration": [[62, 69]]}}}, {"text": "The Duration class offers methods such as toMinutes, toSeconds, the results of which you can feed as your delay to a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[117, 140]], "Duration": [[4, 11]], "your delay": [[101, 110]]}}}, {"text": "Take the Function<T,R> interface for example, the only method you really care about is R apply(T t), so when you need a Functionsomewhere, you can pass a lambda and it will create a Function instance where that lambda method is the apply method", "label": {"api": {"Function<T,R>": [[9, 21]]}}}, {"text": "Also when there is a InputMismatchException you have to finish reading the line (because you used Scanner#nextInt instead of Scanner#nextLine) and set a variable (repeatValue) to true", "label": {"api": {"Scanner#nextInt": [[98, 112]], "Scanner#nextLine": [[125, 140]]}}}, {"text": "The syntax List<Integer> myList=new List<Integer>{1, 2, 3, 4, 5}; is incorrect", "label": {"api": {"List": [[11, 14], [27, 30], [36, 39]]}}}, {"text": "You should use one of the classes that implement List which is an interface, such as ArrayList, LinkedList, etc", "label": {"api": {"List": [[49, 52], [90, 93], [102, 105]], "ArrayList": [[85, 93]], "LinkedList": [[96, 105]]}}}, {"text": "A correct syntax would be, for instance, List<Integer> myList=new ArrayList<Integer>();", "label": {"api": {"List": [[41, 44], [57, 60], [71, 74]], "ArrayList": [[66, 74]]}}}, {"text": "Variable myList is not static and non-static fields cannot be acceded inside static methods", "label": {"api": {"List": [[11, 14]]}}}]