[{"text": "If you look at the documentation for Integer.parseInt, you will find that it throws NumberFormatException", "label": {"api": {"Integer.parseInt": [[37, 52]], "NumberFormatException": [[84, 104]]}}}, {"text": "NumberFormatException - if the string does not contain a parsable integer", "label": {"api": {"NumberFormatException": [[0, 20]]}}}, {"text": "There is a slight improvement that you can do that uses the BigDecimal's internal cache by using its valueOf method", "label": {"api": {"BigDecimal": [[60, 69]], "valueOf": [[101, 107]]}}}, {"text": "You should use an Executor of some sort rather than worrying about thread management yourself", "label": {"api": {"Executor": [[18, 25]]}}}, {"text": "The Executors class provides a variety of simple ways to create executor instances", "label": {"api": {"Executor": [[4, 11]], "Executors class": [[4, 18]]}}}, {"text": "The use of %s will result in the toString() method being called on the object, and thus will work for any type T", "label": {"api": {"will result": [[14, 24]], "toString()": [[33, 42]]}}}, {"text": "List#toArray() returns an Object[] array", "label": {"api": {"List#toArray()": [[0, 13]]}}}, {"text": "use overloaded List#toArray(T[]) instead", "label": {"api": {"List#toArray(T[])": [[15, 31]]}}}, {"text": "Note that System.arraycopy will let you copy part of an array", "label": {"api": {"System.arraycopy": [[10, 25]]}}}, {"text": "If you do such operations a lot, maybe it is better to use DataInputStream, which provides a set of operations, like readDouble and so on", "label": {"api": {"DataInputStream": [[59, 73]]}}}, {"text": "And, you can try using DataInputStream to read Double, Float, Integer, and others", "label": {"api": {"DataInputStream": [[23, 37]]}}}, {"text": "You can instantiate a DataInputStream using", "label": {"api": {"DataInputStream": [[22, 36]]}}}, {"text": "The changes are applied to the model via the TableModel's .setValueAt() method", "label": {"api": {"TableModel's .setValueAt()": [[45, 70]]}}}, {"text": "The reason xTest and y do not have the same value is because a Timer has an initial delay (which is set to the delay provided in the constructor)", "label": {"api": {"initial delay": [[76, 88]]}}}, {"text": "It clearly mentions list() will return null in case the object is not a directory http://docs.oracle.com/javase/6/docs/api/java/io/File.html#list()", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/File.html#list()": [[82, 146]]}}}, {"text": "Better error messages and error handling, especially if you also add the JSR303 @NotNull annotation", "label": {"api": {"JSR303 @NotNull annotation": [[73, 98]]}}}, {"text": "My recommendation would be to look into the FileLock API", "label": {"api": {"FileLock": [[44, 51]]}}}, {"text": "We can use retainAll method of Collections", "label": {"api": {"retainAll method of Collections": [[11, 41]]}}}, {"text": "You need to annotate your exception mapper with @Provider, otherwise it will never get registered with the JAX-RS runtime", "label": {"api": {"@Provider": [[48, 56]]}}}, {"text": "Also, to protect against SQL Injection attacks, consider using PreparedStatement", "label": {"api": {"PreparedStatement": [[63, 79]]}}}, {"text": "For instance, there's the type ExternalContext that abstracts from the \"nature of its containing application environment\"", "label": {"api": {"ExternalContext": [[31, 45]]}}}, {"text": "If you're using Matcher.find(), it'll find that anywhere/everywhere because it can match anywhere in a string", "label": {"api": {"Matcher.find()": [[16, 29]]}}}, {"text": "You can check this link", "label": {"api": {"this link": [[14, 22]]}}}, {"text": "The getTime() function actually returns a date, which you can pass to your formatter, so there is no need to parse it", "label": {"api": {"getTime()": [[4, 12]]}}}, {"text": "So, by definition android.database.SQLException and java.sql.SQLException share about the same scope of application, which is to provide information about errors while accessing/modifying a database", "label": {"api": {"java.sql.SQLException": [[52, 72]]}}}, {"text": "Why did Google make their android.database.SQLException unchecked when java.sql.SQLException is checked", "label": {"api": {"java.sql.SQLException": [[71, 91]]}}}, {"text": "android.database.SQLException is based on java.lang.RuntimeException and don't need to be checked, but java.sql.SQLException isn't", "label": {"api": {"java.lang.RuntimeException": [[42, 67]]}}}, {"text": "To draw an image onto the screen, you first need to get the Graphics object, of the Container or Component you're painting it onto", "label": {"api": {"Graphics object": [[60, 74]]}}}, {"text": "You should take a look at the documentation of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[47, 62]]}}}, {"text": "read() reads a single byte from the stream", "label": {"api": {"read()": [[0, 5]]}}}, {"text": "If you receive -1 from the stream, that means the end-of-stream EOS (which is the end of the file when using FileInputStream)", "label": {"api": {"FileInputStream": [[109, 123]]}}}, {"text": "in.read() is executed first, the value is assigned to c, then a boolean comparison c != -1 is evaluated as while-loop argument", "label": {"api": {"read()": [[3, 8]]}}}, {"text": "The Java6 EE API docs declare only 5 annotations to security use", "label": {"api": {"Java6 EE API docs": [[4, 20]]}}}, {"text": "You can implement your own custom implementation of DynamicMBean which returns the appropriate description of your management \"interface\" (without actually creating said interface)", "label": {"api": {"DynamicMBean": [[52, 63]]}}}, {"text": "In order to do this, you must use the Iterator", "label": {"api": {"Iterator": [[38, 45]]}}}, {"text": "Assuming you are using Java 6 or newer, you might want to take a look at Normalizer, which can decompose accents, then use a regex to strip the combining accents", "label": {"api": {"Normalizer": [[73, 82]]}}}, {"text": "Then when a request comes in, send a request JMS message and leave a way for the consumer to call back to the calling thread, like a SynchronousQueue that the caller is waiting to take() from", "label": {"api": {"SynchronousQueue": [[133, 148]], "take()": [[180, 185]]}}}, {"text": "If you have to wait on multiple messages to serve a single request, maybe combine a ConcurrentLinkedQueue to drop the responses on with a CountdownLatch to signal the requesting thread when the responses are all received", "label": {"api": {"ConcurrentLinkedQueue": [[84, 104]], "CountdownLatch": [[138, 151]]}}}, {"text": "You should call nextInt once, save the result and use it for comparison", "label": {"api": {"nextInt": [[16, 22]]}}}, {"text": "Replace \"UTF-8\" if you want a different encoding", "label": {"api": {"different": [[30, 38]]}}}, {"text": "Instead of writing your own and then abandoning the idea because you couldn't make it work, why not use a Semaphore, which is already there and is implemented correctly", "label": {"api": {"Semaphore": [[106, 114]]}}}, {"text": "The jGRASP home pages states that the latest version only requires JDK 1.5 to run, whereas Arrays.copyOfRange() wasn't added until JDK 1.6", "label": {"api": {"Arrays.copyOfRange()": [[91, 110]]}}}, {"text": "Witness the lack of any such method in the docs for Arrays in 1.5", "label": {"api": {"docs for Arrays in 1.5": [[43, 64]]}}}, {"text": "use the startsWith method like this ..", "label": {"api": {"startsWith method": [[8, 24]]}}}, {"text": "What are you expecting cats.get(index) to return", "label": {"api": {"get": [[28, 30]]}}}, {"text": "cats is of type ArrayList<Cat> - so you should find the documentation for ArrayList<E>, then navigate to the get method, and see that it's declared like this", "label": {"api": {"ArrayList<E>": [[74, 85]], "get": [[109, 111]]}}}, {"text": "So in an ArrayList<Cat>, the get method will return Cat", "label": {"api": {"get": [[29, 31]]}}}, {"text": "Take a look at ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "In Java Lambda API the main class is java.util.function.Function", "label": {"api": {"java.util.function.Function": [[37, 63]]}}}, {"text": "If you always want a specific alias to be chosen, you'll need to implement your own X509KeyManager, possibly wrapping the default manager", "label": {"api": {"X509KeyManager": [[84, 97]]}}}, {"text": "One approach to take would be to use fillRect and \"paint\" the squares", "label": {"api": {"fillRect": [[37, 44]]}}}, {"text": "Make the objects implement Comparable", "label": {"api": {"Comparable": [[27, 36]]}}}, {"text": "Finally, you may consider using the LinkedHashSet collection for your registrations", "label": {"api": {"LinkedHashSet": [[36, 48]]}}}, {"text": "Though, the problem with HashSet is that the order in which the elements were added gets lost", "label": {"api": {"HashSet": [[25, 31]]}}}, {"text": "So if you want to preserve the order of elements, I would suggest using a LinkedHashSet", "label": {"api": {"HashSet": [[80, 86]], "LinkedHashSet": [[74, 86]]}}}, {"text": "With a LinkedHashSet, iterating over the elements will return them in the order they were inserted", "label": {"api": {"HashSet": [[13, 19]], "LinkedHashSet": [[7, 19]]}}}, {"text": "I suggest using the Calendar object; it has a method called Calendar#add(int field, int amount", "label": {"api": {"Calendar": [[20, 27], [60, 67]], "Calendar#add(int field, int amount": [[60, 93]]}}}, {"text": "From the LinkedList API documentation", "label": {"api": {"LinkedList API documentation": [[9, 36]]}}}, {"text": "Socket.shutdownOutput() means that the client is finished sending any data through the TCP connection", "label": {"api": {"Socket.shutdownOutput()": [[0, 22]]}}}, {"text": "Just match int surrounded by word boundaries, which are matched by \\b", "label": {"api": {"word boundaries, which are matched by \\b": [[29, 68]]}}}, {"text": "You have System.load(String filename) and System.loadLibrary(String libname)", "label": {"api": {"System.load(String filename)": [[9, 36]], "System.loadLibrary(String libname)": [[42, 75]]}}}, {"text": "From looking at how it is used in the jdk libraries, I would say", "label": {"api": {"how it is used in the jdk libraries": [[16, 50]]}}}, {"text": "new Thread (\"F\"); creates a new Thread object named \"F\", which isn't the same as one of your NewThread objects", "label": {"api": {"Thread": [[4, 9], [32, 37], [96, 101]]}}}, {"text": "Also, it's very unusual to create a Thread inside of a Runnable", "label": {"api": {"Thread": [[36, 41]], "Runnable": [[55, 62]]}}}, {"text": "Instead, you should create a Runnable, then create a Thread to hold your Runnable and start() the Thread", "label": {"api": {"Thread": [[53, 58], [98, 103]], "Runnable": [[29, 36], [73, 80]], "create a Thread to hold your Runnable": [[44, 80]], "start()": [[86, 92]]}}}, {"text": "Use TreeMap, the entries will be sorted by key", "label": {"api": {"TreeMap": [[4, 10]]}}}, {"text": "If you are storing the pieces to be turned in an ArrayList, you can use the clear() method to erase the contents of the collection between each turn", "label": {"api": {"clear()": [[76, 82]]}}}, {"text": "If so, you can Class ProcessBuilder to create operating system processes", "label": {"api": {"Class ProcessBuilder": [[15, 34]]}}}, {"text": "Convert your java.util.Date to java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[31, 48]]}}}, {"text": "you can get all the pixel values with BufferedImage.getRGB(...)", "label": {"api": {"BufferedImage.getRGB(...)": [[38, 62]]}}}, {"text": "Collections.addAll is a varargs method which allows us to add any number of items to a collection in a single statement", "label": {"api": {"Collections.addAll": [[0, 17]]}}}, {"text": "Use the Pattern and Matcher classes", "label": {"api": {"Pattern": [[8, 14]], "Matcher": [[20, 26]]}}}, {"text": "You need setTextContent(String textContent) method and not setAttribute method", "label": {"api": {"setTextContent(String textContent)": [[9, 42]]}}}, {"text": "You can launch the user's default web browser by using the java.awt.Desktop class", "label": {"api": {"java.awt.Desktop": [[59, 74]]}}}, {"text": "See the Annotation Retention Policy", "label": {"api": {"Annotation Retention Policy": [[8, 34]]}}}, {"text": "This would be an ideal job for a SwingWorker - do the upload in doInBackground, and have it call setProgress with an updated progress number every so often", "label": {"api": {"SwingWorker": [[33, 43]]}}}, {"text": "You can place a JavaFX Chart in a JFXPanel which may be placed in a Swing component", "label": {"api": {"JFXPanel": [[34, 41]]}}}, {"text": "See the documentation of executeBatch() for more details", "label": {"api": {"executeBatch()": [[25, 38]]}}}, {"text": "Use LinkedHashMap if you want to retrieve in order in which you put key", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "But you can use LinkedHashMap (http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html) and then you will be guaranteed", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html": [[31, 99]]}}}, {"text": "Collections.unmodifiableSet allows me to create an unmodifiable view of a set", "label": {"api": {"Collections.unmodifiableSet": [[0, 26]]}}}, {"text": "Use .matches(\"(?s).*vlan.*\") or so for new line characters being catched by .; See DOTALL", "label": {"api": {"DOTALL": [[83, 88]]}}}, {"text": "I don't think Element, Node, or NodeList provide a direct way to get this info, but it's easy enough to write your own quick function to do it", "label": {"api": {"Element": [[14, 20]], "Node": [[23, 26], [32, 35]], "NodeList": [[32, 39]]}}}, {"text": "There is a specialized class in Java for decimal formatting called DecimalFormat and advise you to take a look about how to format numbers in java in this page", "label": {"api": {"DecimalFormat": [[67, 79]]}}}, {"text": "This is done using a CountDownLatch", "label": {"api": {"CountDownLatch": [[21, 34]]}}}, {"text": "2 of the Callables will call countDown() on the latch, the one that should wait will call await() (possibly with a timeout)", "label": {"api": {"countDown()": [[29, 39]], "await()": [[90, 96]]}}}, {"text": "You need to implement the HttpSessionListener interface", "label": {"api": {"HttpSessionListener": [[26, 44]]}}}, {"text": "The DataSource, Driver or ConnectionPoolDataSource that you can select in the Glassfish config is not exposed to your application directly, instead the Application Server has its own DataSource that maintains a connection pool, this datasource uses the configured DataSource, Driver or ConnectionPoolDataSource as the factory for the connections it will keep in its pool", "label": {"api": {"DataSource": [[4, 13], [40, 49], [183, 192], [264, 273], [300, 309]], "Driver": [[16, 21], [276, 281]], "ConnectionPoolDataSource": [[26, 49], [286, 309]]}}}, {"text": "So when you configure Glassfish with a ConnectionPoolDataSource, it uses the ConnectionPoolDataSource to create the physical connections (PooledConnection objects) for a connection pool", "label": {"api": {"DataSource": [[53, 62], [91, 100]], "ConnectionPoolDataSource": [[39, 62], [77, 100]], "PooledConnection": [[138, 153]]}}}, {"text": "This connection pool is kept by the application server DataSource implementation", "label": {"api": {"DataSource": [[55, 64]]}}}, {"text": "Your application then access that connection pool using this DataSource", "label": {"api": {"DataSource": [[61, 70]]}}}, {"text": "The DataSource hands out logical Connection objects from the connection pool", "label": {"api": {"DataSource": [[4, 13]]}}}, {"text": "I'll assume that you're using HttpURLConnection", "label": {"api": {"HttpURLConnection": [[30, 46]]}}}, {"text": "To get the current angle of the rotation, you should use the rotateProperty of the ImageView", "label": {"api": {"rotateProperty": [[61, 74]]}}}, {"text": "In this case, you want to attach an ItemListener()", "label": {"api": {"ItemListener()": [[36, 49]]}}}, {"text": "I'm trying to create a JFrame including a JPanel containing only the stuff necessary to choose a RGB color", "label": {"api": {"JFrame": [[23, 28]], "JPanel": [[42, 47]]}}}, {"text": "I've been messing around with JColorChooser, AbstractColorChooserPanel and ColorModel, reading Oracle tutorials, but I didn't get to understand how to develop exactly what I want", "label": {"api": {"JColorChooser": [[30, 42]], "AbstractColorChooserPanel": [[45, 69]]}}}, {"text": "You need to use one of standard Set class", "label": {"api": {"Set": [[32, 34]]}}}, {"text": "Consider using DataInputStream and DataOutputStream", "label": {"api": {"DataInputStream": [[15, 29]], "DataOutputStream": [[35, 50]]}}}, {"text": "The easiest option is to perhaps use an ArrayList<Integer> for coinsSoFar, resizing it appropriately as you go along", "label": {"api": {"ArrayList<Integer>": [[40, 57]]}}}, {"text": "An alternative to the solution by @Sam is to use javax.swing.Timer", "label": {"api": {"Timer": [[61, 65]]}}}, {"text": "You should use URLDecoder, which is particularly appropriate because, despite of its name, it does application/x-www-form-urlencoded decoding", "label": {"api": {"URLDecoder": [[15, 24]]}}}, {"text": "However note that if the URL is passed as a URI object, it has a nice getQuery() which already returns the unescaped text", "label": {"api": {"getQuery()": [[70, 79]]}}}, {"text": "If you use the servlet API, you don't have to escape anything because there are nice methods like getParameterMap()", "label": {"api": {"getParameterMap()": [[98, 114]]}}}, {"text": "@Max - The annotated element must be a number whose value must be lower or equal to the specified maximum", "label": {"api": {"@Max": [[0, 3]]}}}, {"text": "@Min - The annotated element must be a number whose value must be higher or equal to the specified minimum", "label": {"api": {"@Min": [[0, 3]]}}}, {"text": "@NotNull - The annotated element must not be null", "label": {"api": {"@NotNull": [[0, 7]]}}}, {"text": "The following will execute the @Required and @MinLength validation for the username field", "label": {"api": {"@Min": [[45, 48]]}}}, {"text": "Here is the matrix returned by getTranslationInstance", "label": {"api": {"getTranslationInstance": [[31, 52]]}}}, {"text": "The -1 values you have set in the parameters for getTranslationInstance seem suspect to me..", "label": {"api": {"getTranslationInstance": [[49, 70]]}}}, {"text": "Call myThread.start() and not myThread.run()", "label": {"api": {"myThread.start()": [[5, 20]]}}}, {"text": "If you are sorting an array, use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[33, 45]]}}}, {"text": "If you are sorting a List, use Collections.sort()", "label": {"api": {"Collections.sort()": [[31, 48]]}}}, {"text": "You can use OracleCallableStatement and pass the REF type on the setREF(....) method.", "label": {"api": {"CallableStatement": [[18, 34]]}}}, {"text": "For independent library, use CallableStatement, passing the Ref type on the setRef(....) method", "label": {"api": {"CallableStatement": [[29, 45]], "Ref": [[60, 62], [79, 81]], "setRef(....)": [[76, 87]]}}}, {"text": "I gone through the api and found in that they can fire queries on the beans", "label": {"api": {"api": [[19, 21]]}}}, {"text": "Quote from the Matcher.replaceAll() API page", "label": {"api": {"Matcher.replaceAll() API page": [[15, 43]]}}}, {"text": "You could just obtain a java.util.Enumerator from your collection, via the java.util.Collections.enumeration() Method", "label": {"api": {"java.util.Collections.enumeration()": [[75, 109]]}}}, {"text": "Here is the documentation", "label": {"api": {"Here is the documentation": [[0, 24]]}}}, {"text": "Use the overloaded variant of await that accepts a timeout", "label": {"api": {"await": [[30, 34]]}}}, {"text": "Since you say you're using Java, it looks like SimpleDateFormat will give you an RFC-822 compliant date if you use Z to format the zone in your time format (rather than z)", "label": {"api": {"SimpleDateFormat": [[47, 62]]}}}, {"text": "Use java pattern matching and regular expressions to determine the index of the beginning and ending characters", "label": {"api": {"pattern matching": [[9, 24]]}}}, {"text": "Yes, you can use String.replaceAll which takes a regex", "label": {"api": {"String.replaceAll": [[17, 33]]}}}, {"text": "Call repaint on the ImageComponent in your action listener", "label": {"api": {"repaint": [[5, 11]]}}}, {"text": "You can do it using a SessionContext and an InitialContext (or a self-created context based on the Initial- or SessionContext)", "label": {"api": {"SessionContext": [[22, 35], [111, 124]], "InitialContext": [[44, 57]]}}}, {"text": "Have a look at the HttpURLConnection class within the JDK or use Apache Http Components", "label": {"api": {"HttpURLConnection": [[19, 35]]}}}, {"text": "With HttpURLConnection it might look like this", "label": {"api": {"HttpURLConnection": [[5, 21]]}}}, {"text": "It sounds to me like you are looking for ReadWriteLocks", "label": {"api": {"ReadWriteLock": [[41, 53]]}}}, {"text": "The main feature of ReadWriteLocks I am suggesting you use is the ability to grab and release read locks from multiple threads very quickly but attempting a write lock will wait for all read locks to be released and then block all new read locks until the write lock is released", "label": {"api": {"ReadWriteLock": [[20, 32]]}}}, {"text": "In order to get the original url that the user tried to access, please try using the variable RequestDispatcher.FORWARD_REQUEST_URI", "label": {"api": {"RequestDispatcher.FORWARD_REQUEST_URI": [[94, 130]]}}}, {"text": "You should be using the new ExecutorService", "label": {"api": {"ExecutorService": [[28, 42]]}}}, {"text": "We then create a new ExecutorService with a thread pool the same size as the number of work classes we created - notice we can have fewer threads", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "We now call invokeAll passing in the List of work classes, this is where we ask the ExecutorService to call all the Callables", "label": {"api": {"ExecutorService": [[84, 98]]}}}, {"text": "Finally, and this is where the ExecutorService shines, we loop over the returned list of Future classes and call get - this will throw an ExecutionException if there were any problems running the work associated with that future", "label": {"api": {"ExecutorService": [[31, 45]]}}}, {"text": "Use an overloaded divide method of BigDecimal that takes a scale as an argument; you can get an arbitary scale that way", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "If you want a list with two values HashMap http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html is what you need", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html": [[43, 105]]}}}, {"text": "Since Java 1.4 I'd rather use getModifiersEx which will report these modifiers and the buttons separately", "label": {"api": {"getModifiersEx": [[30, 43]]}}}, {"text": "Java Thread Pool Example using Executors and ThreadPoolExecutor and the docs on ExecutorService", "label": {"api": {"ExecutorService": [[80, 94]]}}}, {"text": "Another way, still using java.util.concurrent", "label": {"api": {"java.util.concurrent": [[25, 44]]}}}, {"text": "You should use the getColumn(int) method of the model, and for accessing the model, you'll need to convert the row and column view indices with JTable's convertRowIndexToModel(int), convertColumnIndexToModel(int) and the equivalents for converting the model indices to view indices", "label": {"api": {"JTable": [[144, 149]], "convertRowIndexToModel(int)": [[153, 179]], "convertColumnIndexToModel(int)": [[182, 211]]}}}, {"text": "Maintain a java.util.BitSet reference in your class myTeams and instantiate it with a number equaling the number of teams", "label": {"api": {"java.util.BitSet": [[11, 26]]}}}, {"text": "As you can see timer.schedule() may has 3 parameters to start immediately", "label": {"api": {"As you can see timer.schedule()": [[0, 30]]}}}, {"text": "I'd probably deserialize the JSON into a java.util.Map, get the values from the Map as a Collection using the Map.values() method, and then create a new ArrayList using the constructor that takes a Collection", "label": {"api": {"the Map.values() method": [[106, 128]], "the constructor that takes a Collection": [[169, 207]]}}}, {"text": "Assuming that you have a reference to the Socket object that you want to remove, then just call remove on your ArrayList", "label": {"api": {"ArrayList": [[111, 119]], "Socket": [[42, 47]]}}}, {"text": "This works, because even though Socket doesn't implement the equals method, the Object class's reference equality is used", "label": {"api": {"Socket": [[32, 37]]}}}, {"text": "As long as that Socket object is in the ArrayList, remove will remove it", "label": {"api": {"ArrayList": [[40, 48]], "Socket": [[16, 21]]}}}, {"text": "You can also take a look at the StringTokenizer, which has an option to keep delimiters", "label": {"api": {"StringTokenizer": [[32, 46]]}}}, {"text": "Use .indexOf and find push", "label": {"api": {".indexOf": [[4, 11]]}}}, {"text": "Use the File constructor", "label": {"api": {"File": [[8, 11]]}}}, {"text": "Note that using the File constructor like this is generally considered preferable to assuming a directory separator of /, even though in practice that works on all platforms that I'm aware of", "label": {"api": {"File": [[20, 23]]}}}, {"text": "The String.indexOf(String str, int fromIndex) function gets the first occurence of str after the specified index", "label": {"api": {"String.indexOf(String str, int fromIndex)": [[4, 44]]}}}, {"text": "You can use ProcessBuilder, and populate the map returned by the environment() method", "label": {"api": {"ProcessBuilder": [[12, 25]], "environment()": [[65, 77]]}}}, {"text": "Alternatively, you can use Runtime.exec", "label": {"api": {"Runtime.exec": [[27, 38]]}}}, {"text": "See the documentation for toArray()", "label": {"api": {"toArray()": [[26, 34]]}}}, {"text": "You should not use Thread.stop(), Thread.suspend() or Thread.resume()", "label": {"api": {"Thread.stop()": [[19, 31]], "Thread.suspend()": [[34, 49]], "Thread.resume()": [[54, 68]]}}}, {"text": "I would suggest you investigate using a SwingWorker instead, as this is explicitly designed for the sort of thing you're trying to do", "label": {"api": {"SwingWorker": [[40, 50]]}}}, {"text": "From the Scanner.close() documentation", "label": {"api": {"Scanner.close()": [[9, 23]]}}}, {"text": "just use String#replaceAll(regex, str)", "label": {"api": {"String#replaceAll(regex, str)": [[9, 37]]}}}, {"text": "If you test your methods for 'isBridge()', you can filter out the 'wrong' methods (also filters out some strange results you can get with covariance returns)", "label": {"api": {"isBridge()": [[30, 39]]}}}, {"text": "Consider using XPath", "label": {"api": {"XPath": [[15, 19]]}}}, {"text": "The method above uses Class#getEnumConstants to retrieve all the values defined in the enum", "label": {"api": {"Class#getEnumConstants": [[22, 43]]}}}, {"text": "You can get the user's home directory with System.getProperty", "label": {"api": {"System.getProperty": [[43, 60]]}}}, {"text": "regardless of the problem- you should use SwingWorker to do the dirty IO work, and keep the UI responsive", "label": {"api": {"SwingWorker": [[42, 52]]}}}, {"text": "Both Java and ICU provide APIs for finding grapheme clusters (Java calls these \"character breaks\")", "label": {"api": {"Java": [[5, 8], [62, 65]]}}}, {"text": "If you have two String objects, where 1 holds the Date and the other Time, you can combine the 2 Strings and use a SDF to parse it and get the Date object, which you can then convert to DateTime", "label": {"api": {"SDF": [[115, 117]]}}}, {"text": "In fact Map.Entry objects are chained for a given hashcode", "label": {"api": {"Map.Entry": [[8, 16]]}}}, {"text": "You can refer to the PrintStream javadoc for more informations", "label": {"api": {"PrintStream javadoc": [[21, 39]]}}}, {"text": "TaskExecutor is a very simple abstraction that only allows you to execute Runnables not thinking about actual executing strategy", "label": {"api": {"Runnables": [[74, 82]]}}}, {"text": "The resource producer (CDI) for the entity managers (where @H2Database and @OracleDatabase are qualifiers)", "label": {"api": {"qualifiers": [[95, 104]]}}}, {"text": "Feel the difference between java Class (which actually generic too) object and class name", "label": {"api": {"Class": [[33, 37]]}}}, {"text": "Use NumberFormat#getCurrencyInstance that already handles this for you", "label": {"api": {"NumberFormat#getCurrencyInstance": [[4, 35]]}}}, {"text": "If you want to omit the decimal part, just use NumberFormat#setMaximumFractionDigits", "label": {"api": {"NumberFormat#setMaximumFractionDigits": [[47, 83]]}}}, {"text": "Yes there is a one liner, use Arrays.asList(T...a) to convert an array into list and pass it as an argument into the ArrayList overloaded constructor which takes a Collection", "label": {"api": {"Arrays.asList(T...a)": [[30, 49]]}}}, {"text": "Use regular expressions", "label": {"api": {"regular expressions": [[4, 22]]}}}, {"text": "String.matches(regexp) returns true if the string matches the regular expression given as parameter", "label": {"api": {"String.matches(regexp)": [[0, 21]]}}}, {"text": "java.util.Comparator coupled with java.util.Collection.sort should do the trick", "label": {"api": {"java.util.Comparator": [[0, 19]], "java.util.Collection.sort": [[34, 58]], "sort": [[55, 58]]}}}, {"text": "You could also have MyData implement java.util.Comparable and use the other sort method, but that isn't quite as flexible", "label": {"api": {"java.util.Comparable": [[37, 56]], "sort": [[76, 79]]}}}, {"text": "A lot can be gleaned by even just reading the Javadoc for HashSet and HashMap", "label": {"api": {"HashSet": [[58, 64]], "HashMap": [[70, 76]]}}}, {"text": "A HashSet is backed by a HashMap", "label": {"api": {"HashSet": [[2, 8]], "HashMap": [[25, 31]]}}}, {"text": "According to the HashMap Javadoc, it's defined by an initial capacity and load factor", "label": {"api": {"HashMap": [[17, 23]]}}}, {"text": "Use Collections.sort, but I think, you have to write your own Comparator", "label": {"api": {"Collections.sort": [[4, 19]]}}}, {"text": "Use get(int)method to retrieve an element", "label": {"api": {"get(int)": [[4, 11]]}}}, {"text": "Use add(int, E)method to insert an element at an index", "label": {"api": {"add(int, E)": [[4, 14]]}}}, {"text": "See String.split() for details", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "An alternative method would be to use the Comparator interface to dictate exactly how elements are compared, but that would probably amount to converting each String value to an int anyway - making the above approach much more efficient", "label": {"api": {"Comparator": [[42, 51]]}}}, {"text": "I don't see any such methods in the documentation, so I would say NO", "label": {"api": {"in the documentation": [[29, 48]]}}}, {"text": "Implement a SecurityManager1 for the client code", "label": {"api": {"SecurityManager": [[12, 26]]}}}, {"text": "You could try to make a main class which launch your prog using one of the versions of Runtime.exec(...) method", "label": {"api": {"Runtime.exec(...)": [[87, 103]]}}}, {"text": "By this you could use its process' outputStream to transmit to the main program the value each of your processes has computed", "label": {"api": {"process' outputStream": [[26, 46]]}}}, {"text": "By turning this into a one to one producer consumer setup, you can minimize latency, by using the appropriate queuing, like ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[124, 144]]}}}, {"text": "The SwingWorker class seems to be a good candidate for that purpose", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can write the data to a ByteArrayOutputStream and pass that to the caller", "label": {"api": {"ByteArrayOutputStream": [[28, 48]]}}}, {"text": "You need to make it accessible first", "label": {"api": {"make it accessible": [[12, 29]]}}}, {"text": "Character.isLetterOrDigit(int) is only supported in Java 1.5 or newer", "label": {"api": {"Character.isLetterOrDigit(int)": [[0, 29]]}}}, {"text": "with icons, but also offers the IntegrationService that allows the shortcuts to be examined/installed programmatically", "label": {"api": {"IntegrationService": [[32, 49]]}}}, {"text": "Instead of using a for-each loop, use an explicit Iterator object and Iterator.remove()", "label": {"api": {"Iterator.remove()": [[70, 86]]}}}, {"text": "You have to use an Iterator to walk through your list", "label": {"api": {"Iterator": [[19, 26]]}}}, {"text": "InputStream#read only reads a single byte and will not consume the newline character (will be 2 characters, LF and CR on Windows platforms), passing it through to the next read", "label": {"api": {"InputStream#read": [[0, 15]]}}}, {"text": "That being said, if you can get a handle to the memory where the .class file's data resides (after loading the DLL) and pass it to Java as a byte[] or ByteBuffer, you'd then want to use any one of ClassLoader's defineClass overloads along with a call to findLoadedClass and then finally loadClass", "label": {"api": {"ByteBuffer": [[151, 160]], "ClassLoader": [[197, 207]], "findLoadedClass": [[254, 268]], "loadClass": [[287, 295]]}}}, {"text": "Use BigDecimal Instead of a double", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "This works because BigDecimal maintains a \"precision,\" and the BigDecimal(String) constructor sets that from the number of digits to the right of the ., and uses it in toString", "label": {"api": {"BigDecimal": [[19, 28], [63, 72]]}}}, {"text": "I will also add that you can use DecimalFormatSymbols to choose which decimal separator to use", "label": {"api": {"DecimalFormatSymbols": [[33, 52]]}}}, {"text": "If you want to format output, use PrintStream#format(...)", "label": {"api": {"PrintStream#format(...)": [[34, 56]]}}}, {"text": "If you don't want to use PrintStream#format(...), use DecimalFormat#format(...)", "label": {"api": {"PrintStream#format(...)": [[25, 47]], "DecimalFormat#format(...)": [[54, 78]]}}}, {"text": "The easiest way to read a whole file is to use the Files convenience methods, for example", "label": {"api": {"the Files convenience methods": [[47, 75]]}}}, {"text": "You can use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[14, 37]]}}}, {"text": "you should replace your aameThread with a javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[42, 58]]}}}, {"text": "It's smelly, ugly, and I don't like it, but you can use Class#forName() and Class#isInstance(Object)", "label": {"api": {"Class#forName()": [[56, 70]], "Class#isInstance(Object)": [[76, 99]]}}}, {"text": "Class#cast() only gets you compile-time type safety when you've got a Class<T> â€“ but you can only get a Class<?> from Class#forName()", "label": {"api": {"Class#forName()": [[118, 132]]}}}, {"text": "To get the number of bytes your BigInteger instance currently uses, you can make use of the Instrumentation interface, especially getObjectSize(Object)", "label": {"api": {"getObjectSize(Object)": [[130, 150]]}}}, {"text": "Let's try using the constructor that takes a File instead", "label": {"api": {"constructor": [[20, 30]]}}}, {"text": "You don't need regex at all for this, just String#split(\",\") and Integer#parseInt()", "label": {"api": {"String#split(\",\")": [[43, 59]], "Integer#parseInt()": [[65, 82]]}}}, {"text": "Alternatively, the JLabel could also be added at startup, allowing you to call setIcon to update the image", "label": {"api": {"setIcon": [[79, 85]]}}}, {"text": "getServletContext is not method of ServletContext interface", "label": {"api": {"ServletContext": [[3, 16], [35, 48]]}}}, {"text": "It is the method of ServletConfig interface which GenericServlet is implementing and due to this it is available in HttpServlet which is extending GenericServlet", "label": {"api": {"ServletConfig": [[20, 32]], "GenericServlet": [[50, 63], [147, 160]], "HttpServlet": [[116, 126]]}}}, {"text": "ServletContext might be implemented by the Web servers and they might be returning object of that class in GenericServlet", "label": {"api": {"ServletContext": [[0, 13]], "GenericServlet": [[107, 120]]}}}, {"text": "Implement a ServletContextListener that stores the lists in the Application scope in its contextInitialized method", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "When and how strings are interned is described in the String#intern documentation and the JLS Section 3.10.5", "label": {"api": {"String#intern documentation": [[54, 80]]}}}, {"text": "Just invoke Date#getTime()", "label": {"api": {"Date#getTime()": [[12, 25]]}}}, {"text": "Given the following from the Java API Docs for Files.move", "label": {"api": {"Java API Docs": [[29, 41]]}}}, {"text": "Please note that updating the GUI from an other thread is a bad idea, use SwingUtilities.invokeLater to avoid some strange errors/bugs", "label": {"api": {"SwingUtilities.invokeLater": [[74, 99]]}}}, {"text": "You should add the elements to a Set which by definition requires the elements to be unique", "label": {"api": {"Set": [[33, 35]]}}}, {"text": "How about a SynchronousQueue that thread a is waiting to take() from and thread b put()s its result on", "label": {"api": {"SynchronousQueue": [[12, 27]]}}}, {"text": "Following the idea of @PhiLho's answer to How to convert a BufferedImage to 8 bit?, I want to use ColorQuantizerDescriptor to convert a BufferedImage, imageType TYPE_INT_RGB, but RenderedOp#getColorModel() is throwing the following exception", "label": {"api": {"RenderedOp#getColorModel()": [[179, 204]]}}}, {"text": "Take a look at the documentation for the substring() method", "label": {"api": {"substring()": [[41, 51]]}}}, {"text": "What you may want instead is the indexOf() method", "label": {"api": {"indexOf()": [[33, 41]]}}}, {"text": "go to here http://docs.oracle.com/javase/6/docs/api/java/lang/String.html and read to understand", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[11, 72]]}}}, {"text": "This link should be your friend when dealing with date format problems", "label": {"api": {"link": [[5, 8]]}}}, {"text": "KeyEvent class has static fields with these values", "label": {"api": {"KeyEvent": [[0, 7]]}}}, {"text": "For example, KeyEvent.VK_A represent \"A\" key", "label": {"api": {"KeyEvent": [[13, 20]]}}}, {"text": "Take a look here, and use with Properties class", "label": {"api": {"Properties": [[31, 40]]}}}, {"text": "Eventually, you get the type of the fields with the method Field.getType()", "label": {"api": {"Field.getType()": [[59, 73]]}}}, {"text": "You should really make use of a SwingWorker to do the \"heavy\" work on a background Thread", "label": {"api": {"SwingWorker": [[32, 42]]}}}, {"text": "getBytes returns a byte array, and the toString methods of arrays do not display their contents (which can be annoying at times)", "label": {"api": {"getBytes": [[0, 7]]}}}, {"text": "Try Arrays.toString to show the contents of arrays instead", "label": {"api": {"Arrays.toString": [[4, 18]]}}}, {"text": "Use File.exists(), it check wheater you can do something with a file", "label": {"api": {"File.exists()": [[4, 16]]}}}, {"text": "Using a RandomAccessFile to seek, then read your bytes out", "label": {"api": {"RandomAccessFile": [[8, 23]], "seek": [[28, 31]], "read": [[39, 42]]}}}, {"text": "JMS has a QueueReceiver, which, well, receives messages", "label": {"api": {"QueueReceiver": [[10, 22]]}}}, {"text": "You can set a MessageListener to this QueueReceiver to be notified of new messages", "label": {"api": {"QueueReceiver": [[38, 50]]}}}, {"text": "If not, a Map is a good choice for this type of scenario", "label": {"api": {"Map": [[10, 12]]}}}, {"text": "String.indexOf starts searching at the index you provide", "label": {"api": {"String.indexOf": [[0, 13]]}}}, {"text": "Regarding the example provided in the javadoc for Condition, I have a question about the use of", "label": {"api": {"the javadoc for Condition": [[34, 58]]}}}, {"text": "If it is inside a jar, you should use the openStream() method to get access to the contents", "label": {"api": {"openStream()": [[42, 53]]}}}, {"text": "If it is not inside a jar, print the absolute path of the File using getAbsolutePath() and verify if it exists", "label": {"api": {"getAbsolutePath()": [[69, 85]]}}}, {"text": "If you really need this level of precision, you should consider using BigDecimal", "label": {"api": {"BigDecimal": [[70, 79]]}}}, {"text": "From looking through the source code of BMPImageWriter, the mechanism of this is the return value of ColorModel#getPixelSize()", "label": {"api": {"ColorModel#getPixelSize()": [[101, 125]]}}}, {"text": "Have a look at the SimpleDateFormat javadocs for information on which format string to use", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "You might want to use Futures to wait for the result", "label": {"api": {"Futures": [[22, 28]]}}}, {"text": "java.lang.Long is a immutable, the only way is to reassign the modified value to the previous reference", "label": {"api": {"java.lang.Long": [[0, 13]]}}}, {"text": "The documentation of List by Oracle does not seem to shed light on the above", "label": {"api": {"documentation of List": [[4, 24]]}}}, {"text": "The following quoted specification that may answer the question, has been found in the documentation of java.util.AbstractList class (and a bit surprisingly, not in documentation of java.util.List)", "label": {"api": {"documentation of java.util.AbstractList class": [[87, 131]]}}}, {"text": "The answer is found, unsurprisingly, in the Javadoc for the List interface", "label": {"api": {"List": [[60, 63]]}}}, {"text": "True if the next read() is guaranteed not to block for input, false otherwise", "label": {"api": {"read()": [[17, 22]]}}}, {"text": "In the Java land, there is the Comparable<E> interface", "label": {"api": {"interface": [[45, 53]]}}}, {"text": "Then you must implement a method compareTo", "label": {"api": {"compareTo": [[33, 41]]}}}, {"text": "With this property clearly defined you can use Collections.sort utility to sort your collection", "label": {"api": {"Collections.sort": [[47, 62]]}}}, {"text": "Before printing, add each line to a sorted set, as a TreeSet", "label": {"api": {"TreeSet": [[53, 59]]}}}, {"text": "You could use Set.containsAll(Collection) link to API to check if one set is contained in the other", "label": {"api": {"link to API": [[42, 52]]}}}, {"text": "I did some research on extra mouse buttons and found another Oracle page talking about Desktop Properties", "label": {"api": {"Desktop Properties": [[87, 104]]}}}, {"text": "Java's Font API documentation", "label": {"api": {"Java's Font API documentation": [[0, 28]]}}}, {"text": "String.contains does not interpret the argument as regex", "label": {"api": {"String.contains": [[0, 14]]}}}, {"text": "You can use Java Random class", "label": {"api": {"Random": [[17, 22]]}}}, {"text": "Try giving the full qualified name, which is needed by the method", "label": {"api": {"method": [[59, 64]]}}}, {"text": "You can add your db cleanup code in contextInitialized() method", "label": {"api": {"contextInitialized()": [[36, 55]]}}}, {"text": "If yes, then how do I do the conversion from Joda-Time to Date and vice versa", "label": {"api": {"Date": [[58, 61]]}}}, {"text": "You can do this with java.io.File, by using the constructor which takes a File and a String as arguments, will interpret the String as a relative path to the File", "label": {"api": {"java.io.File": [[21, 32]]}}}, {"text": "Or with java.net.URL, you can send an URL and a String to the constructur, which will interpret the URL as a context for the String parameter", "label": {"api": {"java.net.URL": [[8, 19]]}}}, {"text": "Using Arrays.copyOf(int[], int)", "label": {"api": {"Arrays.copyOf(int[], int)": [[6, 30]]}}}, {"text": "Probably the most straightforward is using a ScheduledExecutionService, which will give you a Future that you can wait on, in a way similar to the join method you're used to", "label": {"api": {"ScheduledExecutionService": [[45, 69]]}}}, {"text": "Another way would be to use a CountDownLatch to have each timer task decrement the latch when it is done; you can then wait for them to finish by using await", "label": {"api": {"CountDownLatch": [[30, 43]]}}}, {"text": "To get around that, look to wrap the call in a PrivilegedAction", "label": {"api": {"PrivilegedAction": [[47, 62]]}}}, {"text": "You can use java.util.Random class to generate random numbers", "label": {"api": {"java.util.Random": [[12, 27]]}}}, {"text": "Also consider Collections.shuffle(), illustrated here for List<JLabel> and here for List<Icon>", "label": {"api": {"Collections.shuffle()": [[14, 34]]}}}, {"text": "I have seen some libraries using UnsupportedOperationException for this", "label": {"api": {"UnsupportedOperationException": [[33, 61]]}}}, {"text": "Unfortunately the File.delete() method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "label": {"api": {"File.delete()": [[18, 30]]}}}, {"text": "Java 7 introduced the new java.nio.file package which is a much more robust file access API", "label": {"api": {"java.nio.file": [[26, 38]]}}}, {"text": "It provides the concept of an abstract Path and separates concrete operations into the Files class, in particular it provides Files.delete() which is documented to raise clear exceptions describing the reasons deletion might fail", "label": {"api": {"Path": [[39, 42]], "Files": [[87, 91], [126, 130]], "Files.delete()": [[126, 139]]}}}, {"text": "Use Path and Files; you'll be glad you did", "label": {"api": {"Path": [[4, 7]], "Files": [[13, 17]]}}}, {"text": "Making use of Java 5's Exchanger class, the solution gets pretty small", "label": {"api": {"Exchanger": [[23, 31]]}}}, {"text": "I ended up with a single Runnable class", "label": {"api": {"Runnable": [[25, 32]]}}}, {"text": "The Exchanger class facilitates the passing around of the boolean values in a thread safe manner", "label": {"api": {"Exchanger": [[4, 12]]}}}, {"text": "A Runnable only 'executes' its code when it has the boolean true value", "label": {"api": {"Runnable": [[2, 9]]}}}, {"text": "Use Timer for your background process' timing", "label": {"api": {"Timer": [[4, 8]]}}}, {"text": "To put your GUI code in EDT, use SwingUtilities class", "label": {"api": {"SwingUtilities": [[33, 46]]}}}, {"text": "This is a case where LinkedHashMap is appropriate, overriding the removeEldestEntry() method", "label": {"api": {"LinkedHashMap": [[21, 33]]}}}, {"text": "player1 and player2 are ints and not Integers (which is a Java Class)", "label": {"api": {"Integers": [[37, 44]]}}}, {"text": "You can also cast them as Integers", "label": {"api": {"Integers": [[26, 33]]}}}, {"text": "You can read this topic to learn more about autoboxing of Integers", "label": {"api": {"Integers": [[58, 65]]}}}, {"text": "use the sort method of java Collections class, pass it a Comparator to order (in ascending order) the mark and then count until you find that mark is greater then your threshold", "label": {"api": {"sort": [[8, 11]], "Comparator": [[57, 66]]}}}, {"text": "For more information look at oracle documentation", "label": {"api": {"oracle documentation": [[29, 48]]}}}, {"text": "You can implement Comparable interface (http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html) with your Student class and then to use Collections (http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html) class to use max and min functions to get the max and the min grade values", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html": [[40, 105]], "http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html": [[161, 231]]}}}, {"text": "For example, Collection returns a boolean value if it was changed as a result of the operation", "label": {"api": {"Collection": [[13, 22]]}}}, {"text": "Another example of this is AtomicBoolean", "label": {"api": {"AtomicBoolean": [[27, 39]]}}}, {"text": "To make sure the user has an idea about that would happen this time after pressing your button, I would suggest to change the button label or even icon depending on the context (JButton.setText)", "label": {"api": {"JButton.setText": [[178, 192]]}}}, {"text": "Use a List", "label": {"api": {"List": [[6, 9]]}}}, {"text": "That's what Lists are for", "label": {"api": {"List": [[12, 15]]}}}, {"text": "There is no dynamic allocation in Java, Lists are here on this purpose", "label": {"api": {"Lists": [[40, 44]]}}}, {"text": "Take a look at the method Thread#join()", "label": {"api": {"Thread#join()": [[26, 38]]}}}, {"text": "My opinion is that you should use CountDownLatch", "label": {"api": {"CountDownLatch": [[34, 47]]}}}, {"text": "From the parameter documentation", "label": {"api": {"parameter documentation": [[9, 31]]}}}, {"text": "One solution is to split the String according to", "label": {"api": {"split": [[19, 23]]}}}, {"text": "example.split(\":\")[1] will contain 123456 xy bla bla bla and then we split according to a whitespace, and return the first element, which will contain 123456", "label": {"api": {"split": [[8, 12], [69, 73]]}}}, {"text": "Just let JSF/EL conditionally print the class based on FacesContext#isValidationFailed()", "label": {"api": {"FacesContext#isValidationFailed()": [[55, 87]]}}}, {"text": "You can use Graphics and draw lines", "label": {"api": {"Graphics": [[12, 19]]}}}, {"text": "I would reccomend making disease a Set of Strings", "label": {"api": {"Set": [[35, 37]]}}}, {"text": "Sets are \"better\", in this case, than other Collections because they cannot hold duplicates", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "You may be interested on the collections provided by the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[57, 76]]}}}, {"text": "You may try using the session.getId() value as key", "label": {"api": {"session.getId()": [[22, 36]]}}}, {"text": "You're using the POST method to send the data to the server, so you need to override the doPost method instead of the doGet method you are now in", "label": {"api": {"doPost": [[89, 94]]}}}, {"text": "As suggested by xav, it is advisable to use ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[44, 57]]}}}, {"text": "As specified in documenation for Collections.binarySearch", "label": {"api": {"documenation for Collections.binarySearch": [[16, 56]]}}}, {"text": "parseLong exists as well", "label": {"api": {"parseLong": [[0, 8]]}}}, {"text": "Or even better, use ProcessBuilder along with ProcessBuilder.directory() instead", "label": {"api": {"ProcessBuilder": [[20, 33], [46, 59]], "ProcessBuilder.directory()": [[46, 71]]}}}, {"text": "Note that Arrays.fill() exists, but will only get you halfway, since it won't fill multidimensional arrays", "label": {"api": {"Arrays.fill()": [[10, 22]]}}}, {"text": "Look at RandomAccessFile", "label": {"api": {"RandomAccessFile": [[8, 23]]}}}, {"text": "The RandomAccessFile methods exist", "label": {"api": {"RandomAccessFile": [[4, 19]]}}}, {"text": "The use of the TimeUnit class simplifies the maths", "label": {"api": {"TimeUnit": [[15, 22]]}}}, {"text": "The general solution is to call KeyEvent.getExtendedKeyCodeForChar(int c)", "label": {"api": {"KeyEvent.getExtendedKeyCodeForChar(int c)": [[32, 72]]}}}, {"text": "There is javacardx.framework.math package in JavaCard API since 2.2.2 with limited functionality (add, subtract, multiply only)", "label": {"api": {"javacardx.framework.math": [[9, 32]]}}}, {"text": "JCAlgTest now also provides results for all JavaCard packages including all versions as supported by cards in the database (including the javacardx.framework.math)", "label": {"api": {"javacardx.framework.math": [[138, 161]]}}}, {"text": "If your problem is just the spacing around the components, set its Insets", "label": {"api": {"Insets": [[67, 72]]}}}, {"text": "you need to flush the written data, close your FileWriter", "label": {"api": {"flush": [[12, 16]], "close": [[36, 40]]}}}, {"text": "Also, use BufferedWriter or PrintWriter instead as they are highly efficient and evolved than FileWriter", "label": {"api": {"BufferedWriter": [[10, 23]], "PrintWriter": [[28, 38]]}}}, {"text": "It's good to read the Iterator interface doc to undestand the way you need to implement it and start from there", "label": {"api": {"Iterator interface doc": [[22, 43]]}}}, {"text": "It may be more elegant to produce a class to hold your two values and ensure that implements Comparable, as shown below", "label": {"api": {"Comparable": [[93, 102]]}}}, {"text": "You could use BigDecimal", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "Create a BigDecimal with your double value then check the scale with bigDVariable.scale() and round with the wanted scale depending on the value returned by it and its value", "label": {"api": {"BigDecimal": [[9, 18]]}}}, {"text": "You could use a HashMap instead of the HashTable (which is obsolete) and a for-each loop", "label": {"api": {"HashMap": [[16, 22]]}}}, {"text": "You should definitely also consider using some of the newer collection classes (like HashMap, for example)", "label": {"api": {"HashMap": [[85, 91]]}}}, {"text": "To add rooms to your rooms ArrayList, just do something like that (don't forget to check the ArrayList API, http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html": [[108, 172]]}}}, {"text": "I guess you want to just read a binary file and FileInputStream should suffice", "label": {"api": {"FileInputStream": [[48, 62]]}}}, {"text": "which uses the Supplier<T> functional interface", "label": {"api": {"Supplier<T>": [[15, 25]]}}}, {"text": "Looking at the NavigableSet and TreeSet apis I found a method that gives the descending iterator so creating a new set in reverse order is not necessary", "label": {"api": {"NavigableSet": [[15, 26]], "TreeSet": [[32, 38]]}}}, {"text": "The above was with the wrong assumption that news was of Type TreeSet not the correct TreeMap", "label": {"api": {"TreeSet": [[62, 68]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html#accept() for a description of ServerSocket.accept()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html#accept()": [[4, 79]]}}}, {"text": "You can use the classes from the java.io and java.nio packages to", "label": {"api": {"java.io": [[33, 39]], "java.nio": [[45, 52]]}}}, {"text": "A BufferedReader can read line by line your file", "label": {"api": {"BufferedReader": [[2, 15]]}}}, {"text": "The splitting of columns in this special case can be done by the split method of the String class", "label": {"api": {"split": [[4, 8], [65, 69]], "String": [[85, 90]]}}}, {"text": "For the splitting the usage of Google's Guava library might also be of big help for string splitting", "label": {"api": {"split": [[8, 12], [91, 95]]}}}, {"text": "Handling of the numbers can be achieved by using the wrapper classes like Long, Integer and so on, especially the static methods valueOf in the respective classes", "label": {"api": {"Long": [[74, 77]], "Integer": [[80, 86]]}}}, {"text": "Have a look at the Groups and capturing section in this document", "label": {"api": {"document": [[56, 63]]}}}, {"text": "If a list is required, you can choose a LinkedList", "label": {"api": {"LinkedList": [[40, 49]]}}}, {"text": "With the LinkedList you would get a much better performance for random adding/removing", "label": {"api": {"LinkedList": [[9, 18]]}}}, {"text": "Let java.util.Calendar do this work for you", "label": {"api": {"java.util.Calendar": [[4, 21]]}}}, {"text": "I'm guessing that the behavior that you're experiencing is due to the contract implied in the new String(String original) constructor, which indicates that it creates a new object (see http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#String(java.lang.String))", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#String(java.lang.String)": [[185, 275]]}}}, {"text": "GroupLayout is very popular", "label": {"api": {"GroupLayout": [[0, 10]]}}}, {"text": "If your values are unique, you can use a TreeMap, which implements NavigableMap, which has the nice ceilingKey and floorKey methods", "label": {"api": {"TreeMap": [[41, 47]], "NavigableMap": [[67, 78]]}}}, {"text": "You'll want to use a Comparator", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "The ^ character has special meanings in regular expressions; provide a backslash character (which itself needs to be escaped in Java), so that split interprets it as a literal ^", "label": {"api": {"special meanings in regular expressions": [[20, 58]]}}}, {"text": "Map is an interface, and HashMap is an implementation of it", "label": {"api": {"Map": [[0, 2], [29, 31]], "HashMap": [[25, 31]]}}}, {"text": "They're interchangeable in only one direction, meaning that anywhere you can use a Map, you can use a HashMap instead", "label": {"api": {"Map": [[83, 85], [106, 108]], "HashMap": [[102, 108]]}}}, {"text": "It goes much beyond that, though, because Map expresses all the operations that any kind of \"map\" must provide, whether it's a hash-based map (HashMap), a sorting map (TreeMap), a thread-safe map (ConcurrentMap), or an immutable map (ImmutableMap from Guava)", "label": {"api": {"Map": [[42, 44], [147, 149], [172, 174], [207, 209], [243, 245]], "HashMap": [[143, 149]], "TreeMap": [[168, 174]], "ConcurrentMap": [[197, 209]]}}}, {"text": "Any of those different kinds of maps, and more, can be used wherever a Map is called for", "label": {"api": {"Map": [[71, 73]]}}}, {"text": "Map itself doesn't provide any of the actual working code", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "You should not use FileReader in a case like this, as it does not let you specify input encoding", "label": {"api": {"FileReader": [[19, 28]]}}}, {"text": "Construct an InputStreamReader on a FileInputStream", "label": {"api": {"InputStreamReader": [[13, 29]], "FileInputStream": [[36, 50]]}}}, {"text": "take a look at Thread Local , it makes you carry a parameter with thread being its own local variable", "label": {"api": {"Thread Local": [[15, 26]]}}}, {"text": "Simply use ImageIO for reading/writing and maybe encoding", "label": {"api": {"ImageIO": [[11, 17]]}}}, {"text": "Yup, it's behaving as documented", "label": {"api": {"documented": [[22, 31]]}}}, {"text": "Then, you can create a custom DecimalFormat to parse each", "label": {"api": {"DecimalFormat": [[30, 42]]}}}, {"text": "If you are manipulating text data, you should better use a FileWriter which has convenient append methods", "label": {"api": {"FileWriter": [[59, 68]]}}}, {"text": "java.util.Observer most definitely is an interface", "label": {"api": {"java.util.Observer": [[0, 17]]}}}, {"text": "You could use a StringBuilder in the same way you are printing to the console", "label": {"api": {"StringBuilder": [[16, 28]]}}}, {"text": "Look at the java.lang.Math class, there are min and max methods there that will help simplify the math", "label": {"api": {"java.lang.Math": [[12, 25]], "min": [[44, 46]], "max": [[52, 54]]}}}, {"text": "You could check to see if Thread#getState() has a TIMED_WAITING state", "label": {"api": {"Thread#getState()": [[26, 42]]}}}, {"text": "No, but you can create your own Observer for object", "label": {"api": {"Observer": [[32, 39]]}}}, {"text": "In Java it can be achieved with extending Observable class or implementing Observer interface", "label": {"api": {"Observable": [[42, 51]], "Observer": [[75, 82]]}}}, {"text": "Second parameter is not a length, it is an end index", "label": {"api": {"an end index": [[40, 51]]}}}, {"text": "You need to read the documentation for substring - the second parameter isn't a length, it's the end index (exclusive)", "label": {"api": {"the documentation for substring": [[17, 47]]}}}, {"text": "As specified in BitSet#nextSetBit(int) javadocs", "label": {"api": {"BitSet#nextSetBit(int)": [[16, 37]]}}}, {"text": "In Java, the correct data structure for this would be a Map", "label": {"api": {"Map": [[56, 58]]}}}, {"text": "EDIT for choosing a String randomly out of an String array you can use java.util.Random API .For Example here is an array of String and each time the JFrame is closed , a String is picked out randomly out of this array and printed in method callMeBeforeExit", "label": {"api": {"java.util.Random": [[71, 86]]}}}, {"text": "Make your Product class implement the Comparable interface", "label": {"api": {"Comparable": [[38, 47]]}}}, {"text": "This way, you can implement the compareTo method which is the base for the sorting operation", "label": {"api": {"compareTo": [[32, 40]]}}}, {"text": "Implement your very own Comparator", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "A comparator defines a comparation method that takes two elements as a base and compares them in the same way that compareTo does", "label": {"api": {"compareTo": [[115, 123]]}}}, {"text": "The advantage here is that you can switch ordering criteria by ordering with a different Comparator", "label": {"api": {"Comparator": [[89, 98]]}}}, {"text": "Finally, the sorting can be performed by the use of any of the overloads of Collections#sort that takes your collection as an argument and a Comparator if you decide to use one", "label": {"api": {"Comparator": [[141, 150]]}}}, {"text": "Try ObjectInputStream instead", "label": {"api": {"ObjectInputStream": [[4, 20]]}}}, {"text": "On the server you're using ObjectOutputStream, so the corresponding ObjectInputStream should be used on the client", "label": {"api": {"ObjectInputStream": [[68, 84]]}}}, {"text": "You should use a normal JSF Validator", "label": {"api": {"Validator": [[28, 36]]}}}, {"text": "Any ValidatorException which you throw from that will end up in the right message component", "label": {"api": {"Validator": [[4, 12]]}}}, {"text": "You should use println to print a newline character after each line", "label": {"api": {"println": [[15, 21]]}}}, {"text": "If the number is in the long range, use Long.highestOneBit()", "label": {"api": {"Long.highestOneBit()": [[40, 59]]}}}, {"text": "Alternatively, BigInteger has a bitLength() method", "label": {"api": {"bitLength()": [[32, 42]]}}}, {"text": "Saxon diverts errors to a javax.xml.transform.ErrorListener object", "label": {"api": {"javax.xml.transform.ErrorListener": [[26, 58]]}}}, {"text": "If you don't want to use stderr for anything in the program though, it might be better to just redirect it program-wide using System.setErr", "label": {"api": {"System.setErr": [[126, 138]]}}}, {"text": "It takes a PrintStream object, which you can potentially wrap around any type of output/stream, so I'm sure it can work for your custom logging mechanism", "label": {"api": {"PrintStream": [[11, 21]]}}}, {"text": "You can look up the method being called in http://docs.oracle.com/javase/6/docs/api/java/io/package-summary.html and see what exceptions it can throw, for example", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/package-summary.html": [[43, 111]]}}}, {"text": "Take a look at the RGBImageFilter class, that does exactly what you want", "label": {"api": {"RGBImageFilter": [[19, 32]]}}}, {"text": "Ruby doesn't have all the flags that Java does, so you'll need to watch out for those", "label": {"api": {"the flags": [[22, 30]]}}}, {"text": "You can make use of TreeMap, if you wish", "label": {"api": {"TreeMap": [[20, 26]]}}}, {"text": "As stated in my comment, in order to not deal with Scanner wrong read, it would be better to use Scanner#nextLine() and read the data as String, then try to parse it as double using Double#parseDouble(String) since this method already throws NumberFormatException and you can handle this error", "label": {"api": {"Scanner#nextLine()": [[97, 114]], "Double#parseDouble(String)": [[182, 207]], "NumberFormatException": [[242, 262]]}}}, {"text": "I want to convert HashMap to json array my code is as follow", "label": {"api": {"HashMap": [[18, 24]]}}}, {"text": "TableUI would be the class that could define the look and feel", "label": {"api": {"TableUI": [[0, 6]]}}}, {"text": "Since your elements are strings, Collections.max() is returning the value that's the largest lexicographically", "label": {"api": {"Collections.max()": [[33, 49]]}}}, {"text": "If you wish to compare the strings numerically, you need to use the two-argument version of Collections.max() and supply an appropriate comparator", "label": {"api": {"Collections.max()": [[92, 108]]}}}, {"text": "I think you can use System.setOut(PrintStream) to set your output to a file output stream", "label": {"api": {"System.setOut(PrintStream)": [[20, 45]]}}}, {"text": "Your server seems to be unreachable", "label": {"api": {"unreachable": [[24, 34]]}}}, {"text": "You can use java.net.NetworkInterface for that, here's a simple example no how to do it", "label": {"api": {"java.net.NetworkInterface": [[12, 36]]}}}, {"text": "From the Socket Javadoc", "label": {"api": {"Socket Javadoc": [[9, 22]]}}}, {"text": "I would use a Timer to achieve this", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "See the documentation of this method to understand how one is selected", "label": {"api": {"this method": [[25, 35]]}}}, {"text": "The Cipher Javadocs explains the purpose of this argument", "label": {"api": {"Cipher Javadocs": [[4, 18]]}}}, {"text": "Also, Hashtable is somewhat obsolete and HashMap is preferred in most situations", "label": {"api": {"HashMap": [[41, 47]]}}}, {"text": "\\Q and \\E, among all others, are thoroughly documented on the java.util.regex.Pattern Javadoc page", "label": {"api": {"java.util.regex.Pattern": [[62, 84]]}}}, {"text": "Perhaps I'm going about this the wrong way but I'm missing some absolute put methods on ByteBuffer", "label": {"api": {"ByteBuffer": [[88, 97]]}}}, {"text": "If you look at ByteBuffer you'll see that most of the put methods have both an absolute and a relative variant", "label": {"api": {"ByteBuffer": [[15, 24]]}}}, {"text": "Writing parts of a byte array into the ByteBuffer", "label": {"api": {"ByteBuffer": [[39, 48]]}}}, {"text": "Writing a ByteBuffer into the ByteBuffer", "label": {"api": {"ByteBuffer": [[10, 19], [30, 39]]}}}, {"text": "To be clear ByteBuffer has methods", "label": {"api": {"ByteBuffer": [[12, 21]]}}}, {"text": "Incedentially ByteBuffer is also missing an absolute get method for partial byte array move", "label": {"api": {"ByteBuffer": [[14, 23]]}}}, {"text": "Unfortunately, the slice method does not take a position parameter either; instead it uses the current position of the original buffer", "label": {"api": {"slice": [[19, 23]]}}}, {"text": "If it fits with the way you're using the buffer, you can prepare a copy of the buffer with slice() and keep that around for when you need to put data at a position independent of the original's position", "label": {"api": {"slice": [[91, 95]]}}}, {"text": "That won't work to put at an earlier position, unfortunately, since the position on the slice is not allowed to be negative", "label": {"api": {"slice": [[88, 92]]}}}, {"text": "Never mind, I forgot about the duplicate method", "label": {"api": {"duplicate": [[31, 39]]}}}, {"text": "You could just split the String or use a StringTokenizer", "label": {"api": {"split": [[15, 19]], "StringTokenizer": [[41, 55]]}}}, {"text": "Check Node API document to see what type of nodes will return null for getNodeValue", "label": {"api": {"Node API document": [[6, 22]]}}}, {"text": "You can use Java's support for format strings to automatically pad the name field and give it a maximum width, thus aligning all of your scores in the same column", "label": {"api": {"format strings": [[31, 44]]}}}, {"text": "Set your DocumentBuilderFactor to be name space aware, and implement your own NameSpaceContext", "label": {"api": {"DocumentBuilderFactor": [[9, 29]], "name space awar": [[37, 51]], "NameSpaceContext": [[78, 93]]}}}, {"text": "Then you can create a ByteBuffer that directly accesses the shared memory using NewDirectByteBuffer like this", "label": {"api": {"ByteBuffer": [[22, 31], [89, 98]]}}}, {"text": "Now you can just create a ByteBuffer that is backed by this shared memory", "label": {"api": {"ByteBuffer": [[26, 35]]}}}, {"text": "You can use SimpleDateFormat to format your date", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "I believe you are looking for String#indexOf(String)", "label": {"api": {"String#indexOf(String)": [[30, 51]]}}}, {"text": "That's because there is no OutOfMemoryException in Java; there is OutOfMemoryError", "label": {"api": {"OutOfMemoryError": [[66, 81]]}}}, {"text": "Instead of rolling your own concurrency, I strongly recommend using ScheduledExecutor.schedule() to do this", "label": {"api": {"ScheduledExecutor.schedule()": [[68, 95]]}}}, {"text": "If you're doing something quick and/or something that requires you to update a UI when you reach the target time, you want to use a Java Swing Timer", "label": {"api": {"Java Swing Timer": [[132, 147]]}}}, {"text": "Class.forName() only accepts fully-qualified names", "label": {"api": {"Class.forName()": [[0, 14]]}}}, {"text": "You need to set the content type of the JTextPane to \"text/html\" JEditorPane API", "label": {"api": {"JEditorPane API": [[65, 79]]}}}, {"text": "However, using standard POST and form data, via exchange.setRequestContentType(\"multipart/form-data\"); and obtain those values using HttpServletRequest.getParameter(\"Content\"), etc.", "label": {"api": {"HttpServletRequest.getParameter(\"Content\")": [[133, 174]]}}}, {"text": "Then you can return a sub-list of the largest courses", "label": {"api": {"sub-list": [[22, 29]]}}}, {"text": "KeyEvent.VK_META, with key code 157, is Java's virtual key that maps to the the Mac command key", "label": {"api": {"KeyEvent.VK_META": [[0, 15]]}}}, {"text": "Use a ClassLoader", "label": {"api": {"ClassLoader": [[6, 16]]}}}, {"text": "Once you have a URL for the image you can turn that in to an InputStream if you need to", "label": {"api": {"URL": [[16, 18]], "InputStream": [[61, 71]]}}}, {"text": "Take a look at java.text.SimpleDateFormat for additional details on patterns", "label": {"api": {"java.text.SimpleDateFormat": [[15, 40]]}}}, {"text": "You can also try DatatypeConverter.parseDateTime which returns a java.util.Calendar object", "label": {"api": {"DatatypeConverter.parseDateTime": [[17, 47]]}}}, {"text": "The getField method will only find the field if it's public", "label": {"api": {"getField": [[4, 11]]}}}, {"text": "You will need to use the getDeclaredField method instead, which will find any field that is declared directly on the class, even if it's not public", "label": {"api": {"getDeclaredField": [[25, 40]]}}}, {"text": "Comparable is an interface, not a class", "label": {"api": {"Comparable": [[0, 9]]}}}, {"text": "You cannot put throws IOException in the run method because the Runnable interface does not say that the run method throws any checked exceptions", "label": {"api": {"Runnable": [[64, 71]]}}}, {"text": "Usually this error message means your servlet doesn't have doPost() overridden", "label": {"api": {"doPost": [[59, 64]]}}}, {"text": "See the doPost docs", "label": {"api": {"doPost": [[8, 13]]}}}, {"text": "If you go with a AWT layout, GridBagLayout gives you the most control", "label": {"api": {"GridBagLayout": [[29, 41]]}}}, {"text": "Instead of trying to get ahold of the input data from a separate batch file, you could just use Java's Runtime class to execute a command using the inputs as arguments", "label": {"api": {"Runtime": [[103, 109]], "execute a command": [[120, 136]]}}}, {"text": "You can use Object#getClass to get the object's actual class, then compare that to KillXEnemies.class", "label": {"api": {"Object#getClass": [[12, 26]]}}}, {"text": "It's likely they'll just state that 0e-59 is still zero, so not a bug, or that the rather complex behaviour being described on the BigDecimal documentation page is working as intended", "label": {"api": {"BigDecimal documentation page": [[131, 159]]}}}, {"text": "You could use Integer.toStringint i, int radix) to convert each of your numbers into a string in hexadecimal, and then concatenate them together", "label": {"api": {"Integer.toStringint i, int radix)": [[14, 46]]}}}, {"text": "Refer to Integer's toHexString", "label": {"api": {"toHexString": [[19, 29]]}}}, {"text": "Have a look at http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html": [[15, 84]]}}}, {"text": "The newer Path class from NIO2 (available in Java 7 and later) however was explicitly designed with virtual file systems in mind", "label": {"api": {"newer Path class": [[4, 19]]}}}, {"text": "Look at this tutorial and the FileSystemProvider class to find out how to define your own virtual file system", "label": {"api": {"the FileSystemProvider class": [[26, 53]]}}}, {"text": "Consider to use a Stream approach", "label": {"api": {"a Stream approach": [[16, 32]]}}}, {"text": "Use a threadpool with lots of threads -- maybe 100 or more -- because they'll be spending most of their time waiting for the creat to complete", "label": {"api": {"threadpool": [[6, 15]]}}}, {"text": "Use a TreeMap", "label": {"api": {"TreeMap": [[6, 12]]}}}, {"text": "There is the Detecting System.setProperty method invocations question about implementing a custom java.lang.SecurityManager which I am looking into now, but I don't still understand how the WAR file can influence the 3rd-party-ejb.jar behavior", "label": {"api": {"java.lang.SecurityManager": [[98, 122]]}}}, {"text": "Convert the start time (date / time) to a Calendar instance", "label": {"api": {"Calendar": [[42, 49]]}}}, {"text": "Convert the end time (date / time) to a Calendar instance", "label": {"api": {"Calendar": [[40, 47]]}}}, {"text": "Use the Calendar after and before methods to determine if the time (date / time) entered is in between the start time and end time", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "if you want to add items as you iterate, you'll want to use a ListIterator", "label": {"api": {"ListIterator": [[62, 73]]}}}, {"text": "If you need to iterate and add concurrently to your list, you should use a concurrent list, such as CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[100, 119]]}}}, {"text": "See the isName() documentation", "label": {"api": {"isName()": [[8, 15]]}}}, {"text": "From API doc for TransformerFactory.html#newInstance(), we can see that there are several ways to achieve this", "label": {"api": {"TransformerFactory.html#newInstance()": [[17, 53]]}}}, {"text": "This reason is in the JavaDoc for LogRecord", "label": {"api": {"LogRecord": [[34, 42]]}}}, {"text": "Note that if the client application has not specified an explicit source method name and source class name, then the LogRecord class will infer them automatically when they are first accessed (due to a call on getSourceMethodName or getSourceClassName) by analyzing the call stack", "label": {"api": {"LogRecord": [[117, 125]]}}}, {"text": "The call stack in this case ends at a method defined by SuperClass, so the LogRecord assumes that it's the class being invoked", "label": {"api": {"LogRecord": [[75, 83]]}}}, {"text": "It appears that you'll have to implement your own Formatter class, and specify it using the java.util.logging.ConsoleHandler.formatter property", "label": {"api": {"Formatter": [[50, 58]]}}}, {"text": "Calling nf.format() returns a String which you can see from the documentation", "label": {"api": {"from the documentation": [[55, 76]]}}}, {"text": "You can use JavaFX in Swing applications via the JFXPanel control", "label": {"api": {"JFXPanel": [[49, 56]]}}}, {"text": "To add items to a TreeView that was created via the FXMLLoader you can use the setRoot() function", "label": {"api": {"setRoot()": [[79, 87]]}}}, {"text": "If you're going to set the month and the year, then when you set the day, use DAY_OF_MONTH instead of DAY_OF_YEAR", "label": {"api": {"DAY_OF_MONTH": [[78, 89]]}}}, {"text": "Check out the links above, and the java.sql code as well as general research on relational databases", "label": {"api": {"java.sql": [[35, 42]]}}}, {"text": "You can do something like this using Properties", "label": {"api": {"Properties": [[37, 46]]}}}, {"text": "The idea is in the usage of DatabaseMetaData and check type against it (as Hibernate detects dialect)", "label": {"api": {"DatabaseMetaData": [[28, 43]]}}}, {"text": "You can use StringBuilder.insertâ€‹(int offset, String str) to achieve this", "label": {"api": {"StringBuilder.insertâ€‹(int offset, String str)": [[12, 56]]}}}, {"text": "You can initialize it by calling the getGraphics() method that Applet inherits from Component", "label": {"api": {"getGraphics()": [[37, 49]]}}}, {"text": "you can use Collections.reverseOrder() to obtain a Comparator in reverse of a given one", "label": {"api": {"Collections.reverseOrder()": [[12, 37]]}}}, {"text": "substring method has been utilized here", "label": {"api": {"substring": [[0, 8]]}}}, {"text": "Since all of your lines are the same size you could look at the skip() method in the BufferedReader", "label": {"api": {"skip()": [[64, 69]]}}}, {"text": "Use LineNumberReader which is intended for this very purpose", "label": {"api": {"LineNumberReader": [[4, 19]]}}}, {"text": "I would use the Desktop or BasicService API", "label": {"api": {"Desktop": [[16, 22]], "BasicService": [[27, 38]]}}}, {"text": "As noted in the BasicService demo", "label": {"api": {"BasicService": [[16, 27]]}}}, {"text": "BasicService.showDocument(another.jnlp)) will be handed directly to JavaWS, with no browser window appearing", "label": {"api": {"BasicService": [[0, 11]]}}}, {"text": "I expect this has always been true of the Desktop API, given the JWS client is the default consumer for that file type", "label": {"api": {"Desktop": [[42, 48]]}}}, {"text": "I've utilized methods setConnectTimeout() and setReadTimeout() from the URLConnection class to my favor, however I lack full understanding of their impact, now say I specify a value of 10 seconds for both", "label": {"api": {"URLConnection": [[72, 84]]}}}, {"text": "NotNull is EE6 standard", "label": {"api": {"NotNull": [[0, 6]]}}}, {"text": "You need to use the return value of executeUpdate()", "label": {"api": {"executeUpdate()": [[36, 50]]}}}, {"text": "Since executeUpdate() returns an int;  the number of entities updated or deleted you can use it to solve your problem", "label": {"api": {"executeUpdate()": [[6, 20]]}}}, {"text": "Is there any way to check if an async ServletRequest is completed from an AsyncContext", "label": {"api": {"AsyncContext": [[74, 85]]}}}, {"text": "System.in.read() reads from the standard input", "label": {"api": {"System.in.read()": [[0, 15]]}}}, {"text": "In particular, a PropertyChangeListener, illustrated here, may be a useful approach to loose coupling", "label": {"api": {"PropertyChangeListener": [[17, 38]]}}}, {"text": "You can convert an entry from the array into a number using Integer.parseInt or Long.parseLong as appropriate", "label": {"api": {"Integer.parseInt": [[60, 75]], "Long.parseLong": [[80, 93]]}}}, {"text": "If you are using transaction demarcation you can use TransactionAttributeType.html#REQUIRES_NEW", "label": {"api": {"TransactionAttributeType.html#REQUIRES_NEW": [[53, 94]]}}}, {"text": "You can use String.split()", "label": {"api": {"String.split()": [[12, 25]]}}}, {"text": "I also use String.trim() to remove leading and trailing spaces around the question and the answer before comparing them", "label": {"api": {"String.trim()": [[11, 23]]}}}, {"text": "You could, however, maintain a Map that maps String identifiers to their corresponding Beings", "label": {"api": {"Map": [[31, 33]]}}}, {"text": "Apparently there is no writeUTF defined for java.io.OutputStream", "label": {"api": {"java.io.OutputStream": [[44, 63]]}}}, {"text": "You should probably declare outstream as DataOutputStream reference", "label": {"api": {"DataOutputStream": [[41, 56]]}}}, {"text": "as the method writeUTF is defined for DataOutputStream", "label": {"api": {"DataOutputStream": [[38, 53]]}}}, {"text": "You can use String.substring(int, int) method", "label": {"api": {"String.substring(int, int)": [[12, 37]]}}}, {"text": "Calling repaint() does not mean that the component will be repainted immediately", "label": {"api": {"repaint()": [[8, 16]]}}}, {"text": "If you suspect repaint() may be called way too often, use the version that accepts the maximal time after that the object should be repainted", "label": {"api": {"repaint()": [[15, 23]]}}}, {"text": "Also better to consistently use the correct overloaded method of add when adding to a container with GridBagLayout", "label": {"api": {"add": [[65, 67], [74, 76]]}}}, {"text": "Look at java.utill.Calendar class", "label": {"api": {"java.utill.Calendar": [[8, 26]]}}}, {"text": "It has Calendar.WEEK_OF_MONTH and Calendar.WEEK_OF_YEAR attributes", "label": {"api": {"Calendar.WEEK_OF_MONTH": [[7, 28]], "Calendar.WEEK_OF_YEAR": [[34, 54]]}}}, {"text": "you can use it in combination of Calendar.add(int field, int amount)", "label": {"api": {"Calendar.add(int field, int amount)": [[33, 67]]}}}, {"text": "Use Overloaded Arrays#Sort(T[] a, Comparator c) which takes Comparator as the second argument", "label": {"api": {"Arrays#Sort(T[] a, Comparator c)": [[15, 46]]}}}, {"text": "File.listFiles returns null if the abstract pathname does not denote a directory", "label": {"api": {"File.listFiles": [[0, 13]]}}}, {"text": "In reading through the Javadoc of Enum I can see a signature of valueOf() that is not what I usually use", "label": {"api": {"signature of valueOf()": [[51, 72]]}}}, {"text": "Starting with JavaFX 8u40, the best way to restrict the input of a text field is to set a TextFormatter on the text field", "label": {"api": {"TextFormatter": [[90, 102]]}}}, {"text": "Use a CharSequence instead of a String[][] (or you could also use variable arity parameters)", "label": {"api": {"CharSequence": [[6, 17]]}}}, {"text": "The docs show that requestFocusInWindow(boolean) is protected so can only be called by subclasses of JComponent", "label": {"api": {"requestFocusInWindow(boolean)": [[19, 47]], "requestFocusInWindow": [[19, 38]]}}}, {"text": "Instead you should use the publicly accessible requestFocusInWindow", "label": {"api": {"requestFocusInWindow": [[47, 66]]}}}, {"text": "You may work with BigDecimal instead, but note that computations with BigDecimal are slower", "label": {"api": {"BigDecimal": [[18, 27], [70, 79]]}}}, {"text": "serialVersionID (a field) is not declared as a member the Serializable interface", "label": {"api": {"Serializable": [[58, 69]]}}}, {"text": "The warning is \"compiler magic\" that knows it should emit a warning when encountering a type implementing Serializable that does not have such a field", "label": {"api": {"Serializable": [[106, 117]]}}}, {"text": "If you need to keep a rendering information like the number of digits after the comma, you need something else, like BigDecimal", "label": {"api": {"BigDecimal": [[117, 126]]}}}, {"text": "Java 8 now has its own LocalTime class", "label": {"api": {"LocalTime": [[23, 31]]}}}, {"text": "You need to consume the event with evt.consume() to ensure it isn't processed by the text field itself", "label": {"api": {"evt.consume()": [[35, 47]]}}}, {"text": "The default layout for JPanel is FlowLayout, which uses a centered alignment", "label": {"api": {"FlowLayout": [[33, 42]]}}}, {"text": "If you want the label to be aligned to the left, you can use a FlowLayout, making sure the alignment is set to LEADING", "label": {"api": {"FlowLayout": [[63, 72]]}}}, {"text": "Look at ArrayBlockingQueue and another BlockingQueue implementations", "label": {"api": {"ArrayBlockingQueue": [[8, 25]], "BlockingQueue": [[13, 25], [39, 51]]}}}, {"text": "You should be using Timer.schedule(yourTask, 0, 1000)", "label": {"api": {"Timer.schedule(yourTask, 0, 1000)": [[20, 52]]}}}, {"text": "You can write a wrapper, either by using the delegate pattern, or by Proxy (reflection)", "label": {"api": {"Proxy": [[69, 73]]}}}, {"text": "If you want to go fancy, you may also register an implementation of Driver that rewrites the connection URL and returns an instance of your Connection", "label": {"api": {"Driver": [[68, 73]]}}}, {"text": "If you are looking for natural ordering you could choose TreeSet", "label": {"api": {"natural ordering": [[23, 38]]}}}, {"text": "where elements are ordered using their natural ordering, or by a Comparator provided at set creation time", "label": {"api": {"natural ordering": [[39, 54]], "Comparator": [[65, 74]]}}}, {"text": "The easiest way would be to use Runtime.getRuntime.exec()", "label": {"api": {"Runtime.getRuntime.exec()": [[32, 56]]}}}, {"text": "If you check the JavaDoc for Class.getDeclaredMethod() you can see that it expects a parameter type array", "label": {"api": {"JavaDoc for Class.getDeclaredMethod()": [[17, 53]]}}}, {"text": "You can inject the HttpServletResponse in your resource using the @Context annotation and call the addHeader method on it", "label": {"api": {"HttpServletResponse": [[19, 37]]}}}, {"text": "Create a table model to hold the orders - implementation of TableModel", "label": {"api": {"TableModel": [[60, 69]]}}}, {"text": "Below is an example that illustrates a very basic extension of AbstractTableModel", "label": {"api": {"TableModel": [[71, 80]]}}}, {"text": "Take a look at the BigInteger and BigDecimal classes", "label": {"api": {"BigInteger": [[19, 28]], "BigDecimal": [[34, 43]]}}}, {"text": "As the names would imply, BigInteger is only used for integers, while BigDecimal can store any rational decimal number", "label": {"api": {"BigInteger": [[26, 35]], "BigDecimal": [[70, 79]]}}}, {"text": "JSlider#getValue returns an int value so there's no need to use Integer.parseInt which expects a String", "label": {"api": {"JSlider#getValue": [[0, 15]]}}}, {"text": "1) is to read the file in advance, counting how many lines it has (for example using a scanner's HasNextLine ( http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html#hasNextLine() ) and then you can initialize the array to be that large and count it again", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html#hasNextLine()": [[111, 191]]}}}, {"text": "To label your JTextField, I recommend putting all of the labels and the field in a Box", "label": {"api": {"Box": [[83, 85]]}}}, {"text": "Use varargs for the parameter and use Arrays.copyOf()", "label": {"api": {"Arrays.copyOf()": [[38, 52]]}}}, {"text": "Control whether or not a cell is editable through the TableModel", "label": {"api": {"TableModel": [[54, 63]]}}}, {"text": "Define your own TableModel class by extending DefaultTableModel", "label": {"api": {"TableModel": [[16, 25], [53, 62]], "DefaultTableModel": [[46, 62]]}}}, {"text": "If you don't want to have to implement all of them, you could use a WindowAdapter, as follows", "label": {"api": {"WindowAdapter": [[68, 80]]}}}, {"text": "There is an interface called WindowListener and here is a event that gets fired when window is opened.You can find all the events in the first link", "label": {"api": {"WindowListener": [[29, 42]], "opened": [[95, 100]]}}}, {"text": "The WindowListener works only once", "label": {"api": {"WindowListener": [[4, 17]]}}}, {"text": "Sentinel class would not support all interface methods of course, so those methods can either return null;/do nothing, or throw new IllegalStateException(\"Sentinel does not support Xxxx.\"); depending on method and if calling that method for sentinel is bug in calling code or not (better start with throwing exception)", "label": {"api": {"throw new IllegalStateException(\"Sentinel does not support Xxxx.\");": [[122, 188]]}}}, {"text": "The Java Thread itself implements a Java Runnable", "label": {"api": {"Thread": [[9, 14]]}}}, {"text": "and according to most of the experts over Internet, implements Runnable is preferred over extends Thread", "label": {"api": {"Thread": [[98, 103]]}}}, {"text": "even though we cannot use utilize Runnable in the sense of thread with out the Thread class", "label": {"api": {"Thread": [[79, 84]]}}}, {"text": "Then why do we prefer to implement Runnable over extending Thread since in both cases the actual thread is stated by calling a Thread implemented method (i.e", "label": {"api": {"Thread": [[59, 64], [127, 132]]}}}, {"text": "start() or run()) although in case of Thread we are not truly \"extending\" the functionality of Thread by merely overriding the run() method", "label": {"api": {"Thread": [[38, 43], [95, 100]]}}}, {"text": "Majority of factory methods within java.util.concurrent.Executors return either instance of ThreadPoolExecutor or its child ScheduledThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[92, 109], [133, 150]], "ScheduledThreadPoolExecutor": [[124, 150]]}}}, {"text": "And if you check javadoc for ExecutorService, then you'll see that these are well-known implementations", "label": {"api": {"ExecutorService": [[29, 43]]}}}, {"text": "To properly destroy a JFrame, you should dispose it", "label": {"api": {"dispose": [[41, 47]]}}}, {"text": "It should be a simple coding problem, using String.lastIndexOf(String str, int fromIndex)", "label": {"api": {"String.lastIndexOf(String str, int fromIndex)": [[44, 88]]}}}, {"text": "If you want a hash code that is based on object identity rather than equality use System.identityHashCode()", "label": {"api": {"System.identityHashCode()": [[82, 106]]}}}, {"text": "When you want to run a task in specific intervals, you should use the java.util.Timer class to scheduleAtFixedRate a java.util.TimerTask at regular intervals", "label": {"api": {"java.util.Timer": [[70, 84], [117, 131]], "scheduleAtFixedRate": [[95, 113]], "java.util.TimerTask": [[117, 135]]}}}, {"text": "There is a number of libraries out there, or you can use ServerSocket / SSLServerSocket to implement it low level", "label": {"api": {"ServerSocket": [[57, 68], [75, 86]], "SSLServerSocket": [[72, 86]]}}}, {"text": "You could use Maven to generate a Properties file and load  it in your Java Class", "label": {"api": {"Properties": [[34, 43]], "load": [[54, 57]]}}}, {"text": "You could use a JTable with two columns and a TableColumnAdjuster or a TableCellRenderer in order to adjust the width of the columns to the longest content", "label": {"api": {"TableCellRenderer": [[71, 87]]}}}, {"text": "Your logic is correct, but File.list does not do what you think", "label": {"api": {"File.list": [[27, 35]]}}}, {"text": "which I think somehow come from ServletContext.getRealPath..", "label": {"api": {"ServletContext.getRealPath": [[32, 57]]}}}, {"text": "DefaultTableModel has a method removeRow which removes a row from the table", "label": {"api": {"removeRow": [[31, 39]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "According Oracle's Java API for Applets there is no method there you can pass a string", "label": {"api": {"Java API for Applets": [[19, 38]]}}}, {"text": "Instead of a HashMap, you should use a HashSet", "label": {"api": {"HashSet": [[39, 45]]}}}, {"text": "The performance are equivalent since an HashSetis backed by an HashMap<E,Object>", "label": {"api": {"HashSet": [[40, 46]]}}}, {"text": "An HashSet offers constant time performance for the basic operations", "label": {"api": {"HashSet": [[3, 9]]}}}, {"text": "But you can only iterate over a collection using for-each if and only if  your collection implements Iterable interface", "label": {"api": {"Iterable": [[101, 108]]}}}, {"text": "String.split(String regex) should work, just choose the appropriate regular expression", "label": {"api": {"String.split(String regex)": [[0, 25]], "regular expression": [[68, 85]]}}}, {"text": "You may also use a CountDownLatch with a count of 1, instead of waiting until flag is true", "label": {"api": {"CountDownLatch": [[19, 32]]}}}, {"text": "The standard Socket class, however, uses TCP by default", "label": {"api": {"Socket": [[13, 18]]}}}, {"text": "This can be overridden by telling it to use UDP in the constructor by passing true as a third parameter (which is deprecated), or when you passed a custom socket implementation to the static method Socket.setSocketImplFactory which uses UDP (which would be insane - the purpose of this method is to implement exotic transport layer protocols which are neither UDP nor TCP)", "label": {"api": {"Socket": [[198, 203], [208, 213]], "Socket.setSocketImplFactory": [[198, 224]]}}}, {"text": "Usually, UDP sockets are represented by the class DatagramSocket", "label": {"api": {"Socket": [[58, 63]], "DatagramSocket": [[50, 63]]}}}, {"text": "The reason is because it's based on Iterable interface", "label": {"api": {"Iterable": [[36, 43]]}}}, {"text": "Can you use InetAddress.getAllByName() to get all ip addresses for that host, and then use isReachable() on each IP address in turn", "label": {"api": {"InetAddress.getAllByName()": [[12, 37]]}}}, {"text": "If you want more fine grained control over the keep-alive settings (etc) then you can call the ThreadPoolExecutor constructor directly", "label": {"api": {"ThreadPoolExecutor constructor": [[95, 124]]}}}, {"text": "You should probably use ExecutorService, which you can construct from one of numerous convenience methods in Executors, including methods to specify a bounded queue, etc, for inserting items", "label": {"api": {"Executors": [[109, 117]]}}}, {"text": "By setting the allowCoreThreadTimeOut() to true, the threads in the pool are allowed to terminate after the specified timeout (60 seconds in this example)", "label": {"api": {"allowCoreThreadTimeOut()": [[15, 38]]}}}, {"text": "More details can be found in the JavaDoc of ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[44, 61]]}}}, {"text": "To test if the stack is empty, use the empty() method", "label": {"api": {"empty()": [[39, 45]]}}}, {"text": "See the Highlighter.HighlightPainter interface, that easily (questionable), allows you to change the appearance of the highlight", "label": {"api": {"Highlighter.HighlightPainter": [[8, 35]]}}}, {"text": "You can start workers threads (without an executor), and have them take elements from a bounded blocking queue", "label": {"api": {"bounded blocking queue": [[88, 109]]}}}, {"text": "Alternatively, you may use a ThreadPoolExecutor with a bounded blocking queue and CallerRunsPolicy", "label": {"api": {"ThreadPoolExecutor": [[29, 46]], "bounded blocking queue": [[55, 76]]}}}, {"text": "If you're looking for a string that matches the regex, use String.matches()", "label": {"api": {"String.matches()": [[59, 74]]}}}, {"text": "If your goal really is to split a string into tokens then you might also consider String.split(), which is sometimes more convenient to use", "label": {"api": {"String.split()": [[82, 95]]}}}, {"text": "*in an unnecessarily inefficient manner; string concatenation in a loop should almost always be replaced with usage of a StringBuilder", "label": {"api": {"StringBuilder": [[121, 133]]}}}, {"text": "Try using the other Overload method of JOption.showConfirmDialog method", "label": {"api": {"JOption.showConfirmDialog": [[39, 63]]}}}, {"text": "For example, ArrayIndexOutOfBoundsException carries the offending array index, and SQL exceptions tends to carry database-specific error codes and messages", "label": {"api": {"ArrayIndexOutOfBoundsException": [[13, 42]]}}}, {"text": "Caller of a method might want to convert IndexOutOfBoundsException to null return value, while letting other exceptions to propagate normally", "label": {"api": {"IndexOutOfBoundsException": [[41, 65]], "Exception": [[57, 65]]}}}, {"text": "If you want your custom exception to be handled in default ways, you extend right existing exception class, such as IOException", "label": {"api": {"IOException": [[116, 126]], "Exception": [[118, 126]]}}}, {"text": "You can then catch your specific IO exception when you want to do something specific just there, but also let it be handled like any other IOException when you don't need special handling (can't do anything useful to recover)", "label": {"api": {"IOException": [[139, 149]], "Exception": [[141, 149]]}}}, {"text": "If you have a totally custom exception which should never be caught by a superclass catch, which always should have specific catch block, then you extend Exception directly", "label": {"api": {"Exception": [[154, 162]]}}}, {"text": "I think it's pretty rare to need to extend RuntimeException, because if it an exception meant to be caught it should be Exception subclass, and if it's meant to end the program or just generate log output, then it should be covered by default RuntimeException implementations with custom message string", "label": {"api": {"Exception": [[50, 58], [120, 128], [250, 258]], "RuntimeException": [[43, 58], [243, 258]]}}}, {"text": "The java.nio package sounds right for what you want to do", "label": {"api": {"java.nio": [[4, 11]]}}}, {"text": "If you are using Oracle then I suggest that you use the data pump features of SQL Developer to do it", "label": {"api": {"data pump": [[56, 64]]}}}, {"text": "You can use replaceAll method of String class", "label": {"api": {"replaceAll": [[12, 21]]}}}, {"text": "Use File.createTempFile() or Files.createTempFile() instead", "label": {"api": {"File.createTempFile()": [[4, 24]], "Files.createTempFile()": [[29, 50]]}}}, {"text": "If you need unique file names for temporary files, use File.createTempFile(prefix, suffix, directory)", "label": {"api": {"File.createTempFile(prefix, suffix, directory)": [[55, 100]]}}}, {"text": "The TreeMap is a SortedMap and will use the compareTo method for sorting the map elements", "label": {"api": {"TreeMap": [[4, 10]], "SortedMap": [[17, 25]]}}}, {"text": "The cause of NPE may be connection object or res.getString() returns null", "label": {"api": {"getString()": [[49, 59]]}}}, {"text": "Properties files are generally stored in ISO 8859-1, but it is possible to perform your own character decoding by providing an InputStreamReader", "label": {"api": {"perform your own character decoding": [[75, 109]]}}}, {"text": "BasicArrowButton is another way, like they show here and here", "label": {"api": {"BasicArrowButton": [[0, 15]]}}}, {"text": "Normally for a ScrollPane you would do something like this", "label": {"api": {"ScrollPane": [[15, 24]]}}}, {"text": "But you may configure your own DecimalFormat", "label": {"api": {"DecimalFormat": [[31, 43]]}}}, {"text": "Make use of ThreadLocal", "label": {"api": {"ThreadLocal": [[12, 22]]}}}, {"text": "Collections.sort(List<T>) expects that T must implement Comparable<", "label": {"api": {"Collections.sort(List<T>)": [[0, 24]]}}}, {"text": "You may use a SAX parser, with a DeclHandler", "label": {"api": {"DeclHandler": [[33, 43]]}}}, {"text": "To set the DeclHandler for an XML reader, use the setProperty method with the property name http://xml.org/sax/properties/declaration-handler and an object implementing DeclHandler", "label": {"api": {"DeclHandler": [[11, 21], [169, 179]]}}}, {"text": "The model argument in method DeclHandler.elementDecl(String name, String model) for name=\"note\" would be (to,from,heading,body)", "label": {"api": {"DeclHandler": [[29, 39]]}}}, {"text": "From the Javadoc for String", "label": {"api": {"Javadoc for String": [[9, 26]]}}}, {"text": "Use a secondary table", "label": {"api": {"secondary table": [[6, 20]]}}}, {"text": "Instead, use a ServletContextInitializer to schedule a TimerTask that does your background work", "label": {"api": {"ServletContextInitializer": [[15, 39]], "schedule a TimerTask": [[44, 63]]}}}, {"text": "The documentation of SwingWorker has a neat example of how you should implement performing several tasks in the background of the application (the PrimeNumbersTask class showed there)", "label": {"api": {"documentation of SwingWorker": [[4, 31]]}}}, {"text": "Then I would create a Comparator which orders the records by the frequency", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "Then I would use Arrays.sort() or Collections.sort() to sort the collection using the Comparator", "label": {"api": {"Comparator": [[86, 95]], "Arrays.sort()": [[17, 29]], "Collections.sort()": [[34, 51]]}}}, {"text": "you override the Object.toString() method", "label": {"api": {"Object.toString()": [[17, 33]]}}}, {"text": "For more complex handling, you might want to consider implementing the Formattable interface - although I've never personally done so myself", "label": {"api": {"Formattable": [[71, 81]]}}}, {"text": "If all you need is an incremental counter, you can use AtomicLong's incrementAndGet()", "label": {"api": {"AtomicLong's incrementAndGet()": [[55, 84]]}}}, {"text": "If you foresee yourself handling lots of concurrent use cases in the future, the java.util.concurrent package provides lots of battle-proven implementations for your use cases", "label": {"api": {"java.util.concurrent": [[81, 100]]}}}, {"text": "Use SimpleDateFormat in this way", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "The one interface that describes performance, RandomAccess is a marker interface, and doesn't even extend Collection or re-expose the get(index) API", "label": {"api": {"RandomAccess": [[46, 57]]}}}, {"text": "Use Arrays.toString() to print the contents of an array", "label": {"api": {"Arrays.toString()": [[4, 20]]}}}, {"text": "If you do use Arrays.toString(), print the array outside the loops", "label": {"api": {"Arrays.toString()": [[14, 30]]}}}, {"text": "In either case, you'll have to serialize the BufferedImage to some byte sequence first, probably using ImageIO.write in conjunction with a ByteArrayOutputStream", "label": {"api": {"BufferedImage": [[45, 57]], "ImageIO.write": [[103, 115]], "ByteArrayOutputStream": [[139, 159]]}}}, {"text": "Yes, you can get it from the File object by using File.toPath()", "label": {"api": {"File": [[29, 32], [50, 53]], "File.toPath()": [[50, 62]]}}}, {"text": "You likely want File.toPath()", "label": {"api": {"File.toPath()": [[16, 28]]}}}, {"text": "Remember for example BufferedReader", "label": {"api": {"BufferedReader": [[21, 34]], "Reader": [[29, 34]]}}}, {"text": "It's a very similar thing to your case - it is a thin wrapper (a decorator) around any Reader which makes it buffered and has some additional methods (can read lines)", "label": {"api": {"Reader": [[87, 92]]}}}, {"text": "What you are looking for, I think, is the tail set", "label": {"api": {"tail set": [[42, 49]]}}}, {"text": "If you use StringBuilder, which you should generally use when you want a \"modifiable String\", then you can just use StringBuilder.setCharAt(int, char)", "label": {"api": {"StringBuilder.setCharAt(int, char)": [[116, 149]]}}}, {"text": "According to Oracle's docs on FileReader, the file needs to be local", "label": {"api": {"docs on FileReader": [[22, 39]]}}}, {"text": "If java.awt.Rectangle is permitted, here's an outline of how you can use it in your implementation", "label": {"api": {"java.awt.Rectangle": [[3, 20]]}}}, {"text": "My suggestion (easy fix) is to use a AtomicInteger instead of an int", "label": {"api": {"AtomicInteger": [[37, 49]]}}}, {"text": "To get a Date from a String object which has the String representation of Date, use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[84, 99]]}}}, {"text": "I want to watch (monitor) multiple directories using Java NIO  WatchService", "label": {"api": {"WatchService": [[63, 74]]}}}, {"text": "My problem here is the number of directories to watch is dynamic and the user can add any number of directories to the WatchService", "label": {"api": {"WatchService": [[119, 130]]}}}, {"text": "If you read the javadoc for FileReader, it says (emphasis mine)", "label": {"api": {"FileReader": [[28, 37]]}}}, {"text": "Have a look at java.text.Collator.newInstance(Locale)", "label": {"api": {"java.text.Collator.newInstance(Locale)": [[15, 52]]}}}, {"text": "You can find unique words by using a Set", "label": {"api": {"Set": [[37, 39]]}}}, {"text": "Set is a Collection which contains no duplicate elements", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "Have you check the API, what is returned by values() method", "label": {"api": {"values()": [[44, 51]]}}}, {"text": "And what ArrayList constructor accepts", "label": {"api": {"constructor": [[19, 29]]}}}, {"text": "As you can see in the API documentation, that method is deprecated, which means it is replaced by another method", "label": {"api": {"API documentation": [[22, 38]]}}}, {"text": "The API documentation even mentions what you should use instead", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "You are correct that each Java app on Heroku has its own JVM, and the easiest way to introspect it is by adding a Java Agent to your app", "label": {"api": {"Java Agent": [[114, 123]]}}}, {"text": "To get started, you might want to take a look at the heroku-javaagent, which is a very simple Java Agent that prints out vital stats (e.g", "label": {"api": {"Java Agent": [[94, 103]]}}}, {"text": "I suggest using the File.listFiles(FileFilter filter) method on each directory in the path", "label": {"api": {"File.listFiles(FileFilter filter)": [[20, 52]]}}}, {"text": "Pattern has a method to do this for you, namely Pattern.quote(String s)", "label": {"api": {"Pattern.quote(String s)": [[48, 70]]}}}, {"text": "You should use BigDecimal, because it allows you to specify the number of decimal places and the rounding strategy", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "Take a look at the ZipOutputStream in Java if you want to programmatically create zip files", "label": {"api": {"ZipOutputStream": [[19, 33]]}}}, {"text": "JavaScript only has one numerical type - Number which is analogous to the Java Double type", "label": {"api": {"Double": [[79, 84]]}}}, {"text": "I don't see how this can work regardless of whether you're expecting ArrayList.remove(int) to take an index or a value (it takes an index)", "label": {"api": {"ArrayList.remove(int)": [[69, 89]]}}}, {"text": "Look at Java Doc the scheduleAtFixedRate() method will execute a runnable at fixed intervals", "label": {"api": {"runnable": [[65, 72]]}}}, {"text": "The \"round counting\" code would be moved to a class that implements the runnable interface", "label": {"api": {"runnable": [[72, 79]]}}}, {"text": "Another way to do it is using the String format method to right-pad the student's name with spaces", "label": {"api": {"format": [[41, 46]]}}}, {"text": "The entrySet() method already returns a collection of all of the entries (key/value pairs) in the map, not just a single entry", "label": {"api": {"entrySet()": [[4, 13]]}}}, {"text": "You should use File#listFiles", "label": {"api": {"File#listFiles": [[15, 28]]}}}, {"text": "According to java doc of Serializable interface, all the subtypes of a serializable class  are themselves serializable", "label": {"api": {"Serializable": [[25, 36]]}}}, {"text": "So, the answer is yes, if Person implements Serializable all its children will be serializable", "label": {"api": {"Serializable": [[44, 55]]}}}, {"text": "You can reposition a FileInputStream to any arbitrary point by getting its channel via getChannel() and calling position() on that channel", "label": {"api": {"channel": [[75, 81], [131, 137]]}}}, {"text": "StringListModel is an extension of AbstractListModel to handle list of Strings", "label": {"api": {"AbstractListModel": [[35, 51]]}}}, {"text": "This might be a dumb question, but why not use BufferedReader/readLine, and then String.indexOf or other regex, rather than shelling out to grep", "label": {"api": {"readLine": [[62, 69]]}}}, {"text": "As your strings are all valid identifiers, you could create an enumeration with those strings as the item labels, use Enum.valueOf(Class, String) (or the similar valueOf(String) method that will be created in your enumeration class) to convert to a member of the enumeration type, and then switch based on that..", "label": {"api": {"Enum.valueOf(Class, String)": [[118, 144]]}}}, {"text": "Why doesn't TimeZone.getTimeZone() method throw an error if it is given an invalid time zone ID", "label": {"api": {"TimeZone.getTimeZone()": [[12, 33]]}}}, {"text": "Note that there are plenty of classes to hold almost any kind of common collections, and you have Queue and PriorityQueue that can help you in your real work", "label": {"api": {"Queue": [[98, 102], [116, 120]], "PriorityQueue": [[108, 120]]}}}, {"text": "Or creating a new implementation of an interface, like Queue or List", "label": {"api": {"Queue": [[55, 59]]}}}, {"text": "You can compute the remaining time (in seconds) using the HttpSession API", "label": {"api": {"HttpSession": [[58, 68]]}}}, {"text": "Elements are compared using their natural ordering", "label": {"api": {"using their natural ordering": [[22, 49]]}}}, {"text": "Use String#equals to compare the contents of Strings", "label": {"api": {"String#equals": [[4, 16]]}}}, {"text": "This will roll back the days by 12, and then the year by 12", "label": {"api": {"roll": [[10, 13]]}}}, {"text": "One possible way appears to be Toolkit.addAWTEventListener, with a custom listener as the first argument and KEY_EVENT_MASK as the second", "label": {"api": {"Toolkit.addAWTEventListener": [[31, 57]], "KEY_EVENT_MASK": [[109, 122]]}}}, {"text": "The listener registered in this way should get notified of all keystroks, so you can cast them to KeyEvent and inspect them whether they are Ctrl+h and act accordingly", "label": {"api": {"KeyEvent": [[98, 105]]}}}, {"text": "After sorting you can put back your entries in a map that supports ordering, for example LinkedHashMap", "label": {"api": {"LinkedHashMap": [[89, 101]]}}}, {"text": "Instead you should have an Executor", "label": {"api": {"Executor": [[27, 34]]}}}, {"text": "The easiest would be to use Thread.join, which will cause the current thread to pause until the thread you're invoking join() on has finished", "label": {"api": {"Thread.join": [[28, 38]]}}}, {"text": "If so, something like a concurrent queue might be better, because it's less fragile -- you can change which thread does the work of consuming or producing the thing without things breaking", "label": {"api": {"concurrent queue": [[24, 39]]}}}, {"text": "If this is the case don't use clone method  as it is already specified in oracle docs that it provides shallow copy of the associated object", "label": {"api": {"clone": [[30, 34]]}}}, {"text": "See also the Javadoc for JAXBContext", "label": {"api": {"Javadoc for JAXBContext": [[13, 35]]}}}, {"text": "Have you tried using the java.nio.file.Files#isWritable method", "label": {"api": {"java.nio.file.Files#isWritable": [[25, 54]]}}}, {"text": "You can use ProcessBuilder do do this", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "It can be easily improved in efficiency by using StringBuilder", "label": {"api": {"StringBuilder": [[49, 61]]}}}, {"text": "StringBuilder keeps an internal character array, so that concatenation operations work on that array and only one String object is allocated when you call its toString() method", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "You would be better off appending to a single StringBuilder object", "label": {"api": {"StringBuilder": [[46, 58]]}}}, {"text": "Comparable takes a Type parameter", "label": {"api": {"Comparable": [[0, 9]]}}}, {"text": "If you'd still like to use your custom program to contact the servlet, you can always limit the number of requests and back them up with a blocking queue through a threadpool executor", "label": {"api": {"blocking queue through a threadpool executor": [[139, 182]]}}}, {"text": "Yes, a TableModelEvent gets fired whenever rows are added or deleted", "label": {"api": {"TableModelEvent": [[7, 21]]}}}, {"text": "you need to create a TableModelListener and then add it to your TableModel using addTableModelListener", "label": {"api": {"TableModelListener": [[21, 38], [84, 101]], "addTableModelListener": [[81, 101]]}}}, {"text": "Where yourTableListener is an instance of a class that implements the TableModelListener interface", "label": {"api": {"TableModelListener": [[70, 87]]}}}, {"text": "Had you implemented your logic with Runnable, you would be able to use ThreadFactory, and you would not longer be tied to the default implementation of Thread (which comes handy in some situations)", "label": {"api": {"ThreadFactory": [[71, 83]]}}}, {"text": "I would rather implement the Runnable interface, and then that object can be made available not only to a Thread constructor, but also to thread pools, executors etc", "label": {"api": {"Runnable": [[29, 36]]}}}, {"text": "that consume Runnable objects for submission to threads at later times", "label": {"api": {"Runnable": [[13, 20]]}}}, {"text": "Use the CountDownLatch", "label": {"api": {"CountDownLatch": [[8, 21]]}}}, {"text": "Scanner allows any Java Regex Pattern to function as a delimiter", "label": {"api": {"Regex Pattern": [[24, 36]]}}}, {"text": "The same value is printed differently for float and double because the Java specification requires printing as many digits as needed to distinguish the value from adjacent representable values in the same type (per my answer here, and see the linked documentation for more precision in the definition)", "label": {"api": {"linked documentation": [[243, 262]]}}}, {"text": "One solution to your problem is to wrap the dialog code in a call to SwingUtilities.invokeAndWait()", "label": {"api": {"SwingUtilities.invokeAndWait()": [[69, 98]]}}}, {"text": "If you use ConcurrentHashMap, it will do all syncronization work for you", "label": {"api": {"ConcurrentHashMap": [[11, 27]]}}}, {"text": "If allSpikes is populated before all the threads start, you could make sure it isn't changed later by saving it as an unmodifiable map", "label": {"api": {"unmodifiable map": [[118, 133]]}}}, {"text": "The ${loop.index} returns the index of the current iteration round", "label": {"api": {"${loop.index}": [[4, 16]]}}}, {"text": "Also consider a ComboBox for such an implementation, as it has a mechanisms built into it to abstract the values of nodes from the display of the nodes (via a CellFactory)", "label": {"api": {"ComboBox": [[16, 23]], "CellFactory": [[159, 169]]}}}, {"text": "Use of a ComboBox is however often more complex than a ChoiceBox", "label": {"api": {"ComboBox": [[9, 16]]}}}, {"text": "For changing JTable entries, use TableModel#setValueAt", "label": {"api": {"TableModel#setValueAt": [[33, 53]]}}}, {"text": "Java has two Timer classes, one under swing , and one under util ..", "label": {"api": {"swing": [[38, 42]], "util": [[60, 63]]}}}, {"text": "Does  this mean if I'm building a GUI I have to use the swing version for a timer", "label": {"api": {"swing": [[56, 60]]}}}, {"text": "However, if you look at the javadocs for MBeanServerConnection which backs most of the JMX clients, you can see that InstanceNotFoundException means", "label": {"api": {"javadocs for MBeanServerConnection": [[28, 61]]}}}, {"text": "You can also use String.substring()", "label": {"api": {"String.substring()": [[17, 34]]}}}, {"text": "trim() will remove what you want from the beginning and end of string", "label": {"api": {"trim()": [[0, 5]]}}}, {"text": "Just use str.trim() to get rid of all leading and trailing spaces", "label": {"api": {"str.trim()": [[9, 18]]}}}, {"text": "Look at ImageIO read() and write() methods for loading and saving images", "label": {"api": {"ImageIO": [[8, 14]]}}}, {"text": "Have a look at Arrays.sort() which accepts a Comparator where you can implement whatever logic you want for ordering your objects", "label": {"api": {"Arrays.sort()": [[15, 27]]}}}, {"text": "Take a look at ScheduledExecutorService, more specifically the scheduleAtFixedRate() method", "label": {"api": {"ScheduledExecutorService": [[15, 38]], "scheduleAtFixedRate()": [[63, 83]]}}}, {"text": "Take a look at ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "If you want your computations to be exact, you could use BigDecimal instead of float/double", "label": {"api": {"BigDecimal": [[57, 66]]}}}, {"text": "Class.getResource will return null if the resource could not be found or the invoker doesn't have adequate  privileges to get the resource", "label": {"api": {"getResource": [[6, 16]]}}}, {"text": "Take a look at the documentation of the getResource to understand how an absolute resource name is constructed from the given resource named and what are the rules for searching resources", "label": {"api": {"getResource": [[40, 50]]}}}, {"text": "You can find a sample implementation of NamespaceContext on my blog", "label": {"api": {"NamespaceContext": [[40, 55]]}}}, {"text": "I think you are looking for ExecutorService", "label": {"api": {"ExecutorService": [[28, 42]]}}}, {"text": "Even the java.util.logging package would suffice to append log-lines to a file upon button-click", "label": {"api": {"java.util.logging package": [[9, 33]]}}}, {"text": "The formatting can just be done with the MessageFormat-class before writing the complete line to the file", "label": {"api": {"MessageFormat": [[41, 53]]}}}, {"text": "You can use Collections.sort(List, Comparator) with your implementation of Comparator, which will sort as you wish", "label": {"api": {"Collections.sort(List, Comparator)": [[12, 45]]}}}, {"text": "In my case, a class was missing a @XmlAccessorType, adding this annotation solved my problem", "label": {"api": {"@XmlAccessorType": [[34, 49]]}}}, {"text": "You can retrieve information about all stored procedures using DatabaseMetaData.getProcedures(...) and DatabaseMetaData.getProcedureColumns(...)", "label": {"api": {"DatabaseMetaData.getProcedures(...)": [[63, 97]], "DatabaseMetaData.getProcedureColumns(...)": [[103, 143]]}}}, {"text": "If you wanted to do this at a later date, you'd need to use Double.toRawLongBits", "label": {"api": {"Double.toRawLongBits": [[60, 79]]}}}, {"text": "The documentation for Comparable explains this in some detail", "label": {"api": {"Comparable": [[22, 31]]}}}, {"text": "Virtually all Java core classes that implement Comparable have natural orderings that are consistent with equals", "label": {"api": {"Comparable": [[47, 56]]}}}, {"text": "As long as your strings are < 65536 characters long, you can use DataOutputStream.writeUtf() and DataInputStream.readUTF()", "label": {"api": {"DataOutputStream.writeUtf()": [[65, 91]], "DataInputStream.readUTF()": [[97, 121]]}}}, {"text": "And as I pointed before clear is the standard and optimal solution to clear a list", "label": {"api": {"clear": [[24, 28], [70, 74]]}}}, {"text": "FileInputStream is used to load resources from files located on the file system", "label": {"api": {"FileInputStream": [[0, 14]], "InputStream": [[4, 14]]}}}, {"text": "You need to use a different InputStream", "label": {"api": {"InputStream": [[28, 38]]}}}, {"text": "For this case, using the ClassLoader#getResourceAsStream(String) method would be advised", "label": {"api": {"ClassLoader#getResourceAsStream(String)": [[25, 63]]}}}, {"text": "It returns an InputStream resource found on the classpath", "label": {"api": {"InputStream": [[14, 24]]}}}, {"text": "Make a use of ArrayList#subList() and ArrayList#toArray()", "label": {"api": {"ArrayList#subList()": [[14, 32]], "ArrayList#toArray()": [[38, 56]]}}}, {"text": "To set the view of a scrollpane, use setViewportView()", "label": {"api": {"setViewportView()": [[37, 53]]}}}, {"text": "In the future, you'll want to know about Point2D class", "label": {"api": {"Point2D": [[41, 47]]}}}, {"text": "For an array of int values, you can wrap in an IntBuffer", "label": {"api": {"IntBuffer": [[47, 55]]}}}, {"text": "Your best bet is using the version of listFiles() that receives a FileFilter, notice that in the accept() method you can ask the size of each file before returning the File[], and only include the files that have the expected size", "label": {"api": {"listFiles()": [[38, 48]], "FileFilter": [[66, 75]], "accept()": [[97, 104]]}}}, {"text": "I think you should look at the DirectoryStream", "label": {"api": {"DirectoryStream": [[31, 45]]}}}, {"text": "PreparedStatement.setObject's  Javadoc says it's not safe to just pass null value, and recommends using setNull instead, which requires to pass the column DB type along", "label": {"api": {"PreparedStatement.setObject": [[0, 26]]}}}, {"text": "Class#cast() might look like a useful alternative, but that's not going to be of any use here, since you've only got Class<?>, and not Class<T>", "label": {"api": {"Class#cast()": [[0, 11]]}}}, {"text": "I don't know about the KeyTool class, and since it's not a public API I'd be averse to using it, but you can read and write keystores yourself using the KeyStore class", "label": {"api": {"KeyStore": [[153, 160]]}}}, {"text": "Have your class implement Comparable and provide said sort ordering in compareTo method", "label": {"api": {"Comparable": [[26, 35]], "compareTo": [[71, 79]]}}}, {"text": "And to sort, simply use Collections#sort, although be aware that it's an inline sort", "label": {"api": {"Collections#sort": [[24, 39]]}}}, {"text": "Please use LineNumberReader class from java.io package It will help your course", "label": {"api": {"LineNumberReader": [[11, 26]]}}}, {"text": "I was attempting to create a faster version of String.equals() method and started by simply copying it", "label": {"api": {"String.equals()": [[47, 61]]}}}, {"text": "The equals() method I wrote is a copy-pasted version of the one found in String.equals() method", "label": {"api": {"String.equals()": [[73, 87]]}}}, {"text": "See the javadocs for Statement class for more information", "label": {"api": {"javadocs for Statement class": [[8, 35]]}}}, {"text": "If you want to remove spaces from input, take a look at the FilterInputStream class", "label": {"api": {"FilterInputStream": [[60, 76]]}}}, {"text": "If you want to remove spaces from output, take a look at the FilterOutputStream class", "label": {"api": {"FilterOutputStream": [[61, 78]]}}}, {"text": "The Pattern to capture the names of the named capturing group is \\(\\?<([a-zA-Z][a-zA-Z0-9]*)> (derived based on Pattern class documentation)", "label": {"api": {"Pattern class documentation": [[112, 138]]}}}, {"text": "It currently doesn't work with regex in Pattern.COMMENTS mode", "label": {"api": {"Pattern.COMMENTS": [[40, 55]]}}}, {"text": "Another point, for Swing it is better to use javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[45, 61]]}}}, {"text": "You can do this using ObjectOutputStream and ObjectInputStream", "label": {"api": {"ObjectOutputStream": [[22, 39]], "ObjectInputStream": [[45, 61]]}}}, {"text": "You can send any Object that implements the Serializable interface (also note that any Objects within the Object has to implement it as well)", "label": {"api": {"Serializable": [[44, 55]]}}}, {"text": "In Java 8 and above, you can use the String's method chars()", "label": {"api": {"String's method chars()": [[37, 59]]}}}, {"text": "Description provided in java api docs at http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html is same", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html": [[41, 109]]}}}, {"text": "Use Socket on the sending (initiating) side and ServerSocket on the receiving (listening for the message) side", "label": {"api": {"Socket": [[4, 9], [54, 59]], "ServerSocket": [[48, 59]]}}}, {"text": "Socket allows to open output stream and ServerSocket can spawn another Socket where you can open input stream", "label": {"api": {"Socket": [[0, 5], [46, 51], [71, 76]], "ServerSocket": [[40, 51]]}}}, {"text": "Also you could use ProcessBuilder's redirectErrorStream(true) to redirect stderr to stdout so you will catch them both in only one loop", "label": {"api": {"redirectErrorStream(true)": [[36, 60]]}}}, {"text": "If you merge the error stream with the output stream (redirectErrorStream(true)), you can get along with a single (additional) background thread", "label": {"api": {"redirectErrorStream(true)": [[54, 78]]}}}, {"text": "You can avoid this, when you use redirectOutput(File) (or inheritIO)", "label": {"api": {"redirectOutput(File)": [[33, 52]]}}}, {"text": "You are trying to call a method on the class java.lang.Class, which doesn't exist", "label": {"api": {"java.lang.Class": [[45, 59]]}}}, {"text": "I'm a tad rusty at Java, but maybe you could use vector math as opposed to trig", "label": {"api": {"vector math": [[49, 59]]}}}, {"text": "You can use Arrays.asList() which takes an array and returns a wrapper List object", "label": {"api": {"Arrays.asList()": [[12, 26]]}}}, {"text": "Use a ServletContextListener configured in your web.xml", "label": {"api": {"ServletContextListener": [[6, 27]]}}}, {"text": "This is because replace takes a String; you need to call replaceAll, which does take a regular expression", "label": {"api": {"replace": [[16, 22], [57, 63]], "replaceAll": [[57, 66]]}}}, {"text": "StringIndexOutofBoundsException means you're try to access the String using an index and the index is either negative or greater than the size of the string", "label": {"api": {"StringIndexOutofBoundsException": [[0, 30]]}}}, {"text": "StackOverflowError is thrown when a stack overflow occurs because an application recurses too deeply", "label": {"api": {"StackOverflowError": [[0, 17]]}}}, {"text": "See the Object.wait() javadoc", "label": {"api": {"Object.wait() javadoc": [[8, 28]]}}}, {"text": "In this particular case, you can get a better result with BigDecimal rather than double", "label": {"api": {"BigDecimal": [[58, 67]]}}}, {"text": "...but BigDecimal has its own issues (for instance, try 10 / 3)", "label": {"api": {"BigDecimal": [[7, 16]]}}}, {"text": "But it's probably a better choice for a calculator app, just keep in mind that when dividing, you'll probably need to use the version that accepts a scale and rounding mode", "label": {"api": {"the version that accepts a scale and rounding mode": [[122, 171]]}}}, {"text": "Well, you're using a generic type (LinkedList<E>) but you're using it as the raw type, as if you didn't know about generics", "label": {"api": {"LinkedList<E>": [[35, 47]]}}}, {"text": "The closest you can get, I think, is to populate a Map<String, Obj> that can be used to look up Obj instances by name", "label": {"api": {"Map<String, Obj>": [[51, 66]]}}}, {"text": "If you want to associate names with objects, you could use a Map<String,Object>", "label": {"api": {"Map<String,Object>": [[61, 78]]}}}, {"text": "You could also think about clustering and SFSB replication - your EJB might be serialized to another machine, and a Thread isn't really applicable for this (it isn't Serializable)", "label": {"api": {"Serializable": [[166, 177]]}}}, {"text": "Use s1.equals(s2) instead", "label": {"api": {"s1.equals(s2)": [[4, 16]]}}}, {"text": "In other words, with the same recursive bounds that Enum and EnumSet declare", "label": {"api": {"Enum": [[52, 55], [61, 64]], "EnumSet": [[61, 67]]}}}, {"text": "Then make sure to type theset and esvals as EnumSet<T> instead of EnumSet<?>", "label": {"api": {"Enum": [[44, 47], [66, 69]], "EnumSet": [[44, 50], [66, 72]]}}}, {"text": "There is no way to retrieve the PID of the process using the apache-commons API (nor using the underlying Java API)", "label": {"api": {"Java API": [[106, 113]]}}}, {"text": "As stated in the CallableStatement API", "label": {"api": {"CallableStatement API": [[17, 37]]}}}, {"text": "It is common to use SwingWorker to handle such lengthy tasks", "label": {"api": {"SwingWorker": [[20, 30]]}}}, {"text": "Any Exception that is a child type of RuntimeException is not required to be handled", "label": {"api": {"RuntimeException": [[38, 53]]}}}, {"text": "RuntimeException are unchecked exception which the calling program need not handle", "label": {"api": {"RuntimeException": [[0, 15]]}}}, {"text": "Any sub-class like ClassCastException etc, are derived from RuntimeException and you need not worry about handling them", "label": {"api": {"RuntimeException": [[60, 75]]}}}, {"text": "In Java, you use Collections.binarySearch to find the lower bound of the equal range in a sorted list (Arrays.binarySearch provides a similar capability for arrays)", "label": {"api": {"Collections.binarySearch": [[17, 40]]}}}, {"text": "These methods work for methods implementing the Comparable interface", "label": {"api": {"Comparable": [[48, 57]]}}}, {"text": "For classes that do not implement the Comparable, you can supply an instance of a custom Comparator for comparing the elements of your specific type", "label": {"api": {"Comparable": [[38, 47]], "Comparator": [[89, 98]]}}}, {"text": "matches() checks if the complete input string matches the pattern, whereas find() checks if the pattern can be found somewhere in the input string", "label": {"api": {"matches()": [[0, 8]], "find()": [[75, 80]]}}}, {"text": "Using the replaceAll() method you don't need a precompiled pattern, but you could extract the regex to a final field of type String", "label": {"api": {"replaceAll()": [[10, 21]]}}}, {"text": "Also consider using SwingWorkers rather than constructing a new thread yourself", "label": {"api": {"SwingWorkers": [[20, 31]]}}}, {"text": "I'm guessing you're thinking of MessageFormat", "label": {"api": {"MessageFormat": [[32, 44]]}}}, {"text": "One alternative to notify/wait code like this is to use BlockingQueue like LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[75, 93]]}}}, {"text": "For more info read the Pattern docs section Groups and capturing", "label": {"api": {"Groups and capturing": [[44, 63]]}}}, {"text": "The way to solve your problem, then, is to access the resource contents using the de facto standard of invoking Class.getResourceAsStream (or ClassLoader.getResourceAsStream), save the contents to a temporary file, and execute from that file", "label": {"api": {"Class.getResourceAsStream": [[112, 136]]}}}, {"text": "Create a temporary file, preferably using File.createTempFile", "label": {"api": {"File.createTempFile": [[42, 60]]}}}, {"text": "Use Calendar API like this to subtract 2 days from a Date object", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "You have overridden the default entity name, which would have been the simple name of the class, in the Group class", "label": {"api": {"default entity name": [[24, 42]]}}}, {"text": "If you are running out of the number of threads then you may need to create ExecutorService thread-pools or other mechanisms to run many jobs on fewer threads", "label": {"api": {"ExecutorService thread-pools": [[76, 103]]}}}, {"text": "You have to call execute or executeUpdate on pst in order to actually do the work", "label": {"api": {"execute": [[17, 23], [28, 34]], "executeUpdate": [[28, 40]]}}}, {"text": "All that the code you've shown does is prepare the statement for execution, it doesn't execute it", "label": {"api": {"execute": [[87, 93]]}}}, {"text": "In Statement, you pass the SQL to execute directly into executeUpdate (as seen in your commented-out line using stmt)", "label": {"api": {"execute": [[34, 40], [56, 62]], "executeUpdate": [[56, 68]]}}}, {"text": "as you've done, set those parameters, and then call executeUpdate (or execute), which you haven't done", "label": {"api": {"execute": [[52, 58], [70, 76]], "executeUpdate": [[52, 64]]}}}, {"text": "If you want the main thread to wait until the new thread is finishes, use Futures for a result", "label": {"api": {"Futures": [[74, 80]]}}}, {"text": "Have you tried @OrderColumn", "label": {"api": {"@OrderColumn": [[15, 26]]}}}, {"text": "If you try to use \"PDT\" here, you will end up with the GMT timezone", "label": {"api": {"end up with the GMT timezone": [[39, 66]]}}}, {"text": "Use a Task as in the JavaFX Concurrency Tutorial", "label": {"api": {"Task": [[6, 9]]}}}, {"text": "Here is some sample code for accessing a database using a Task", "label": {"api": {"Task": [[58, 61]]}}}, {"text": "The method trim() removes the trailing white space", "label": {"api": {"trim()": [[11, 16]]}}}, {"text": "Now indexOf() doesn't find \"<category\" (with a trailing space) and returns -1", "label": {"api": {"indexOf()": [[4, 12]]}}}, {"text": "Brief tutorial on set", "label": {"api": {"set": [[18, 20]]}}}, {"text": "Have a look at the RenderingHints", "label": {"api": {"RenderingHints": [[19, 32]]}}}, {"text": "I would use String.format instead of concatenation for clarity", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "Substring can be used via CriteriaBuilder.substring", "label": {"api": {"CriteriaBuilder.substring": [[26, 50]]}}}, {"text": "In current approach you are calling toString method of Path", "label": {"api": {"Path": [[55, 58]]}}}, {"text": "Line2D.ptSegDist(x1, y1, x2, y2, xP, yP) returns 0.0 iff the point (xP, yP) is on the line segment from (x1, y1) to (x2, y2)", "label": {"api": {"Line2D.ptSegDist(x1, y1, x2, y2, xP, yP)": [[0, 39]]}}}, {"text": "Line2D.ptLineDist does the same thing for the infinite line", "label": {"api": {"Line2D.ptLineDist": [[0, 16]]}}}, {"text": "Try repaint() without arguments, repaint(int x, int y, int width, int height) repaints only a specified rectangle of the component", "label": {"api": {"repaint()": [[4, 12]]}}}, {"text": "You can find the complete list of display modes that Java thinks your monitor supports by calling GraphicsDevice.getDisplayModes()", "label": {"api": {"GraphicsDevice.getDisplayModes()": [[98, 129]]}}}, {"text": "If you want \"right now\" in that format, you can use System.currentTimeMillis() / 1000, or if you have a Date object, you can use date.getTime() / 1000", "label": {"api": {"Date": [[104, 107]]}}}, {"text": "Use a SwingWorker", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "3) Make sure you actually call addActionListener()", "label": {"api": {"addActionListener()": [[31, 49]]}}}, {"text": "You can read more about Maps here", "label": {"api": {"read more about Maps here": [[8, 32]]}}}, {"text": "Another way for huge values is to use the BigInteger class, but that will create objects which may be difficult to deal with", "label": {"api": {"BigInteger": [[42, 51]]}}}, {"text": "Those numbers are larger than the largest int value, which is 231-1 or 2147483647, and which is available as the constant Integer.MAX_VALUE", "label": {"api": {"Integer.MAX_VALUE": [[122, 138]]}}}, {"text": "To fix the problem, make your variables long (64 bits) and your constants long also by appending L at the end if the number (the default numerical type in java is int), and your should use Long.parseLong() to cater for the larger values in your input", "label": {"api": {"Long.parseLong()": [[189, 204]]}}}, {"text": "to 263-1 or 9223372036854775807, which is available as the constant Long.MAX_VALUE", "label": {"api": {"Long.MAX_VALUE": [[68, 81]]}}}, {"text": "The Javadoc for Thread.stop() explains", "label": {"api": {"Thread.stop()": [[16, 28]]}}}, {"text": "In such a case, you can call Thread.interrupt() to instruct the thread to stop what it's doing (instead of the pattern described above, you could use Thread.interrupt() to similar effect) however similarly, if the thread's designer hasn't written it to handle interrupts, this may not do anything or cause inconsistent states or other errors", "label": {"api": {"Thread.interrupt()": [[29, 46], [150, 167]]}}}, {"text": "Ultimately, Thread.stop() is what you want if you just want to \"[Force] the thread to stop executing\" and can't modify the thread's implementation; however like using kill in Unix, this is a dangerous proposition, and you should essentially consider your JVM to be in an unstable and irreparable state after terminating a thread in this way, and attempt to exit the program as quickly as possible thereafter", "label": {"api": {"Thread.stop()": [[12, 24]]}}}, {"text": "This means you could call Thread.interrupt(), the thread could start it's proper interrupt-handling behavior, then midway through that, your call to Thread.stop() fires, violently killing the thread and potentially breaking your JVM", "label": {"api": {"Thread.stop()": [[149, 161]], "Thread.interrupt()": [[26, 43]]}}}, {"text": "Calls to Thread.interrupt() provide no guarantee as to when or how the thread will respond to that interrupt, which is why I prefer the explicit behavior in StoppableRunnable", "label": {"api": {"Thread.interrupt()": [[9, 26]]}}}, {"text": "Needless to say, if you're ever going to call Thread.stop() there's little to be gained by calling Thread.interrupt() first", "label": {"api": {"Thread.stop()": [[46, 58]], "Thread.interrupt()": [[99, 116]]}}}, {"text": "I don't recommend it, but you might as well just call Thread.stop() in the first place", "label": {"api": {"Thread.stop()": [[54, 66]]}}}, {"text": "Care must be taken that all JavaFX processing is done on the JavaFX application thread (by using Platform.runLater constructs) and Swing processing is done on the Swing Event Dispatch thread (by using SwingUtilities.invokeLater constructs)", "label": {"api": {"Platform.runLater": [[97, 113]], "SwingUtilities.invokeLater": [[201, 226]]}}}, {"text": "The JTree API recommends a MouseListener, but a key binding is also handy", "label": {"api": {"JTree": [[4, 8]]}}}, {"text": "Use BigDecimal for perfect decimal precision", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "Use a Stage instead of a Popup", "label": {"api": {"Stage": [[6, 10]], "Popup": [[25, 29]]}}}, {"text": "Before showing the stage, invoke stage.initModality as either APPLICATION_MODAL or WINDOW_MODAL, as appropriate", "label": {"api": {"stage.initModality": [[33, 50]], "APPLICATION_MODAL": [[62, 78]], "WINDOW_MODAL": [[83, 94]]}}}, {"text": "Also invoke stage.initOwner to the parent window of your new stage so that it will appropriately block it for the WINDOW_MODAL case", "label": {"api": {"WINDOW_MODAL": [[114, 125]], "stage.initOwner": [[12, 26]]}}}, {"text": "This is normally done using decode", "label": {"api": {"decode": [[28, 33]]}}}, {"text": "Check out SimpleDateFormat, from the JDK", "label": {"api": {"SimpleDateFormat": [[10, 25]]}}}, {"text": "Try Robot, which is a built-in class that facilitates automated keyboard/mouse interaction", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "Alternatively, consider FileSystemView, which is \"the gateway to the file system\" used by JFileChooser", "label": {"api": {"FileSystemView": [[24, 37]]}}}, {"text": "Using nanoTime() is preferred since it is the most precise system timer available in Java", "label": {"api": {"nanoTime()": [[6, 15]]}}}, {"text": "You can use Clone method", "label": {"api": {"Clone": [[12, 16]]}}}, {"text": "Have a look at CardLayout, this would allow to switch the content of your frame", "label": {"api": {"CardLayout": [[15, 24]]}}}, {"text": "A CardLayout object is a layout manager for a container", "label": {"api": {"CardLayout": [[2, 11]]}}}, {"text": "The first component added to a CardLayout object is the visible component when the container is first displayed", "label": {"api": {"CardLayout": [[31, 40]]}}}, {"text": "See How to Use CardLayout for an example", "label": {"api": {"CardLayout": [[15, 24]]}}}, {"text": "InflaterInputStream is expecting raw deflate data (RFC 1951), whereas compress2() is producing zlib-wrapped deflate data (RFC 1950 around RFC 1951)", "label": {"api": {"InflaterInputStream": [[0, 18]], "Inflater": [[0, 7]]}}}, {"text": "Inflater on the other hand does process zlib-wrapped data (unless you give it the nowrap option)", "label": {"api": {"Inflater": [[0, 7]]}}}, {"text": "This would be fine except that the second argument to the FileWriter constructor indicates that you want to append to an existing file, meaning that the file must exist", "label": {"api": {"FileWriter": [[58, 67]]}}}, {"text": "I suggest that you check for existence of the file using File.exists(), and if it exists use new FileWriter(\"somefile.txt\", true);, otherwise use new FileWriter(\"somefile.txt\", false); to create the file for the first time", "label": {"api": {"FileWriter": [[97, 106], [150, 159]], "File.exists()": [[57, 69]]}}}, {"text": "This is documented in the JavaFX Deployment Guide documentation for the Java Deployment Tookit (dtjava.js) as well as the JavaFX Application getParameters method JavaDoc", "label": {"api": {"getParameters": [[141, 153]]}}}, {"text": "As specified in the javadoc of take it will throw an InterruptedException when the thread waiting is interrupted", "label": {"api": {"javadoc of take": [[20, 34]]}}}, {"text": "So you need to make sure that your executor implementation will call Thread.interrupt() on all it's owning threads on shutdown", "label": {"api": {"Thread.interrupt()": [[69, 86]]}}}, {"text": "If you use shutdownNow() instead, it will actually interrupt the threads", "label": {"api": {"shutdownNow()": [[11, 23]]}}}, {"text": "When you want to store a handfull of key/value pairs like some user preferences, you could use the Preferences class, which is implemented using the registry on Windows, config files on Linux and whatever else is the preferred way to store user preferences on other plattforms", "label": {"api": {"Preferences": [[99, 109]]}}}, {"text": "You can try to use  the java.net.uri", "label": {"api": {"java.net.uri": [[24, 35]]}}}, {"text": "There are two different Locale categories, one for display and one for format", "label": {"api": {"Locale categories": [[24, 40]]}}}, {"text": "You do not stop a thread in Java, you send an interrupt() signal", "label": {"api": {"interrupt()": [[46, 56]]}}}, {"text": "If it is waiting, or sleeping or joining (wait(), sleep() or join()) has been called on it), an InterruptedException will be raised", "label": {"api": {"wait()": [[42, 47]], "sleep()": [[50, 56]], "InterruptedException": [[96, 115]]}}}, {"text": "The Thread (in its while loop) can test whether it has been interrupted by calling the isInterrupted() method and then decide to commit suicide (e.g", "label": {"api": {"isInterrupted()": [[87, 101]]}}}, {"text": "Alternatively and more easily, you could use a ProcessBuilder and call its redirectErrorStream(true) method", "label": {"api": {"ProcessBuilder": [[47, 60]]}}}, {"text": "If these are user values, then use a PreparedStatement with bind variables instead", "label": {"api": {"PreparedStatement": [[37, 53]]}}}, {"text": "Like many collection classes, Stack provides a addAll method", "label": {"api": {"Stack": [[30, 34]], "addAll": [[47, 52]]}}}, {"text": "JPA is not notified about changes made to data via script, but in typical use case with no additional caches and transaction-scoped PersistenceContext that is not the issue, because query will hit the database and deliver fresh data", "label": {"api": {"PersistenceContext": [[132, 149]]}}}, {"text": "Java's version is HashMap", "label": {"api": {"HashMap": [[18, 24]]}}}, {"text": "Use another constructor for FileWriter that provides the 'append' argument", "label": {"api": {"another constructor for FileWriter": [[4, 37]]}}}, {"text": "invokeLater may help here to ensure the code is executed on EDT", "label": {"api": {"invokeLater": [[0, 10]]}}}, {"text": "In the if, you are using == to compare strings; use String#equals instead", "label": {"api": {"String#equals": [[52, 64]]}}}, {"text": "In the else, you are using the assignment operator = to compare strings; use String#equals instead", "label": {"api": {"String#equals": [[77, 89]]}}}, {"text": "To counter this, you could to maintain co-ordinate information using the Polygon class about previous polygons in a separate List which could be painted along with the \"in-progress\" polygon", "label": {"api": {"Polygon": [[73, 79]]}}}, {"text": "You can set the minimum number of fraction digits on a NumberFormat instance using setMinimumFractionDigits(int)", "label": {"api": {"NumberFormat": [[55, 66]], "setMinimumFractionDigits(int)": [[83, 111]]}}}, {"text": "Just pitching here, but if you are using swing, look into JOptionPane especially the showMessageDialog methods", "label": {"api": {"JOptionPane": [[58, 68]]}}}, {"text": "I've used ManagementFactory#getRuntimeMXBean() fairly effectively for debugging purposes", "label": {"api": {"ManagementFactory#getRuntimeMXBean()": [[10, 45]]}}}, {"text": "You probably just want the name", "label": {"api": {"name": [[27, 30]]}}}, {"text": "Returns the name representing the running Java virtual machine", "label": {"api": {"name": [[12, 15]]}}}, {"text": "The returned name string can be any arbitrary string and a Java virtual machine implementation can choose to embed platform-specific useful information in the returned name string", "label": {"api": {"name": [[13, 16], [168, 171]]}}}, {"text": "Each running virtual machine could have a different name", "label": {"api": {"name": [[52, 55]]}}}, {"text": "Most of what you are doing looks to be things that throw IOException", "label": {"api": {"IOException": [[57, 67]]}}}, {"text": "However there is no StrongReference class, and according to the Reference javadocs", "label": {"api": {"Reference javadocs": [[64, 81]]}}}, {"text": "I don't know what is in 'getServletConnection()', but you could try using 'doOutput()' and not reading from the response, until you have finished writing to the request", "label": {"api": {"'doOutput()'": [[74, 85]]}}}, {"text": "Well you can write to anywhere you like in a file using RandomAccessFile - just use seek to get to the right place, and start writing", "label": {"api": {"RandomAccessFile": [[56, 71]], "seek": [[84, 87]]}}}, {"text": "You should make your timer to fire event repeatedly using Timer.setRepeats(true)", "label": {"api": {"Timer.setRepeats(true)": [[58, 79]]}}}, {"text": "You could check whether your Document also is an instance of EventTarget", "label": {"api": {"EventTarget": [[61, 71]]}}}, {"text": "For example, if the event being handled is a MutationEvent, you might get information about the modification to the document", "label": {"api": {"MutationEvent": [[45, 57]]}}}, {"text": "To make a thread a daemon thread, call Thread.setDaemon(true) before startin it", "label": {"api": {"Thread.setDaemon(true)": [[39, 60]]}}}, {"text": "Use LinkedList.get(int index) or the enhanced for loop to iterate over all elements in list", "label": {"api": {"LinkedList.get(int index)": [[4, 28]]}}}, {"text": "Use the method addAll() of List to add a Collection of Object", "label": {"api": {"addAll()": [[15, 22]]}}}, {"text": "I'd play around with BufferedReader", "label": {"api": {"BufferedReader": [[21, 34]]}}}, {"text": "Get user input using java.util.Scanner and use java.io.File.listFiles(FilenameFilter) method to get the list of files in the folder with specific filter", "label": {"api": {"java.util.Scanner": [[21, 37]], "java.io.File.listFiles(FilenameFilter)": [[47, 84]]}}}, {"text": "Just get the image in byte[] flavor the usual Java I/O way and feed that in turn to DataTypeConverter#printHexBinary() to get a hex string out of it", "label": {"api": {"DataTypeConverter#printHexBinary()": [[84, 117]]}}}, {"text": "Beside the solution provided by other users, you can make a List from the Array and then use an already existing method that finds the maximum value in the list", "label": {"api": {"List": [[60, 63]]}}}, {"text": "You comparator doesn't look like it conforms to the specification", "label": {"api": {"specification": [[52, 64]]}}}, {"text": "The Javadoc for Class.newInstance() explains it like this", "label": {"api": {"Class.newInstance()": [[16, 34]]}}}, {"text": "The answer is obvious from a thorough reading of the javadoc for java.lang.Class", "label": {"api": {"java.lang.Class": [[65, 79]]}}}, {"text": "Where then does the annotation @WebServiceRef come into play", "label": {"api": {"@WebServiceRef": [[31, 44]]}}}, {"text": "Also, as is so often the case there are data types that will help you, and TreeSet is a great example of one", "label": {"api": {"TreeSet": [[75, 81]]}}}, {"text": "It implements the SortedSet interface and is alphabetical every time you iterate through ti (actually it's alphabetical every time you insert into it, something to keep in mind as the set grows in length)", "label": {"api": {"SortedSet": [[18, 26]]}}}, {"text": "Given this property if you wanted to optimize you may only need to use TreeSet when the list might change it's alphabetic order (on insert)", "label": {"api": {"TreeSet": [[71, 77]]}}}, {"text": "You could achieve the desired results using the java util concurrent's SynchronousQueue", "label": {"api": {"SynchronousQueue": [[71, 86]]}}}, {"text": "Use the take call to initiate block read onto the SynchronousQueue", "label": {"api": {"SynchronousQueue": [[50, 65]]}}}, {"text": "So if all the workers have taken one work each and are busy processing them (communicating with the socket), there will be none reading from the SynchronousQueue and hence an offer to synchronous queue will fail", "label": {"api": {"SynchronousQueue": [[145, 160]]}}}, {"text": "The simplest way to implement sorting in Java Collections is using the Collections#sort method", "label": {"api": {"Collections#sort": [[71, 86]]}}}, {"text": "It is important to say that it can only sort objects of a class that implements the Comparable interface, so you may need to take that into account", "label": {"api": {"Comparable": [[84, 93]]}}}, {"text": "For that it's best if you define a Comparator when you invoke the method", "label": {"api": {"Comparator": [[35, 44]]}}}, {"text": "Use the ServerSocket class", "label": {"api": {"ServerSocket": [[8, 19]]}}}, {"text": "You want a StringBuilder object, to which you can append char characters, then you convert it to a String with toString()", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "Use a StringBuilder", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "It has a append(char c) method to do exactly what you want", "label": {"api": {"append(char c)": [[9, 22]]}}}, {"text": "Also, at the end of processing you can use its toString method to get the equivalent String object", "label": {"api": {"toString": [[47, 54]]}}}, {"text": "Om, and I would consider using StringBuilder", "label": {"api": {"StringBuilder": [[31, 43]]}}}, {"text": "Use the String#indexOf method to determine if the word is in the string", "label": {"api": {"String#indexOf": [[8, 21]]}}}, {"text": "You need to pass a java.util.File as stated in ImageIO#read documentation", "label": {"api": {"ImageIO#read documentation": [[47, 72]]}}}, {"text": "You want to open the OutputStream in append mode", "label": {"api": {"append mode": [[37, 47]]}}}, {"text": "Use a TableModel to your JTable", "label": {"api": {"TableModel": [[6, 15]]}}}, {"text": "Updating the table can be done using setValueAt method", "label": {"api": {"setValueAt": [[37, 46]]}}}, {"text": "System.out.print is a void method", "label": {"api": {"System.out.print": [[0, 15]]}}}, {"text": "If you want to return something from your toString() method, you only need to return what you wanted from the System.out.print method", "label": {"api": {"System.out.print": [[110, 125]]}}}, {"text": "Based on @Aurand suggestion, you can have a switch that will call your methods and a List<Integer> that will contain the indexes of the methods you want to invoke, then shuffle the list elements using Collections.shuffle and calling the switch to call your methods", "label": {"api": {"Collections.shuffle": [[201, 219]]}}}, {"text": "Use Collections.shuffle(list) and just 3 lines of code for the whole thing", "label": {"api": {"Collections.shuffle(list)": [[4, 28]]}}}, {"text": "You can do this using Random Access File", "label": {"api": {"Random Access File": [[22, 39]]}}}, {"text": "This is because pack() causes the frame to be re-sized", "label": {"api": {"re-sized": [[46, 53]]}}}, {"text": "From the doc", "label": {"api": {"the doc": [[5, 11]]}}}, {"text": "See the the documentation for Object and note also that if you override equals you SHOULD also override the hashCode() method", "label": {"api": {"the documentation for Object": [[8, 35]]}}}, {"text": "I think the better way to code is to have a condition in your while loop using Scanner#hasNextLine()", "label": {"api": {"Scanner#hasNextLine()": [[79, 99]]}}}, {"text": "Scanner#hasNextLine() would make sure that code inside while would only run if it has a line in the file=", "label": {"api": {"Scanner#hasNextLine()": [[0, 20]]}}}, {"text": "The way to do this is by using the @Enumerated annotation directly on the field", "label": {"api": {"@Enumerated annotation": [[35, 56]]}}}, {"text": "If needed, I guess you could annotate your JobId class with @Embeddable and then put the @Enumerated annotation on your JobType field", "label": {"api": {"@Enumerated annotation": [[89, 110]]}}}, {"text": "I think you can achieve that by implementing your own SpinnerModel and supplying that as argument to the JSpinner constructor", "label": {"api": {"SpinnerModel": [[54, 65]]}}}, {"text": "The effect of calling Connection.close() when a transaction is active is implementation defined", "label": {"api": {"Connection.close()": [[22, 39]]}}}, {"text": "See the docs for SimpleDateFormat for more details about what the various format specifiers mean", "label": {"api": {"SimpleDateFormat": [[17, 32]]}}}, {"text": "See SwingWorker docs, it has a pretty good example how to utilize publish()/process() methods", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Use java.util.UUID to generate proper unique ID", "label": {"api": {"java.util.UUID": [[4, 17]]}}}, {"text": "You should try using Pattern and Matcher", "label": {"api": {"Pattern": [[21, 27]], "Matcher": [[33, 39]]}}}, {"text": "You can use the Arc2D class for drawing circles with float/double precision, since it is a Shape and the Graphics2D class can draw shapes", "label": {"api": {"Arc2D": [[16, 20]], "Shape": [[91, 95]], "Graphics2D": [[105, 114]]}}}, {"text": "In a similar way, you can draw rectangles by using the Rectangle2D class", "label": {"api": {"Rectangle2D": [[55, 65]]}}}, {"text": "If you need concurrency, a better datastructure for this would be a CopyOnWriteArrayList that guarantees the integrity of the list while iterating over it, but the remove operation is more costly", "label": {"api": {"CopyOnWriteArrayList": [[68, 87]]}}}, {"text": "paramList(remove);, iterator operations are not supported for CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[62, 81]]}}}, {"text": "You should probably use System.currentTimeMillis to calculate both startTime and endTime1", "label": {"api": {"System.currentTimeMillis": [[24, 47]]}}}, {"text": "Or if you need nanosecond resolution (though not guaranteed with System.nanoTime) you should represent max duration in nanoseconds", "label": {"api": {"System.nanoTime": [[65, 79]]}}}, {"text": "Look at the Map interface and what the JDK offers for concrete implementations", "label": {"api": {"Map": [[12, 14]]}}}, {"text": "Java has built-in support; please see the HashMap class", "label": {"api": {"HashMap": [[42, 48]]}}}, {"text": "If you just want values stored, then perhaps a HashSet would be a better choice for when the key is the value", "label": {"api": {"HashSet": [[47, 53]]}}}, {"text": "Just looking thru the Java thread states", "label": {"api": {"thread states": [[27, 39]]}}}, {"text": "You want this.getClass().getClassLoader().getResourceAsStream", "label": {"api": {"this.getClass().getClassLoader().getResourceAsStream": [[9, 60]]}}}, {"text": "You neet to use JPasswordField for this", "label": {"api": {"JPasswordField": [[16, 29]]}}}, {"text": "Using the setEchoChar(char) you can echo any character you want", "label": {"api": {"setEchoChar(char)": [[10, 26]]}}}, {"text": "For example, TreeSet.tailSet returns a view of the portion of backing set whose elements are greater than or equal to fromElement", "label": {"api": {"TreeSet.tailSet": [[13, 27]]}}}, {"text": "From the documentation", "label": {"api": {"From the documentation": [[0, 21]]}}}, {"text": "No need to write a ConcurrentHashMap, use this one", "label": {"api": {"this one": [[42, 49]]}}}, {"text": "You use find when you want to look up an entity by primary key", "label": {"api": {"find": [[8, 11]]}}}, {"text": "You use createQuery when you want to find entities using criteria or if you want to use a JPQL statement to define what you get back", "label": {"api": {"find": [[37, 40]], "createQuery": [[8, 18]]}}}, {"text": "ColorConvertOp is illustrated here and compared to a disabled image here", "label": {"api": {"ColorConvertOp": [[0, 13]]}}}, {"text": "SwingWorker is the way to go", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "If you're not familiar with SwingWorker, it's basically a class that lets you have long-running computations running", "label": {"api": {"SwingWorker": [[28, 38]]}}}, {"text": "The task can do this by invoking SwingWorker.publish", "label": {"api": {"SwingWorker": [[33, 43]]}}}, {"text": "Each argument must be of the type specified by SwingWorker's second type parameter", "label": {"api": {"SwingWorker": [[47, 57]]}}}, {"text": "If for some reason you can't use SwingWorker, you'd need to use asynchronous threads to do this", "label": {"api": {"SwingWorker": [[33, 43]]}}}, {"text": "You could put the long-running task on an executor (which would execute the task asynchronously using a thread pool) and return a Future that you can use later to get the answer", "label": {"api": {"Future": [[130, 135]]}}}, {"text": "When you call get on the future, it blocks until the task finishes, so you can use your initial answer right away and call Future.get when you need more precision later, having given the task some time to finish", "label": {"api": {"Future": [[123, 128]]}}}, {"text": "You can use a ByteArrayOutputStream as a light-weight expandable array of bytes", "label": {"api": {"ByteArrayOutputStream": [[14, 34]]}}}, {"text": "Why would something like Set.addAll(Collection c) not suffice", "label": {"api": {"Set.addAll(Collection c)": [[25, 48]]}}}, {"text": "String.split() can split over a regex string", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "Yes, you can, because replaceAll first creates a Pattern before replacing, and if you look at the javadocs for Pattern, you can see that | has exactly the function you want to", "label": {"api": {"Pattern": [[49, 55], [111, 117]]}}}, {"text": "If you are willing to lose some specificty, all of the Crypto exceptions extend GeneralSecurityException, you can just catch that instead", "label": {"api": {"GeneralSecurityException": [[80, 103]]}}}, {"text": "You can use the string replaceAll function", "label": {"api": {"string replaceAll": [[16, 32]]}}}, {"text": "The exception is thrown from ImageIcon constructor", "label": {"api": {"constructor": [[39, 49]]}}}, {"text": "Looks from the sample like ImageIcon is initialized with URL, this constructor", "label": {"api": {"constructor": [[67, 77]]}}}, {"text": "You should look into using a SwingWorker", "label": {"api": {"SwingWorker": [[29, 39]]}}}, {"text": "Basically you do all the IO on the background thread that the SwingWorker provides, and there are built-in ways of reporting the progress to the swing thread", "label": {"api": {"SwingWorker": [[62, 72]]}}}, {"text": "Take a look at Swingworker Timeout or SwingWorker with FileReader to see if either will help", "label": {"api": {"SwingWorker": [[38, 48]]}}}, {"text": "An alternative solution, if you don't want to use a SwingWorker, would probably just be to, instead of updating that position value, update the progress bar directly, with a call like this", "label": {"api": {"SwingWorker": [[52, 62]]}}}, {"text": "See the Pattern documentation for more details", "label": {"api": {"Pattern": [[8, 14]]}}}, {"text": "For example, use ArrayList", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "It seems like there is no official benchmarks for some of the very commonly used classes, for example ArrayList", "label": {"api": {"ArrayList": [[102, 110]]}}}, {"text": "Compared to Python's List, which is similar to ArrayList, there is a well documented runtime complexity (see link above)", "label": {"api": {"ArrayList": [[47, 55]]}}}, {"text": "This post, gave some somewhat detailed benchmark on removing and copying elements from an ArrayList, but it still doesn't give the exact complexity analysis", "label": {"api": {"ArrayList": [[90, 98]]}}}, {"text": "I'm working on a project which takes extremely long data (~500,000 data points) so I can't sit back and assume removing or inserting data from ArrayList operates in constant time like magic", "label": {"api": {"ArrayList": [[143, 151]]}}}, {"text": "After sending the message you then need to access the socket InputStream to read the response from the server", "label": {"api": {"InputStream": [[61, 71]]}}}, {"text": "what I'd get from Class.getResource(String)) as a java.nio.file.Path", "label": {"api": {"Class.getResource(String)": [[18, 42]], "java.nio.file.Path": [[50, 67]]}}}, {"text": "Note that Number can't be auto-unboxed; you would have to call intValue() to get an int back", "label": {"api": {"intValue()": [[63, 72]]}}}, {"text": "Second,  Integer.valueOf() will cache values in a byte range, from -128 to 127", "label": {"api": {"cache values in a byte range, from -128 to 127": [[32, 77]]}}}, {"text": "Just look at the java.util.Arrays class; having to write this kind of code is enough to make me want to switch to C++", "label": {"api": {"java.util.Arrays class": [[17, 38]]}}}, {"text": "If you don't want any external dependencies the class to use from the standard library is java.net.HttpURLConnection", "label": {"api": {"java.net.HttpURLConnection": [[90, 115]]}}}, {"text": "Well you haven't said what you want the string to look like, but you might want Arrays.toString(int[]) or Arrays.toString(double[]) (as you've now changed the variable type)", "label": {"api": {"Arrays.toString(int[])": [[80, 101]], "Arrays.toString(double[])": [[106, 130]]}}}, {"text": "For some concurrent programming I could use the Java's CountDownLatch concept", "label": {"api": {"CountDownLatch": [[55, 68]]}}}, {"text": "DefaultListModel is a generic type from Java 7", "label": {"api": {"generic type": [[22, 33]]}}}, {"text": "From Java 7 DefaultListModel is considered as Generic class", "label": {"api": {"DefaultListModel": [[12, 27]]}}}, {"text": "And while extending it you are not providing generic type to the DefaultListModel that you are extending", "label": {"api": {"DefaultListModel": [[65, 80]]}}}, {"text": "Check the documentation for the Queue Interface for more information", "label": {"api": {"Queue Interface": [[32, 46]]}}}, {"text": "Your current code runs, as mentioned, on the uiThread", "label": {"api": {"Thread": [[47, 52]]}}}, {"text": "Consider using either an asynctask or a class which extends Thread", "label": {"api": {"Thread": [[60, 65]]}}}, {"text": "Use a JFormattedTextField, for example", "label": {"api": {"JFormattedTextField": [[6, 24]]}}}, {"text": "Oracle provides a tutorial based on the FileVisitor interface that explains how one can go by", "label": {"api": {"FileVisitor": [[40, 50]]}}}, {"text": "I understand many of these issues have been fixed with the new Java 7 Phaser but I am not yet sufficiently familliar with it to say one way or the other", "label": {"api": {"Phaser": [[70, 75]]}}}, {"text": "I suggest you to use a sorted collection like a SortedSet< Integer > (implementation class TreeSet)", "label": {"api": {"SortedSet< Integer >": [[48, 67]], "TreeSet": [[91, 97]], "sort": [[23, 26]]}}}, {"text": "Always sorted and remove duplicates", "label": {"api": {"sort": [[7, 10]]}}}, {"text": "If you absolutely want an int[], java.util.Arrays utility contains search and sort", "label": {"api": {"java.util.Arrays": [[33, 48]], "search": [[67, 72]], "sort": [[78, 81]]}}}, {"text": "You can use the regex pattern given as a String with the matches(...) method of the String class", "label": {"api": {"matches(...) method": [[57, 75]], "String class": [[84, 95]]}}}, {"text": "You can also use a Pattern and a Matcher object to reuse the pattern for multiple uses", "label": {"api": {"Pattern": [[19, 25]]}}}, {"text": "Try to use getSelectedValue()", "label": {"api": {"getSelectedValue()": [[11, 28]]}}}]