[{"text":"You could then have Person implement the Comparable interface, e.g","label":{"api":{"Comparable":[[41,50]]}}},{"text":"Now that the ordering of a Person would be defined based on the dateTime attribute, sorting a List<Person> myPersonList in ascending datetime order is as simple as Collections.sort(myPersonList) and sorting by descending order as simple as Collections.sort(myPersonList, Collections.reverseOrder())","label":{"api":{"Person":[[27,32]],"dateTime":[[64,71]],"List<Person>":[[94,105]],"Collections.sort(myPersonList)":[[164,193]],"Collections.sort(myPersonList, Collections.reverseOrder())":[[240,297]]}}},{"text":"Alternatively, the quick-and-dirty solution to the problem is to create a custom Comparator, which would allow you to order a list of List<String> myStringList based on the datetime token (in index 5, when split by the _ delimiter) of each element","label":{"api":{"Comparator":[[81,90]],"List<String>":[[134,145]]}}},{"text":"With Comparator<String> myComparator = new UserInfoDateTimeComparator(), myStringList can be sorted through Collections.sort(myStringList, myComparator) in ascending datetime order and through Collections.sort(myStringList, Collections.reverseOrder(myComparator)) in descending order","label":{"api":{"Collections.sort(myStringList, myComparator)":[[108,151]],"Collections.sort(myStringList, Collections.reverseOrder(myComparator))":[[193,262]]}}},{"text":"One solution that I could suggest is using Proxy objects","label":{"api":{"Proxy":[[43,47]]}}},{"text":"The Arrays class contains various methods for manipulating arrays, including the static stream() method which returns a sequential Stream with the specified array as its source","label":{"api":{"Arrays":[[4,9]],"stream()":[[88,95]],"Stream":[[131,136]]}}},{"text":"You have to use @JoinColumn for association columns","label":{"api":{"@JoinColumn":[[16,26]]}}},{"text":"If you're already on Java 7+, better yet is to let your context implement AutoCloseable whereby close() invokes remove() and then use a try-with-resources block","label":{"api":{"AutoCloseable":[[74,86]],"close()":[[96,102]],"remove()":[[112,119]]}}},{"text":"I have a Delegate that instanciate the corresponding Bean sending credentials (Josso Authentication) through InitialContext as shown here","label":{"api":{"Delegate":[[9,16]],"InitialContext":[[109,122]]}}},{"text":"You can use Java's WatchService to watch a directory for changes","label":{"api":{"WatchService":[[19,30]]}}},{"text":"The direct solution would be to invoke ifPresent(consumer) on the Optional returned by findFirst()","label":{"api":{"ifPresent(consumer)":[[39,57]],"Optional":[[66,73]],"findFirst()":[[87,97]]}}},{"text":"But note that the remove(Object) operation will again traverse the list to find the element to remove","label":{"api":{"remove(Object)":[[18,31]]}}},{"text":"With this solution, the remove(int) operation operates directly on the index","label":{"api":{"remove(int)":[[24,34]]}}},{"text":"The hashCode of List implementations is defined in terms of the hashCode of its elements","label":{"api":{"hashCode":[[4,11],[64,71]],"List":[[16,19]]}}},{"text":"You seem to be assuming that it uses the default hashCode of Object, which is not the case","label":{"api":{"hashCode":[[49,56]],"Object":[[61,66]]}}},{"text":"Additionally, even if ArrayList did not implement hashCode, the default hash code (also known as the identity hash code) of an ArrayList would not change if the internal array was re-allocated, as the ArrayList object itself stays the same, just the internal array object (that you don't get direct access to) will be replaced with a new one","label":{"api":{"ArrayList":[[22,30],[127,135],[201,209]],"hashCode":[[50,57]]}}},{"text":"String.format returns a String as per the docs","label":{"api":{"String.format":[[0,12]],"String":[[24,29]]}}},{"text":"See the PasswordCallback from JAAS that uses this mechanism","label":{"api":{"PasswordCallback":[[8,23]]}}},{"text":"If you need to specify endianness, or anything about the charset for that matter, you should use getBytes(Charset) or getBytes(String)","label":{"api":{"getBytes(Charset)":[[97,113]],"getBytes(String)":[[118,133]]}}},{"text":"There are a few standard charsets that all JREs support — including UTF_16BE (big endian) and UTF_16LE (little endian)","label":{"api":{}}},{"text":"What about a TreeSet","label":{"api":{"TreeSet":[[13,19]]}}},{"text":"You may need to use the constructor with a Comparator","label":{"api":{"Comparator":[[43,52]]}}},{"text":"However, standard Java does have a class in the runtime library which contains all of the Java keywords - the SourceVersion enum in the javax.lang.model package","label":{"api":{"runtime":[[48,54]],"SourceVersion":[[110,122]],"javax.lang.model":[[136,151]]}}},{"text":"This is what DataOutputStream # writeDouble does","label":{"api":{"DataOutputStream # writeDouble":[[13,42]]}}},{"text":"A Java >= 7 buffered solution which will take care of closing resources using a try-with-resources block","label":{"api":{}}},{"text":"If you always want the ceil value, you could use Math.ceil","label":{"api":{"Math.ceil":[[49,57]]}}},{"text":"You might want to use a Scanner object instead of BufferedReader","label":{"api":{"Scanner":[[24,30]],"BufferedReader":[[50,63]]}}},{"text":"You could also store the ticket numbers in an ArrayList constructed like this","label":{"api":{"ArrayList":[[46,54]]}}},{"text":"Using a DateTimeFormatterBuilder, you can append the wanted pattern with the time part in an optional section, i.e","label":{"api":{"DateTimeFormatterBuilder":[[8,31]]}}},{"text":"The OFFSET_SECONDS field to 0 represents no offset from UTC","label":{"api":{"OFFSET_SECONDS":[[4,17]]}}},{"text":"The constructor for File taking a URI assumes it gets a file","label":{"api":{"File":[[20,23]],"URI":[[34,36]]}}},{"text":"See https://docs.oracle.com/javase/7/docs/api/java/lang/String.html for more help","label":{"api":{}}},{"text":"Why does Collections.sort(List<T>) have the signature","label":{"api":{"Collections.sort(List<T>)":[[9,33]]}}},{"text":"As you have already recognized, the behaviour of java.util.Date.toString() is based on TimeZone.getDefault()","label":{"api":{"TimeZone.getDefault()":[[87,107]]}}},{"text":"I am parsing MS SQL date with java.text.SimpleDateFormat but it is giving me wrong output","label":{"api":{"java.text.SimpleDateFormat":[[30,55]]}}},{"text":"According to the documentation of SimpleDateFormat, it should parse correctly or may be I am missing something","label":{"api":{"SimpleDateFormat":[[34,49]]}}},{"text":"Within DateTimeFormatter, the S format specifier does mean \"fraction-of-second\"","label":{"api":{"DateTimeFormatter":[[7,23]]}}},{"text":"You should use the Collection.removeIf(predicate) method","label":{"api":{"Collection.removeIf(predicate)":[[19,48]]}}},{"text":"You can use addAll() of Collections","label":{"api":{"addAll()":[[12,19]],"Collections":[[24,34]]}}},{"text":"As an example look at the API doc for classes in the java.util.concurrent packages, like BlockingQueue, see how methods like put and offer throw InterruptedException","label":{"api":{"java.util.concurrent":[[53,72]],"BlockingQueue":[[89,101]],"InterruptedException":[[145,164]]}}},{"text":"Then you might use a BufferedReader to read the lines","label":{"api":{"BufferedReader":[[21,34]]}}},{"text":"If you are using Java 8, then the OffsetTime may come in handy for a few reasons","label":{"api":{"OffsetTime":[[34,43]]}}},{"text":"And you can compare to other time objects using the method isBefore","label":{"api":{"time":[[29,32]],"isBefore":[[59,66]]}}},{"text":"If the date should be considered, then you can use OffsetDateTime","label":{"api":{"OffsetDateTime":[[51,64]]}}},{"text":"But you can create a ServletContextListener which is loaded at application startup before any filter or servlet, initialize your variables in the listener, and let your serlvets and filters then use the already initialized variables","label":{"api":{"ServletContextListener":[[21,42]]}}},{"text":"In the Java crypto libraries, there are two different representations of a key - Key and KeySpec","label":{"api":{"crypto":[[12,17]],"Key":[[81,83]],"KeySpec":[[89,95]]}}},{"text":"The docs imply there's a difference between the two - a KeySpec is 'transparent' (whatever that means), but has no methods, whereas Key has got a getEncoded method","label":{"api":{"KeySpec":[[56,62]],"Key":[[132,134]],"getEncoded":[[146,155]]}}},{"text":"You're meant to use a KeyFactory to convert between the two (and it indeed has got a getKeySpec method to convert)","label":{"api":{"KeyFactory":[[22,31]],"getKeySpec":[[85,94]]}}},{"text":"However, SecretKeySpec implements both Key and KeySpec","label":{"api":{"SecretKeySpec":[[9,21]],"Key":[[39,41]],"KeySpec":[[47,53]]}}},{"text":"But there is a SecretKeyFactory class as well, that doesn't inherit off KeyFactory","label":{"api":{"SecretKeyFactory":[[15,30]],"KeyFactory":[[72,81]]}}},{"text":"What's the different between a Key and a KeySpec, and how does SecretKeySpec and SecretKeyFactory come into it","label":{"api":{"Key":[[31,33]],"KeySpec":[[41,47]],"SecretKeySpec":[[63,75]],"SecretKeyFactory":[[81,96]]}}},{"text":"It looks like double.TryParse is what is ultimately used when Json.NET parses a number to double and Double.parseDouble is what is ultimately used when Jackson ObjectMapper parses a number to double","label":{"api":{"double.TryParse":[[14,28]],"Json.NET":[[62,69]],"Double.parseDouble":[[101,118]],"Jackson ObjectMapper":[[152,171]]}}},{"text":"Can I expect Microsoft's double.TryParse and Java's Double.parseDouble to agree exactly on the value of every JSON number","label":{"api":{"double.TryParse":[[25,39]],"Double.parseDouble":[[52,69]]}}},{"text":"I would suggest to use ExecutorService instead of creating threads by hand, more specifically Executors.newFixedThreadPool","label":{"api":{"ExecutorService":[[23,37]],"Executors.newFixedThreadPool":[[94,121]]}}},{"text":"On other hand, in your current code, replace synchronized block and incrementing of static variable with AtomicInteger","label":{"api":{"AtomicInteger":[[105,117]]}}},{"text":"In spare time, take a look at java.util.concurrent package, it contains lots of great stuff usable for multithreading","label":{"api":{"java.util.concurrent":[[30,49]]}}},{"text":"The Possible solution is define area as a array or list(if size is unknown), Store values in array and display it","label":{"api":{}}},{"text":"There's a link to Java Filesystem glob patterns , which in turn links to getPathMatcher(String), that lists all the globbing options","label":{"api":{"getPathMatcher(String)":[[73,94]]}}},{"text":"You can use Objects::nonNull from the Java8 SDK","label":{"api":{"Objects::nonNull":[[12,27]]}}},{"text":"I know I can use the Invocable class to invoke methods on a class","label":{"api":{"Invocable":[[21,29]]}}},{"text":"You can use StringTokenizer class for parsing data","label":{"api":{"StringTokenizer":[[12,26]]}}},{"text":"Having said that, take a look at ScheduledExecutorService specifically at the scheduleAtFixedRate method","label":{"api":{"ScheduledExecutorService":[[33,56]],"scheduleAtFixedRate":[[78,96]]}}},{"text":"I highly recommend browsing the javadocs for the java.util.concurrent package","label":{"api":{"java.util.concurrent":[[49,68]]}}},{"text":"Take a look at java.io.RandomAccessFile.seek()","label":{"api":{"java.io.RandomAccessFile.seek()":[[15,45]]}}},{"text":"You can set the position in the file for a FileInputStream using FileChannel.position(long) of it's FileChannel","label":{"api":{"FileInputStream":[[43,57]],"FileChannel.position(long)":[[65,90]],"FileChannel":[[100,110]]}}},{"text":"You can use allMatch(predicate) to determine if all deals of an option are red","label":{"api":{"allMatch(predicate)":[[12,30]]}}},{"text":"TreeMap provides the navigableKeySet() method which returns a NavigableSet which provides a descendingIterator()","label":{"api":{"TreeMap":[[0,6]],"navigableKeySet()":[[21,37]],"NavigableSet":[[62,73]],"descendingIterator()":[[92,111]]}}},{"text":"You can use a list of matrix parameters, represented by the @MatrixParam annotation, as following","label":{"api":{"@MatrixParam":[[60,71]]}}},{"text":"Have you tried using a FileWriter with append mode","label":{"api":{"FileWriter":[[23,32]]}}},{"text":"For example in case of TreeSet, iterators are fail-fast, therefore adding elements while iterating will trigger a ConcurrentModificationException","label":{"api":{"TreeSet":[[23,29]],"ConcurrentModificationException":[[114,144]]}}},{"text":"From the JavaDoc of TreeSet","label":{"api":{"TreeSet":[[20,26]]}}},{"text":"However, more fundamentally, Collection.add (and Set.add) is documented as an optional operation, so we can never rely upon a call to SortedSet.add being safe, whether in the context an ongoing iteration or not","label":{"api":{"Collection.add":[[29,42]],"Set.add":[[49,55]],"SortedSet.add":[[134,146]]}}},{"text":"For instance, calling add on a SortedSet returned by Collections.unmodifiableSortedSet or a Guava ImmutableSortedSet would result in an UnsupportedOperationException","label":{"api":{"SortedSet":[[31,39]],"Collections.unmodifiableSortedSet":[[53,85]],"ImmutableSortedSet":[[98,115]],"UnsupportedOperationException":[[136,164]]}}},{"text":"I've done some googling and reading through http://docs.oracle.com/javaee/6/api/javax/persistence/Query.html and haven't found an easy way to do what I'm looking to do","label":{"api":{}}},{"text":"The constructor for Scanner that takes a String parameter does not do what you think it does","label":{"api":{"Scanner":[[20,26]],"String":[[41,46]]}}},{"text":"Read the javadoc on the Scanner API","label":{"api":{"Scanner":[[24,30]]}}},{"text":"I have looked at CriteriaBuilder.least(..) and greatest(..), but am having a difficult time trying to understand how to create the Expression<T> to pass to either function","label":{"api":{"CriteriaBuilder.least(..)":[[17,41]],"greatest(..)":[[47,58]],"Expression<T>":[[131,143]]}}},{"text":"This could be achieved easily using stream API","label":{"api":{"stream":[[36,41]]}}},{"text":"In java 8 the compute method was added to the Map interface","label":{"api":{"compute":[[14,20]],"Map":[[46,48]]}}},{"text":"The lambda expression passed as second parameter to compute receives the old value the key was mapped to as second parameter or null, if there was no mapping","label":{"api":{}}},{"text":"You could also consider using an ExecutorService with a fixed number of threads, and submit the jobs to this executor service","label":{"api":{"ExecutorService":[[33,47]],"executor service":[[109,124]]}}},{"text":"I though of doing something like return t.equals(URI_LIST_TYPE), but I don't know how to get an instance of Type that represents List<URI>","label":{"api":{"t.equals(URI_LIST_TYPE)":[[40,62]],"Type":[[108,111]],"List<URI>":[[129,137]]}}},{"text":"You can implement your pojo to use a map as container for all your properties","label":{"api":{"map":[[37,39]],"properties":[[67,76]]}}},{"text":"Or you directly use the built-in java properties","label":{"api":{"properties":[[38,47]]}}},{"text":"JTable.getRowCount returns the number of rows in the view, not the model","label":{"api":{"JTable.getRowCount":[[0,17]]}}},{"text":"You need to convert view indices to model indices and vice versa using the JTable.convertRowIndexToView and JTable.convertRowIndexToModel","label":{"api":{"JTable.convertRowIndexToView":[[75,102]],"JTable.convertRowIndexToModel":[[108,136]]}}},{"text":"Look into JTable.convertColumnIndexToView and JTable.convertColumnIndexToModel","label":{"api":{"JTable.convertColumnIndexToView":[[10,40]],"JTable.convertColumnIndexToModel":[[46,77]]}}},{"text":"Look up the value using model.getValueAt()","label":{"api":{"model.getValueAt()":[[24,41]]}}},{"text":"Delete the row with model.removeRow(), afterwards decrement your loop variable (eg model.removeRow(i--);)","label":{"api":{"model.removeRow()":[[20,36]]}}},{"text":"Iterate the model's dataVector to find the rows to delete, and delete them using Iterator.remove","label":{"api":{"dataVector":[[20,29]],"Iterator.remove":[[81,95]]}}},{"text":"After your loop, call fireTableChanged on your model","label":{"api":{"fireTableChanged":[[22,37]]}}},{"text":"Servlet Context, the the meaning of ServletContext class, is the application-wide context a Servlet webapp has","label":{"api":{"Servlet Context":[[0,14]],"ServletContext":[[36,49]],"Servlet":[[92,98]]}}},{"text":"You can achieve that using a GridLayout","label":{"api":{"GridLayout":[[29,38]]}}},{"text":"assign a GridLayout to panelButton with two rows and one column, and then add the two panels to it","label":{"api":{"GridLayout":[[9,18]],"panelButton":[[23,33]]}}},{"text":"Now you can test the second method and pass a a fixed clock - no need to use a mocking framework","label":{"api":{}}},{"text":"You can serialize your GcsOutputChannel using any Java serialization means (typically using ObjectOutputStream)","label":{"api":{"GcsOutputChannel":[[23,38]],"ObjectOutputStream":[[92,109]]}}},{"text":"The readObject method (https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()) is what you want, you just need to cast the RESULT to the class you expect","label":{"api":{}}},{"text":"This is an implementation using JSR-310","label":{"api":{"JSR-310":[[32,38]]}}},{"text":"You can achieve that with your Scanner by using the useDelimiter method","label":{"api":{"Scanner":[[31,37]],"useDelimiter":[[52,63]]}}},{"text":"This matches the printf method signature, which takes in the format String first, followed by any number of Object variable parameters","label":{"api":{"printf":[[17,22]],"String":[[68,73]],"Object":[[108,113]]}}},{"text":"In your case, using the index variant  getInt(int) would be the easiest","label":{"api":{"getInt(int)":[[39,49]]}}},{"text":"The following snippet parses the Scanner input line by line adding to the list","label":{"api":{"Scanner":[[33,39]]}}},{"text":"From the documentation for GridLayout","label":{"api":{"GridLayout":[[27,36]]}}},{"text":"You might want to take a look at the new CompletableFuture facility","label":{"api":{"CompletableFuture":[[41,57]]}}},{"text":"Java 8 ConcurrentHashMap.keySet() returns a KeySetView<K, V> while in Java 7 it returns a Set<K> (where K maps a key and V maps the value)","label":{"api":{"ConcurrentHashMap.keySet()":[[7,32]],"KeySetView<K, V>":[[44,59]],"Set<K>":[[90,95]]}}},{"text":"From the JavaDoc of the java.awt.print.Printable (https://docs.oracle.com/javase/7/docs/api/java/awt/print/Printable.html)","label":{"api":{"java.awt.print.Printable":[[24,47]]}}},{"text":"From getPathMatcher documentation","label":{"api":{"getPathMatcher":[[5,18]]}}},{"text":"https://docs.oracle.com/javaee/7/api/javax/persistence/Converter.html, JSR-338, Chapter 11.1.10 Convert annotation, page 438","label":{"api":{"JSR-338":[[71,77]],"Convert":[[96,102]]}}},{"text":"You could use the scanner to check if there is an additional [appropriate] input with hasNextDouble()","label":{"api":{"hasNextDouble()":[[86,100]]}}},{"text":"Basically, because the contract says so","label":{"api":{}}},{"text":"You can do that by using the groupingBy(classifier, downstream) collector that will classify according to the first character of the key and the downstream collector, which is applied on all values classified to same key, would be averagingDouble","label":{"api":{"groupingBy(classifier, downstream)":[[29,62]],"averagingDouble":[[231,245]]}}},{"text":"The Stream interface has two overloads for the method of()","label":{"api":{"Stream":[[4,9]],"of()":[[54,57]]}}},{"text":"I see that the implementation differs between these methods, with the difference apparently being how the Spliterator is instantiated; but what advantage does this offer to the Stream API","label":{"api":{"Spliterator":[[106,116]],"Stream":[[177,182]]}}},{"text":"However as soon as request is received (Socket.accept returns), almost all servers would immediately fork or reuse another thread to complete the request","label":{"api":{"Socket.accept":[[40,52]]}}},{"text":"As others have mentioned, using a Future would be much simpler and easy to understand","label":{"api":{"Future":[[34,39]]}}},{"text":"And then, you submit this task to an Executor","label":{"api":{"Executor":[[37,44]]}}},{"text":"There are a lot of Executors in JDK","label":{"api":{"Executor":[[19,26]]}}},{"text":"Remember that the futures returned by the executor are in the same order as the Callables you submitted (or added) to the Collection (in this case, an ArrayList)","label":{"api":{"futures":[[18,24]],"executor":[[42,49]],"Callables":[[80,88]],"Collection":[[122,131]],"ArrayList":[[151,159]]}}},{"text":"You can either synchronise access to this queue or better you can also have thread safe concurrent queue such as ConcurrentLinkedQueue","label":{"api":{"ConcurrentLinkedQueue":[[113,133]]}}},{"text":"You could use an AsynchronousFileChannel, read a chunk of the file, and calculate the hash of the partition you read in a different thread once the partition is read","label":{"api":{"AsynchronousFileChannel":[[17,39]]}}},{"text":"Because File is just an object representing a file name","label":{"api":{"File":[[8,11]]}}},{"text":"While a FileReader is an open resource used for reading the content of a file, and implements AutoCloseable","label":{"api":{"FileReader":[[8,17]],"AutoCloseable":[[94,106]]}}},{"text":"Java 8 has a function CompletableFuture.allOf(CompletableFuture<?>...cfs) that returns a CompletableFuture that is completed when all the given futures complete","label":{"api":{"CompletableFuture.allOf(CompletableFuture<?>...cfs)":[[22,72]],"CompletableFuture":[[89,105]]}}},{"text":"If you task isn’t implementation of the snuffle algorithm you can use standard java.util.Collections#shuffle method","label":{"api":{"java.util.Collections#shuffle":[[79,107]]}}},{"text":"I suggest you to look into the Java API","label":{"api":{}}},{"text":"Arrays.asList receives an ellipsis (T...), so you just don't need the array literal","label":{"api":{"Arrays.asList":[[0,12]],"ellipsis (T...)":[[26,40]]}}},{"text":"You could do this with two calls - substring to get the sequence you're interested in and then toUpperCase to capitalize it","label":{"api":{"substring":[[35,43]],"toUpperCase":[[95,105]]}}},{"text":"There's no such tool in the JDK, but you can simply wrap your InputStream into a DataInputStream and call readFully(byte[]) on it","label":{"api":{"InputStream":[[62,72]],"DataInputStream":[[81,95]],"readFully(byte[])":[[106,122]]}}},{"text":"To have a class with a next() method, implement the Iterator interface and do the above internally","label":{"api":{"next()":[[23,28]],"Iterator":[[52,59]]}}},{"text":"TestNG associates each ITestResult with its execution thread using an InheritableThreadLocal<T>","label":{"api":{"TestNG":[[0,5]],"ITestResult":[[23,33]],"InheritableThreadLocal<T>":[[70,94]]}}},{"text":"You need to use the no-argument version of executeQuery(), i.e","label":{"api":{"executeQuery()":[[43,56]]}}},{"text":"This appears to be backed up by the Javadoc for the TargetDataLine class","label":{"api":{"TargetDataLine":[[52,65]]}}},{"text":"the tutorial in Java (https://docs.oracle.com/javase/tutorial/security/apisign/versig.html) doesn't teach how to obtain a certificate from the trusted certificate store and verify using that","label":{"api":{}}},{"text":"String.valueOf and Integer.toString","label":{"api":{"String.valueOf":[[0,13]],"Integer.toString":[[19,34]]}}},{"text":"Read the javadoc of Stack","label":{"api":{"Stack":[[20,24]]}}},{"text":"A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class","label":{"api":{"Deque":[[79,83]]}}},{"text":"Even the javadoc of Deque says it","label":{"api":{"Deque":[[20,24]]}}},{"text":"Deques can also be used as LIFO (Last-In-First-Out) stacks","label":{"api":{"Deque":[[0,4]]}}},{"text":"This interface should be used in preference to the legacy Stack class","label":{"api":{"Stack":[[58,62]]}}},{"text":"The string parameter to Enum.valueOf is the declared name of the enum","label":{"api":{"Enum.valueOf":[[24,35]]}}},{"text":"I want to fetch some data from a database and display it in a JTable","label":{"api":{"JTable":[[62,67]]}}},{"text":"You need to set the path of the cookie, otherwise it's valid only for the current path","label":{"api":{}}},{"text":"This will create a DoubleStream with the help of the iterate(seed, f) method where the seed is 1 and the function, which returns the next value, simply increments the current iteration number i and multiplies the previous value with x / i","label":{"api":{"DoubleStream":[[19,30]],"iterate(seed, f)":[[53,68]]}}},{"text":"The Stream is limited to n element with limit and the sum is retrieved with sum()","label":{"api":{"Stream":[[4,9]],"limit":[[40,44]],"sum()":[[76,80]]}}},{"text":"Although there is no boolean stream, you can use an IntStream for this","label":{"api":{"IntStream":[[52,60]]}}},{"text":"IntegerProperty.integerProperty creates a property that's bidirectionally connected to the property it wraps","label":{"api":{"IntegerProperty.integerProperty":[[0,30]]}}},{"text":"Calling it with 0 is equivalent to calling the single-parameter overload","label":{"api":{}}},{"text":"I have gone through the Oracle Doc  but i could not find any way","label":{"api":{}}},{"text":"If you're sitting in a method invoked by servlet's service() (such as doGet(), doPost(), etc), then just use the inherited getServletContext() method","label":{"api":{"service()":[[51,59]],"doGet()":[[70,76]],"doPost()":[[79,86]],"getServletContext()":[[123,141]]}}},{"text":"If you're sitting in servlet's init(ServletConfig) method, then the inherited getServletContext() isn't available yet as long as you haven't called super.init(config)","label":{"api":{"init(ServletConfig)":[[31,49]],"getServletContext()":[[78,96]],"super.init(config)":[[148,165]]}}},{"text":"You'd need to grab it from ServletConfig","label":{"api":{"ServletConfig":[[27,39]]}}},{"text":"But much better is to override init() instead","label":{"api":{"init()":[[31,36]]}}},{"text":"In a decent servlet you usually never need to override init(ServletConfig)","label":{"api":{"init(ServletConfig)":[[55,73]]}}},{"text":"a filter which lacks the inherited getServletContext() method and you only have ServletRequest at hands, then you could grab it from there","label":{"api":{"getServletContext()":[[35,53]],"ServletRequest":[[80,93]]}}},{"text":"Hence the introduction of ServletRequest#getServletContext() — although you could also simply extract it from FilterConfig (hey, there's yet another way!)","label":{"api":{"ServletRequest#getServletContext()":[[26,59]],"FilterConfig":[[110,121]]}}},{"text":"And then there are HTTP session listeners where you could listen on a.o","label":{"api":{}}},{"text":"There's no other way to obtain the servlet context than via HttpSession#getServletContext()","label":{"api":{"HttpSession#getServletContext()":[[60,90]]}}},{"text":"Do note that there's no ServletRequest anywhere as there's not necessarily means of an active HTTP request during server side session timeout","label":{"api":{"ServletRequest":[[24,37]]}}},{"text":"As last, there's also ServletContext#getContext() which returns the ServletContext of a different web application deployed to same server (this works only if the server is configured to enable cross context access on the target webapp)","label":{"api":{"ServletContext#getContext()":[[22,48]],"ServletContext":[[68,81]]}}},{"text":"Yes, you can make a Stream<String> of your elements, map each of them to the respective enum value with the mapper MyVal::valueOf and collect that into a new EnumSet with toCollection initialized by noneOf","label":{"api":{"Stream<String>":[[20,33]],"MyVal::valueOf":[[115,128]],"EnumSet":[[158,164]],"toCollection":[[171,182]],"noneOf":[[199,204]]}}},{"text":"String.replaceAll is for regular expressions","label":{"api":{"String.replaceAll":[[0,16]]}}},{"text":"If you are not trying to use regular expressions, use String.replace, NOT String.replaceAll","label":{"api":{"String.replace":[[54,67]],"String.replaceAll":[[74,90]]}}},{"text":"I would like to understand the difference between javax.crypto.Mac and javax.crypto.Cipher","label":{"api":{"javax.crypto.Mac":[[50,65]],"javax.crypto.Cipher":[[71,89]]}}},{"text":"I'd use a SwingWorker for this kind of processing","label":{"api":{"SwingWorker":[[10,20]]}}},{"text":"Consider having your enum classes implement a common interface, like StandardCopyOption and Month do","label":{"api":{"StandardCopyOption":[[69,86]],"Month":[[92,96]]}}},{"text":"If Row implements Comparable<Row>, as shown in the example cited here, then Set<Row> will automatically exclude duplicates when you invoke add()","label":{"api":{"Row":[[3,5]],"Comparable<Row>":[[18,32]],"Set<Row>":[[76,83]],"add()":[[139,143]]}}},{"text":"The spec says that equal objects must have equal hash-codes","label":{"api":{}}},{"text":"A custom ServletContextListener would be an appropriate place to start/stop embedded netty servers","label":{"api":{"ServletContextListener":[[9,30]]}}},{"text":"From the jdk","label":{"api":{}}},{"text":"The scene anti-aliasing documentation refers to the SCENE3D conditional feature","label":{"api":{}}},{"text":"You can use CDI and @Inject annotation","label":{"api":{"CDI":[[12,14]],"@Inject":[[20,26]]}}},{"text":"If you don't like the behavior of the JScrollPane + JTextField, you need to use JScrollBar#setModel(BoundedRangeModel) + JTextField#getHorizontalVisibility()","label":{"api":{"JScrollPane":[[38,48]],"JTextField":[[52,61]],"JScrollBar#setModel(BoundedRangeModel)":[[80,117]],"JTextField#getHorizontalVisibility()":[[121,156]]}}},{"text":"First of all, you need to distinguish between ImageView and Image","label":{"api":{"ImageView":[[46,54]],"Image":[[60,64]]}}},{"text":"ImageView is the scene graph node which displays an Image, and Image is the actual image (shown by an ImageView)","label":{"api":{"ImageView":[[0,8],[102,110]],"Image":[[52,56],[63,67]]}}},{"text":"The ImageView is part of the scene graph and shows the Image it currently contains","label":{"api":{"ImageView":[[4,12]],"Image":[[55,59]]}}},{"text":"So, instead of creating multiple ImageView objects, only create one, and create Image objects for your images","label":{"api":{"ImageView":[[33,41]],"Image":[[80,84]]}}},{"text":"One way of converting JavaFX Image into byte[] is first to convert it to BufferedImage using SwingFXUtils, subsequently use ImageIO.write() to write into a ByteArrayOutputStream and obtain byte[] via toByteArray()","label":{"api":{"Image":[[29,33]],"byte[]":[[40,45],[189,194]],"BufferedImage":[[73,85]],"SwingFXUtils":[[93,104]],"ImageIO.write()":[[124,138]],"ByteArrayOutputStream":[[156,176]],"toByteArray()":[[200,212]]}}},{"text":"Also depending on how you do processing on the client side, you can read data into JavaFX Image directly, using this constructor","label":{"api":{"Image":[[90,94]]}}},{"text":"Alternatively, considering that you are reading the image from a file anyway, you can read the image into byte[] directly with Files.readAllBytes()","label":{"api":{"byte[]":[[106,111]],"Files.readAllBytes()":[[127,146]]}}},{"text":"But you can use getRequestURL()","label":{"api":{"getRequestURL()":[[16,30]]}}},{"text":"Use -fx-padding (see CSS properties for Region)","label":{"api":{"-fx-padding":[[4,14]]}}},{"text":"IMHO that description is better than the one in the javadoc for the Region class","label":{"api":{"Region":[[68,73]]}}},{"text":"I managed to solve this issue by using the ServletContext.getResourceAsStream() which can be used to obtain an InputStream for the specified resource","label":{"api":{"ServletContext.getResourceAsStream()":[[43,78]],"InputStream":[[111,121]]}}},{"text":"According to the java documentation, there is a method intersects(Rectangle r)","label":{"api":{"intersects(Rectangle r)":[[55,77]]}}},{"text":"Once your images are loaded, for each image create an ImageView and attach to the root","label":{"api":{"ImageView":[[54,62]]}}},{"text":"To my mind this could be easily accomplished by implementing a ServletContextListener","label":{"api":{"ServletContextListener":[[63,84]]}}},{"text":"You can use Collections.sort(list, comparator)","label":{"api":{"Collections.sort(list, comparator)":[[12,45]]}}},{"text":"While looking for best existing lib (if I could, I'd like to avoid implementing it on my own) I found that FileHandler lib is almost exactly what I want","label":{"api":{"FileHandler":[[107,117]]}}},{"text":"Also, if you know some other lib which could acomplish this, I'd be willing to ditch FileHandler in favor of that one","label":{"api":{"FileHandler":[[85,95]]}}},{"text":"You have to create a custom java.util.Formatter and install it on your FileHandler","label":{"api":{"java.util.Formatter":[[28,46]],"FileHandler":[[71,81]]}}},{"text":"The Formatter.getHead method is used to write your headers and is called every time the FileHandler is open or rotates","label":{"api":{"Formatter.getHead":[[4,20]],"FileHandler":[[88,98]]}}},{"text":"The Formatter.format method would be used in this case to generate one row of data per given LogRecord","label":{"api":{"Formatter.format":[[4,19]]}}},{"text":"So you need to generate (or reuse) one LogRecord every one second and publish it to the FileHandler","label":{"api":{"LogRecord":[[39,47]],"FileHandler":[[88,98]]}}},{"text":"From my Perl days, I'd like to be able to write code like this, given the definition Color.rgb(int,int,int)","label":{"api":{"Color.rgb(int,int,int)":[[85,106]]}}},{"text":"I assumed I wouldn't have a problem, since when I call URLClassLoader.newInstance(), it gets created from the default parent class loader, which I suppose should be the SystemClassLoader, which I assume contains the WebApp classes","label":{"api":{"URLClassLoader.newInstance()":[[55,82]],"SystemClassLoader":[[169,185]],"WebApp":[[216,221]]}}},{"text":"See ImageIcon.setImageObserver for details","label":{"api":{"ImageIcon.setImageObserver":[[4,29]]}}},{"text":"It would definitely simplify your code if your code became a task managed by a task scheduler, like a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[102,125]]}}},{"text":"You are looking for the flatMap(mapper) operation","label":{"api":{"flatMap(mapper)":[[24,38]]}}},{"text":"In this case, we're making a Stream<Bookmark> by calling stream(), flat mapping it to the revisions of each bookmark and, finally, collecting that into a list with toList()","label":{"api":{"Stream<Bookmark>":[[29,44]],"stream()":[[57,64]],"toList()":[[164,171]]}}},{"text":"Note that your current code could also be improved by calling addAll instead of looping over each revisions","label":{"api":{"addAll":[[62,67]]}}},{"text":"Instead, use the Arrays.fill() method","label":{"api":{"Arrays.fill()":[[17,29]]}}},{"text":"You can use java.util.Arrays to convert your array to a list via Arrays.asList(array) to create methods that return the next and previous entry like this (assuming no duplicates and that the list is already in order, as the question says)","label":{"api":{"java.util.Arrays":[[12,27]],"Arrays.asList(array)":[[65,84]]}}},{"text":"See DataInput for the byte structure of the UTF representation","label":{"api":{"DataInput":[[4,12]]}}},{"text":"in this case I think Map is your best option.","label":{"api":{"Map":[[21,23]]}}},{"text":"Java's BigInteger is an arbitrary length integer, limited only by available memory or implementation limitations, whereas SqlServer's BIGINT type is simply a 64 bit signed integer","label":{"api":{"BigInteger":[[7,16]]}}},{"text":"You are likely experiencing truncation once the value stored in your BigInteger exceeds 2^63-1","label":{"api":{"BigInteger":[[69,78]]}}},{"text":"boolean value = (cursor.getInt(registerDatabase.ID) == 1); thows a NPE because it has no results, to avoid this Exception use Objects.equals and check number of results of the Cursor","label":{"api":{"NPE":[[67,69]],"Exception":[[112,120]],"Objects.equals":[[126,139]]}}},{"text":"You can use a StringBuilder instead","label":{"api":{"StringBuilder":[[14,26]]}}},{"text":"You can use replaceFirst (that accepts a regex), using the following pattern","label":{"api":{"replaceFirst":[[12,23]]}}},{"text":"Of course there are many alternatives, look at the String API to fuel your creative fire","label":{"api":{"String":[[51,56]]}}},{"text":"As per the BorderLayout API","label":{"api":{"BorderLayout":[[11,22]]}}},{"text":"Pass a Comparator as a constructor parameter, e.g","label":{"api":{"Comparator":[[7,16]]}}},{"text":"You get a Future having a cancel method","label":{"api":{"Future":[[10,15]]}}},{"text":"You need to create a class that extends AbstractTableModel","label":{"api":{"AbstractTableModel":[[40,57]]}}},{"text":"In method getRowCount() you need to return the size of your array / list","label":{"api":{"getRowCount()":[[10,22]]}}},{"text":"Now after this, use the java.util.Arrays.copyOf() method to trim out the empty elements of the array, like so","label":{"api":{"java.util.Arrays.copyOf()":[[24,48]]}}},{"text":"Then finally, use the java.util.Arrays.copyOf() method to trim out the empty elements of the array again, like so","label":{"api":{"java.util.Arrays.copyOf()":[[22,46]]}}},{"text":"Create a java.io.FileWriter object first, then create a java.io.PrintWriter based on that FileWriter object","label":{"api":{"java.io.FileWriter":[[9,26]],"java.io.PrintWriter":[[56,74]],"FileWriter":[[90,99]]}}},{"text":"From my research, it would seem that the Robot Java class and the FFmpeg tool are my best options","label":{"api":{"Robot":[[41,45]],"FFmpeg":[[66,71]]}}},{"text":"However, Robot seems to best-fit the use case of obtaining images, not videos","label":{"api":{"Robot":[[9,13]]}}},{"text":"And consider to use computeIfAbsent() instead of putIfAbsent() in order to avoid unnessessary VoteItem creations","label":{"api":{"computeIfAbsent()":[[20,36]],"putIfAbsent()":[[49,61]]}}},{"text":"Collections#disjoint() may help to make this more readable","label":{"api":{"Collections#disjoint()":[[0,21]]}}},{"text":"If we are to consider the current case, you can surely \"shorten\" the pattern to \\b (which will also find a match at the end of the string, though Java String#split will safely remove trailing empty elements from the resulting array) that matches all locations between a non-word and word characters and also at the start/end of the string if there is a word character at its start/end","label":{"api":{"String#split":[[151,162]]}}},{"text":"See also the description of parser in question","label":{"api":{"parser":[[28,33]]}}},{"text":"You can just use a HashSet and that should take care of the duplicates issue","label":{"api":{"HashSet":[[19,25]]}}},{"text":"This will take your array, convert it to a List, feed that to the constructor of HashSet<String>, and then convert it back to an array for you","label":{"api":{"List":[[43,46]],"HashSet<String>":[[81,95]]}}},{"text":"You can use groupingBy(classifier) where the classifier extracts the year from the date","label":{"api":{"groupingBy(classifier)":[[12,33]]}}},{"text":"In this case, the date is parsed with LocalDate.parse but you could easily extend that by giving your own formatter","label":{"api":{"LocalDate.parse":[[38,52]]}}},{"text":"The API documentation seems pretty definite, no qualifications or weasel-wording","label":{"api":{}}},{"text":"According to the docs of Stream.concat()","label":{"api":{"Stream.concat()":[[25,39]]}}},{"text":"ConcurrentSkipListMap implements ConcurrentNavigableMap, which has a descdendingMap() method returning view of this map ordered in reverse","label":{"api":{"ConcurrentSkipListMap":[[0,20]],"ConcurrentNavigableMap":[[33,54]],"descdendingMap()":[[69,84]]}}},{"text":"There is a Class#getDeclaringClass method that may work in your case","label":{"api":{"Class#getDeclaringClass":[[11,33]]}}},{"text":"I've had a look at the \"group by\" styles of provided Collectors, but they don't seem to apply since I'm not really grouping by a classifier- you can't compute the groups based only on a property of each individual element, you have to consider the properties of each element in relation to the groups that have been computed so far","label":{"api":{"Collectors":[[53,62]]}}},{"text":"Add a ChangeListener to the value property instead","label":{"api":{"ChangeListener":[[6,19]]}}},{"text":"Also usually you'd use a Slider for this (since the handle size doesn't seem to have a meaning in this case)","label":{"api":{"Slider":[[25,30]]}}},{"text":"I agree with Fabian, just use a Slider for this task, rather than a ScrollBar","label":{"api":{"Slider":[[32,37]],"ScrollBar":[[68,76]]}}},{"text":"A Slider is a more suitable control","label":{"api":{"Slider":[[2,7]]}}},{"text":"As an alternative to a single-element array, you can instead use AtomicInteger","label":{"api":{"AtomicInteger":[[65,77]]}}},{"text":"In order to get image's height we can use ImageIO.read(new URL(\"…\")).getHeight()","label":{"api":{"ImageIO.read(new URL(\"…\")).getHeight()":[[42,79]]}}},{"text":"The ID's values are based on the strategy (see GenerationType) that is used along with the @GeneratedValue annotation","label":{"api":{"GenerationType":[[47,60]],"@GeneratedValue":[[91,105]]}}},{"text":"If you don't specify any specific strategy for a @GeneratedValue-field, the default strategy should be javax.persistence.GenerationType.AUTO according to the JPA JavaDoc of GeneratedValue","label":{"api":{"@GeneratedValue-field":[[49,69]],"javax.persistence.GenerationType.AUTO":[[103,139]],"GeneratedValue":[[173,186]]}}},{"text":"However EclipseLink seems to use javax.persistence.GenerationType.TABLE according to their documentation","label":{"api":{"javax.persistence.GenerationType.TABLE":[[33,70]]}}},{"text":"The strategy of the GeneratedValue is defined by the GenerationType enumerated type","label":{"api":{"GeneratedValue":[[20,33]],"GenerationType":[[53,66]]}}},{"text":"If you want to use a different strategy or another table for generation you should take a look at the JavaDoc of TableGenerator and SequenceGenerator","label":{"api":{"TableGenerator":[[113,126]],"SequenceGenerator":[[132,148]]}}},{"text":"by using an Executor), but I wrote it very quickly","label":{"api":{"Executor":[[12,19]]}}},{"text":"I do not believe there is something like that but you could use a ConcurrentSkipListMap<K,V> directly as a cache (see NavigableMap & time-based caches for an example) or keep a NavigableMap<K,V> in sync with a Guava Cache by loading/putting to both the cache and the navigable map and using a RemovalListener<K,V> to remove entries from the navigable map when they are removed from the cache (see Removal Listeners)","label":{"api":{"ConcurrentSkipListMap<K,V>":[[66,91]],"NavigableMap<K,V>":[[177,193]],"RemovalListener<K,V>":[[293,312]]}}},{"text":"You could try to use a Timer (https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html) to schedule a task every 20 seconds","label":{"api":{"Timer":[[23,27]]}}},{"text":"Character has many static isXxxx() methods to test if a character belongs to some category","label":{"api":{"Character":[[0,8]],"isXxxx()":[[26,33]]}}},{"text":"You can use a javax.swing.Timer object for this, for example","label":{"api":{"javax.swing.Timer":[[14,30]]}}},{"text":"the null check on conn is superfluous as DriverManager.getConnection() throws an exception if it fails","label":{"api":{"DriverManager.getConnection()":[[41,69]]}}},{"text":"In java 8 you can use Map#computeIfAbsent method","label":{"api":{"Map#computeIfAbsent":[[22,40]]}}},{"text":"next() increments the result set cursor, therefore the instruction after it will exclude the first result","label":{"api":{"next()":[[0,5]]}}},{"text":"What you probably want is isBeforeFirst(), which returns false if the cursor is not at the beginning of the result set OR if the result set is empty","label":{"api":{"isBeforeFirst()":[[26,40]]}}},{"text":"It looks like you are trying to follow the FXML custom component pattern","label":{"api":{}}},{"text":"You can use Arrays.toString() like this","label":{"api":{"Arrays.toString()":[[12,28]]}}},{"text":"FileWriter and FileReader assume that default character encoding is acceptable (UTF-8 on my system)","label":{"api":{"FileWriter":[[0,9]],"FileReader":[[15,24]]}}},{"text":"I'll add this from the text of the ConcurrentModificationException reference page","label":{"api":{"ConcurrentModificationException":[[35,65]]}}},{"text":"listIterator(int) and listIterator()","label":{"api":{"listIterator(int)":[[0,16]],"listIterator()":[[22,35]]}}},{"text":"Here the BorderLayout API specifically states (highlighting mine)","label":{"api":{"BorderLayout":[[9,20]]}}},{"text":"An Instant is a moment on the timeline in UTC","label":{"api":{"Instant":[[3,9]]}}},{"text":"Using Java 7 NIO FileChannel#force method","label":{"api":{"FileChannel#force":[[17,33]]}}},{"text":"See the JavaDocs of java.lang.String.replaceAll and especially java.util.regex.Pattern for more information","label":{"api":{"java.lang.String.replaceAll":[[20,46]],"java.util.regex.Pattern":[[63,85]]}}},{"text":"The atan2() method returns the angle you need to move","label":{"api":{"atan2()":[[4,10]]}}},{"text":"From a mathematical standpoint, Complex numbers can't be ordered, and as such aren't a good fit for the the Comparable interface","label":{"api":{"Comparable":[[108,117]]}}},{"text":"Note that the contract of the compareTo method requires you to return an int, not a double","label":{"api":{"compareTo":[[30,38]]}}},{"text":"Also, you should define your class as extending Comparable<Complex> instead of a raw Comparable, so you don't have to mess around with casting and runtime type checking","label":{"api":{"Comparable<Complex>":[[48,66]],"Comparable":[[85,94]]}}},{"text":"The improvements in JDK 8's Comparator interface allow for a much more elegant implementation with the same behavior","label":{"api":{"Comparator":[[28,37]]}}},{"text":"Depending on your use case, a work-around could be to use the Desktop class, though this will create a dependency on the AWT stack for the time being","label":{"api":{"Desktop":[[62,68]]}}},{"text":"To determine if the result set can see its own updates call:DatabaseMetaData::ownUpdatesAreVisible","label":{"api":{"DatabaseMetaData::ownUpdatesAreVisible":[[60,97]]}}},{"text":"Or, rather consider using ExecutorService for this and its shutdown method which can do the work easily and it's standard solution for this kind of problems","label":{"api":{"ExecutorService":[[26,40]],"shutdown":[[59,66]]}}},{"text":"There is a LineNumberReader class which does exactly what you want","label":{"api":{"LineNumberReader":[[11,26]]}}},{"text":"codePointAt(CharSequence seq, int index)","label":{"api":{"codePointAt(CharSequence seq, int index)":[[0,39]]}}},{"text":"Try to call method setExtendedState","label":{"api":{"setExtendedState":[[19,34]]}}},{"text":"replace() works with plain Strings, not regex","label":{"api":{"replace()":[[0,8]]}}},{"text":"Use the wait(long timeout) method","label":{"api":{"wait(long timeout)":[[8,25]]}}},{"text":"Use a ScheduledExecutorService (Tutorial)","label":{"api":{"ScheduledExecutorService":[[6,29]]}}},{"text":"We'll set our deadline to be x minutes in the future, using Instant from the modern java.time framework (Tutorial)","label":{"api":{"Instant":[[60,66]],"java.time":[[84,92]]}}},{"text":"I have the string value produced by NSLocale localeIdentifier, and I need to construct a java.util.Locale","label":{"api":{"NSLocale":[[36,43]],"java.util.Locale":[[89,104]]}}},{"text":"ScheduledExecutorService.schedule() allows to execute a task after a specified delay","label":{"api":{"ScheduledExecutorService.schedule()":[[0,34]]}}},{"text":"Platform.runLater() executes the Runnable on the JavaFX-Thread","label":{"api":{"Platform.runLater()":[[0,18]],"Runnable":[[33,40]]}}},{"text":"The basic facility to run something on the JavaFX application thread is Platform.runLater()","label":{"api":{"Platform.runLater()":[[72,90]]}}},{"text":"Of course there are many helpful methods in the ArrayList API that can make your life much easier","label":{"api":{"ArrayList":[[48,56]]}}},{"text":"If there's no restriction on other data structures, you can consider using Map as well","label":{"api":{"Map":[[75,77]]}}},{"text":"I'll also add that you should probably consider using Joda Time for Java 7 or earlier, and java.time for Java 8 or newer","label":{"api":{"java.time":[[91,99]]}}},{"text":"If you want your call to DatagramSocket.receive to finish at your time limit, you will need to make a call to DatagramSocket.setSoTimeout(int), which sets a timeout on the read operation","label":{"api":{"DatagramSocket.receive":[[25,46]],"DatagramSocket.setSoTimeout(int)":[[110,141]]}}},{"text":"For that I need a class that implements BeanInfo","label":{"api":{"BeanInfo":[[40,47]]}}},{"text":"I am quite satisfied with the GUI elements of JavafX, however, the ListView control (https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ListView.html) seems to offer no 'common' keyboard navigability by default","label":{"api":{"ListView":[[67,74]]}}},{"text":"StringBuilder's reverse takes the first situation into account, but I'm not aware of anything that takes the second into account","label":{"api":{"StringBuilder":[[0,12]],"reverse":[[16,22]]}}},{"text":"ScheduledExecutorService inherits two methods from the ExecutorService, shutdown() and shutdownNow()","label":{"api":{"ScheduledExecutorService":[[0,23]],"ExecutorService":[[55,69]],"shutdown()":[[72,81]],"shutdownNow()":[[87,99]]}}},{"text":"I can't interrupt the threads because third party libraries are involved and they don't deal well with interrupts :-( But I need to cancel scheduled tasks, that are not currently executing since most of them are scheduled in an hour or so","label":{"api":{}}},{"text":"What's the Java 8 Stream equivalent of LINQ's SelectMany","label":{"api":{"Stream":[[18,23]],"SelectMany":[[46,55]]}}},{"text":"You're looking to flatMap all the values contained in the map","label":{"api":{"flatMap":[[18,24]]}}},{"text":"This code first retrieves all the values of the map as a Collection<List<Tag>> with values(), creates a Stream out of this collection with stream(), and then flat maps each List<Tag> into a Stream with the method reference List::stream","label":{"api":{"Collection<List<Tag>>":[[57,77]],"values()":[[84,91]],"stream()":[[139,146]],"List<Tag>":[[173,181]],"Stream":[[190,195]],"List::stream":[[223,234]]}}},{"text":"This creates a Stream of the values with stream(), maps each of them to their size with mapToInt, where the mapper is the method reference List::size refering to List#size(), and sum the results with sum()","label":{"api":{"Stream":[[15,20]],"stream()":[[41,48]],"mapToInt":[[88,95]],"List::size":[[139,148]],"List#size()":[[162,172]],"sum()":[[200,204]]}}},{"text":"To avoid long living dead connections the best option is to set SO_KEEPALIVE option on the socket","label":{"api":{"SO_KEEPALIVE":[[64,75]]}}},{"text":"If erase method just tries to remove an item from universeEntities collection by calling ArrayList's remove method it just break an iterator","label":{"api":{"remove":[[30,35],[101,106]],"universeEntities":[[50,65]],"ArrayList":[[89,97]]}}},{"text":"If you do not want to use iterators you can collect items that should be removed in some kind of collection, return from reduceLifeTime method and remove using removeAll afterwards","label":{"api":{"remove":[[73,78],[147,152]],"reduceLifeTime":[[121,134]],"removeAll":[[160,168]]}}},{"text":"In the case of lists implementing RandomAccess, which includes all arraylist style implementations, the solution will mimic something similar to Java 8’s ArrayList.removeIf implementation though we don’t have direct access to the internal array and I left out all fail-fast concurrent modification detection stuff","label":{"api":{"RandomAccess":[[34,45]],"arraylist":[[67,75]],"ArrayList.removeIf":[[154,171]]}}},{"text":"The method also fulfills the contract of Java 8’s removeIf method of returning whether the list has been changed by the operation","label":{"api":{"removeIf":[[50,57]]}}},{"text":"1 CopyOnWriteArrayList is an exception but for a copy-on-write list the idea of an in-place removeIf is moot, unless provided by the list itself, as, when implementing it via its remove(int) (or any other public) operation we’re effectively copying the entire list on each change","label":{"api":{"CopyOnWriteArrayList":[[2,21]],"removeIf":[[92,99]],"remove(int)":[[179,189]]}}},{"text":"So in that case, copying the entire list into an ordinary list, performing the removeIf on that list and copying it back will be more efficient in most cases","label":{"api":{"removeIf":[[79,86]]}}},{"text":"Artist, pass MusiqueComparator.ARTISTE to Collections.sort to sort your list by that criterion","label":{"api":{"MusiqueComparator.ARTISTE":[[13,37]],"Collections.sort":[[42,57]]}}},{"text":"You can use split() in the String class","label":{"api":{"split()":[[12,18]],"String":[[27,32]]}}},{"text":"One option is to use javafx.animation.Timeline","label":{"api":{"javafx.animation.Timeline":[[21,45]]}}},{"text":"or simply use Thread.sleep()","label":{"api":{"Thread.sleep()":[[14,27]]}}},{"text":"getModifiers returns a set of flags","label":{"api":{"getModifiers":[[0,11]]}}},{"text":"Assuming you are using Java 8, you can use the Executable.getParameters() method to get the formal parameters of a Method","label":{"api":{"Executable.getParameters()":[[47,72]]}}},{"text":"This returns an array of Parameter instances, on which you can invoke Parameter.getModifiers()","label":{"api":{"Parameter.getModifiers()":[[70,93]]}}},{"text":"If unable to get a true integration working, another option might be to simply make external Process calls out from Java to the command line Bluetooth utilities that you know already work","label":{"api":{"Process":[[93,99]]}}},{"text":"java.lang.Integer.parseInt, I noticed that the code header is","label":{"api":{"java.lang.Integer.parseInt":[[0,25]]}}},{"text":"Because NumberFormatException subclasses IllegalArgumentException, which in turn subclasses RuntimeException","label":{"api":{"NumberFormatException":[[8,28]],"IllegalArgumentException":[[41,64]],"RuntimeException":[[92,107]]}}},{"text":"Subclasses of RuntimeException, unlike those of Exception, do not need to be explicitly caught (although they can be)","label":{"api":{"RuntimeException":[[14,29]],"Exception":[[48,56]]}}},{"text":"From the RuntimeException javadoc page","label":{"api":{"RuntimeException":[[9,24]]}}},{"text":"RuntimeException and its subclasses are unchecked exceptions","label":{"api":{"RuntimeException":[[0,15]]}}},{"text":"You can use writeByte to send STX, ETX","label":{"api":{"writeByte":[[12,20]]}}},{"text":"For full documentation refer to JavaFX API","label":{"api":{}}},{"text":"It seems to me that you are also searching for a way to check if a certain Node is a direct or indirect child of another Node or Scene","label":{"api":{"Node":[[75,78],[121,124]],"Scene":[[129,133]]}}},{"text":"Following a method that checks if a certain Node is a direct or indirect child of another Node","label":{"api":{"Node":[[44,47],[90,93]]}}},{"text":"To check if a given Node is the root or an indirect child of a Scene, we can use a similar approach","label":{"api":{"Node":[[20,23]],"Scene":[[63,67]]}}},{"text":"Use the @XmlTransient annotation","label":{"api":{"@XmlTransient":[[8,20]]}}},{"text":"In Java 8, the conversion from list to array is relatively clean (see related question)","label":{"api":{}}},{"text":"If the Process was created using ProcessBuilder, then you should call redirectErrorStream(true) to merge the error output with the standard output","label":{"api":{"Process":[[7,13]],"ProcessBuilder":[[33,46]],"redirectErrorStream(true)":[[70,94]]}}},{"text":"What you have seems identical to how the API documentation recommends you do this","label":{"api":{}}},{"text":"Integer.toString(int) returns the string representation of an integer","label":{"api":{"Integer.toString(int)":[[0,20]]}}},{"text":"The simplest solution would be to use Collectors.summarizingInt()","label":{"api":{"Collectors.summarizingInt()":[[38,64]]}}},{"text":"The IntSummaryStatistics class maintains count, sum, min and max values","label":{"api":{"IntSummaryStatistics":[[4,23]],"count":[[41,45]],"sum":[[48,50]],"min":[[53,55]],"max":[[61,63]]}}},{"text":"The Scanner has a method nextInt to retrieve the next integer","label":{"api":{"Scanner":[[4,10]],"nextInt":[[25,31]]}}},{"text":"Otherwise you can convert a string to an integer using the method Integer.parseInt as follow","label":{"api":{"Integer.parseInt":[[66,81]]}}},{"text":"If you take a look to the EntityManager class (which means going one step deeper than Spring Data), you'll see its remove method returns nothing","label":{"api":{"EntityManager":[[26,38]],"remove":[[115,120]]}}},{"text":"You should check out the Scanner API","label":{"api":{"Scanner":[[25,31]]}}},{"text":"You can get the reference by using getSource of the MouseEvent","label":{"api":{"getSource":[[35,43]],"MouseEvent":[[52,61]]}}},{"text":"Use BigDecimal#toPlainString(), per the documentation","label":{"api":{"BigDecimal#toPlainString()":[[4,29]]}}},{"text":"toPlainString() - Returns a string representation of this BigDecimal without an exponent field","label":{"api":{"toPlainString()":[[0,14]],"BigDecimal":[[58,67]]}}},{"text":"BigDecimal's documentation lists three to*String() methods","label":{"api":{"BigDecimal":[[0,9]],"to*String()":[[39,49]]}}},{"text":"The regular toString() method uses scientific notation (1.00E-7), while toEngineeringString() uses engineering notation (100E-9) and toPlainString() uses no notation (0.000000100)","label":{"api":{"toString()":[[12,21]],"toEngineeringString()":[[72,92]],"toPlainString()":[[133,147]]}}},{"text":"If you're looking for insertion order, use a LinkedHashMap","label":{"api":{"LinkedHashMap":[[45,57]]}}},{"text":"If you're looking for natural order (A-Z, 0-9), use a TreeMap","label":{"api":{"TreeMap":[[54,60]]}}},{"text":"You can use Collector API","label":{"api":{"Collector":[[12,20]]}}},{"text":"Use flatMap, it does exactly what you need","label":{"api":{"flatMap":[[4,10]]}}},{"text":"Also you can notice that this constructor is @Deprecated","label":{"api":{"@Deprecated":[[45,55]]}}},{"text":"So better idea is to use Calendar","label":{"api":{"Calendar":[[25,32]]}}},{"text":"Use Collections.sort() with Comparator","label":{"api":{"Collections.sort()":[[4,21]],"Comparator":[[28,37]]}}},{"text":"The PrintWriter will create the file for you, even though nothing is written to it (like with this empty list)","label":{"api":{"PrintWriter":[[4,14]]}}},{"text":"Java has the URLEncoder which will let you convert a String to the desired format","label":{"api":{"URLEncoder":[[13,22]]}}},{"text":"To get your data into a useful format to go into the URLEncoder, I recommend a custom method to read the Object and produce the desired String","label":{"api":{"URLEncoder":[[53,62]]}}},{"text":"Column aliases can be retrieved with ResultSetMetadata.getColumnLabel(int)","label":{"api":{"ResultSetMetadata.getColumnLabel(int)":[[37,73]]}}},{"text":"each id is mapped to the corresponding Foo that is found by calling findFirst() on the foos having that id","label":{"api":{"findFirst()":[[68,78]]}}},{"text":"That's because you need to use the String constructor, that also takes a radix","label":{"api":{"String":[[35,40]]}}},{"text":"equals should be defined to take an Object, not a Test","label":{"api":{"equals":[[0,5]],"Object":[[36,41]],"Test":[[50,53]]}}},{"text":"Currently, I am changing the JavaFX Image to a BufferedImage, then using the BufferedImage#subImage function to get a sub image, then using SwingFXUtils to change it back to a JavaFX Image","label":{"api":{"Image":[[36,40]],"BufferedImage":[[47,59]],"BufferedImage#subImage":[[77,98]],"SwingFXUtils":[[140,151]]}}},{"text":"Use the GraphicsContext::drawImage method to draw the part of the image which you wish onto the canvas","label":{"api":{"GraphicsContext::drawImage":[[8,33]]}}},{"text":"You should use Json factory class to create object builders","label":{"api":{"Json factory":[[15,26]],"builders":[[51,58]]}}},{"text":"The Double equals method is documented in the API documentation","label":{"api":{"Double equals":[[4,16]]}}},{"text":"The method's got the following signature","label":{"api":{}}},{"text":"In my opinion, it would be much more convinient to declare the method as follows","label":{"api":{}}},{"text":"Alternatively you can set the focusTraversable property of the Button to false","label":{"api":{"focusTraversable":[[30,45]],"Button":[[63,68]]}}},{"text":"SS in SimpleDateFormat is milliseconds","label":{"api":{"SimpleDateFormat":[[6,21]]}}},{"text":"However, a better solution would be to use a ListIterator","label":{"api":{"ListIterator":[[45,56]]}}},{"text":"This code retrieves it with listIterator()","label":{"api":{"listIterator()":[[28,41]]}}},{"text":"While there are still elements and the next element is 0, we remove it with remove()","label":{"api":{"remove()":[[76,83]]}}},{"text":"Is not working as System.identityHashCode in Java does not guarantee two different objects will return a different identityHashCode (yes, yes it happens)","label":{"api":{"System.identityHashCode":[[18,40]]}}},{"text":"Because you create Comparator that always returns the first element to be the greatest","label":{"api":{"Comparator":[[19,28]]}}},{"text":"Use @PrimaryKeyJoinColumn instead of a foreign key","label":{"api":{"@PrimaryKeyJoinColumn":[[4,24]]}}},{"text":"Take a look at the function File.lastModified and the functions in Date to check if it's in the last 7 days","label":{"api":{"File.lastModified":[[28,44]],"Date":[[67,70]]}}},{"text":"The closest would be to use parse(CharSequence,ParsePosition) using two different formatters","label":{"api":{"parse(CharSequence,ParsePosition)":[[28,60]]}}},{"text":"As there say:when you call List.toString(),it will print out the element.toString() one by one,but you didn't custom the method for this element:Coin object,so its address is print out","label":{"api":{"List.toString()":[[27,41]],"element.toString()":[[65,82]],"Coin":[[145,148]]}}},{"text":"Implement WindowListener in your new jFrame and pass a reference to the parent jFrame","label":{"api":{"WindowListener":[[10,23]],"jFrame":[[37,42],[79,84]]}}},{"text":"Also, this method throws a ArithmeticException if the given argument is negative, which, as per your edit, is not your case","label":{"api":{"ArithmeticException":[[27,45]]}}},{"text":"This is actually the same difference for primitive int a and b and calculating a % b (which behaves like remainder) and Math.floorMod(a, b) (which behaves like mod)","label":{"api":{"Math.floorMod(a, b)":[[120,138]]}}},{"text":"In java, dictionaries are defined with the Map interface","label":{"api":{"Map":[[43,45]]}}},{"text":"The common implementations are TreeMap and HashMap","label":{"api":{"TreeMap":[[31,37]],"HashMap":[[43,49]]}}},{"text":"Similarly, ArrayList and LinkedList are common implementations of the List interface","label":{"api":{"ArrayList":[[11,19]],"LinkedList":[[25,34]],"List":[[70,73]]}}},{"text":"It seems the text field is listening for KEY_TYPED events","label":{"api":{"text":[[13,16]]}}},{"text":"Note that for KEY_TYPED events, the text should be the empty string, and the code should be KeyCode.UNDEFINED","label":{"api":{"KEY_TYPED":[[14,22]],"KeyCode.UNDEFINED":[[92,108]]}}},{"text":"Note also that in your test case, the text field is never added to a live scene","label":{"api":{}}},{"text":"I am trying to use the Java's FileVisitor interface to walk through a list of files and import the contents onto a database","label":{"api":{"FileVisitor":[[30,40]]}}},{"text":"Read the Queue interface documentation","label":{"api":{"Queue":[[9,13]]}}},{"text":"You must call ExecutorService#shutdown() or ExecutorService#shutdownNow() to terminate the executor's threadpool","label":{"api":{"ExecutorService#shutdown()":[[14,39]],"ExecutorService#shutdownNow()":[[44,72]]}}}]