[{"text": "Instead of calling defListModel.addElement(aStudent.toString()), you could add the actual objects to the appropriately typed JList/DefaultListModel", "label": {"api": {"DefaultListModel": [[131, 146]]}}}, {"text": "You need to use compareAndSet for your if statement to be mutally exclusive", "label": {"api": {"compareAndSet": [[16, 28]]}}}, {"text": "Without compareAndSet, there is a possibility that two threads can check the value and enter the if block at the same time before one has a chance to call set(true)", "label": {"api": {"compareAndSet": [[8, 20]]}}}, {"text": "Stream.map() and Collectors.joining() are your friends here", "label": {"api": {"Stream.map()": [[0, 11]], "Collectors.joining()": [[17, 36]]}}}, {"text": "I have a java.util.Date object, or a java.util.Calendar object", "label": {"api": {"java.util.Date": [[9, 22]]}}}, {"text": "How do I convert that to the right type in java.time framework", "label": {"api": {"java.time": [[43, 51]]}}}, {"text": "I have heard that we should now be doing the bulk of our business logic with java.time types", "label": {"api": {"java.time": [[77, 85]]}}}, {"text": "When working with old code not yet updated for java.time I need to be able to convert back and forth", "label": {"api": {"java.time": [[47, 55]]}}}, {"text": "What types map to java.util.Date or java.util.Calendar", "label": {"api": {"java.util.Date": [[18, 31]]}}}, {"text": "You can simply use the compareTo method", "label": {"api": {"compareTo": [[23, 31]]}}}, {"text": "There are other methods as well like before or after which you can use for Dates", "label": {"api": {"before": [[37, 42]], "after": [[47, 51]]}}}, {"text": "From the documentation for Scanner.hasNextLine()", "label": {"api": {"documentation for Scanner.hasNextLine()": [[9, 47]]}}}, {"text": "If normal synchronisation mechanisms seem too onerous you may be better to use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[81, 93]]}}}, {"text": "Use a Task to get the data from the database and any method described in Passing Parameters JavaFX FXML to get the data to the controller, e.g", "label": {"api": {"Task": [[6, 9]]}}}, {"text": "After you find the user in the LDAP DIT you should then modify tne environment to contain the user's DN and password and then issue LdapContext.reconnect() using the same Context", "label": {"api": {"LdapContext.reconnect()": [[132, 154]]}}}, {"text": "Use the Float class", "label": {"api": {"Float": [[8, 12]]}}}, {"text": "This is another property on top of all the possible ways to configure a ThreadPoolExecutor and probably simplifies the task of using a thread pool", "label": {"api": {"ThreadPoolExecutor": [[72, 89]]}}}, {"text": "To answer your question, new threads will be created for your tasks if your throttle-limit is greater than corePoolSize only if maximumPoolSize is greater than corePoolSize and the blocking queue in your ThreadPoolExecutor is full", "label": {"api": {"ThreadPoolExecutor": [[204, 221]]}}}, {"text": "queue up in your ThreadPoolExecutor or possibly be rejected with an exception (see the default handler AbortPolicy)", "label": {"api": {"ThreadPoolExecutor": [[17, 34]], "AbortPolicy": [[103, 113]]}}}, {"text": "See Rejected tasks in the ThreadPoolExecutor javadocs", "label": {"api": {"ThreadPoolExecutor": [[26, 43]]}}}, {"text": "See for example this gotcha when your ThreadPoolExecutor is unexpectedly not creating any more than corePoolSize Threads", "label": {"api": {"ThreadPoolExecutor": [[38, 55]]}}}, {"text": "The closest option to what you're trying to do is perhaps to use iterate and unordered", "label": {"api": {"iterate": [[65, 71]], "unordered": [[77, 85]]}}}, {"text": "See the API Note or this question for more information", "label": {"api": {"API Note": [[8, 15]]}}}, {"text": "The problem is that you have broken the contract for add(int, E)", "label": {"api": {"add(int, E)": [[53, 63]]}}}, {"text": "If you override set(int, E) so that sometimes it doesn't set the element, it would break the contract for that method too, and it would prevent Collections.sort() from working as you identified", "label": {"api": {"set(int, E)": [[16, 26]]}}}, {"text": "Check out DateTimeFormatter and this question about how to convert from old to new", "label": {"api": {"DateTimeFormatter": [[10, 26]]}}}, {"text": "Among other advantages, DateTimeFormatter is fully thread safe", "label": {"api": {"DateTimeFormatter": [[24, 40]]}}}, {"text": "The format patterns for both the old and new style are the same; here are the docs for the new one", "label": {"api": {"here are the docs": [[65, 81]]}}}, {"text": "The ConcurrentLinkedQueue data structure already provides it's own lock system and guarantees thread safety", "label": {"api": {"ConcurrentLinkedQueue": [[4, 24]]}}}, {"text": "I'd recomment you take a look at ExecutorService and ThreadPools", "label": {"api": {"ExecutorService": [[33, 47]]}}}, {"text": "Why not use a Semaphore with just one permit", "label": {"api": {"Semaphore": [[14, 22]]}}}, {"text": "File selectedFile = fileChooser.getSelectedFile(); gives you a File object for the file that was clicked on", "label": {"api": {"File": [[0, 3], [13, 16], [43, 46], [63, 66]]}}}, {"text": "Simply using Scanner input = new Scanner(selectedFile); will allow you to parse the file", "label": {"api": {"File": [[49, 52]]}}}, {"text": "Using the Path class, you can get the real path to your file on your file system", "label": {"api": {"Path": [[10, 13]]}}}, {"text": "see the docs about the Path class", "label": {"api": {"Path": [[23, 26]]}}}, {"text": "You say you add ServletContext and it returns null (@Autowired or not), making it sound like the value of servletContext is null, when your wording and code example otherwise seems to indicate that getRealPath() is returning null", "label": {"api": {"getRealPath()": [[198, 210]]}}}, {"text": "If servletContext is null, then servletContext.getRealPath() will cause a NullPointerException", "label": {"api": {"getRealPath()": [[47, 59]]}}}, {"text": "If servletContext is not null, then servletContext.getRealPath() will succeed, but may return null", "label": {"api": {"getRealPath()": [[51, 63]]}}}, {"text": "Quoting javadoc of getRealPath()", "label": {"api": {"getRealPath()": [[19, 31]]}}}, {"text": "So, if /WEB-INF/ is in a .war file that hasn't been unpacked, there is no real path, and getRealPath() will return null", "label": {"api": {"getRealPath()": [[89, 101]]}}}, {"text": "You could protect the workflow with a Semaphore that is initialized with the same number of permits as you have threads in your pool", "label": {"api": {"Semaphore": [[38, 46]]}}}, {"text": "This code uses the java.time framework built into Java 8 and later", "label": {"api": {"java.time": [[19, 27]]}}}, {"text": "or you can define it in FXML in a <fx:define> block", "label": {"api": {"<fx:define>": [[34, 44]]}}}, {"text": "Arrays.binarySearch can be used to find the correct insertion point efficiently", "label": {"api": {"Arrays.binarySearch": [[0, 18]]}}}, {"text": "In Java 8, Comparator has a handful of static and default methods that make it easy to create custom comparators", "label": {"api": {"Comparator": [[11, 20]]}}}, {"text": "Use a TextFormatter with a filter that vetoes any changes that don't leave the text in the correct form", "label": {"api": {"TextFormatter": [[6, 18]]}}}, {"text": "Instead of using Math.random(), I would suggest using Random", "label": {"api": {"Random": [[54, 59]]}}}, {"text": "Quoting the javadoc of class Clock (added in java 8)", "label": {"api": {"javadoc of class Clock": [[12, 33]]}}}, {"text": "Please review the Javadocs for ArrayList", "label": {"api": {"Javadocs for ArrayList": [[18, 39]]}}}, {"text": "Or maybe more descriptive using POSIX character classes", "label": {"api": {"POSIX character classes": [[32, 54]]}}}, {"text": "Potentially prefixed by (?U) for full unicode/international support", "label": {"api": {"(?U)": [[24, 27]]}}}, {"text": "Then, a call anyMatch(predicate) returns whether one of the element of this stream matches the given predicate, which, in this case, tests whether the element is contained in list1", "label": {"api": {"anyMatch(predicate)": [[13, 31]]}}}, {"text": "If you choose to use java.math.BigInteger, you can use the constructor with the radix like so", "label": {"api": {"java.math.BigInteger": [[21, 40]]}}}, {"text": "According to the JavaFX CSS reference, there is a pseudoclass :selected on Cells, so I tried the following css", "label": {"api": {"JavaFX CSS reference": [[17, 36]]}}}, {"text": "Added @Column annotation for the id", "label": {"api": {"@Column annotation": [[6, 23]]}}}, {"text": "The Tab in JavaFX is not inherited from the Node", "label": {"api": {"Tab": [[4, 6]], "Node": [[44, 47]]}}}, {"text": "based on the Node", "label": {"api": {"Node": [[13, 16]]}}}, {"text": "It is preferable that all custom controls inherit from Control, which will simplify and standardize their development", "label": {"api": {"Control": [[55, 61]]}}}, {"text": "You can use Collectors.groupingBy to turn your stream of (grouping) -> (list of things in that grouping)", "label": {"api": {"Collectors.groupingBy": [[12, 32]]}}}, {"text": "java.util.Scanner already does most of the heavy lifting for you, it's just a matter of using it", "label": {"api": {"java.util.Scanner": [[0, 16]]}}}, {"text": "setSoTimeout is a timeout on blocking reads for TCP", "label": {"api": {"setSoTimeout": [[0, 11]]}}}, {"text": "Add the buttons to a List - you can do that in a loop if the button text and their behavior is similar enough", "label": {"api": {"List": [[21, 24]]}}}, {"text": "I suggest you consider using a PriorityQueue with an appropriate ordering", "label": {"api": {"PriorityQueue": [[31, 43]]}}}, {"text": "Currently I'm thinking about a Java application, so I wonder whether there are any chances that a casual user of some Java software in some country could end up with defaultCharset being reported in such a way that \"AZaz09\".getBytes() returns something different than \"AZaz09\".getBytes(\"UTF-8\")", "label": {"api": {"defaultCharset": [[166, 179]], "\"AZaz09\".getBytes()": [[215, 233]], "\"AZaz09\".getBytes(\"UTF-8\")": [[268, 293]]}}}, {"text": "The standard way to expose a ListIterator is to have a public <T> ListIterator<T> listIterator() method on your class, as in the standard List class, so you can use it as", "label": {"api": {"List": [[29, 32], [66, 69], [138, 141]]}}}, {"text": "Note that the builtin Deque<T> class does not support ListIterators", "label": {"api": {"List": [[54, 57]]}}}, {"text": "When porting a large project with 5000 Java-files from Java ME to Java SE, I have tried to replace javax.microedition.event.Event with my own class (same for EventManager and EventListener)", "label": {"api": {"javax.microedition.event.Event": [[99, 128]]}}}, {"text": "Using the Java Time API, you can construct a YearMonth object representing the current year-month and call minusMonths to subtract a number of months", "label": {"api": {"YearMonth": [[45, 53]], "minusMonths": [[107, 117]]}}}, {"text": "Then, you can get the textual representation of the month name with Month.getDisplayName(style, locale)", "label": {"api": {"Month.getDisplayName(style, locale)": [[68, 102]]}}}, {"text": "The given TextStyle is used to style the output; you can use SHORT for your case", "label": {"api": {"TextStyle": [[10, 18]], "SHORT": [[61, 65]]}}}, {"text": "Note the StandardCharsets class", "label": {"api": {"StandardCharsets": [[9, 24]]}}}, {"text": "When you have a Field, you can directly invoke unreflectGetter on the lookup factory to retrieve a MethodHandle", "label": {"api": {"unreflectGetter": [[47, 61]]}}}, {"text": "Depending on the accessibility of the field, you might need to invoke setAccessible(true)", "label": {"api": {"setAccessible(true)": [[70, 88]]}}}, {"text": "According to the javadoc, Node is any piece of data that can exist in an XML doc, including comments, headers, and text (text value of XML element) so not all kind of nodes can have have a \"name\" or have child elements", "label": {"api": {"Node": [[26, 29]]}}}, {"text": "an Element defines the kinds of node that may have child elements that may be retrieved by a name", "label": {"api": {"Element": [[3, 9]]}}}, {"text": "However, when you call getBytes() on a String, you get (quoting javadoc)", "label": {"api": {"getBytes()": [[23, 32]]}}}, {"text": "To fix it, use getBytes(Charset charset), as in", "label": {"api": {"getBytes(Charset charset)": [[15, 39]]}}}, {"text": "The Shadow effect in JavaFX is for implementing drop shadow style effects for 2D objects; it will not create appropriate shadow effects for 3D objects and is not built for that purpose", "label": {"api": {"Shadow": [[4, 9]]}}}, {"text": "The Runnable interface defines the run method with return type void", "label": {"api": {"Runnable": [[4, 11]]}}}, {"text": "Have you considered simply using the TreeMap class instead of a custom subclass of LinkedHashMap", "label": {"api": {"TreeMap": [[37, 43]]}}}, {"text": "It will maintain order if you implement the Comparable interface on the keys", "label": {"api": {"Comparable": [[44, 53]]}}}, {"text": "The only real way to achieve this, AFAIK, is to have a second ScheduledExecutor", "label": {"api": {"ScheduledExecutor": [[62, 78]]}}}, {"text": "You can use Thread.getAllStackTraces() to get most of this", "label": {"api": {"Thread.getAllStackTraces()": [[12, 37]]}}}, {"text": "Use a StringBuilder", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "use the descendingIterator() method and loop n number of times where n is the index", "label": {"api": {"descendingIterator()": [[8, 27]]}}}, {"text": "You then wrap it in a ByteBuffer using LITTLE_ENDIAN byte order", "label": {"api": {"ByteBuffer": [[22, 31]], "LITTLE_ENDIAN": [[39, 51]]}}}, {"text": "When you then call getInt(), it will consume 4 bytes", "label": {"api": {"getInt()": [[19, 26]]}}}, {"text": "It then enters the loop and calls getInt() again, trying to read another 4 bytes, but there is only 1 left, so it throws BufferUnderflowException", "label": {"api": {"getInt()": [[34, 41]]}}}, {"text": "You just need the #find method", "label": {"api": {"#find": [[18, 22]]}}}, {"text": "Have a look at Collections.synchronizedList or CopyOnWriteArrayList (the latter doesn't need synchronizing for iteration)", "label": {"api": {"Collections.synchronizedList": [[15, 42]], "CopyOnWriteArrayList": [[47, 66]]}}}, {"text": "according to the API SimpleDateFormat documentation, you should use d (day in month) instead of D (day in year), in your format definition", "label": {"api": {"SimpleDateFormat documentation": [[21, 50]]}}}, {"text": "If there are multiple \"greatest/lowest\" elements in a Stream which the Comparator passed to the max or min methods considers equal (returns 0), is it specified somewhere which element will be found", "label": {"api": {"max": [[96, 98]], "min": [[103, 105]]}}}, {"text": "Please have a look at Scanner", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "Collections.shuffle() can do the trick", "label": {"api": {"Collections.shuffle()": [[0, 20]]}}}, {"text": "We can see from the URL constructor spec that a the exception you are seeing will be thrown if something is wrong with the spec", "label": {"api": {"from the URL constructor spec": [[11, 39]]}}}, {"text": "See the documentation for add()", "label": {"api": {"the documentation for add()": [[4, 30]]}}}, {"text": "You first need to call setSize() to make space", "label": {"api": {"setSize()": [[23, 31]]}}}, {"text": "The format strings MMMM or MMM will parse Apr just fine", "label": {"api": {"The format strings MMMM or MMM will parse Apr just fine": [[0, 54]]}}}, {"text": "The ListChangeListener.Change documentation describes the values returned by c.getFrom(), c.getTo(), c.wasRemoved(), c.getAdded(), etc", "label": {"api": {"ListChangeListener.Change documentation": [[4, 42]]}}}, {"text": "Instead of a list, use a map with the Phone's id as the key", "label": {"api": {"map": [[25, 27]]}}}, {"text": "Since  that is a list of objects then you can sort it by the date using collections.sort..", "label": {"api": {"collections.sort": [[72, 87]]}}}, {"text": "Animate the stokeDashOffsetProperty of the line from a value of 0 until the total length of the items in the stroke dash array", "label": {"api": {"stokeDashOffsetProperty": [[12, 34]]}}}, {"text": "Just run the timeline in reverse if you want to animate in the opposite direction", "label": {"api": {"timeline": [[13, 20]]}}}, {"text": "The Java documentation on the matter https://docs.oracle.com/javase/7/docs/api/java/lang/Character.html did not help me either", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Character.html": [[37, 102]]}}}, {"text": "This can be done with ImageIO.write(Image, String, OutputStream) which can write to an arbitrary OutputStream rather than disk", "label": {"api": {"ImageIO.write(Image, String, OutputStream)": [[22, 63]]}}}, {"text": "ByteArrayOutputStream can store the output bytes into an array in memory", "label": {"api": {"ByteArrayOutputStream": [[0, 20]]}}}, {"text": "As shown in Image processing with Java 2D, you can create a Map<String, BufferedImageOp> that holds concrete instances of the BufferedImageOp interface", "label": {"api": {"BufferedImageOp": [[72, 86], [126, 140]]}}}, {"text": "You should check how to use the Comparator Interface", "label": {"api": {"Comparator Interface": [[32, 51]]}}}, {"text": "If you're developing in Java 8, I suggest that you use StringJoiner", "label": {"api": {"StringJoiner": [[55, 66]]}}}, {"text": "You can find an example to create a CSV with StringJoiner here", "label": {"api": {"StringJoiner": [[45, 56]]}}}, {"text": "Take a look a the BigInteger class which lets you have almost infinitely large numbers", "label": {"api": {"BigInteger": [[18, 27]]}}}, {"text": "You can create your own RMIConnectorServer, and conditionally enable it for SSL", "label": {"api": {"RMIConnectorServer": [[24, 41]]}}}, {"text": "When constructing the server instance, the environment map can be loaded with defined RMIClientSocketFactory and RMIServerSocketFactory instances", "label": {"api": {"RMIClientSocketFactory": [[86, 107]], "RMIServerSocketFactory": [[113, 134]]}}}, {"text": "To enable SSL, these factories can be set as configured SslRMIClientSocketFactory and SslRMIServerSocketFactory instances and you will have recreated the equivalent of the system props configured connector server", "label": {"api": {"RMIClientSocketFactory": [[59, 80]], "RMIServerSocketFactory": [[89, 110]], "SslRMIClientSocketFactory": [[56, 80]], "SslRMIServerSocketFactory": [[86, 110]]}}}, {"text": "Why does Number Class have an abstract methods intValue(),longValue() etc, even though Numbers are expected to return int or long etc", "label": {"api": {"Number": [[9, 14], [87, 92]], "intValue()": [[47, 56]], "longValue()": [[58, 68]]}}}, {"text": "(You may also use List.contains instead of an nested loop which is clearer and shorter)", "label": {"api": {"List.contains": [[18, 30]]}}}, {"text": "But I read in the Comprator javadoc that compare to needs to be a total ordering relation", "label": {"api": {"Comprator javadoc": [[18, 34]]}}}, {"text": "You can create a javafx.scene.image.Image from any node by calling snapshot(...) on the node", "label": {"api": {"snapshot(...)": [[67, 79]]}}}, {"text": "The javax.imageio.ImageIO class has methods for saving images in standard formats, but only works with AWT images, so you need to convert it first", "label": {"api": {"javax.imageio.ImageIO": [[4, 24]]}}}, {"text": "To create a map with custom sorting you can use the constructor which takes a Comparator", "label": {"api": {"Comparator": [[78, 87]]}}}, {"text": "In Java 8 Comparator.comparing was added, which makes creating a comparator using the new streaming feature easy", "label": {"api": {"Comparator": [[10, 19]], "Comparator.comparing": [[10, 29]]}}}, {"text": "To fix that, we can chain an additional comparator using thenComparing()", "label": {"api": {"thenComparing()": [[57, 71]]}}}, {"text": "Because thread.toString() returns a string representation of this thread, including the thread's name, priority, and thread group", "label": {"api": {"thread.toString()": [[8, 24]]}}}, {"text": "There's a much easier way to do what you're trying to do, using String's split() method", "label": {"api": {"split()": [[73, 79]]}}}, {"text": "To get the exact length, you have to use method of such as  Graphics.getFontMetrics and FontMetrics.stringWidth are", "label": {"api": {"Graphics.getFontMetrics": [[60, 82]], "FontMetrics.stringWidth": [[88, 110]]}}}, {"text": "For details, see http://docs.oracle.com/javaee/6/api/javax/persistence/Query.html", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/Query.html": [[17, 80]]}}}, {"text": "You will need a different overload of divide that takes a scale to use (number of decimal digits beyond the decimal point) and the rounding mode", "label": {"api": {"different overload of divide": [[16, 43]]}}}, {"text": "You can use Java file properties", "label": {"api": {"properties": [[22, 31]]}}}, {"text": "It supports ':' as separator for the property name / value", "label": {"api": {"supports": [[3, 10]]}}}, {"text": "I've noticed many functionalities exposed in Stream are apparently duplicated in Collectors, such as Stream.map(Foo::bar) versus Collectors.mapping(Foo::bar, ...), or Stream.count() versus Collectors.counting()", "label": {"api": {"Stream": [[45, 50], [101, 106], [167, 172]], "Collectors": [[81, 90], [129, 138], [189, 198]]}}}, {"text": "Take a look at the Stream package summary javadoc for more information", "label": {"api": {"Stream package summary": [[19, 40]]}}}, {"text": "You can use Comparator's default method reversed() to reverse the sense of comparisons to sort it descending", "label": {"api": {"Comparator's default method reversed()": [[12, 49]]}}}, {"text": "JMenu#getPopupMenu() and JPopupMenu#pack() works fine for me", "label": {"api": {"JMenu#getPopupMenu()": [[0, 19]], "JPopupMenu#pack()": [[25, 41]]}}}, {"text": "Consider using a list (http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html) instead - it will let you add any number of items, however large or small", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html": [[23, 88]]}}}, {"text": "If the hashmap needs to support concurrent access/modification, then take a look at the ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[88, 104]]}}}, {"text": "Looks like your code could be simplified a lot by just using an ArrayList", "label": {"api": {"ArrayList": [[64, 72]]}}}, {"text": "Arrays.stream(la) executes the method public static LongStream stream(long[] array) which produces a LongStream", "label": {"api": {"public static LongStream stream(long[] array)": [[38, 82]]}}}, {"text": "LongStream's map method returns a LongStream (i.e", "label": {"api": {"map": [[13, 15]]}}}, {"text": "each long element of the source LongStream is mapped to a long element in the target LongStream)", "label": {"api": {"map": [[46, 48]]}}}, {"text": "It should work if you use mapToObj", "label": {"api": {"map": [[26, 28]]}}}, {"text": "Your second snippet works since here Arrays.stream produces a Stream of a reference type (Stream<String>) whose map method produces another Stream of a reference type (Stream<Long> in your case)", "label": {"api": {"map": [[112, 114]]}}}, {"text": "The easiest approach in this case seems that it would be to just replace the square brace characters [ and ] (via a replace() or replaceAll() call) and then perform your split() function using", "label": {"api": {"replace()": [[116, 124]], "replaceAll()": [[129, 140]], "split()": [[170, 176]]}}}, {"text": "If your question is simply how to get the current thread, you can get the current thread using the static method currentThread of the class Thread", "label": {"api": {"currentThread": [[113, 125]]}}}, {"text": "If you use a Buffer you need to flush it or close it, otherwise if the buffer is not full the data remains in the buffer", "label": {"api": {"flush": [[32, 36]], "close": [[44, 48]]}}}, {"text": "It is ok also to close it because as you can see from the javadoc closing a stream will also flush it", "label": {"api": {"flush": [[93, 97]], "close": [[17, 21]]}}}, {"text": "From the javadoc of OutputStream you can see what flushing means", "label": {"api": {"flush": [[50, 54]]}}}, {"text": "additionally remember to close both input and output streams when you finished to use them, otherwise you still have not properly closed resources using memory", "label": {"api": {"close": [[25, 29], [130, 134]]}}}, {"text": "Second, since your fields are separated by a , and (I'm assuming) always have the same number of fields, you can use the split() method to separate each line into an array of strings", "label": {"api": {"split()": [[121, 127]]}}}, {"text": "The pro way to do it ProcessBuilder", "label": {"api": {"ProcessBuilder": [[21, 34]]}}}, {"text": "A custom consumer class will allow keeping track of the expensive operations as it reduces the list", "label": {"api": {"consumer": [[9, 16]]}}}, {"text": "Instead of creating Threads explicitly, submit your Runnables to an ExecutorService, then call its shutdown and awaitTermination methods", "label": {"api": {"shutdown": [[99, 106]], "awaitTermination": [[112, 127]]}}}, {"text": "Another way is to use the Future interface", "label": {"api": {"Future interface": [[26, 41]]}}}, {"text": "Your base class, JFrame, does not have a method named paintComponent()", "label": {"api": {"JFrame": [[17, 22]]}}}, {"text": "Assuming there's a getName() method in your RequestObject class, you could do it with Collectors.groupingBy() and Collectors.counting() as follows", "label": {"api": {"Collectors.groupingBy()": [[86, 108]], "Collectors.counting()": [[114, 134]]}}}, {"text": "For your second question, you can read the full line of numbers and then split (divide) the string that you have read taking as reference the space that you put between each number", "label": {"api": {"split": [[73, 77]]}}}, {"text": "In Java 8+ there is also an Optional type, which can serve the same purpose without a Collection", "label": {"api": {"Optional": [[28, 35]]}}}, {"text": "You could use FileOutputStream instead of FileWriter and use stream.getChannel().truncate(0)", "label": {"api": {"FileOutputStream": [[14, 29]]}}}, {"text": "There's currently a bug in Java, see bug reports here and here, where Class#getDeclaredMethods() returns a bridge Method for each inherited method from a superclass declared as package-private", "label": {"api": {"Class#getDeclaredMethods()": [[70, 95]]}}}, {"text": "See https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html for details", "label": {"api": {"https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html": [[4, 74]]}}}, {"text": "There is a get  method in HashMap", "label": {"api": {"get": [[11, 13]]}}}, {"text": "System.arrayCopy() allows you to copy the contents of an array to a new (potentially larger) array, however even that is too manual", "label": {"api": {"System.arrayCopy()": [[0, 17]]}}}, {"text": "The Collections API provides a number of higher-level data structures that are more user-friendly than arrays, including the List interface which defines an API similar to arrays but has many additional features including the ability to be resized, and ArrayList, a List implementation that is backed by arrays under the covers", "label": {"api": {"List": [[125, 128], [258, 261], [266, 269]], "ArrayList": [[253, 261]]}}}, {"text": "In short, if you need a resizable array, you really want an ArrayList", "label": {"api": {"List": [[65, 68]], "ArrayList": [[60, 68]]}}}, {"text": "I tired to initialize KeyPairGenerator with a RandomSecure object which uses the same seed", "label": {"api": {"KeyPairGenerator": [[22, 37]], "RandomSecure": [[46, 57]]}}}, {"text": "In addition, while the JsonArray library in java is written to this spec you can get the index of items in the JSON, but JsonWriter will not let you specify an index to insert into the JSON", "label": {"api": {"JsonArray": [[23, 31]], "JsonWriter": [[121, 130]]}}}, {"text": "The easiest way is to use Map#merge()", "label": {"api": {"Map#merge()": [[26, 36]]}}}, {"text": "You could use a regex, using Pattern.quote to escape out any special characters", "label": {"api": {"Pattern.quote": [[29, 41]]}}}, {"text": "Lock is an interface", "label": {"api": {"Lock": [[0, 3]]}}}, {"text": "ReentrantLock is a concrete class that implements the Lock interface", "label": {"api": {"Lock": [[9, 12], [54, 57]], "ReentrantLock": [[0, 12]]}}}, {"text": "It implements all the methods defined in Lock, plus much more", "label": {"api": {"Lock": [[41, 44]]}}}, {"text": "The Lock interface makes it possible for you to implement your own kind of lock", "label": {"api": {"Lock": [[4, 7]]}}}, {"text": "Another class that uses your lock wouldn't care about the internal details of your lock; it only cares that your custom lock respects the Lock interface", "label": {"api": {"Lock": [[138, 141]]}}}, {"text": "The Byte.toString method takes the byte value as a number and converts it to a String, not the char value, so that is why you get \"68\"", "label": {"api": {"Byte.toString method": [[4, 23]]}}}, {"text": "Cast it to a char, which the String.valueOf method can use to create a String", "label": {"api": {"String.valueOf method": [[29, 49]]}}}, {"text": "I would try to create an ExceptionMapper that maps the standard WebApplicationException when the exception occurs, check if it is a SERVICE_UNAVAILABLE Response.Status", "label": {"api": {"ExceptionMapper": [[25, 39]], "WebApplicationException": [[64, 86]], "SERVICE_UNAVAILABLE": [[132, 150]]}}}, {"text": "If it is, handle the exception, if not fall back to the default WebApplicationException", "label": {"api": {"WebApplicationException": [[64, 86]]}}}, {"text": "you can put a Set", "label": {"api": {"Set": [[14, 16]]}}}, {"text": "The easiest way to achieve this behavior would be to use Collectors.groupingBy with your own classifier", "label": {"api": {"Collectors.groupingBy": [[57, 77]]}}}, {"text": "First look at the Javadoc for @JoinTable", "label": {"api": {"Javadoc for @JoinTable": [[18, 39]]}}}, {"text": "The Javadoc for mappedBy for the ManyToMany annotation says", "label": {"api": {"Javadoc for mappedBy for the ManyToMany annotation says": [[4, 58]]}}}, {"text": "instead of a string of 0's and 1's, you could use a java BitSet to store the 1/0's as boolean bits, and then when you write it, you'd use toByteArray to write the bytes directly as a binary file, instead of writing a string of text", "label": {"api": {"java BitSet": [[52, 62]]}}}, {"text": "No, you should call hasNextInt() before calling nextInt()", "label": {"api": {"hasNextInt()": [[20, 31]], "nextInt()": [[48, 56]]}}}, {"text": "You could use the getInt(int) method", "label": {"api": {"getInt(int)": [[18, 28]]}}}, {"text": "Else, you can generate hashes of your strings with MessageDigest in the java.security package", "label": {"api": {"MessageDigest": [[51, 63]]}}}, {"text": "PreparedStatement#executeBatch is perfect candidate to solve your problem", "label": {"api": {"PreparedStatement#executeBatch": [[0, 29]]}}}, {"text": "The easiest way is to parse the string to a LocalDateTime object", "label": {"api": {"a LocalDateTime object": [[42, 63]]}}}, {"text": "As this document has provided, option elements of @RequestMapping annotation", "label": {"api": {"document": [[8, 15]]}}}, {"text": "Use the printf format specifiers as described in the Formatter API", "label": {"api": {"Formatter API": [[53, 65]]}}}, {"text": "My read of the docs suggests that setting HttpsParameters.setNeedClientAuth(true) ought to cause an authentication failure when the client isn't trusted", "label": {"api": {"setting HttpsParameters.setNeedClientAuth(true)": [[34, 80]]}}}, {"text": "Call File.delete() which deletes the file or directory denoted by this abstract pathname", "label": {"api": {"File.delete()": [[5, 17]]}}}, {"text": "Because DefaultTableCellRenderer is JLabel, you can use it's text alignment properties in a custom renderer to label the icon", "label": {"api": {"DefaultTableCellRenderer": [[8, 31]]}}}, {"text": "Use BigInteger, which can support very long numbers", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "If you need help with that, see the java API for the Random class", "label": {"api": {"java API": [[36, 43]]}}}, {"text": "You can create a custom comparator and pass it to the Collections.sort(..)", "label": {"api": {"Collections.sort(..)": [[54, 73]]}}}, {"text": "I'm looking for the equivalent of Java's Float.intBitsToFloat(int) in Swift", "label": {"api": {"Float.intBitsToFloat(int)": [[41, 65]]}}}, {"text": "Kindly note that mm stands for Minute and not Month", "label": {"api": {"mm": [[17, 18]]}}}, {"text": "I think a SortedSet is a NavigableSet which in turn has methods like subSet, tailSet, headSet, ceiling and floor for this kind of problems", "label": {"api": {"SortedSet": [[10, 18]], "NavigableSet": [[25, 36]], "subSet": [[69, 74]], "headSet": [[86, 92]], "ceiling": [[95, 101]]}}}, {"text": "Obviously you can create you TreeSet with whatever Comparator you want, and perform the searches in the order that you find more convenient", "label": {"api": {"TreeSet": [[29, 35]], "Comparator": [[51, 60]]}}}, {"text": "The Character class provides helper methods, which are less error-prone and more readable", "label": {"api": {"Character class": [[4, 18]]}}}, {"text": "See Duration#parse() JavaDoc for reference", "label": {"api": {"Duration#parse()": [[4, 19]]}}}, {"text": "Thankfully, the Executor system was created to make this easier (I remember creating one in a framework a long time ago before this was available)", "label": {"api": {"Executor": [[16, 23]]}}}, {"text": "The end strategy is effectively the same, except your Executor is in charge of spinning up or reusing threads for your short term asynchronous work", "label": {"api": {"Executor": [[54, 61]]}}}, {"text": "Maybe use a Semaphore and a Timer to release tokens", "label": {"api": {"Semaphore": [[12, 20]]}}}, {"text": "If you don't do either of those, using java.reflect.Proxy might help", "label": {"api": {"java.reflect.Proxy": [[39, 56]]}}}, {"text": "At run-time, we can use Font.canDisplayUpTo(String) to determine which of the installed fonts can display a given text", "label": {"api": {"Font.canDisplayUpTo(String)": [[24, 50]]}}}, {"text": "Instead of an array, you could use an ArrayList, it will allow you to add elements without having to supply an index", "label": {"api": {"ArrayList": [[38, 46]]}}}, {"text": "It is true that the Comparator interface has 2 abstract methods", "label": {"api": {"Comparator": [[20, 29]]}}}, {"text": "As such, this makes the Comparator interface a functional interface where the functional method is compare(o1, o2)", "label": {"api": {"Comparator": [[24, 33]], "compare(o1, o2)": [[99, 113]]}}}, {"text": "Make a Polygon and check that", "label": {"api": {"Polygon": [[7, 13]]}}}, {"text": "use JavaFX Polygon - for double points", "label": {"api": {"Polygon": [[11, 17]]}}}, {"text": "This refers to the Labeled.mnemonicParsing property", "label": {"api": {"Labeled.mnemonicParsing property": [[19, 50]]}}}, {"text": "Instead you can use an image that represents your level and then have the image in an ImageView", "label": {"api": {"ImageView": [[86, 94]]}}}, {"text": "On that ImageView you can define a viewport of the area of the image that is visible", "label": {"api": {"ImageView": [[8, 16]]}}}, {"text": "I'd use Socket.getInetAddress() and compare the result to whatever you have the IPs you want to send to in", "label": {"api": {"Socket.getInetAddress()": [[8, 30]]}}}, {"text": "java.util.Random is specified to use the following recurrence to advance the seed", "label": {"api": {"specified": [[20, 28]]}}}, {"text": "The first is that we need modular exponentiation to evaluate this efficiently, and the second is that we need 80-bit arithmetic to compute (a^N - 1) mod (a-1)m", "label": {"api": {"modular exponentiation": [[26, 47]]}}}, {"text": "Both of these problems can be solved using Java's BigInteger class, which provides modular exponentiation and arbitrary-precision integers", "label": {"api": {"BigInteger class": [[50, 65]], "modular exponentiation": [[83, 104]]}}}, {"text": "Alternatively, we can use a variation on the modular exponentiation algorithm to calculate ((a^N - 1) mod (a-1)m)/(a-1) as (a^(N-1) + a^(N-2) + ..", "label": {"api": {"modular exponentiation": [[45, 66]]}}}, {"text": "You could use that with the parameters specified for java.util.Random to implement a java.util.Random equivalent with skipahead capabilities, or you could write it yourself", "label": {"api": {"specified": [[39, 47]]}}}, {"text": "But according to the contract, there is never any guarantee that hashcodes for two objects will be different", "label": {"api": {"contract": [[21, 28]]}}}, {"text": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results", "label": {"api": {"equals(java.lang.Object)": [[68, 91]]}}}, {"text": "To load content of a file inside your Jar (which is on the classpath, we presume), use getResourceAsStream()", "label": {"api": {"getResourceAsStream()": [[87, 107]]}}}, {"text": "If I were you, I'd rather use Collections#shuffle method, which \"randomly permutes the specified list using a default source of randomness", "label": {"api": {"Collections#shuffle method": [[30, 55]]}}}, {"text": "I'd have a good read of the following", "label": {"api": {"following": [[28, 36]]}}}, {"text": "Iterator.remove() is a really tricky method to get right, particularly in the face of potential concurrent modification (see ConcurrentModificationException)", "label": {"api": {"ConcurrentModificationException": [[125, 155]]}}}, {"text": "AbstractCollection) which provide reasonable defaults for a number of tricky methods", "label": {"api": {"AbstractCollection": [[0, 17]]}}}, {"text": "Your Bag class should instead probably implement Collection (or extend AbstractCollection) which is the general interface most Java data structures implement (it specifies .add(), .remove(), .size(), and so on)", "label": {"api": {"Collection": [[49, 58], [79, 88]], "AbstractCollection": [[71, 88]]}}}, {"text": "What is a problem is your class doesn't override .equals() and .hashcode() (you have to do neither or both), meaning that no two Bag instances can ever be considered equivalent, regardless of the order of their elements", "label": {"api": {".equals()": [[49, 57]], ".hashcode()": [[63, 73]]}}}, {"text": "You have two basic choices; ensure your backing array is always sorted (that's an invariant - at the end of every method the array will be sorted) or use a more efficient data structure for equality checks such as a Set", "label": {"api": {"Set": [[216, 218]]}}}, {"text": "Correctly ensuring an array is always sorted is very tricky; Java's TreeMap does this and most people consider this the type of code they'd never ever want to re-implement themselves", "label": {"api": {"TreeMap": [[68, 74]]}}}, {"text": "Using a Set lets you efficiently check if an element exists in your collection, but comes at the cost of preventing duplicate elements", "label": {"api": {"Set": [[8, 10]]}}}, {"text": "A \"bag\" data structure generally permits duplicates, so using a Set as a backing data structure may not be acceptable for your use case", "label": {"api": {"Set": [[64, 66]]}}}, {"text": "Nevertheless, as a starting point a standard brute force .equals() implementation may be good enough", "label": {"api": {".equals()": [[57, 65]]}}}, {"text": "Perform a snapshot of the GraphicsContext into a JavaFX Image by calling snapshot()", "label": {"api": {"snapshot()": [[73, 82]]}}}, {"text": "Then convert it into a BufferedImage using SwingFXUtils and finally to byte[] using ImageIO and ByteArrayOutputStream", "label": {"api": {"SwingFXUtils": [[43, 54]], "ImageIO": [[84, 90]]}}}, {"text": "The correct way to reference a resource file would be to use either getResource or getResourceAsStream", "label": {"api": {"getResource": [[68, 78], [83, 93]], "getResourceAsStream": [[83, 101]]}}}, {"text": "Look at Future interface", "label": {"api": {"Future": [[8, 13]]}}}, {"text": "It turns out, for this case, since I know the input is unique, I could do this similarly with the available grouping collector", "label": {"api": {"grouping collector": [[108, 125]]}}}, {"text": "Also if you use String.valueOf(encrypted) it will fall back to the valueOf(Object) method because there is no valueOf(byte[])", "label": {"api": {"valueOf(Object) method": [[67, 88]]}}}, {"text": "new String(encrypted) to convert the contents of the byte array to a readable string", "label": {"api": {"new String(encrypted)": [[0, 20]]}}}, {"text": "Don't use valueOf()", "label": {"api": {"valueOf()": [[10, 18]]}}}, {"text": "If you have a java.util.Date and want a java.sql.Date (or java.sql.Timestamp), use the Date(long date) constructor", "label": {"api": {"java.util.Date": [[14, 27]], "java.sql.Date": [[40, 52]], "java.sql.Timestamp": [[58, 75]], "Date(long date)": [[87, 101]]}}}, {"text": "SimpleDateFormat is not thread-safe", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Alternate cleaner solution, using anyMatch", "label": {"api": {"anyMatch": [[34, 41]]}}}, {"text": "If you are using Java 7 or greater, you can use the System.lineSeparator() method", "label": {"api": {"System.lineSeparator()": [[52, 73]]}}}, {"text": "You can use the Files class to copy files, e.g.", "label": {"api": {"Files": [[16, 20]]}}}, {"text": "Java 8 has a CharSequence#codePoints method that produces an IntStream of the Unicode codepoints in a string", "label": {"api": {"CharSequence#codePoints method": [[13, 42]]}}}, {"text": "It can be solved more efficiently (in terms of asymptotic complexity) only if you allow hashing and extra space, by populating a hash table (HashSet), and inserting all elements into it while iterating, and if you find a dupe while iterating - print it", "label": {"api": {"HashSet": [[141, 147]]}}}, {"text": "All Java timer, even the Swing Timer, uses a separate thread to wait and trigger the event at the appropriate time", "label": {"api": {"Timer": [[31, 35]]}}}, {"text": "If the main thread is otherwise idle, you can calculate the amount of time until next event, and sleep until then", "label": {"api": {"sleep": [[97, 101]]}}}, {"text": "Take a look at Thread.State and more specifically the WAITING and BLOCKED states", "label": {"api": {"Thread.State": [[15, 26]]}}}, {"text": "If you are interested in the internal implementation, both can be achieved using LockSupport.park() and LockSupport.unpark(Thread), and that's actually how they are implemented in most places", "label": {"api": {"LockSupport.park()": [[81, 98]], "LockSupport.unpark(Thread)": [[104, 129]]}}}, {"text": "Why don't you just use String.replaceAll", "label": {"api": {"String.replaceAll": [[23, 39]]}}}, {"text": "https://docs.oracle.com/javase/8/javafx/api/javafx/scene/image/PixelFormat.html has limited set of predefined pixel formats", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/scene/image/PixelFormat.html": [[0, 78]]}}}, {"text": "Here's the docs for the SystemTray and TrayIcon classes, for anyone that might be interested", "label": {"api": {"SystemTray": [[24, 33]], "TrayIcon": [[39, 46]]}}}, {"text": "You would be looking for the method TrayIcon.displayMessage()", "label": {"api": {"TrayIcon": [[36, 43]]}}}, {"text": "You can use Node.pseudoClassStateChanged", "label": {"api": {"Node.pseudoClassStateChanged": [[12, 39]]}}}, {"text": "In Java, you can enable matching all Unicode letters and digits by prepending the pattern with (?U) inline modifier, or by compiling the pattern with Pattern.UNICODE_CHARACTER_CLASS modifier flag", "label": {"api": {"Pattern.UNICODE_CHARACTER_CLASS modifier flag": [[150, 194]]}}}, {"text": "You can achieve that using Stream", "label": {"api": {"Stream": [[27, 32]]}}}, {"text": "You need to use a Set  which is", "label": {"api": {"Set": [[18, 20]]}}}, {"text": "And a TreeSet for the sorting (if needed)", "label": {"api": {"Set": [[10, 12]], "TreeSet": [[6, 12]]}}}, {"text": "I think you could do this with an XmlAdapter", "label": {"api": {"XmlAdapter": [[34, 43]]}}}, {"text": "We use a cluster of HttpServers (bundled with java) to handle http requests", "label": {"api": {"HttpServers (bundled with java)": [[20, 50]]}}}, {"text": "Check out the java.util.Properties class", "label": {"api": {"java.util.Properties": [[14, 33]]}}}, {"text": "If you want Table then the better is to use JTabel", "label": {"api": {"JTabel": [[44, 49]]}}}, {"text": "You could try a ContainerRequestFilter, as following", "label": {"api": {"ContainerRequestFilter": [[16, 37]]}}}, {"text": "For dynamic binding, you also could try a DynamicFeature", "label": {"api": {"DynamicFeature": [[42, 55]]}}}, {"text": "You don't have any elements in your ArrayList<Integer> work_array = new ArrayList<Integer>(); therefore your index ist out of range, since the  size() returns 0", "label": {"api": {"out of range": [[119, 130]]}}}, {"text": "Assuming that you already parsed the xml file and have a version variable with that information you can use the Class.forName(String) like this", "label": {"api": {"Class.forName(String)": [[112, 132]]}}}, {"text": "You may take a look at the FileWriter", "label": {"api": {"FileWriter": [[27, 36]]}}}, {"text": "Quoting javadoc of StringTokenizer", "label": {"api": {"StringTokenizer": [[19, 33]]}}}, {"text": "StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "And it relies on the fact that by default, when you \"swallow\" the next token with anything but .nextLine() with a Scanner, it relies on the current delimiter, which by default matches a newline", "label": {"api": {"delimiter": [[148, 156]]}}}, {"text": "If your goal is to grow the array, you may want to check out LinkedBlockingQueue or CopyOnWriteArrayList, depending on your use case", "label": {"api": {"LinkedBlockingQueue": [[61, 79]], "CopyOnWriteArrayList": [[84, 103]]}}}, {"text": "You could use a sortedSet", "label": {"api": {"sortedSet": [[16, 24]]}}}, {"text": "How can I alter the time-of-day portion of an existing ZonedDateTime object", "label": {"api": {"ZonedDateTime": [[55, 67]]}}}, {"text": "Because Swing is single threaded, it uses the EventQueue to hold instances of Runnable so that they can be dispatched sequentially and in the order posted, whether generated by the system or your program", "label": {"api": {"EventQueue": [[46, 55]]}}}, {"text": "The sine qua non usage is posting an event via EventQueue.invokeLater(), which ensures that Swing GUI objects are constructed and manipulated only on the event dispatch thread", "label": {"api": {"EventQueue": [[47, 56]]}}}, {"text": "You can replace the AWT EventQueue with your own implementation, as shown here, to see the events as they are placed in the queue", "label": {"api": {"EventQueue": [[24, 33]]}}}, {"text": "When executing an external program from Java, you can use  Process.exitValue() to obtain its exit code", "label": {"api": {"Process.exitValue()": [[59, 77]]}}}, {"text": "Use the  A[] toArray(IntFunction generator) method", "label": {"api": {" A[] toArray(IntFunction generator)": [[8, 42]]}}}, {"text": "You can implement your own FocusTraversalPolicy which will manage the tab order", "label": {"api": {"FocusTraversalPolicy": [[27, 46]]}}}, {"text": "You can then assign it to your frame with the setFocusTraversalPolicy method", "label": {"api": {"FocusTraversalPolicy": [[49, 68]]}}}, {"text": "Look at Shape, some of the child classes will do Bezier curves and such", "label": {"api": {"Shape": [[8, 12]]}}}, {"text": "Each function is mapped to the result of applying it to the given object and null fields are filtered out with the predicate Objects::nonNull", "label": {"api": {"Objects::nonNull": [[125, 140]]}}}, {"text": "Java provides you StringBuilder for building strings", "label": {"api": {"StringBuilder": [[18, 30]]}}}, {"text": "You can also do the replacement when you're building your text in StringBuilder", "label": {"api": {"StringBuilder": [[66, 78]]}}}, {"text": "If so, one easy way to get around the problem is Java's StringBuilder class which is intended for exactly this task", "label": {"api": {"StringBuilder class": [[56, 74]]}}}, {"text": "LocalDate has various overloaded atTime methods, such as this one, which takes two arguments (hour of day and minute)", "label": {"api": {"this one": [[57, 64]]}}}, {"text": "You can also create your own clock to do this", "label": {"api": {"clock": [[29, 33]]}}}, {"text": "This can be a useful option if used repeatedly, because the clock can be stored in a static variable", "label": {"api": {"clock": [[60, 64]]}}}, {"text": "Also see JComponent getTooltipText() method", "label": {"api": {"getTooltipText()": [[20, 35]]}}}, {"text": "You are aware of Java Comparables, right", "label": {"api": {"Java Comparables": [[17, 32]]}}}, {"text": "A java.time.ZonedDateTime (Java 8+) does have a time zone", "label": {"api": {"java.time.ZonedDateTime": [[2, 24]]}}}, {"text": "Using Runtime.exec() is bad practice, you should use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[55, 68]]}}}, {"text": "ProcessBuilder has a .redirectOutput() method which enables you to define where you want to receive the process' output", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "When working with Corba Java frameworks provide Holder Classes to give the reference semantics", "label": {"api": {"Holder Classes": [[48, 61]]}}}, {"text": "I used the method replace from String", "label": {"api": {"String": [[31, 36]]}}}, {"text": "ArrayLists can be easily sorted using a Comparator", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "You can use the distinct() method on Stream to eliminate the duplicates before further processing", "label": {"api": {"distinct()": [[16, 25]]}}}, {"text": "Then we go to the javadoc of tryAdvance() which says that", "label": {"api": {"javadoc of tryAdvance()": [[18, 40]]}}}, {"text": "When you test using operations like .collect(Collectors.toList()) its even unlikely to spot such a violation as most operations consuming all elements will invoke forEachRemaining() on the spliterator whose default implementation is documented as", "label": {"api": {"default implementation is documented as": [[208, 246]]}}}, {"text": "Within ATG there is a way to counter this and it is called the RepeatingRequestMonitor", "label": {"api": {"RepeatingRequestMonitor": [[63, 85]]}}}, {"text": "Somewhere between a database and a simple text file, a RandomAccessFile could help if the data could be written with standard lengths for each field", "label": {"api": {"RandomAccessFile": [[55, 70]]}}}, {"text": "Instead if you want to filter keyboard input correctly with text components such as a JTextField, add a DocumentFilter to the JTextField's Document", "label": {"api": {"DocumentFilter": [[104, 117]]}}}, {"text": "Another easier option is to use an InputVerifier", "label": {"api": {"InputVerifier": [[35, 47]]}}}, {"text": "I think you are looking for a Collator with a specific chosen Locale (like English, since you've stated that it then works correctly)", "label": {"api": {"Collator": [[30, 37]]}}}, {"text": "But you basically overwrote Component.getName() in your code which makes no sense at all, better rename your method to getUsername()", "label": {"api": {"Component.getName()": [[28, 46]]}}}, {"text": "It should be possible to get rid of the extra value tags by annotating the getter for the value field with @XmlValue", "label": {"api": {"@XmlValue": [[107, 115]]}}}, {"text": "In addition to @MatthiasSteinbauer answer, you can use Java 8 stream for both sorting and filer", "label": {"api": {"sorting": [[78, 84]], "filer": [[90, 94]]}}}, {"text": "I would suggest to multiply the number by ten, round it with Math.round(), then divide it back by ten", "label": {"api": {"Math.round()": [[61, 72]]}}}, {"text": "Specifying 10.0 instead of 10 is important since Math.round() returns a long value and you don't want integer divison but float division", "label": {"api": {"Math.round()": [[49, 60]]}}}, {"text": "An example of canceling tasks once an answer has been found is given in the API documentation for ExecutorCompletionService", "label": {"api": {"API documentation for ExecutorCompletionService": [[76, 122]]}}}, {"text": "You could write a custom Comparator that breaks down the key string by the periods and treats each element as an int", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "This Comparator can then be used in a TreeMap", "label": {"api": {"Comparator": [[5, 14]]}}}, {"text": "Note that this VersionStringComparator implementation assumes that it's only applied to strings that look like a series of integers delimited by periods", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "Java 8 provides a nice way to do this using IntStream", "label": {"api": {"IntStream": [[44, 52]]}}}, {"text": "We will use a List to keep them in chronological order as they happen", "label": {"api": {"List": [[14, 17]]}}}, {"text": "We will use the Instant class, a moment on the timeline in UTC with a resolution of nanoseconds", "label": {"api": {"Instant": [[16, 22]]}}}, {"text": "Part of the java.time framework built into Java 8 and later", "label": {"api": {"java.time": [[12, 20]]}}}, {"text": "To use another format, see the java.time.format package", "label": {"api": {"java.time": [[31, 39]], "java.time.format": [[31, 46]]}}}, {"text": "You can even let java.time automatically localize the output for you", "label": {"api": {"java.time": [[17, 25]]}}}, {"text": "As comments said, having run this in April of 2016, you were attempting to change the date to 31 which does not exist in the current month of April", "label": {"api": {"of": [[43, 44], [139, 140]]}}}, {"text": "So change the month to March before setting the day-of-month", "label": {"api": {"of": [[52, 53]]}}}, {"text": "Even better, use the static of method", "label": {"api": {"of": [[28, 29]]}}}, {"text": "Or use an enum constant Month.MARCH", "label": {"api": {"Month.MARCH": [[24, 34]]}}}, {"text": "The documentation for BlockingQueue nicely summarizes all of this, in a way that (in my opinion) eliminates any confusion", "label": {"api": {"documentation for BlockingQueue": [[4, 34]]}}}, {"text": "getBytes() is not defined for non-binary data, e.g", "label": {"api": {"getBytes()": [[0, 9]]}}}, {"text": "Taken from the docs from Scanner for hasNext()", "label": {"api": {"docs from Scanner": [[15, 31]]}}}, {"text": "What this does is that it collect each person into a mutable HashMap", "label": {"api": {"mutable HashMap": [[53, 67]]}}}, {"text": "Use an ArrayList instead of an array", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "I would recommend you to read up on Pattern matching with regular expressions", "label": {"api": {"Pattern": [[36, 42]]}}}, {"text": "See the documentation of Matcher for the available API", "label": {"api": {"documentation of Matcher": [[8, 31]]}}}, {"text": "The Objects.equals method checks for null references and then delegates the check to the equals method of the first argument", "label": {"api": {"Objects.equals": [[4, 17]]}}}, {"text": "It is worth looking at Conditions, they are easier to customise than Semaphores, if you didn't have the requirement of ( when it is full we need to wait for the shop to be completely empty) then a Semaphore would have been the best, we create a Semaphore with 5 permits and we await when people enter and release when they leave", "label": {"api": {"Conditions": [[23, 32]]}}}, {"text": "Call doClick() on the JButton as per it's parent, the AbstractButton's, API", "label": {"api": {"AbstractButton's, API": [[54, 74]]}}}, {"text": "The declaration public Set<Employee> employeeSet is an example of a bad practice, and you should use a private field with some sort of getter", "label": {"api": {"Set": [[23, 25], [45, 47]]}}}, {"text": "employeeSet is a List<Employee>, whereas you are asking for a String when iterating over it", "label": {"api": {"Set": [[8, 10]]}}}, {"text": "You are trying to access getFirstName() from your field employeeSet", "label": {"api": {"Set": [[64, 66]]}}}, {"text": "This won't work, as Set has no such method", "label": {"api": {"Set": [[20, 22]]}}}, {"text": "Also, you may simplify your code to the following one-liner with Java 8 streams", "label": {"api": {"Java 8 streams": [[65, 78]]}}}, {"text": "You can use a HashMap, HashMap<String, Integer> for doing this", "label": {"api": {"HashMap": [[14, 20], [23, 29]]}}}, {"text": "just in case Data would be your whole class, AtomicInteger would be the same, but done properly", "label": {"api": {"AtomicInteger": [[45, 57]]}}}, {"text": "Are you after System.arraycopy()", "label": {"api": {"System.arraycopy()": [[14, 31]]}}}, {"text": "the StringTokenizer docs say that if you don't pass a token delimiter in the constructor, it's assumed to be", "label": {"api": {"StringTokenizer docs": [[4, 23]]}}}, {"text": "the Thread class has an interrupt method", "label": {"api": {"interrupt": [[24, 32]]}}}, {"text": "You can simply check this using the contains() method of the String class", "label": {"api": {"contains()": [[36, 45]], "String": [[61, 66]]}}}, {"text": "A more elegant solution for this usecase (as pointed out by bcsb1001 in comments) is to use Math#max", "label": {"api": {"Math#max": [[92, 99]]}}}, {"text": "If you did this and looked up JLabel, you'll see that it has a setFont(...) method that it gains from its JComponent parent and which you can and should use to set the font", "label": {"api": {"JLabel": [[30, 35]]}}}, {"text": "Your handler method is linked to the onKeyReleased handler for the GridPane", "label": {"api": {"onKeyReleased": [[37, 49]]}}}, {"text": "Since onKeyReleased expects an EventHandler<KeyEvent>, your method (which you very confusingly named handleButtonAction) parameter type should be KeyEvent, not ActionEvent", "label": {"api": {"onKeyReleased": [[6, 18]]}}}, {"text": "If you do, you will find InstallerService which actually updates the Application by calling a OS native command using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[118, 131]]}}}, {"text": "One more thing that is worth to mention - you need to be aware that countTokens() method should be used before consuming tokens - otherwise it will return improper value (it returns a number of how many you can call nextToken() before receiving exception)", "label": {"api": {"countTokens()": [[68, 80]]}}}, {"text": "The default layout manager for Frame is BorderLayout", "label": {"api": {"BorderLayout": [[40, 51]]}}}, {"text": "It was added at the center of the frame with the constraint BorderLayout.CENTER", "label": {"api": {"BorderLayout": [[60, 71]]}}}, {"text": "You can read more about the BorderLayout here", "label": {"api": {"BorderLayout": [[28, 39]]}}}, {"text": "This is supported with CompletableFutures", "label": {"api": {"CompletableFutures": [[23, 40]]}}}, {"text": "If you look at the Arrays class (https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html), you'll find the sort method you're trying to call", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[33, 95]]}}}, {"text": "replaceFirst() means once-only, and [replaceAll()][1] is the same as specifying the g (global) option", "label": {"api": {"replaceFirst()": [[0, 13]]}}}, {"text": "This violates the expectation of the Statement class", "label": {"api": {"Statement class": [[37, 51]]}}}, {"text": "To do this, I recommend using a PrintWriter", "label": {"api": {"PrintWriter": [[32, 42]]}}}, {"text": "I have attached a simple implementation of the PrintWriter class that saves a string", "label": {"api": {"PrintWriter": [[47, 57]]}}}, {"text": "Take a look in the JavaDoc of CompletableFuture", "label": {"api": {"CompletableFuture": [[30, 46]]}}}, {"text": "You may use the showInputDialog method of class JOptionPane", "label": {"api": {"showInputDialog": [[16, 30]]}}}, {"text": "Use a \"dynamic root\"", "label": {"api": {"\"dynamic root\"": [[6, 19]]}}}, {"text": "If you want to print it in format you want, you can use DateFormat to format the Date object as well", "label": {"api": {"format": [[27, 32], [70, 75]]}}}, {"text": "For that you can use the responseComplete method of FacesContext in the end of your authentifier method", "label": {"api": {"responseComplete": [[25, 40]]}}}, {"text": "The java.awt.Robot class provides a useful method for capturing a screenshot", "label": {"api": {"java.awt.Robot": [[4, 17]]}}}, {"text": "You can't stream a Map directly, but you can stream its entry set, given with the entrySet() method", "label": {"api": {"the entrySet() method": [[78, 98]]}}}, {"text": "Arrays (confusingly) do not override Object.equals() (similarly they don't override .toString(), which is why you see those useless \\[Lsome.Type;@28a418fc strings when you print an array), meaning that calling .equals() on two equivalent arrays will not give you the result you'd expect", "label": {"api": {"Arrays": [[0, 5]]}}}, {"text": "Instead you should use the static helper functions in the Arrays class to do these sort of operations on arrays", "label": {"api": {"Arrays": [[58, 63]]}}}, {"text": "So try Arrays.equals() or JUnit's Assert.assertArrayEquals() instead of Assert.assertEquals()", "label": {"api": {"Arrays": [[7, 12]]}}}, {"text": "Stage and Popup inherit an onHidden property from Window", "label": {"api": {"onHidden property": [[27, 43]]}}}, {"text": "Use Collections.swap method", "label": {"api": {"Collections.swap": [[4, 19]]}}}, {"text": "If we look carefully at the documentation for Semaphore.aquire(int) we'll see that is not the case (emphasis mine)", "label": {"api": {"Semaphore.aquire(int)": [[46, 66]]}}}, {"text": "There's a number of possibly useful tools in java.util.concurrent, and which is best somewhat depends on what exactly you're trying to do", "label": {"api": {"java.util.concurrent": [[45, 64]]}}}, {"text": "You may want to use Thread.sleep()", "label": {"api": {"Thread.sleep()": [[20, 33]]}}}, {"text": "I think what you want is selecting into new object instance using its  constructor", "label": {"api": {"selecting into new object instance using its  constructor": [[25, 81]]}}}, {"text": "If you want to communicate across threads you cannot use ThreadLocal and should use a thread-safe data structure instead, such as ConcurrentHashMap or ConcurrentLinkedQueue", "label": {"api": {"ConcurrentHashMap": [[130, 146]], "ConcurrentLinkedQueue": [[151, 171]]}}}, {"text": "For the use case you're describing it would be easy enough to share a ConcurrentLinkedQueue between your threads and have them all write to the queue as needed", "label": {"api": {"ConcurrentLinkedQueue": [[70, 90]]}}}, {"text": "after you call updateProgress(i, 100);, everything will be better", "label": {"api": {"updateProgress": [[15, 28]]}}}, {"text": "This comes from the documentation of updateProgress", "label": {"api": {"updateProgress": [[37, 50]]}}}, {"text": "Calls to updateProgress are coalesced and run later on the FX application thread, and calls to updateProgress, even from the FX Application thread, may not necessarily result in immediate updates to these properties, and intermediate workDone values may be coalesced to save on event notifications", "label": {"api": {"updateProgress": [[9, 22], [95, 108]]}}}, {"text": "Typically, when adding Jersey dependencies, javax.annotation classes are added from javax.annotation-api-1.2.jar, while some of them are already present in the JDK", "label": {"api": {"JDK": [[160, 162]]}}}, {"text": "You could use String.indexOf(String substr) to get the position of the two delimiters in the String, then use String.substring(int beginIndex, int endIndex) to get what's between them", "label": {"api": {"String.indexOf(String substr)": [[14, 42]], "String.substring(int beginIndex, int endIndex)": [[110, 155]]}}}, {"text": "Note that String.indexOf(String substr) returns the starting position of the substring, so to compute the beginIndex you'll need to add the first delimiter's length", "label": {"api": {"String.indexOf(String substr)": [[10, 38]]}}}, {"text": "You can simply call removeAll on keySet", "label": {"api": {"removeAll": [[20, 28]], "keySet": [[33, 38]]}}}, {"text": "The split method takes a regular expression string, so you may want to escape your delimiter String to a valid regex", "label": {"api": {"split": [[4, 8]]}}}, {"text": "See the Pattern.quote method", "label": {"api": {"Pattern.quote": [[8, 20]]}}}, {"text": "Or even better, use String.format", "label": {"api": {"String.format": [[20, 32]]}}}, {"text": "From the annotation's javadoc", "label": {"api": {"annotation's javadoc": [[9, 28]]}}}, {"text": "If you're using GregorianCalendar, you can use a constructor", "label": {"api": {"GregorianCalendar": [[16, 32]]}}}, {"text": "See GregorianCalendar for other constructors you can use", "label": {"api": {"GregorianCalendar": [[4, 20]]}}}, {"text": "For thread-safe collections in Java, look at the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[49, 68]]}}}, {"text": "The reason you're seeing reference equality is because autoboxing internally calls Integer.valueOf() which caches certain values", "label": {"api": {"Integer.valueOf()": [[83, 99]]}}}, {"text": "Your attempt to add() a new ChartPanel \"invalidates the component hierarchy", "label": {"api": {"add()": [[16, 20]]}}}, {"text": "In a GridBagLayout,  the cells (and consequently rows and columns) of the grid do not have a fixed size, but query their contents' preferred sizes, and then give them extra space as determined by their weights (yet another constraint parameter - as always see the fine documentation for details)", "label": {"api": {"fine documentation": [[264, 281]]}}}, {"text": "To do a character-for-character replacement, the most efficient way is to get the char[] of the original string using toCharArray(), the modify the array, and create a new string using new String(char[])", "label": {"api": {"toCharArray()": [[118, 130]], "new String(char[])": [[185, 202]]}}}, {"text": "The easiest way to find the index of a letter in the CONSONANTS constant, is to use the indexOf() method", "label": {"api": {"indexOf()": [[88, 96]]}}}, {"text": "If you can use Java 8, use java.time.LocalDate which represents only the date without the time", "label": {"api": {"java.time.LocalDate": [[27, 45]]}}}, {"text": "Store the long value returned by toEpochDay method", "label": {"api": {"toEpochDay": [[33, 42]]}}}, {"text": "If you use a Servlet Filter, to retrieve and set a threadlocal you'll have to parse the SOAP XML yourself to access the UserId value", "label": {"api": {"Servlet Filter": [[13, 26]]}}}, {"text": "If you just need to pass the UserId value to the web service part of the application, in your handler you can simply set the value on the SOAPMessageContext as is the example here", "label": {"api": {"SOAPMessageContext": [[138, 155]]}}}, {"text": "To remove or clear the threadlocal you could either use a servlet filter or simply check the MESSAGE_OUTBOUND_PROPERTY on the SOAPMessageContext in your handler", "label": {"api": {"SOAPMessageContext": [[126, 143]], "remove": [[3, 8]]}}}, {"text": "If it's outbound, your handler is being asked to handle the web service response, so you'll want to remove", "label": {"api": {"remove": [[100, 105]]}}}, {"text": "You can try to use setText() like this", "label": {"api": {"setText()": [[19, 27]]}}}, {"text": "If you look at the JavaDoc of Thread.interrupt() you should see", "label": {"api": {"Thread.interrupt()": [[30, 47]]}}}, {"text": "You call storedProcedure.getOutputParameterValue(\"output\")", "label": {"api": {"call": [[4, 7]]}}}, {"text": "From the FileNotFoundException documentation", "label": {"api": {"FileNotFoundException documentation": [[9, 43]]}}}, {"text": "If you want more useful feedback, use the modern replacement for File, the Path class", "label": {"api": {"Path": [[75, 78]]}}}, {"text": "The signature of the PrintWriter.println(String) (and the other println methods) return void (not a PrintWriter)", "label": {"api": {"PrintWriter.println(String)": [[21, 47]]}}}, {"text": "By reading removeAttribute() javadoc, no exception should be thrown", "label": {"api": {"removeAttribute() javadoc": [[11, 35]]}}}, {"text": "If you need a ducation, you have java.time.Duration", "label": {"api": {"java.time.Duration": [[33, 50]]}}}, {"text": "Another option is to implement Externalizable but then you would need to implement both read() and write() and will have to serialize an unknown object anyway", "label": {"api": {"Externalizable": [[31, 44]]}}}, {"text": "However, please note that HttpServletRequest derives one fancy method from its superclass, that is ServletRequest#getLocales()", "label": {"api": {"HttpServletRequest": [[26, 43]], "ServletRequest#getLocales()": [[99, 125]]}}}, {"text": "My point is, you'll receive already parsed prioritized Enumeration of Locales", "label": {"api": {"Enumeration": [[55, 65]]}}}, {"text": "In your example, the method writeObject throws the checked exception IOException; you will need to catch it and either throw a runtime exception instead (like the new UncheckedIOException, which complicates a little the code) or do something else (like log it)", "label": {"api": {"UncheckedIOException": [[167, 186]]}}}, {"text": "Could it be done with a ReentrantLock", "label": {"api": {"ReentrantLock": [[24, 36]]}}}, {"text": "URLClassLoader supports only jar files and directories of files", "label": {"api": {"URLClassLoader": [[0, 13]]}}}, {"text": "Put your resources into a jar file and add that jar file into your URLClassLoader", "label": {"api": {"URLClassLoader": [[67, 80]]}}}, {"text": "If you want the label to show the clock updating, you may need to use something like a Timer to reset the label text every second", "label": {"api": {"Timer": [[87, 91]]}}}, {"text": "This cannot be done directly with ProcessBuilder (you can see that no relevant method exists in the class), but you can implement this behavior easily enough once the subprocess has begun", "label": {"api": {"ProcessBuilder": [[34, 47]]}}}, {"text": "Calling Process.waitFor() as you do in your sample code is problematic because it will block your current thread indefinitely - if your process takes longer than five seconds .waitFor() will not stop it", "label": {"api": {"Process.waitFor()": [[8, 24]]}}}, {"text": "However .waitFor() is overloaded and its sibling takes a timeout argument", "label": {"api": {"sibling": [[41, 47]]}}}, {"text": "You can use this in tandem with Process.destroy() to stop the process if it takes too long", "label": {"api": {"Process.destroy()": [[32, 48]]}}}, {"text": "This relies on the fact that Process.destroy() is a no-op when called on an already-finished subprocess", "label": {"api": {"Process.destroy()": [[29, 45]]}}}, {"text": "What about Process.destroyForcibly()", "label": {"api": {"Process.destroyForcibly()": [[11, 35]]}}}, {"text": "The document says that the data will be in single byte array, so it exceeds the limit", "label": {"api": {"The document": [[0, 11]]}}}, {"text": "The @Path annotation in a class designates a root resource", "label": {"api": {"@Path": [[4, 8]]}}}, {"text": "The @Path annotation in a method designates a sub-resource of a root resource", "label": {"api": {"@Path": [[4, 8]]}}}, {"text": "When placed on methods, the @Path annotation does not override the @Path annotation of the class", "label": {"api": {"@Path": [[28, 32], [67, 71]]}}}, {"text": "JAX-RS/Jersey performs a hierarchical matching using the @Path annotations", "label": {"api": {"@Path": [[57, 61]]}}}, {"text": "Use the empty pseudo class (see Cell CSS reference) to set the background color of those rows from css", "label": {"api": {"Cell CSS reference": [[32, 49]]}}}, {"text": "You're looking for Normalizer in java.text.Normalizer", "label": {"api": {"Normalizer": [[19, 28], [43, 52]]}}}, {"text": "You need to store the value returned by next() into some variable, like so", "label": {"api": {"next()": [[40, 45]]}}}, {"text": "I think you're filling you're array with nextDouble() which as documented gives you double precision floating point numbers between 0 and 1", "label": {"api": {"documented": [[63, 72]]}}}, {"text": "Read some characters into a fixed sized buffer with Reader.read() and then scan the buffer", "label": {"api": {"Reader.read()": [[52, 64]]}}}, {"text": "You can make use of LineNumberReader", "label": {"api": {"LineNumberReader": [[20, 35]]}}}, {"text": "You can convert your Iterable to a Stream by accessing the Spliterator, by using StreamSupport.stream", "label": {"api": {"StreamSupport.stream": [[81, 100]]}}}, {"text": "I used a UUID rather than int for the client id", "label": {"api": {"UUID": [[9, 12]]}}}, {"text": "You can use arraylist ArrayList<TeamMember> as an instance variable of TeamMembers for your Teams or a collection with primitive types for the team but I think best is if you make classes for Team, TeamMember and Score that you instanciate in your Bowling class", "label": {"api": {"arraylist": [[12, 20]]}}}, {"text": "A slightly more readable approach is to replace your FileWriter with a Formatter", "label": {"api": {"Formatter": [[71, 79]]}}}, {"text": "Check the official documentation for more", "label": {"api": {"official documentation": [[10, 31]]}}}, {"text": "If you don't have to implement the algorithm exactly like the pseudo-code, I would suggest you use a List class like the ArrayList", "label": {"api": {"ArrayList": [[121, 129]]}}}, {"text": "The ArrayList class has a lot of useful functions that would make your code easier", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "If you have to use an array I suggest you take a look at the arraycopy method to replace your original array, as you cannot resize an array in Java", "label": {"api": {"arraycopy": [[61, 69]]}}}, {"text": "Quote from JavaDoc of Stream class", "label": {"api": {"JavaDoc of Stream": [[11, 27]]}}}, {"text": "Take a look at the API here", "label": {"api": {"API here": [[19, 26]]}}}, {"text": "If you're using JavaSE, maybe a Timer can help you", "label": {"api": {"Timer": [[32, 36]]}}}, {"text": "You can also omit the ^ and $ and use String.matches()", "label": {"api": {"String.matches()": [[38, 53]]}}}, {"text": "For example, what if I want to color negative value in red in TableView cells", "label": {"api": {"TableView": [[62, 70]]}}}, {"text": "I would not code color directly, but assigned some class to a cell, like \"negative\" and later would color it into red with CSS", "label": {"api": {"code color directly": [[12, 30]]}}}, {"text": "Try the great oracle documentation", "label": {"api": {"oracle documentation": [[14, 33]]}}}, {"text": "List's remove method makes this easy to only draw each once", "label": {"api": {"remove": [[7, 12]]}}}, {"text": "A regular Java object implementing the MBeanServer interface", "label": {"api": {"MBeanServer": [[39, 49]]}}}, {"text": "You can use ServletContextListener", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "Override the LogManager.readConfiguration(InputStream) to capture the bytes from the stream and create your own Properties object from the stream", "label": {"api": {"LogManager.readConfiguration(InputStream)": [[13, 53]]}}}, {"text": "The easy way to read the properties file is by using the java.util.Properties class", "label": {"api": {"java.util.Properties": [[57, 76]]}}}, {"text": "JavaFX uses an Image to load the image file and it has a node called ImageView to place that image on the screen graph", "label": {"api": {"Image": [[15, 19], [69, 73]], "ImageView": [[69, 77]]}}}, {"text": "You can use the Timer Class to achieve a automatically increase of your resources", "label": {"api": {"Timer": [[16, 20]]}}}, {"text": "How to use Timer class to call a method, do something, reset timer, repeat", "label": {"api": {"Timer": [[11, 15]]}}}, {"text": "For runtime annotations, you can try to debug the application and set breakpoints on Class methods like getAnnotation, getDeclaredAnnotations etc", "label": {"api": {"getAnnotation": [[104, 116]], "getDeclaredAnnotations": [[119, 140]]}}}, {"text": "only stop at the breakpoint if the parameter of getAnnotation has the right type", "label": {"api": {"getAnnotation": [[48, 60]]}}}, {"text": "Check the javadoc for more details", "label": {"api": {"details": [[27, 33]]}}}, {"text": "I tried to search the Java standard library for an Oval, but there isn't one, so it looks like you made this on your own", "label": {"api": {"but there isn't one": [[57, 75]]}}}, {"text": "Run separate SELECT statement for each name, but batch them", "label": {"api": {"batch them": [[49, 58]]}}}, {"text": "Use the subclass of BufferedReader called LineNumberReader in order to get the getLineNumber() method", "label": {"api": {"BufferedReader": [[20, 33]], "LineNumberReader": [[42, 57]], "getLineNumber()": [[79, 93]]}}}, {"text": "Anyway, your main problem is that reverse()", "label": {"api": {"reverse()": [[34, 42]]}}}, {"text": "So, your first call to reverse() makes the stringBuilder have the value rot, which is also the value assigned to the reverse variable", "label": {"api": {"reverse()": [[23, 31]]}}}, {"text": "Your second call to reverse() in the print statement reverse it back to the value tor, which is then the value printed", "label": {"api": {"reverse()": [[20, 28]]}}}, {"text": "The method above creates a sequence of all letters A through Z, and then applies random shuffle to it (demo)", "label": {"api": {"random shuffle": [[81, 94]]}}}, {"text": "I think the most proper way to do it, just use the following construction with SecureRandom", "label": {"api": {"SecureRandom": [[79, 90]]}}}, {"text": "AtomicInteger -- which makes sure that the integer is incremented or decremented safely across threads", "label": {"api": {"AtomicInteger": [[0, 12]]}}}, {"text": "Using AtomicInteger the process is much easier to control", "label": {"api": {"AtomicInteger": [[6, 18]]}}}, {"text": "If I understand the problem correctly, you could use a DocumentFilter for this, and only allow the text to be inserted if let's say the delay of the keypress is above 0.5 seconds", "label": {"api": {"DocumentFilter": [[55, 68]]}}}, {"text": "Simply use an Iterator instead to cycle your ArrayList", "label": {"api": {"Iterator": [[14, 21]]}}}, {"text": "Iterator uses the methods add(T element) and remove(T element)", "label": {"api": {"Iterator": [[0, 7]]}}}, {"text": "See also documentation on List and ArrayList", "label": {"api": {"List": [[26, 29], [40, 43]], "ArrayList": [[35, 43]]}}}, {"text": "If your methods required arguments (or returned something), then you could either use the appropriate functional interface, or \"pin\" your method arguments to the particular invovation at the call site", "label": {"api": {"functional interface": [[102, 121]]}}}, {"text": "Runtime.exec does not take an array of commands to run", "label": {"api": {"Runtime.exec": [[0, 11]]}}}, {"text": "But that functionality is part of the shell, not the underlying OS; Runtime.exec talks to the OS, so you need to do that splitting yourself", "label": {"api": {"Runtime.exec": [[68, 79]]}}}, {"text": "Sorting and Filtering, use a RowFilter to \"to filter out entries from the model so that they are not shown in the view.\" To match \"G\" exactly in column zero, your filter might look like this", "label": {"api": {"RowFilter": [[29, 37]]}}}, {"text": "Class.getResourceAsStream tries to load an element in the classpath", "label": {"api": {"Class.getResourceAsStream": [[0, 24]]}}}, {"text": "To load a file outside of the classpath, use a FileInputStream instead", "label": {"api": {"FileInputStream": [[47, 61]]}}}, {"text": "Or use the Image(String) constructor and pass the URL of the file", "label": {"api": {"Image(String) constructor": [[11, 35]]}}}, {"text": "As fabian mentioned, Class.getResourceAsStream(...) loads an InputStream from the classpath, (meaning, from the jar file itself)", "label": {"api": {"Class.getResourceAsStream(...)": [[21, 50]]}}}, {"text": "in your error is because Class.getResourceAsStream(...) simply returns null when it can't find the resource that you tell it to look for", "label": {"api": {"Class.getResourceAsStream(...)": [[25, 54]]}}}, {"text": "TimeUnit available since JDK 1.5 is extremely useful to convert durations between time units, like", "label": {"api": {"TimeUnit": [[0, 7]]}}}, {"text": "In Properties files you must escape = and", "label": {"api": {"Properties": [[3, 12]]}}}, {"text": "If you want to remove it only from the end of the string, you can use String#replaceAll", "label": {"api": {"String#replaceAll": [[70, 86]]}}}, {"text": "Please visit the String API to discover many useful methods that will help you", "label": {"api": {"String API": [[17, 26]]}}}, {"text": "If you want to know the size of an RSA cipher text, examine the modulus of the key to be used", "label": {"api": {"examine the modulus": [[52, 70]]}}}, {"text": "You want to use the Document property of WebEngine", "label": {"api": {"Document property": [[20, 36]]}}}, {"text": "You could add a listener to the selected property and change the background on a change, however it would be much easier to do this using a CSS stylesheet containing the following rule (assuming you've assigned the list-view-id id to the ListView)", "label": {"api": {"the selected property": [[28, 48]]}}}, {"text": "Then the FXMLLoader may be used to load your javaFx Node from *.fxml and to inject all @FXML annotated fields into instance of your UI controller", "label": {"api": {"FXMLLoader": [[9, 18]]}}}, {"text": "Yes, using Collection#removeIf(Predicate)", "label": {"api": {"Collection#removeIf(Predicate)": [[11, 40]]}}}, {"text": "Take a look at https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html and related classes", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html": [[15, 81]]}}}, {"text": "Something like the @PostConstruct annotation can be used", "label": {"api": {"@PostConstruct": [[19, 32]]}}}, {"text": "Should I simply use URLEncoder.html#encode or is there more to it", "label": {"api": {"URLEncoder.html#encode": [[20, 41]]}}}, {"text": "You can use computeIfPresent for this", "label": {"api": {"computeIfPresent": [[12, 27]]}}}, {"text": "computeIfPresent applies the BiFunction to the key and the current value in the map if the value is not null (if it is null computeIfPresent returns null immediately) and then either sets the value to the return value of the BiFunction if the return value is not null or removes the key from the map if the return value is null and finally returns the new value", "label": {"api": {"computeIfPresent": [[0, 15], [124, 139]]}}}, {"text": "Would setting java.io.tmpdir with setProperty or passing java.io.tmpdir via -D switch, e.g", "label": {"api": {"setProperty": [[34, 44]]}}}, {"text": "There is also KeyEvent.VK_TAB which might be preferable depending on your use case", "label": {"api": {"KeyEvent.VK_TAB": [[14, 28]]}}}, {"text": "Another approach would be to use java's built in EventListenerList class https://docs.oracle.com/javase/8/docs/api/index.html?javax/swing/event/EventListenerList.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/index.html?javax/swing/event/EventListenerList.html": [[73, 165]]}}}, {"text": "I think a Queue would be better for your purpose", "label": {"api": {"Queue": [[10, 14]]}}}, {"text": "Is there a reason behind the design of the get method of the class", "label": {"api": {"get": [[43, 45]]}}}, {"text": "The getters and setters on the SNMPInterface class that you use for input to PropertyValueFactory should be marked public, not no modifier (otherwise the reflection logic inherent in the PropertyValueFactory won't find them)", "label": {"api": {"PropertyValueFactory": [[77, 96], [187, 206]]}}}, {"text": "(see https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html for formatting details)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html": [[5, 85]]}}}, {"text": "Use the graphics context's FontMetrics", "label": {"api": {"FontMetrics": [[27, 37]]}}}, {"text": "Use invokeAll API from ExecutorService to process all your tasks", "label": {"api": {"invokeAll": [[4, 12]]}}}, {"text": "Have a look at Timer", "label": {"api": {"Timer": [[15, 19]]}}}, {"text": "If you check the documentation https://docs.oracle.com/javase/7/docs/api/java/io/BufferedWriter.html you will see the following", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/BufferedWriter.html": [[31, 99]]}}}, {"text": "Why not use java.util.Currency", "label": {"api": {"java.util.Currency": [[12, 29]]}}}, {"text": "Also for efficiency reasons we're using StAX parsing (XMLStreamReader) when generating XLSX files as opposed to the broadly more memory-hungry DOM Parser method we use for XLS generation", "label": {"api": {"XMLStreamReader": [[54, 68]]}}}, {"text": "Rather than updating the UI directly use the Platform.runLater(Runnable) to schedule the UI tasks on the main JavaFX thread", "label": {"api": {"Platform.runLater(Runnable)": [[45, 71]]}}}, {"text": "They have been supplanted in Java 8 and later by the java.time framework", "label": {"api": {"java.time": [[53, 61]]}}}, {"text": "An Instant represents a moment on the timeline in UTC with a resolution of up to nanoseconds", "label": {"api": {"Instant": [[3, 9]]}}}, {"text": "In Java 8 the current moment is captured up to a resolution of only milliseconds, but a new implementation of Clock in Java 9 will capture up to nanoseconds depending on your computers clock hardware capability", "label": {"api": {"Clock": [[110, 114]]}}}, {"text": "A Duration captures a span of time as a total number of whole seconds and a fraction of a second as nanoseconds", "label": {"api": {"Duration": [[2, 9]]}}}, {"text": "The java.time classes use the ISO 8601 standard when generating a textual representation of a date-time value", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "But if you so desire you can interrogate the Duration for the numbers", "label": {"api": {"Duration": [[45, 52]]}}}, {"text": "If you want to use an HTML file as the content of your message, you can ues setDataHandler", "label": {"api": {"setDataHandler": [[76, 89]]}}}, {"text": "You can avoid this by attaching each image, and modifying the HTML to point to each image's Content-Id as explained in RFC 2392, though it will make the message itself larger", "label": {"api": {"Content-Id": [[92, 101]]}}}, {"text": "To get access to that instance, you need to create a FXMLLoader instance and use getController() after loading the fxml", "label": {"api": {"getController()": [[81, 95]]}}}, {"text": "Use Desktop system integration", "label": {"api": {"Desktop": [[4, 10]]}}}, {"text": "If you want to give them larger internal margins, set their -fx-label-padding CSS properties", "label": {"api": {"-fx-label-padding": [[60, 76]]}}}, {"text": "The list of URI constructors shows that there is no URI constructor which takes two Strings", "label": {"api": {"list of URI constructors": [[4, 27]]}}}, {"text": "In Java, all arrays extend Object and inherit the default toString method of Object", "label": {"api": {"default toString method of Object": [[50, 82]]}}}, {"text": "As of Java 8, you can simply join your addresses with String.join", "label": {"api": {"String.join": [[54, 64]]}}}, {"text": "You also don't need to call bs.clear(i), since a new BitSet doesn't have any bits set", "label": {"api": {"BitSet": [[53, 58]]}}}, {"text": "As for how BitSet.valueOf() works, it's fairly simple", "label": {"api": {"BitSet": [[11, 16]]}}}, {"text": "The BitSet will then be built with the first N (8 or 64) bits from the first value, the next N bits from the second value, and so forth", "label": {"api": {"BitSet": [[4, 9]]}}}, {"text": "if you call BitSet.valueOf(new long[] { 1, 2, 3 }), bits 0-63 come from first number, bits 64-127 comes from second number, and bits 128-191 comes from third number, resulting in {0, 65, 128, 129}", "label": {"api": {"BitSet": [[12, 17]]}}}, {"text": "If you call BitSet.valueOf(new byte[] { 1, 2, 3 }), bits 0-7 come from first number, bits 8-15 comes from second number, and bits 16-23 comes from third number, resulting in {0, 9, 16, 17}", "label": {"api": {"BitSet": [[12, 17]]}}}, {"text": "In older versions of Java, you can use DatatypeConverter", "label": {"api": {"DatatypeConverter": [[39, 55]]}}}, {"text": "Use an ObservableMap with a listener that keeps the TableView items and the keys of the map the same and use the cellValueFactory with Bindings.valueAt, e.g.", "label": {"api": {"Bindings.valueAt": [[135, 150]]}}}, {"text": "But if you have Java 8, you can use Optional to do something similar", "label": {"api": {"Optional": [[36, 43]]}}}, {"text": "When you load from a stream, FXMLLoader does not know how to resolve relative paths because there is no concept of a relative location in relation to a stream", "label": {"api": {"load": [[9, 12]]}}}, {"text": "Instead, in your FXMLManager load the FXML from a URL location that you already set on the FXMLLoader instance", "label": {"api": {"load": [[29, 32]], "URL location that you already set on the FXMLLoader instance": [[50, 109]]}}}, {"text": "In addition to the different look and behavior as pointed out by Jan's answer, the window ownership hierarchy effects window modality", "label": {"api": {"window modality": [[118, 132]]}}}, {"text": "You can use XMLStreamWriter to avoid creating the full XML in memory, streaming it out directly instead", "label": {"api": {"XMLStreamWriter": [[12, 26]]}}}, {"text": "You have to create a custom FileFilter class that have information about the current users and will modify the files shown based on the user info", "label": {"api": {"FileFilter": [[28, 37]]}}}, {"text": "I need to find the first day of the last week of a year using Java 8 Date and Time API (java.time) and finally came to this solution", "label": {"api": {"java.time": [[88, 96]]}}}, {"text": "The Files.size() declares an IOException", "label": {"api": {"Files.size()": [[4, 15]]}}}, {"text": "Which other exceptions might be thrown, other than FileNotFoundException", "label": {"api": {"FileNotFoundException": [[51, 71]]}}}, {"text": "Use RowFilter.andFilter() to allow multiple filter be applied to a single JTable with an AND logic (only if both filters are true, the item will show up) (there is also an OR, NOT,...)", "label": {"api": {"RowFilter.andFilter()": [[4, 24]]}}}, {"text": "Then you can try b1.clone()", "label": {"api": {"clone()": [[20, 26]]}}}, {"text": "In your case it will be p.add(b1.clone());", "label": {"api": {"clone()": [[33, 39]]}}}, {"text": "clone() can create a shallow copy of your object, see clone()", "label": {"api": {"clone()": [[0, 6], [54, 60]]}}}, {"text": "You can use Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[12, 29]]}}}, {"text": "changed the code to use a scanner, and scanner.next() to get one character at a time", "label": {"api": {"scanner.next()": [[39, 52]]}}}, {"text": "You are calling the new Date(String s) constructor", "label": {"api": {"new Date(String s)": [[20, 37]]}}}, {"text": "This includes the new Date(String s) call that you shouldn't be using anyway", "label": {"api": {"new Date(String s)": [[18, 35]]}}}, {"text": "If you want a ten decimal place internal representation, you should be using BigDecimal with scale factor 10", "label": {"api": {"BigDecimal": [[77, 86]]}}}, {"text": "Use AtomicInteger instead of int, or perform the critical work under synchronization", "label": {"api": {"AtomicInteger": [[4, 16]]}}}, {"text": "The appearance of a JTable is controlled by its UI delegate, typically a subclass of TableUI", "label": {"api": {"TableUI": [[85, 91]]}}}, {"text": "If you want to wait on the main execution line for the pool to be terminated you can use awaitTermination", "label": {"api": {"awaitTermination": [[89, 104]]}}}, {"text": "As it says in the Javadoc", "label": {"api": {"in the Javadoc": [[11, 24]]}}}, {"text": "[\\p{Alpha}\\p{Digit}] (see Java regex reference)", "label": {"api": {"Java regex reference": [[26, 45]]}}}, {"text": "If you want the boolean value of a string, use Boolean.parseBoolean(String) (if you want a boolean) or Boolean.valueOf(String) (if you want a Boolean)", "label": {"api": {"Boolean.parseBoolean(String)": [[47, 74]], "Boolean.valueOf(String)": [[103, 125]]}}}, {"text": "Here is how to proceed with pure Java 8 using a DateTimeFormatter to parse the dates", "label": {"api": {"DateTimeFormatter": [[48, 64]]}}}, {"text": "One option is to run the application as a separate process, launching the process when you want to create the application and exiting the process when the application is no longer needed (so completing a full application lifecycle)", "label": {"api": {"application lifecycle": [[209, 229]]}}}, {"text": "Some example routes you could look at are the ProcessBuilder, which is admittedly a pretty finicky and horrible API or the new Process API updates that will be available with Java 9", "label": {"api": {"ProcessBuilder": [[46, 59]]}}}, {"text": "Instead I'd recommend to use the Java Compiler API, which provides the java-way of compiling source without invoking the commandline", "label": {"api": {"Java Compiler API": [[33, 49]]}}}, {"text": "I think you need to use BiPredicate as a parameter", "label": {"api": {"BiPredicate": [[24, 34]]}}}, {"text": "Don't use DataOutputStream to write a text file", "label": {"api": {"DataOutputStream": [[10, 25]]}}}, {"text": "Use a Writer", "label": {"api": {"Writer": [[6, 11]]}}}, {"text": "Javadoc of DataOutputStream says", "label": {"api": {"DataOutputStream": [[11, 26]]}}}, {"text": "A DataOutputStream lets an application write primitive Java data types to an output stream in a portable way", "label": {"api": {"DataOutputStream": [[2, 17]]}}}, {"text": "An application can then use a DataInputStream to read the data back in", "label": {"api": {"DataInputStream": [[30, 44]]}}}, {"text": "A Writer however", "label": {"api": {"Writer": [[2, 7]]}}}, {"text": "To help print newlines, use a PrintWriter", "label": {"api": {"Writer": [[35, 40]], "PrintWriter": [[30, 40]]}}}, {"text": "Then the println() method will write the correct line terminator for you", "label": {"api": {"println()": [[9, 17]]}}}, {"text": "You can so use the formatting version, printf()", "label": {"api": {"printf()": [[39, 46]]}}}, {"text": "In the example below, each combo gets its own instance of a single renderer that implements the strategy pattern, passing a Function<Person, String> that selects the correct attribute when the renderer is called", "label": {"api": {"Function<Person, String>": [[124, 147]]}}}, {"text": "Check the link", "label": {"api": {"link": [[10, 13]]}}}, {"text": "The correct way to check this, however, is with the equals method, which tests whether two objects have the same value", "label": {"api": {"equals": [[52, 57]]}}}, {"text": "Yes, you must use LinkedHashMap which has a stable iteration order even across Java versions, as enforced by its contract", "label": {"api": {"contract": [[113, 120]]}}}, {"text": "Applications can make text available on the clipboard in multiple formats, for the benefit of consumers that may or may not support the richest representation", "label": {"api": {"clipboard": [[44, 52]]}}}, {"text": "To be more precise, I'm looking for a way to enumerate and then fetch the contents of the clipboard when it contains rich text in different formats, e.g", "label": {"api": {"clipboard": [[90, 98]]}}}, {"text": "I won't be dealing with exotic types like collections of files moved via the clipboard", "label": {"api": {"clipboard": [[77, 85]]}}}, {"text": "I've browsed around the clipboard-related features of the java awt toolkit, but they seem to be organized around specific \"flavors\" (formats) that the consumer is able to use-- not around what's available", "label": {"api": {"clipboard": [[24, 32]]}}}, {"text": "Parsing a multipart MIME message is an order of magnitude easier if you use a JavaMail implementation, as you can make use of its MimeMultipart class, and its related classes", "label": {"api": {"MimeMultipart": [[130, 142]]}}}, {"text": "Let ClientManager contain a ListModel<Client> that is updated with each added Client", "label": {"api": {"ListModel<Client>": [[28, 44]]}}}, {"text": "The exact details depend on context, but the ListModel<Client> must be updated on the event dispatch thread", "label": {"api": {"ListModel<Client>": [[45, 61]]}}}, {"text": "First, you should use the Random class, not Math.random()", "label": {"api": {"Random": [[26, 31]], "Math.random()": [[44, 56]]}}}, {"text": "For one, it has the nice helper method nextInt(int n) that generates a random integer between 0 and n-1 (inclusive)", "label": {"api": {"nextInt(int n)": [[39, 52]]}}}, {"text": "Notice the +1, since the method is like Random.nextInt(n) and returns a number 0 to n-1, where n is the number of weights given", "label": {"api": {"Random": [[40, 45]]}}}, {"text": "You could easily turn it into a nice class, where the weights are given on the constructor, and the class manages the Random object for you", "label": {"api": {"Random": [[118, 123]]}}}, {"text": "If you call Class.getResourceAsStream() on the class com.example.SomeClass, then the path is evaluated relatively to SomeClass if it does not start with a /, so file.png becomes /com/example/file.png and com/example/file.png becomes /com/example/com/example/file.png", "label": {"api": {"Class.getResourceAsStream()": [[12, 38]]}}}, {"text": "If you call ClassLoader.getResourceAsStream() on its ClassLoader, then the path is implicitly absolute and must not start with a /, so file.png becomes /file.png and com/example/file.png becomes /com/example/file.png", "label": {"api": {"ClassLoader.getResourceAsStream()": [[12, 44]]}}}, {"text": "Unfortunately this implicit absoluteness of ClassLoader.getResourceAsStream() is only documented implicitly in the documentation of Class.getResourceAsStream(), which states that it strips the leading slash before it delegates to its ClassLoaders method", "label": {"api": {"Class.getResourceAsStream()": [[132, 158]], "ClassLoader.getResourceAsStream()": [[44, 76]]}}}, {"text": "Java 8 provides a better way, using IntStream#average()", "label": {"api": {"IntStream#average()": [[36, 54]]}}}, {"text": "You can use Matcher#appendReplacement to modify your string while matching", "label": {"api": {"Matcher#appendReplacement": [[12, 36]]}}}, {"text": "If you are on Java 8 you can use removeIf from Collection", "label": {"api": {"Collection": [[47, 56]]}}}, {"text": "If you prefer to not change the listItems, and only get a new list without the wrong items, you can use stream filtering", "label": {"api": {"stream filtering": [[104, 119]]}}}, {"text": "A ClassLoader is able to load classes (i.e", "label": {"api": {"ClassLoader": [[2, 12]]}}}, {"text": "You may question the two by calling HttpsURLConnectionImpl.class.getClassLoader().toString() and HttpsURLConnection.class.getClassLoader().toString()", "label": {"api": {"ClassLoader": [[68, 78], [125, 135]]}}}, {"text": "The next best thing may be using FileChannel.transferTo or transferFrom methods", "label": {"api": {"FileChannel.transferTo or transferFrom": [[33, 70]]}}}, {"text": "Check out the java.util.ServiceLoader documentation for an example of how to implement it", "label": {"api": {"java.util.ServiceLoader": [[14, 36]]}}}, {"text": "However, to get String.join(CharSequence delimiter, Iterable<", "label": {"api": {"CharSequence": [[28, 39]]}}}, {"text": "extends CharSequence> elements) to work, merely having a toString() method is not enough", "label": {"api": {"CharSequence": [[8, 19]]}}}, {"text": "extends CharSequence>, which means Foo should implement CharSequence", "label": {"api": {"CharSequence": [[8, 19], [56, 67]]}}}, {"text": "The most direct way would be to use a ReentrantLock`", "label": {"api": {"ReentrantLock": [[38, 50]]}}}, {"text": "If you want to get both key and value, use floorEntry()", "label": {"api": {"floorEntry()": [[43, 54]]}}}, {"text": "You can use a ScheduledExecutorService and schedule the reset of the counter after a certain timeout", "label": {"api": {"ScheduledExecutorService": [[14, 37]]}}}, {"text": "Something like this, using Arrays.fill(char[], char)", "label": {"api": {"Arrays.fill(char[], char)": [[27, 51]]}}}, {"text": "use Semaphores or other thread communication mechanisms", "label": {"api": {"Semaphores": [[4, 13]]}}}, {"text": "This does not directly answer your question, but in java 8, there are methods on Comparator to simply creating compound Camparator implementations", "label": {"api": {"Comparator": [[81, 90]]}}}, {"text": "Or you can follow suggestion by Jon Skeet and use indexOf()", "label": {"api": {"indexOf()": [[50, 58]]}}}, {"text": "If you need an arbitrarily-long integer type, you can use BigInteger, but this is a reference type, and has no \"convenient\" operators like +", "label": {"api": {"BigInteger": [[58, 67]]}}}, {"text": "Decoding is easy using java.util.Base64 (Java SE 8+)", "label": {"api": {"java.util.Base64": [[23, 38]]}}}, {"text": "The javax.comm.CommPort API says this", "label": {"api": {"javax.comm.CommPort API says this": [[4, 36]]}}}, {"text": "If your target JAR is inside another JAR, you can use a LoaderClassPath created using a URLClassLoader which is defined using a JarURLConnection URL path of the JAR", "label": {"api": {"URLClassLoader": [[88, 101]], "JarURLConnection": [[128, 143]]}}}, {"text": "By passing an URL to the load method, you use one of the static load methods of FXMLLoader, which of course cannot store the controller in your FXMLLoader instance since there is no information about the instance available", "label": {"api": {"FXMLLoader": [[80, 89], [144, 153]]}}}, {"text": "Since you already specify the URL in the FXMLLoader constructor, simply use the parameterless load method instead", "label": {"api": {"FXMLLoader": [[41, 50]]}}}, {"text": "Here's one solution on how to call dice using Timer and TimerTask", "label": {"api": {"Timer": [[46, 50], [56, 60]], "TimerTask": [[56, 64]]}}}, {"text": "Also note that your program will never complete, unless you make the secondary thread a daemon thread", "label": {"api": {"daemon thread": [[88, 100]]}}}, {"text": "I search though the functions and Google but I saw nothing interesting", "label": {"api": {"functions": [[20, 28]]}}}, {"text": "According to JavaDoc, File#createNewFile does not throw an exception but just returns false", "label": {"api": {"According to JavaDoc": [[0, 19]]}}}, {"text": "If you are on a recent Java version, you should use Files#createFile instead (which will throw the exception)", "label": {"api": {"Files#createFile": [[52, 67]]}}}, {"text": "As already pointed out, Runnable is an interface containing just one method, run(), abstract as you pointed out", "label": {"api": {"Runnable": [[24, 31]], "run()": [[77, 81]]}}}, {"text": "Class A must be either declared abstract or implement abstract method 'run()' in 'Runnable', so as pointed by the error message you can choose to implement the method", "label": {"api": {"Runnable": [[82, 89]], "run()": [[71, 75]]}}}, {"text": "According to the specification, if szRead is negative (for example, if the file is at EOF when calling read()), it will throw an exception, so you could do either", "label": {"api": {"the specification": [[13, 29]]}}}, {"text": "What about using IntStream.range", "label": {"api": {"IntStream.range": [[17, 31]]}}}, {"text": "According to the official documentation for the Java Hashtable class (https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html), the get() opperation will return one of it's recorded values, if said value has a key that returns true when the parameter is fed into that key's equals() opperation", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html": [[70, 135]]}}}, {"text": "Here is the general contract of the hashCode() method you must consider while implementing it", "label": {"api": {"Here is the general contract": [[0, 27]]}}}, {"text": "I would not recommend this unless you know what you're doing but you could use a URLClassLoader as follows", "label": {"api": {"URLClassLoader": [[81, 94]]}}}, {"text": "I would like to shorten this code using Java 8 methods like computeIfAbsent", "label": {"api": {"computeIfAbsent": [[60, 74]]}}}, {"text": "You can take advantage of the fact that the add(element) method will return true if the set didn't contain the specified element", "label": {"api": {"add(element)": [[44, 55]]}}}, {"text": "but in the official JavaDocs this line was removed", "label": {"api": {"official JavaDocs": [[11, 27]]}}}, {"text": "The Package java.util.stream doc in the Side-effects paragraph states", "label": {"api": {"Package java.util.stream doc": [[4, 31]]}}}, {"text": "On the other hand, it also states in the Ordering section", "label": {"api": {"Ordering": [[41, 48]]}}}, {"text": "I often use Date.parse(String) to parse a date in an unknown format", "label": {"api": {"Date.parse(String)": [[12, 29]]}}}, {"text": "However, there's no static parse method in DateFormat, just an instance method, which requires a DateFormat object, which I won't have for an unknown date format", "label": {"api": {"an instance method": [[60, 77]]}}}, {"text": "SimpleDateFormat or Calendar objects are preferred", "label": {"api": {"SimpleDateFormat": [[0, 15]], "Calendar": [[20, 27]]}}}, {"text": "Collection.toArray() returns Object[]", "label": {"api": {"Collection.toArray()": [[0, 19]]}}}, {"text": "You need to use Collection.toArray(T[]) to get an array of your specific object type", "label": {"api": {"Collection.toArray(T[])": [[16, 38]]}}}, {"text": "According to the Consumer javadoc, a consumer must be declared with a method having the signature void accept(T)", "label": {"api": {"Consumer javadoc": [[17, 32]]}}}, {"text": "Use the java.util.Random class to generate random numbers like so", "label": {"api": {"java.util.Random": [[8, 23]]}}}, {"text": "setEnabled(boolean) is a void method, that means it returns nothing, But when checking if() you need to pass Boolean inside", "label": {"api": {"setEnabled(boolean)": [[0, 18]]}}}, {"text": "Amongst others, you could use MD5, SHA-1 and SHA256 in standard Java, as described in the Oracle documentation", "label": {"api": {"Oracle documentation": [[90, 109]]}}}, {"text": "The @Override annotation means that the method must override a method from a parent class/interface", "label": {"api": {"@Override": [[4, 12]]}}}, {"text": "Because of the way Point implements equals(Object), if you have clicked exactly the same point, indexOf will return the index of the first matching Point, not the second (or subsequent) occurrence", "label": {"api": {"Point implements equals(Object)": [[19, 49]]}}}, {"text": "Use the Java Scripting API", "label": {"api": {"Java Scripting API": [[8, 25]]}}}, {"text": "Likewise, PathIterator.currentSegment says \"SEG_CLOSE does not return any points\" (since closePath() was not called with any points)", "label": {"api": {"PathIterator.currentSegment": [[10, 36]]}}}, {"text": "Note that you could use a PrintWriter instead, which has println methods to take care of new lines", "label": {"api": {"PrintWriter": [[26, 36]]}}}, {"text": "What is the Difference between PrintWriter and DataOutputStream", "label": {"api": {"PrintWriter": [[31, 41]]}}}, {"text": "Take a look at the Scanner class", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "One method for doing this would be to use java's Set interface; read each line as a string, add it to the set, then do a removeAll() with the second set on the first set, thus retaining the rows which differ", "label": {"api": {"Set": [[49, 51]], "removeAll()": [[121, 131]]}}}, {"text": "Make an actual HashMap instead of a HashSet as above, use the PK as the key and the row as the value", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "A Clip implements javax.sound.sampled.Line interface, so we can use Line.addLineListener(LineListener).", "label": {"api": {"Line.addLineListener(LineListener)": [[68, 101]]}}}, {"text": "floorDiv() from Java.Math that does exactly what you want", "label": {"api": {"floorDiv()": [[0, 9]]}}}, {"text": "-1), you should probably go with whatever Math.pow() returns and then test it with Double.isFinite() to make sure it's valid", "label": {"api": {"Double.isFinite()": [[83, 99]]}}}, {"text": "may be a Semaphore can help you..", "label": {"api": {"Semaphore": [[9, 17]]}}}, {"text": "A java's aproach to Spinlocks and Oracle documentation of semaphores", "label": {"api": {"Oracle documentation of semaphores": [[34, 67]]}}}, {"text": "I initially attempted to parse using a SimpleDateFormat specifying the three digits of milliseconds that I wanted to parse", "label": {"api": {"SimpleDateFormat": [[39, 54]]}}}, {"text": "I can't find anything in the SimpleDateFormat javadoc that clearly explains what's going on at the end of this parsing", "label": {"api": {"SimpleDateFormat": [[29, 44]]}}}, {"text": "Other than truncating the string like I did, is there any other way of telling the SimpleDateFormat to stop parsing the string at the indicated position", "label": {"api": {"SimpleDateFormat": [[83, 98]]}}}, {"text": "Some instructions on addressing can be found in the api for Class", "label": {"api": {"Class": [[60, 64]]}}}, {"text": "Over a socket connection, use an ObjectOutputStream to write the object directly to the stream, and use an ObjectInputStream to deserialize at the other end", "label": {"api": {"ObjectOutputStream": [[33, 50]], "ObjectInputStream": [[107, 123]]}}}, {"text": "All primitives and arrays of primitives are serializable this way (as is anything that implements @Serializable)", "label": {"api": {"@Serializable": [[98, 110]]}}}, {"text": "What you need to do is make a Property class that holds other Property classes, and it sounds like what you could use for it is called a Map", "label": {"api": {"Map": [[137, 139]]}}}, {"text": "The following implementation is provided in the documentation for ModifiableObservableListBase (slightly modified)", "label": {"api": {"ModifiableObservableListBase": [[66, 93]]}}}, {"text": "What about writing x.nextLine()", "label": {"api": {"x.nextLine()": [[19, 30]]}}}, {"text": "Start with this.getClass() which returns a java.lang.Class object", "label": {"api": {"java.lang.Class": [[43, 57]]}}}, {"text": "Get the class's Field descriptions with getFields()", "label": {"api": {"Field": [[16, 20], [43, 47]]}}}, {"text": "Since you're using @AutoValue you can assume a create() method on your class (which you can also discover with reflection), but I'm not sure you can reliably discover the order of the parameters to this method, because reflection Method will give you the parameter types in the correct order, but not their names", "label": {"api": {"Method": [[230, 235]]}}}, {"text": "I'm looking at HttpURLConnection, existing since JDK 1.1, 1997 (almost 20 years now), and I'm quite astonished that it's still Java core's official way to create HTTP connections", "label": {"api": {"HttpURLConnection": [[15, 31]]}}}, {"text": "As far as I could found, no wrapper of HttpURLConnection was added to the JDK", "label": {"api": {"HttpURLConnection": [[39, 55]]}}}, {"text": "Is HttpURLConnection still Java core's official way to create an HTTP connection", "label": {"api": {"HttpURLConnection": [[3, 19]]}}}, {"text": "The old HttpURLConnection is currently the standard way to perform HTTP requests in Java SE", "label": {"api": {"HttpURLConnection": [[8, 24]]}}}, {"text": "Java EE 7 brought the JAX-RS Client API, which is the standard way to consume REST web services built on top of the HTTP protocol", "label": {"api": {"JAX-RS Client API": [[22, 38]]}}}, {"text": "And Java SE 9, to be released in 2017, will bring a new HTTP client API that implements HTTP/2 and WebSocket, and can replace the legacy HttpURLConnection API", "label": {"api": {"HttpURLConnection": [[137, 153]]}}}, {"text": "The existing HttpURLConnection API and its implementation have numerous problems", "label": {"api": {"HttpURLConnection": [[13, 29]]}}}, {"text": "You probably should use RandomAccessFile, it supports seek by position and write", "label": {"api": {"RandomAccessFile": [[24, 39]]}}}, {"text": "Since you are trying to load the logging.properties from inside of the WAR file you have to use the java.util.logging.config.class", "label": {"api": {"java.util.logging.config.class": [[100, 129]]}}}, {"text": "If the \"java.util.logging.config.class\" property is set, then the property value is treated as a class name", "label": {"api": {"java.util.logging.config.class": [[8, 37]]}}}, {"text": "Using that property you can use Class.getResourceAsStream to locate the file inside of the WAR file", "label": {"api": {"Class.getResourceAsStream": [[32, 56]]}}}, {"text": "What you'd need in your server written in Java 8 is to serialize the LocalDateTime property as \"createdDate\"", "label": {"api": {"LocalDateTime": [[69, 81]]}}}, {"text": "The Collection.contains() method", "label": {"api": {"Collection.contains()": [[4, 24]]}}}, {"text": "If you're using Java 8, the neat Stream.anyMatch() method", "label": {"api": {"Stream.anyMatch()": [[33, 49]]}}}, {"text": "Option 3 is my personal favorite, as it's nearly as compact as Option 1, but allows to to provide a more complex Predicate if you want a comparison based on something other than the equals() method", "label": {"api": {"Predicate": [[113, 121]]}}}, {"text": "Sounds like you need an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[24, 48]]}}}, {"text": "It's because createButton is actually a JPanel, which has a FlowLayout as it's layout manager by default", "label": {"api": {"FlowLayout": [[60, 69]]}}}, {"text": "According to the API doc", "label": {"api": {"the API doc": [[13, 23]]}}}, {"text": "As far as I can gather from the rather lacking JavaFXML documentation, fx:include is a way in which one can separate FXML into individual files and then include them into another just as if the files' contents were copy-pasted", "label": {"api": {"JavaFXML documentation": [[47, 68]]}}}, {"text": "The documentation explicitly shows how to communicate between the controllers in this case", "label": {"api": {"explicitly shows how to communicate": [[18, 52]]}}}, {"text": "If you want to color the whole row, use a rowFactory that changes the color of the TableRows it creates according to item property", "label": {"api": {"rowFactory": [[42, 51]], "TableRows": [[83, 91]]}}}, {"text": "A somewhat different approach would be to either manage a Lock within your class or give someRef an attribute of type Lock", "label": {"api": {"Lock": [[58, 61], [118, 121]]}}}, {"text": "Instead of working with lock() you can use tryLock() or tryLock(long timeout, TimeUnit unit)", "label": {"api": {"Lock": [[46, 49], [59, 62]]}}}, {"text": "This is a scheme on how I would implement this (assuming that someRef has a Lock attribute)", "label": {"api": {"Lock": [[76, 79]]}}}, {"text": "Now, when someRef is changed, the 2nd thread will see the new value of someRef in its next cycle and therefore will try to synchronize on the new Lock and succeed, if no other thread has acquired the Lock", "label": {"api": {"Lock": [[146, 149], [200, 203]]}}}, {"text": "Atomic variables have features that minimize synchronization and help avoid memory consistency errors", "label": {"api": {"Atomic": [[0, 5]]}}}, {"text": "From the code you have posted, AtomicReference seems to be right solution for your problem", "label": {"api": {"AtomicReference": [[31, 45]], "Atomic": [[31, 36]]}}}, {"text": "Have a look at documentation page on Atomic package", "label": {"api": {"Atomic": [[37, 42]]}}}, {"text": "When to use AtomicReference in Java", "label": {"api": {"AtomicReference": [[12, 26]], "Atomic": [[12, 17]]}}}, {"text": "In order to make your life easier, make sure you set the IS_COALESCING property to true on the XMLInputFactory before creating your XMLEventReader (this property forces the reader to combine all adjacent text events into a single event)", "label": {"api": {"IS_COALESCING": [[57, 69]]}}}, {"text": "You can use AtomicReference to achieve the same", "label": {"api": {"AtomicReference": [[12, 26]]}}}, {"text": "When to use AtomicReference in Java", "label": {"api": {"AtomicReference": [[12, 26]]}}}, {"text": "Normally, a ResultSet is TYPE_FORWARD_ONLY", "label": {"api": {"TYPE_FORWARD_ONLY": [[25, 41]]}}}, {"text": "Change that to TYPE_SCROLL_INSENSITIVE (or TYPE_SCROLL_SENSITIVE) by specifying that option on the prepareStatement() call", "label": {"api": {"TYPE_SCROLL_INSENSITIVE": [[15, 37]], "TYPE_SCROLL_SENSITIVE": [[43, 63]], "prepareStatement()": [[99, 116]]}}}, {"text": "That way you can call beforeFirst() to reset the ResultSet to the beginning and iterate it again", "label": {"api": {"beforeFirst()": [[22, 34]]}}}, {"text": "Column values are typed, and things like handling of nulls for primitives (wasNull()) only needs to be done in one place", "label": {"api": {"wasNull()": [[75, 83]]}}}, {"text": "The only way to get a Future, from what I understand, is to use an ExecutorService, which is obtained for instance via Executors.newFixedThreadPool(10) (btw, how do you how many threads to use", "label": {"api": {"Future": [[22, 27]]}}}, {"text": "in some top level IoC) and call the executorService whenever I need new Future", "label": {"api": {"Future": [[72, 77]]}}}, {"text": "The simplest solution that comes to my mind is a BorderLayout for the main panel", "label": {"api": {"BorderLayout": [[49, 60]]}}}, {"text": "Make another BorderLayout containing the inventory button (WEST / LINE_START) and the location label (EAST / LINE_END)", "label": {"api": {"BorderLayout": [[13, 24]]}}}, {"text": "Add that to SOUTH / PAGE_END of the main BorderLayout", "label": {"api": {"BorderLayout": [[41, 52]]}}}, {"text": "Then just add a BoxLayout with vertical alignment to the main BorderLayout's CENTER containing the two buttons", "label": {"api": {"BorderLayout": [[62, 73]], "BoxLayout": [[16, 24]]}}}, {"text": "Use String.format(String, Object...)", "label": {"api": {"String.format(String, Object...)": [[4, 35]]}}}, {"text": "You can use the next() method to get the value the iterator points to, which you can then convert to a string", "label": {"api": {"next()": [[16, 21]]}}}, {"text": "Per the javadocs, getRequestURL() returns a StringBuffer, not a String", "label": {"api": {"the javadocs": [[4, 15]]}}}, {"text": "From the Javadoc", "label": {"api": {"From the Javadoc": [[0, 15]]}}}, {"text": "Either use some kind of coordination mechanism (phaser, which was introduced in Java 7 is useful when you need to add more jobs on the fly) or just keep an external flag you set when done", "label": {"api": {"phaser": [[48, 53]]}}}, {"text": "If you are using JDBC (Java Data Base Connectivity), the ResultSet and ResultSetMetaData interfaces (https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html) can enable you to make fairly flexible tools", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html": [[101, 171]]}}}, {"text": "I am having some problems applying both a translation and scale to a a JavaFx Path node", "label": {"api": {"Path node": [[78, 86]]}}}, {"text": "I have found that whenever a scale is applied via a call to either setScaleX() or scaleY() then any translation applied by a call to relocate() is no long honoured", "label": {"api": {"setScaleX()": [[67, 77]], "scaleY()": [[82, 89]], "relocate()": [[133, 142]]}}}, {"text": "You can use SimpleDateFormat with a pattern such as yyMMdd", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "As Jens points out in the comments, there's a \"Use\" link at the bottom of the Javadoc that takes you to a page full of uses of the Cloneable interface", "label": {"api": {"page full of uses of the Cloneable interface": [[106, 149]]}}}, {"text": "The Properties class extends Hashtable, so it can use all of the Map interface's methods, e.g.", "label": {"api": {"Properties": [[4, 13]], "Hashtable": [[29, 37]]}}}, {"text": "The error message means that you are using an old JDBC driver from before setBlob(int, InputStream) was added (Java 6)", "label": {"api": {"setBlob(int, InputStream)": [[74, 98]]}}}, {"text": "Note that TableDialogEditDemo uses setDefaultEditor(), which will evoke the ColorEditor for all cells whose type is Color.class", "label": {"api": {"setDefaultEditor()": [[35, 52]]}}}, {"text": "Laying Out Components in a Layered Pane, \"All of the layout managers provided by the Java platform arrange the components as if they were all on one layer.\" You have specified BorderLayout", "label": {"api": {"BorderLayout": [[176, 187]]}}}, {"text": "Your call to add() invokes addImpl(java.awt.Component, java.lang.Object, int)", "label": {"api": {"add()": [[13, 17]], "addImpl(java.awt.Component, java.lang.Object, int)": [[27, 76]]}}}, {"text": "Because BorderLayout implements LayoutManager2, your value for the constraints parameter must be a String constraint defined for BorderLayout, not an Integer having the value -1, e.g", "label": {"api": {"BorderLayout": [[8, 19], [129, 140]]}}}, {"text": "It is called Receiver", "label": {"api": {"Receiver": [[13, 20]]}}}, {"text": "If you convert the List to a Stream to a LongStream, you can use .sum()", "label": {"api": {".sum()": [[65, 70]]}}}, {"text": "You have to upload file using MockMvcRequestBuilders.fileUpload() to test MultipartHttpServletRequest it", "label": {"api": {"HttpServletRequest": [[83, 100]]}}}, {"text": "Use @RequestParam annotation to access request parameter instead of accessing them from HttpServletRequest", "label": {"api": {"HttpServletRequest": [[88, 105]]}}}, {"text": "To learn more about named colors in JavaFX please refere to this section", "label": {"api": {"this section": [[60, 71]]}}}, {"text": "Swing has a simple history manager named UndoManager", "label": {"api": {"UndoManager": [[41, 51]]}}}, {"text": "If you don't want to use Swing or UndoManager is not fit to your requirements, then make a try with an alternative standalone solution or implement your own", "label": {"api": {"UndoManager": [[34, 44]]}}}, {"text": "For the purpose of the exercise, the idea is to use Stream.of(...) to create a Stream<List<T>> containing the two given lists, and flat map each list with the method reference List::stream", "label": {"api": {"Stream.of(...)": [[52, 65]], "List::stream": [[176, 187]]}}}, {"text": "Then, you can collect all the elements into a list with Collectors.toList()", "label": {"api": {"Collectors.toList()": [[56, 74]]}}}, {"text": "You have to ensure that the dialog is opened on the JavaFX Application Thread, as every GUI update must happen on this thread in JavaFX", "label": {"api": {"JavaFX Application Thread": [[52, 76]]}}}, {"text": "Add a ToggleButton, ToggleSwitch, CheckBox or RadioButton (some kind of toggle control), to switch between the two states", "label": {"api": {"ToggleButton": [[6, 17]], "CheckBox": [[34, 41]], "RadioButton": [[46, 56]]}}}, {"text": "Read the Javadoc", "label": {"api": {"Read the Javadoc": [[0, 15]]}}}, {"text": "You could override the getPopup() method of the BasicComboBoxUI in order to create a new BasicComboPopup", "label": {"api": {"getPopup()": [[23, 32]]}}}, {"text": "TreeSet treats two objects for which compareTo returns 0 to be equals", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "The API docs for TreeSet contain this important information", "label": {"api": {"The API docs for TreeSet": [[0, 23]]}}}, {"text": "You could either use skip(String) to skip the newline after 3.0, or just call nextLine() once and throw it away", "label": {"api": {"skip(String)": [[21, 32]]}}}, {"text": "Make sure the path exists by calling mkdirs() before trying to create the file", "label": {"api": {"mkdirs()": [[37, 44]]}}}, {"text": "groupingBy collects to a Map<K,List<T>>", "label": {"api": {"groupingBy": [[0, 9]]}}}, {"text": "JavaFX application launch parameters can be accessed via the Application.getParameters() method", "label": {"api": {"Application.getParameters()": [[61, 87]]}}}, {"text": "You don't say which method(s) of these classes you need, but since they both extend TextComponent you could also try casting your object to a TextComponent", "label": {"api": {"TextComponent": [[84, 96], [142, 154]]}}}, {"text": "Quoting javadoc of getResourceAsStream()", "label": {"api": {"getResourceAsStream()": [[19, 39]]}}}, {"text": "All of these options can be configured in ThreadPoolExecutor which is probably the implementation you want to use", "label": {"api": {"ThreadPoolExecutor": [[42, 59]]}}}, {"text": "the Java language specification for SE 8, but that explicitly defines the language itself and has very little mention of the Java core class libraries", "label": {"api": {"the Java core class libraries": [[121, 149]]}}}, {"text": "Maps have a method that returns the set of keys used it's called keySet()", "label": {"api": {"keySet()": [[65, 72]]}}}, {"text": "In a Java program I am using a String with Formatter.format() function, which I get from server", "label": {"api": {"Formatter.format()": [[43, 60]]}}}, {"text": "Formatter.format() throws an exception if there are not enough provided parameters", "label": {"api": {"Formatter.format()": [[0, 17]]}}}, {"text": "This is the definition of the equals() method of interface Set", "label": {"api": {"definition": [[12, 21]]}}}, {"text": "This definition ensures that the equals method works properly across different implementations of the set interface", "label": {"api": {"definition": [[5, 14]]}}}, {"text": "You can use a java for-each loop if you have your ListIF implement Iterable<...> and have your IteratorIF implement Iterator<...>", "label": {"api": {"Iterable<...>": [[67, 79]], "Iterator<...>": [[116, 128]]}}}, {"text": "For date formats different to DateTimeFormatter.ISO_LOCAL_DATE, use a appropriate DateTimeFormatter e.g", "label": {"api": {"DateTimeFormatter.ISO_LOCAL_DATE": [[30, 61]], "DateTimeFormatter": [[30, 46], [82, 98]]}}}, {"text": "In Java, there is a Class class that can be used to represent other classes without instantiating them", "label": {"api": {"Class": [[20, 24]]}}}, {"text": "An interface is just a class for which Class.isInterface() returns true", "label": {"api": {"Class.isInterface()": [[39, 57]]}}}, {"text": "For more info, look at the JavaDoc for Double.parseDouble()", "label": {"api": {"JavaDoc for Double.parseDouble()": [[27, 58]]}}}, {"text": "You should check this link out", "label": {"api": {"link": [[22, 25]]}}}, {"text": "Think of the save methods as instances of Runnable or Callable (the basic Command interfaces in Java)", "label": {"api": {"Runnable": [[42, 49]], "Callable": [[54, 61]]}}}, {"text": "Use indexOf method", "label": {"api": {"indexOf": [[4, 10]]}}}, {"text": "If you are working with Java8, have a look to the java.time package, and use the class Instant instead of Date", "label": {"api": {"java.time package": [[50, 66]]}}}, {"text": "Characters should only read from a Reader - in your case you could use an InputStreamReader", "label": {"api": {"Reader": [[35, 40], [85, 90]]}}}, {"text": "Unfortunately, the Java regular expression classes don't provide a stream for matched results, only a splitAsStream() method, but you don't want split", "label": {"api": {"splitAsStream()": [[102, 116]]}}}, {"text": "Then your code becomes easy by using flatMap()", "label": {"api": {"flatMap()": [[37, 45]]}}}, {"text": "Try using System.out.println (); after printing the question to avoid exceptions (you can read the api here https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine())", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine()": [[108, 182]]}}}, {"text": "If I good understand you looking for a MouseInfo.getPointerInfo().getLocation() might be helpful", "label": {"api": {"MouseInfo.getPointerInfo().getLocation()": [[39, 78]]}}}, {"text": "For more on this, please see the BufferedImage API", "label": {"api": {"BufferedImage API": [[33, 49]]}}}, {"text": "Use BigInteger to hold their cubes", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Use Arrays.toString(a) to print the array of Cars", "label": {"api": {"Arrays.toString(a)": [[4, 21]]}}}, {"text": "You can add a ServletContextListener to your web project, and on contextInitialized(), you can put the externalInstance in the SchedulerContext", "label": {"api": {"ServletContextListener": [[14, 35]]}}}, {"text": "While I have usability concerns, the example below illustrates how to implement the Scrollable interface as discussed in How to Use Scroll Panes", "label": {"api": {"Scrollable": [[84, 93]]}}}, {"text": "Note in particular how the result of getPreferredScrollableViewportSize() differs from the result of getPreferredSize()", "label": {"api": {"Scrollable": [[49, 58]]}}}, {"text": "Quoting javadoc of PriorityQueue", "label": {"api": {"PriorityQueue": [[19, 31]]}}}, {"text": "As you can see, the ordering of the PriorityQueue doesn't matter when using iterator()", "label": {"api": {"PriorityQueue": [[36, 48]]}}}, {"text": "If you're using DOM to create your XML answer, use document.createCDATASection(yourStringBuffer.toString())", "label": {"api": {"document.createCDATASection(yourStringBuffer.toString())": [[51, 106]]}}}, {"text": "Move the Random random = new Random(); out of the loop", "label": {"api": {"Random()": [[29, 36]]}}}, {"text": "By default, Random() seeds itself, and may end up using the same seed if you call it very quickly in succession", "label": {"api": {"Random()": [[12, 19]]}}}, {"text": "I suggestion reading the API docs more and get familiar with them", "label": {"api": {"API docs": [[25, 32]]}}}, {"text": "Instead, you need to use a callback to update the scene on each pulse", "label": {"api": {"callback": [[27, 34]]}}}, {"text": "Instead, either use the in-built high level JavaFX animation facilities such as transitions, or (when those aren't a good fit, as is likely the case here), use the low level AnimationTimer interface", "label": {"api": {"AnimationTimer": [[174, 187]]}}}, {"text": "As it says in the Javadoc of HashMap", "label": {"api": {"Javadoc of HashMap": [[18, 35]]}}}, {"text": "It sounds like what you're looking for is an ObjectOutputStream which allows you to serialize arbitrary (but must implement Serializable) objects to a byte array (or in this case stream) which can then be written to disk", "label": {"api": {"ObjectOutputStream": [[45, 62]]}}}, {"text": "The return type of inventory.getRoom().getobjects().get(counter) appears to be ArrayList", "label": {"api": {"ArrayList": [[79, 87]]}}}, {"text": "An ArrayList is of type Object in Java, but your lowercase object appears to be a new class definition that is not a superclass or interface for ArrayList", "label": {"api": {"ArrayList": [[3, 11], [145, 153]]}}}, {"text": "You could refer to it as an ArrayList or List or Collection or Object (note the capitalization), but you are trying to assign it the type object", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "If your object type really was compatible with the ArrayList you could type cast it to the object type, like", "label": {"api": {"ArrayList": [[51, 59]]}}}, {"text": "If you have a java.util.Date just use http://docs.oracle.com/javase/6/docs/api/java/util/Date.html#getTime() to get the UNIX timestamp as long", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Date.html#getTime()": [[38, 107]]}}}, {"text": "Still, the memory footprint does not depend on the number of the skipped lines, as the size of the BufferedReaders internal buffer will be fixed at the BufferedReaders construction, see BufferedReader(Reader) and BufferedReader(Reader, int)", "label": {"api": {"BufferedReader(Reader)": [[188, 209]], "BufferedReader(Reader, int)": [[215, 241]]}}}, {"text": "Generally, there is no dedicated skip operation in the backends which the Stream API could exploit, which you can verify by looking at the Spliterator interface, so skipping lines is not different to repeatedly invoking readLine() on the BufferedReader, but dropping the resulting strings immediately", "label": {"api": {"Spliterator": [[139, 149]]}}}, {"text": "I think you'll have to use the setLocationRelativeTo method", "label": {"api": {"setLocationRelativeTo": [[31, 51]]}}}, {"text": "Use the filter-method from Java Streams", "label": {"api": {"filter": [[8, 13]]}}}, {"text": "You could consider a SynchronousQueue", "label": {"api": {"SynchronousQueue": [[21, 36]]}}}, {"text": "anyMatch will determine if any elements of the stream satisfies the given condition", "label": {"api": {"anyMatch": [[0, 7]]}}}, {"text": "I've played around by extending @XmlAdapter using the following snippet (example from a blog)", "label": {"api": {"@XmlAdapter": [[32, 42]]}}}, {"text": "Also all the constructors shown at this java doc page takes address as argument", "label": {"api": {"java doc page": [[40, 52]]}}}, {"text": "How can I fix the following example in order to inform the Spring application context where to find a class Application whose constructor is annotated with @Inject, but without introducing a bean method to ApplicationConfiguration annotated with @Bean that returns an instance of class Application", "label": {"api": {"@Inject": [[156, 162]]}}}, {"text": "It is true that common Java arithmetic operations consider the int values as signed, but there methods in java.lang.Integer that operate on two int values considering them as unsigned", "label": {"api": {"methods in java.lang.Integer": [[95, 122]]}}}, {"text": "The reason is that your are not actually interrupting your thread when calling interrupt()", "label": {"api": {"interrupt()": [[79, 89]]}}}, {"text": "Take a look at the documentation of the DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[40, 56]]}}}, {"text": "The one you want is almost like DateTimeFormatter.ISO_INSTANT", "label": {"api": {"DateTimeFormatter": [[32, 48]]}}}, {"text": "When a Calendar is initially obtained by calling Calendar.getInstance() (or other means), it has the \"current time\"", "label": {"api": {"Calendar.getInstance()": [[49, 70]]}}}, {"text": "If you want to capture the current time, just call new Date()", "label": {"api": {"new Date()": [[51, 60]]}}}, {"text": "You have the Collections#synchronizedXXX that works fine for these kind of tasks", "label": {"api": {"Collections#synchronizedXXX": [[13, 39]]}}}, {"text": "In your case, you'll use the Collections#synchronizedMap(Map) map", "label": {"api": {"Collections#synchronizedMap(Map)": [[29, 60]]}}}, {"text": "The result of getPreferredSize() is reliable, once you specify a layout and pack() the parent Window", "label": {"api": {"pack()": [[76, 81]]}}}, {"text": "and the !, is the URL to the file in the JAR, as defined in JarURLConnection", "label": {"api": {"JarURLConnection": [[60, 75]]}}}, {"text": "From the javadoc of putIfAbsent", "label": {"api": {"putIfAbsent": [[20, 30]]}}}, {"text": "There is an initVerify that simply takes a certificate", "label": {"api": {"initVerify that simply takes a certificate": [[12, 53]]}}}, {"text": "In the focusGained() method you are passed a FocusEvent which should contain the object that initiated the event using e.getSource()", "label": {"api": {"FocusEvent": [[45, 54]]}}}, {"text": "The difference between the two is that the color returned by panel.getBackground() is an instance of javax.swing.plaf.ColorUIResource, a subclass of Color which implements UIResource", "label": {"api": {"javax.swing.plaf.ColorUIResource": [[101, 132]]}}}, {"text": "If you call awaitTermination after shutdown, then it will wait for all the threads to complete before the test finishes", "label": {"api": {"awaitTermination": [[12, 27]]}}}, {"text": "You need to create a ServletContextListener implementation, and register it in your web.xml file", "label": {"api": {"ServletContextListener": [[21, 42]]}}}, {"text": "If using servlet 3.0, you can also just annotate the class with the @WebListener annotation instead of registering it in your web.xml file", "label": {"api": {"@WebListener": [[68, 79]]}}}, {"text": "The poll method, on the other hand, can take a timeout as an argument", "label": {"api": {"poll": [[4, 7]]}}}, {"text": "If you want to represent larger integers than the long primitive allows (i.e., 263-1), you'll have to resort to using the BigInteger class", "label": {"api": {"BigInteger": [[122, 131]]}}}, {"text": "Otherwise you might want to use a comparator, which is basically a class that contains the comparing logic", "label": {"api": {"comparator": [[34, 43]]}}}, {"text": "You can have multiple of such comparator classes and switch them in your list container class later on", "label": {"api": {"comparator": [[30, 39]]}}}, {"text": "BTW, do you know Map", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "Stack is a legacy class from Java 1.0 that extends Vector", "label": {"api": {"Stack": [[0, 4]]}}}, {"text": "As mentioned, they are legacy classes, and you shouldn't be using them, e.g javadoc of Stack says", "label": {"api": {"Stack": [[87, 91]]}}}, {"text": "A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class", "label": {"api": {"Deque": [[79, 83]]}}}, {"text": "The javadoc of Deque says", "label": {"api": {"Deque": [[15, 19]]}}}, {"text": "Deques can also be used as LIFO (Last-In-First-Out) stacks", "label": {"api": {"Deque": [[0, 4]]}}}, {"text": "This interface should be used in preference to the legacy Stack class", "label": {"api": {"Stack": [[58, 62]]}}}, {"text": "So, iterating a Deque will see elements in LIFO order, while iterating a Stack will see elements in FIFO order", "label": {"api": {"Stack": [[73, 77]], "Deque": [[16, 20]]}}}, {"text": "You can use the Date#compareTo method", "label": {"api": {"Date#compareTo": [[16, 29]]}}}, {"text": "In Java 8, use a LocalDate and a DateTimeFormatter", "label": {"api": {"LocalDate": [[17, 25]], "DateTimeFormatter": [[33, 49]]}}}, {"text": "If you need to support older versions of Java, use Calendar and SimpleDateFormat", "label": {"api": {"Calendar": [[51, 58]], "SimpleDateFormat": [[64, 79]]}}}, {"text": "Alternatively, add Joda-Time and use its LocalDate and DateTimeFormat", "label": {"api": {"LocalDate": [[41, 49]]}}}, {"text": "The extra thread loops on the take method of the general queue, and once its taken an item it simply stores into one of the other queues, which in turn are taken from by the appropriate threads", "label": {"api": {"take": [[30, 33], [77, 80], [156, 159]]}}}, {"text": "Then the sorting thread would call ExecutorService#Submit on these ExecutorServices instead of sorting into queues", "label": {"api": {"ExecutorService#Submit": [[35, 56]]}}}, {"text": "Wrap your inputStream in a DataInputStream, and then use the readByte(), readInt() methods as appropriate to read the correct type of data from the stream", "label": {"api": {"DataInputStream": [[27, 41]], "readByte()": [[61, 70]], "readInt()": [[73, 81]]}}}, {"text": "Combining the javax.imageio.ImageIO class (ref) and the javafx.embed.swing.SwingFXUtils (ref) can convert an \"input\" (i.e.", "label": {"api": {"ref": [[43, 45], [89, 91]]}}}, {"text": "File provides a method to retrieve the URL for the file and the Image constructor expects a URL String", "label": {"api": {"the Image constructor": [[60, 80]]}}}, {"text": "What you basically need is a background Task which actually stops for a certain amount of time, then updates the GUI on the JavaFX Application Thread by calling Platform.runLater before it goes to sleep again", "label": {"api": {"Task": [[40, 43]], "Platform.runLater": [[161, 177]]}}}, {"text": "im looking for a alternative to java.util.TimerTask", "label": {"api": {"java.util.TimerTask": [[32, 50]]}}}, {"text": "A ListChangeListener added to an ObservableList sees certain specific changes made to the list as a whole", "label": {"api": {"ListChangeListener": [[2, 19]], "ObservableList": [[33, 46]], "changes": [[70, 76]]}}}, {"text": "Because FXCollections.concat() simply copies references from the source lists to the destination's backing list, a listener added to concat will see changes made to concat; it will not see changes to list1 or list2", "label": {"api": {"changes": [[149, 155], [189, 195]], "FXCollections.concat()": [[8, 29]]}}}, {"text": "If you don't need to create a new ObservableList for some other reason, aggregate the lists in a way that allows you to add the same listener to each", "label": {"api": {"ObservableList": [[34, 47]]}}}, {"text": "To see changes to the individual list elements, use an ObservableList<Observable>, such as ObservableList<IntegerProperty>", "label": {"api": {"ObservableList": [[55, 68], [91, 104]], "changes": [[7, 13]]}}}, {"text": "I cannot use Strings since the virtual file can only be referenced using the Path object", "label": {"api": {"Path": [[77, 80]]}}}, {"text": "How do I open a database connection using Paths", "label": {"api": {"Path": [[42, 45]]}}}, {"text": "Work queues are meant to be blocking, and hence you would need to add a decorator to make that CircularFifoQueue a BLockingQueue", "label": {"api": {"Lock": [[116, 119]]}}}, {"text": "You would need to get Conditions and Lock right of course", "label": {"api": {"Conditions": [[22, 31]], "Lock": [[37, 40]]}}}, {"text": "The question is how to do it with the Stream API", "label": {"api": {"Stream API": [[38, 47]]}}}, {"text": "You can do this using the flatMap operation", "label": {"api": {"flatMap": [[26, 32]]}}}, {"text": "You are drawing the text always in the same position 25,25", "label": {"api": {"25,25": [[53, 57]]}}}, {"text": "Instead, check your public key to see if it implements interfaces such as RSAPublicKey or DSAPublicKey", "label": {"api": {"RSAPublicKey": [[74, 85]], "DSAPublicKey": [[90, 101]]}}}, {"text": "You want to call getDeclaredAnnotations() in order to fetch all declared annotations for each of the fields", "label": {"api": {"getDeclaredAnnotations()": [[17, 40]]}}}, {"text": "..by using MethodHandles.collectArguments()", "label": {"api": {"MethodHandles.collectArguments()": [[11, 42]]}}}, {"text": "Use MethodHandles::permuteArguments combined with a MethodType::dropPatameterTypes() call", "label": {"api": {"MethodHandles::permuteArguments": [[4, 34]]}}}, {"text": "And the use of Collections.checkedList", "label": {"api": {"Collections.checkedList": [[15, 37]]}}}, {"text": "Don't know what the purpose of doing it yourself is, but you could just do it the same way the built-in Random class does it for nextDouble(), as described in the javadoc", "label": {"api": {"nextDouble()": [[129, 140]]}}}, {"text": "There is this one in Java CopyOnWriteArrayList it's part of the concurrent package and seems to do exactly what you want", "label": {"api": {"CopyOnWriteArrayList": [[26, 45]]}}}, {"text": "If the purpose of type parameter T is for fields valueA and valueB to be of that type, and that matches() should use the fact that they are Comparable (since T extends Comparable), this is how", "label": {"api": {"Comparable": [[140, 149], [168, 177]]}}}, {"text": "Of course, assuming that the referenced type enforces that Comparable is consistent with equals, then you don't really need Comparable at all", "label": {"api": {"Comparable": [[59, 68], [124, 133]]}}}, {"text": "From the documentation for ConcurrentHashMap.entrySet()", "label": {"api": {"ConcurrentHashMap.entrySet()": [[27, 54]]}}}, {"text": "Scanner#nextInt thorws NoSuchElementException when input is exhausted", "label": {"api": {"Scanner": [[0, 6]], "NoSuchElementException": [[23, 44]]}}}, {"text": "How to remove!- Check valid input by Scanner#hasNextInt before calling Scanner#nextInt", "label": {"api": {"Scanner": [[37, 43], [71, 77]]}}}, {"text": "Read more documentation on Scanner and NoSuchElementException", "label": {"api": {"Scanner": [[27, 33]], "NoSuchElementException": [[39, 60]]}}}, {"text": "I think you can solve this problem with methods setName(String name) and getName() + some counter", "label": {"api": {"methods": [[40, 46]]}}}, {"text": "Use Long as Integer is to short to map all possible values", "label": {"api": {"Long": [[4, 7]], "Integer": [[12, 18]]}}}, {"text": "You're using a BorderPane", "label": {"api": {"BorderPane": [[15, 24]]}}}, {"text": "However a BorderPane only displays the top, center, bottom, right and left Nodes added using the appropriate properties/setters", "label": {"api": {"BorderPane": [[10, 19]]}}}, {"text": "but there is no benefit in wrapping your TabPane in a BorderPane in this case, since it's the only child of the BorderPane", "label": {"api": {"BorderPane": [[54, 63], [112, 121]]}}}, {"text": "JTextPane is Scrollable, so you can make it any preferred size you want and still use any layout you want", "label": {"api": {"JTextPane": [[0, 8]]}}}, {"text": "Sounds like reading one of the BasicFileAttributes, the lastAccessTime, is what you're looking for", "label": {"api": {"BasicFileAttributes": [[31, 49]]}}}, {"text": "A Future does not represent running code but rather a value that could be either immediately available or could become available in the future (hence the name) concurrently w.r.t", "label": {"api": {"Future": [[2, 7]]}}}, {"text": "Quasar's SettableFutures have the additional ability to allow all types of Quasar strands (i.e., at present, regular Java threads as well as Quasar fibers) to block if they await on it when the value is not yet available", "label": {"api": {"Future": [[17, 22]]}}}, {"text": "This means you can create a SettableFuture in any strand (thread or fiber), reference it e.g", "label": {"api": {"Future": [[36, 41]]}}}, {"text": "This pattern too is described in the \"Future\" sub-section of this blog post", "label": {"api": {"Future": [[38, 43]]}}}, {"text": "The DateTimeFormatter.ofLocalizedDate method allows you to obtain a formatter that can output a date, but there is no data available in JDK 8 to output just a localized year-month", "label": {"api": {"DateTimeFormatter.ofLocalizedDate": [[4, 36]]}}}, {"text": "Either wrap your OutputStream in BufferedOutputStream, or just buffer your output manually (e.g", "label": {"api": {"BufferedOutputStream": [[33, 52]]}}}, {"text": "by first collecting the bytes into an array, and then using #write(byte[])", "label": {"api": {"#write(byte[])": [[60, 73]]}}}, {"text": "It might be better to use a Future of some kind", "label": {"api": {"Future": [[28, 33]]}}}, {"text": "convertPointFromScreen(java.awt.Point,java.awt.Component)  Good luck", "label": {"api": {"convertPointFromScreen(java.awt.Point,java.awt.Component)": [[0, 56]]}}}, {"text": "Dirty solution is to add a -1 margin around the Rectangles using GridPane.setMargin(Node child, Insets value)", "label": {"api": {"GridPane.setMargin(Node child, Insets value)": [[65, 108]]}}}, {"text": "You can achieve a better result by setting snapToPixel to false", "label": {"api": {"snapToPixel": [[43, 53]]}}}, {"text": "Furthermore Bindings.min can help you get simpler code for the size", "label": {"api": {"Bindings.min": [[12, 23]]}}}, {"text": "Also the fill of a Shape can be set to a Color directly", "label": {"api": {"fill": [[9, 12]]}}}, {"text": "One option would be to use a ForwardingFuture and decorate .cancel() with this close-if-done behavior, but that seems like it would violate the contract that .cancel() \"will fail if the task has already completed\"", "label": {"api": {"will fail if the task has already completed": [[169, 211]]}}}, {"text": "9999999999 is outside the valid range of values for the int data type (-231 to 231-1, inclusive), as specified by the Integer.MIN_VALUE and Integer.MAX_VALUE constants", "label": {"api": {"Integer.MIN_VALUE": [[118, 134]], "Integer.MAX_VALUE": [[140, 156]]}}}, {"text": "There is a reason the getResource(String) method returns a URL, and not a File", "label": {"api": {"getResource(String)": [[22, 40]]}}}, {"text": "Instead, use the getResourceAsStream(String), and give that InputStream directly to the load(InputStream) method", "label": {"api": {"getResourceAsStream(String)": [[17, 43]], "load(InputStream)": [[88, 104]]}}}, {"text": "You can use the getResource(String) method if you want, but you must then open the stream using the URL.openStream() method", "label": {"api": {"getResource(String)": [[16, 34]], "URL.openStream()": [[100, 115]]}}}, {"text": "So the hierarchy is", "label": {"api": {"hierarchy": [[7, 15]]}}}, {"text": "Instead, to map Joda types, I always use a standard JPA @Convert to map them to the database", "label": {"api": {"@Convert": [[56, 63]]}}}, {"text": "I simply need to install an all-trusting SSL certificate TrustManager", "label": {"api": {"TrustManager": [[57, 68]]}}}, {"text": "You can obtain an Iterator and iterate over all elements and process your check", "label": {"api": {"Iterator": [[18, 25]]}}}, {"text": "Also, if TempListener implements ActionListener, then you must follow the ActionListener interface", "label": {"api": {"ActionListener": [[33, 46], [74, 87]]}}}, {"text": "I believe you will have better luck using a WritableRaster", "label": {"api": {"WritableRaster": [[44, 57]]}}}, {"text": "Regarding TZ, if I use ResultSet.getTimestamp(4), it returns java.sql.Timestamp(2016-06-01 16:14:04.92) - in the correct timezone!!", "label": {"api": {"ResultSet.getTimestamp(4)": [[23, 47]]}}}, {"text": "I need to pass a Calendar", "label": {"api": {"Calendar": [[17, 24]]}}}, {"text": "Doing resultSet.getTimestamp(5, Calendar.getInstance()) returns java.sql.Timestamp(2016-06-01 13:14:04.92) - wrong timezone (UTC instead of IDT)", "label": {"api": {"Calendar": [[32, 39]]}}}, {"text": "As documentation (http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html) says, By default, only one ResultSet object per Statement object can be open at the same time", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html": [[18, 81]]}}}, {"text": "The common thing is that they are using the comsume() method of the Event class", "label": {"api": {"comsume()": [[44, 52]]}}}, {"text": "1) Using KeyCodeCombination", "label": {"api": {"KeyCodeCombination": [[9, 26]]}}}, {"text": "2) Using isShortcutDown() method of KeyEvent", "label": {"api": {"isShortcutDown()": [[9, 24]], "KeyEvent": [[36, 43]]}}}, {"text": "For that I am using the getUserInfo method of  java.net.URI (https://docs.oracle.com/javase/6/docs/api/java/net/URI.html)..", "label": {"api": {"https://docs.oracle.com/javase/6/docs/api/java/net/URI.html": [[61, 119]]}}}, {"text": "You probably want to use an ArrayList, like so", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "You have the wrong assumption that there was a relationship between the Class object you pass to getDeclaredMethod and the return type of Method.invoke", "label": {"api": {"Method.invoke": [[138, 150]]}}}, {"text": "The parameter type of Map.get is Object, invariably, so you have to specify Object.class, regardless of which actual key you will pass to invoke", "label": {"api": {"Map.get": [[22, 28]]}}}, {"text": "Not that it matters, Method.invokes declared return type is always Object, as different Method instances may represent different methods", "label": {"api": {"Method.invoke": [[21, 33]]}}}, {"text": "A more predictable HashMap implementation is the LinkedHashMap which may serve your purposes", "label": {"api": {"LinkedHashMap": [[49, 61]]}}}, {"text": "CompletableFuture represents a task which is associated with some Executor", "label": {"api": {"Executor": [[66, 73]]}}}, {"text": "If you did not specify executor explicitly (for example, you used CompletableFuture.supplyAsync(Supplier) instead of CompletableFuture.supplyAsync(Supplier, Executor)), then common ForkJoinPool is used as executor", "label": {"api": {"Executor": [[157, 164]], "CompletableFuture.supplyAsync(Supplier)": [[66, 104]], "CompletableFuture.supplyAsync(Supplier, Executor))": [[117, 166]]}}}, {"text": "This pool could be obtained via ForkJoinPool.commonPool() and by default it creates as many threads as many hardware threads your system has (usually number of cores, double it if your cores support hyperthreading)", "label": {"api": {"ForkJoinPool.commonPool()": [[32, 56]]}}}, {"text": "You can try using the Java Collections toArray() method", "label": {"api": {"toArray() method": [[39, 54]]}}}, {"text": "To get a byte array from a ByteArrayOutputStream, use ByteArrayOutputStream.tobytearray()", "label": {"api": {"ByteArrayOutputStream.tobytearray()": [[54, 88]]}}}, {"text": "If you wrap System.out in a PrintWriter, you can use the overload of PrintWriter.write which prints a portion of the string", "label": {"api": {"PrintWriter": [[28, 38], [69, 79]]}}}, {"text": "Just use putAll, which is available on Map", "label": {"api": {"putAll": [[9, 14]]}}}, {"text": "While it still narrows down the implementations of Map you can use for your instance field, it's just those that support putAll..", "label": {"api": {"putAll": [[121, 126]]}}}, {"text": "For example, you could use parallelStream() instead of stream and due to source would be splitted by Spliterator it still should work perfect", "label": {"api": {"Spliterator": [[101, 111]]}}}, {"text": "Create a new Properties instance, and populate it using setProperty() calls", "label": {"api": {"setProperty()": [[56, 68]]}}}, {"text": "Then when you store it, the proper escaping will be applied to your Arabic text, which is necessary because property files are encoded with ISO-8859-1 (an encoding for Western Latin characters)", "label": {"api": {"store it,": [[14, 22]]}}}, {"text": "Alternatively, you can store the Properties using a Writer instance that is configured with whatever encoding you choose, but the encoding isn't stored in the file itself, so you will need meta-data or a convention to set the correct encoding when reading the file again", "label": {"api": {"store the Properties using a Writer": [[23, 57]]}}}, {"text": "Finally, you can store the Properties in an XML format, which will use UTF-8 by default, or you can specify another encoding", "label": {"api": {"store the Properties in an XML format,": [[17, 54]]}}}, {"text": "You can only have one @return tag in valid Javadoc, and the convention as done by parts of the API has been to describe what it returns in that single line", "label": {"api": {"as done by parts of the API": [[71, 97]]}}}, {"text": "You also need to register a handler for the onAction event", "label": {"api": {"onAction event": [[44, 57]]}}}, {"text": "This could be a new one for each MenuItem saving the data about the text each, or you could access the event source to get a reference to the MenuItem", "label": {"api": {"event source": [[103, 114]]}}}, {"text": "Note that Java8 introduces the Predicate<T> interface, which could be very helpful in your case", "label": {"api": {"Predicate<T>": [[31, 42]]}}}, {"text": "As you mentioned, you should implement your own Comparator, based on the String's length, not its alphabetical contents", "label": {"api": {"Comparator": [[48, 57]]}}}, {"text": "Once you've done that, you can use it to find the shortest string in the array, or just reuse Collections#min(Collection, Comparator) to do the heavy lifting for you", "label": {"api": {"Comparator": [[122, 131]], "Collections#min(Collection, Comparator)": [[94, 132]]}}}, {"text": "The doocumentation for JEditorPane.setPage is pretty informative on this", "label": {"api": {"doocumentation for JEditorPane.setPage": [[4, 41]]}}}, {"text": "As it says in the Javadoc for ArrayList", "label": {"api": {"Javadoc for ArrayList": [[18, 38]]}}}, {"text": "As it says in the Javadoc for keySet()", "label": {"api": {"Javadoc for keySet()": [[18, 37]]}}}, {"text": "You should use Process and ProcessBuilder instead", "label": {"api": {"Process": [[15, 21], [27, 33]], "ProcessBuilder": [[27, 40]]}}}, {"text": "Fortunately for you, ProcessBuilder supports changing the working directory of the command anyway", "label": {"api": {"Process": [[21, 27]], "ProcessBuilder": [[21, 34]]}}}, {"text": "Notice how a) the command has been split up, and b) that the working directory is passed in and set using ProcessBuilder.directory(File)", "label": {"api": {"Process": [[106, 112]], "ProcessBuilder": [[106, 119]], "ProcessBuilder.directory(File)": [[106, 135]]}}}, {"text": "I encourage you to read about the Integer.decode method and the Scanner class", "label": {"api": {"Integer.decode method": [[34, 54]], "Scanner class": [[64, 76]]}}}, {"text": "You are calling showInputDialog(Component parentComponent, Object message, Object initialSelectionValue), and you are passing QUESTION_MESSAGE (i.e", "label": {"api": {"showInputDialog(Component parentComponent, Object message, Object initialSelectionValue)": [[16, 103]]}}}, {"text": "You could instead call showInputDialog(Component parentComponent, Object message, String title, int messageType), which has a messageType parameter, which would accept QUESTION_MESSAGE", "label": {"api": {"showInputDialog(Component parentComponent, Object message, String title, int messageType)": [[23, 111]]}}}, {"text": "I allocate my ByteBuffers using MappedByteBuffer because it's faster than ByteBuffer.wrap()", "label": {"api": {"MappedByteBuffer": [[32, 47]], "ByteBuffer.wrap()": [[74, 90]]}}}, {"text": "I do my concurrent processing using Executors", "label": {"api": {"Executors": [[36, 44]]}}}, {"text": "The same problem exist with ByteBuffer.wrap() and MappedByteBuffer alike", "label": {"api": {"MappedByteBuffer": [[50, 65]], "ByteBuffer.wrap()": [[28, 44]]}}}, {"text": "If you want your result to be ordered, you can specify LinkedHashMap with another overload", "label": {"api": {"another overload": [[74, 89]]}}}, {"text": "You could use CompletableFuture.anyOf()", "label": {"api": {"CompletableFuture.anyOf()": [[14, 38]]}}}, {"text": "The remove method in ArrayList removes the item at given index and returns the removed item", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "Please read the documentation of ArrayList for further information", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "Just use Character#toLowerCase() for this", "label": {"api": {"Character#toLowerCase()": [[9, 31]]}}}, {"text": "Don't re-invent the wheel use a Timer class for it and schedule the task at a fixed rate..", "label": {"api": {"Timer": [[32, 36]]}}}, {"text": "ByteBuffer is a great class for accomplishing what you are trying to do", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "ByteBuffer allows you to directly convert byte arrays into their corresponding primitive values", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "The check is done using containsAll, which means that it will retain properties containing exactly the given criteria (matching by equality of entries, so equality of both keys and values)", "label": {"api": {"containsAll": [[24, 34]]}}}, {"text": "Properties extends Hashtable<Object, Object>, so you should be able to use the Hashtable.putAll method to add all entries of overrideProperties to mixProperties", "label": {"api": {"Properties": [[0, 9], [133, 142], [150, 159]], "Hashtable<Object, Object>": [[19, 43]], "Hashtable.putAll": [[79, 94]]}}}, {"text": "Create a ZipInputStream from your fileInputStream, then browse its entries with .getNextEntry()", "label": {"api": {"ZipInputStream": [[9, 22]]}}}, {"text": "If it's a directory you might want to create it, if it's a file use the ZipInputStream's read method to read the content of the file into a byte[], which you'll have to write to the disk with a FileOutputStream", "label": {"api": {"ZipInputStream": [[72, 85]]}}}, {"text": "Collections.shuffle is the simplest way of doing this", "label": {"api": {"Collections.shuffle": [[0, 18]]}}}, {"text": "It works fine but I noticed a difference between reading from the device node with cat and reading from a Java program with Files.readAllBytes", "label": {"api": {"Files.readAllBytes": [[124, 141]]}}}, {"text": "Reading with Files.readAllBytes, a buffer with size 1 is passed in at the first call, and then a buffer with size 8191 is passed and the remaining 4 bytes are copied", "label": {"api": {"Files.readAllBytes": [[13, 30]]}}}, {"text": "Write a parser, read the data, create a date object and the proceed to do with it whatever you like", "label": {"api": {"date object": [[40, 50]]}}}, {"text": "Currently I have succeeded in at least implementing the remote desktop part using AWT Robot's screencapture", "label": {"api": {"AWT Robot's screencapture": [[82, 106]]}}}, {"text": "The table's ListSelectionModel uses -1 to indicate that the selection is empty", "label": {"api": {"ListSelectionModel": [[12, 29]]}}}, {"text": "I tried applying the MemoryMXBean to the problem, but I'm getting nonsense results", "label": {"api": {"MemoryMXBean": [[21, 32]]}}}, {"text": "How do I determine how much memory is being allocated in a line of code, and/or what am I doing wrong with my use of the MemoryMXBean", "label": {"api": {"MemoryMXBean": [[121, 132]]}}}, {"text": "You may want to wrap System.in in a BufferedReader and use BufferedReader#readLine and handle the fact you get a string instead of one character, or alternately after getting your character, call read repeatedly until you get the newline", "label": {"api": {"BufferedReader#readLine": [[59, 81]]}}}, {"text": "Take a look at the documentation for the ArrayList.set method", "label": {"api": {"ArrayList.set": [[41, 53]]}}}, {"text": "Create a google maps instance in html and javascript then call the URL in your JavaFX program using WebEngine class", "label": {"api": {"WebEngine": [[100, 108]]}}}, {"text": "WebEngine loads Web pages, creates their document models, applies styles as necessary, and runs JavaScript on pages", "label": {"api": {"WebEngine": [[0, 8]]}}}, {"text": "Instead, you need to use the Class object (usually the this variable)'s .getResource to retrieve a URL or .getResourceAsStream to retrieve an InputStream for it", "label": {"api": {".getResource": [[72, 83], [106, 117]], ".getResourceAsStream": [[106, 125]]}}}, {"text": "You can then pass either of these into one of AudioSystem.getAudioInputStream's overloads as it has one for InputStreams and one for URLs", "label": {"api": {"one for InputStreams": [[100, 119]], "one for URLs": [[125, 136]]}}}, {"text": "The Matcher will give you the position of the found text using start() and end()", "label": {"api": {"Matcher": [[4, 10]], "start()": [[63, 69]], "end()": [[75, 79]]}}}, {"text": "Look at KeyAgreement for Java's DH implementation, and Socket and ServerSocket for creating a MitM between the client and server (assuming that's how you intend to exploit the vulnerability)", "label": {"api": {"KeyAgreement": [[8, 19]], "Socket": [[55, 60], [72, 77]], "ServerSocket": [[66, 77]]}}}, {"text": "These take Runnables as parameters in some of their methods", "label": {"api": {"in some of their methods": [[35, 58]]}}}, {"text": "BorderPane is a JavaFX Node whereas JPanel is a Java Swing Component", "label": {"api": {"Pane": [[6, 9], [37, 40]]}}}, {"text": "You cannot add a JPanel to a BorderPane, what you are looking for instead is the JavaFX equivalent of the JPanel which is the Pane class", "label": {"api": {"Pane": [[18, 21], [35, 38], [107, 110], [126, 129]]}}}, {"text": "If you must use Swing components then you can use the SwingNode class", "label": {"api": {"SwingNode": [[54, 62]]}}}, {"text": "channels() expects a CF array (ie java.util.List object)", "label": {"api": {"java.util.List": [[34, 47]]}}}, {"text": "Can I map a Stack to a relational database in JPA", "label": {"api": {"Stack": [[12, 16]]}}}, {"text": "Collections.binarySearch() expects elements to be in ascending order", "label": {"api": {"Collections.binarySearch()": [[0, 25]]}}}, {"text": "If you want to do a binary search on a descending list, use Comparator.reverseOrder()", "label": {"api": {"Comparator.reverseOrder()": [[60, 84]]}}}, {"text": "Use int Double.compare(double d1, double d2)", "label": {"api": {"int Double.compare(double d1, double d2)": [[4, 43]]}}}, {"text": "Use int Integer.compare(int x, int y)", "label": {"api": {"int Integer.compare(int x, int y)": [[4, 36]]}}}, {"text": "You can simply use Properties class to get *.properties files", "label": {"api": {"Properties": [[19, 28]]}}}, {"text": "This new String(aa) is highly likely to be incorrect", "label": {"api": {"new String(aa)": [[5, 18]]}}}, {"text": "Prevent this by calling Event.consume in the handler methods, e.g", "label": {"api": {"Event.consume": [[24, 36]]}}}, {"text": "Basic I/O in Oracle's Java Tutorials and see the API documentation", "label": {"api": {"API documentation": [[49, 65]]}}}, {"text": "If you just want to identify in comparing, String#compareTo will do", "label": {"api": {"String#compareTo": [[43, 58]]}}}, {"text": "For example, using the YearMonth class in the java.time API (Java 8 and later)", "label": {"api": {"YearMonth": [[23, 31]], "java.time": [[46, 54]]}}}, {"text": "Or to use the stream API (not sure that it is much cleaner in this case)", "label": {"api": {"stream API": [[14, 23]]}}}, {"text": "Java streams are a very powerful tool", "label": {"api": {"streams": [[5, 11]]}}}, {"text": "Note only difference between your code and this is dollar sign before 0 and assigning of replaceAll result to textFile because String type is immutable", "label": {"api": {"immutable": [[142, 150]]}}}, {"text": "As has been pointed out, you can write your own comparator for Arrays.sort()", "label": {"api": {"Arrays.sort()": [[63, 75]]}}}, {"text": "Returns true if the next token in this scanner's input can be interpreted as a double value using the nextDouble() method", "label": {"api": {"nextDouble()": [[102, 113]]}}}, {"text": "You must call hasNextDouble() before calling nextDouble()", "label": {"api": {"nextDouble()": [[45, 56]]}}}, {"text": "That way nextDouble() will never fail and you don't have to catch exceptions", "label": {"api": {"nextDouble()": [[9, 20]]}}}, {"text": "That is easiest done by calling nextLine()", "label": {"api": {"nextLine()": [[32, 41]]}}}, {"text": "Based on the JavaFX CSS reference, Text doesn't have this property like Label and TextField do", "label": {"api": {"JavaFX CSS reference": [[13, 32]], "Text": [[35, 38], [82, 85]], "Label": [[72, 76]], "TextField": [[82, 90]]}}}, {"text": "First note that Text has no style class by default", "label": {"api": {"Text": [[16, 19]]}}}, {"text": "Then you can use the -fx-fill property inherited from Shape", "label": {"api": {"Shape": [[54, 58]]}}}, {"text": "You can try TreeSet which is implemented based on Red-Black tree", "label": {"api": {"TreeSet": [[12, 18]]}}}, {"text": "You can try make it threaded to keep track of the min/max, but requires lots of changes to TreeSet", "label": {"api": {"TreeSet": [[91, 97]]}}}, {"text": "With Java 1.8.0_92, on trying to run the example of MethodHandles.filterArguments(), the following exception is thrown", "label": {"api": {"filterArguments()": [[66, 82]]}}}, {"text": "which would fail at runtime with an ArrayStoreException, since you can't store Object references in a String[]", "label": {"api": {"ArrayStoreException": [[36, 54]]}}}, {"text": "You create a Comparator to be used on a collection of objects in your TreeTableView", "label": {"api": {"Comparator": [[13, 22]]}}}, {"text": "You have JsonObject which comes with Java (but only JavaEE, I believe)", "label": {"api": {"JsonObject": [[9, 18]]}}}, {"text": "The method PrintStream.println has multiple overloads, one of which does accept an Object parameter", "label": {"api": {"PrintStream.println": [[11, 29]]}}}, {"text": "Create seperate cellFactorys for each column and pass the ObservableList to the constructor of ComboBoxTableCell", "label": {"api": {"the constructor of ComboBoxTableCell": [[76, 111]]}}}]