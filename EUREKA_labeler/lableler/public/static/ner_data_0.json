[{"text":"In Java 9 and afterward, if there's a declared zero-parameter (\"nullary\") constructor, you'd use Class.getDeclaredConstructor() to get it, then call newInstance() on it","label":{"api":{"Class.getDeclaredConstructor()":[[97,126]],"newInstance()":[[149,161]]}}},{"text":"Prior to Java 9, you would have used Class.newInstance","label":{"api":{"Class.newInstance":[[37,53]]}}},{"text":"A more robust route is to go through Class.getDeclaredConstructors or Class.getConstructors, which takes you into using the Reflection stuff in the java.lang.reflect package, to find a constructor with the parameter types matching the arguments you intend to give it","label":{"api":{"Class.getDeclaredConstructors":[[37,65]],"Class.getConstructors":[[70,90]],"java.lang.reflect":[[148,164]]}}},{"text":"There's no other feasible option than ServletContextListener","label":{"api":{"ServletContextListener":[[38,59]]}}},{"text":"If you're already on Servlet 3.0, then you could just annotate it with @WebListener, ship it with the webapp and it will be automagically loaded","label":{"api":{"@WebListener":[[71,82]]}}},{"text":"You can try to catch InterruptedIOException","label":{"api":{"InterruptedIOException":[[21,42]]}}},{"text":"Use a collection such as Vector<T> instead","label":{"api":{"Vector<T>":[[25,33]]}}},{"text":"Set.copyOf returns an unmodifiable Set containing the elements of the given Collection","label":{"api":{"Set.copyOf":[[0,9]],"Set":[[35,37]],"Collection":[[76,85]]}}},{"text":"A third option is to use a PropertyChangeListener, as shown here and here","label":{"api":{"PropertyChangeListener":[[27,48]]}}},{"text":"After converting all my code to use java.nio.Path EVERYTHING started working","label":{"api":{"java.nio.Path":[[36,48]]}}},{"text":"And I replaced apache FileUtils (which has the same problem) with java.nio.Files..","label":{"api":{"FileUtils":[[22,30]],"java.nio.Files":[[66,79]]}}},{"text":"An Executor needs to be set in order to make an Endpoint multi-threaded","label":{"api":{"Executor ":[[3,11]]}}},{"text":"Write a ServletContextListener which populates the database and does the work in the contextInitialized() method","label":{"api":{"ServletContextListener":[[8,29]],"contextInitialized()":[[85,104]]}}},{"text":"If the listener is configured in your web.xml, the servlet container will invoke your listener's contextInitialized() method when the webapp is started","label":{"api":{"contextInitialized()":[[97,116]]}}},{"text":"Taking another approach to this using Java 8's Stream functionality, for any number of booleans with an arbitrary required amount","label":{"api":{"Stream":[[47,52]]}}},{"text":"The Stream short circuits if it hits the limit before processing all of the elements","label":{"api":{"Stream":[[4,9]]}}},{"text":"Some frameworks may support @ConstructorProperties as an alternative","label":{"api":{"@ConstructorProperties":[[28,49]]}}},{"text":"It's then available by HttpServletRequest#getRemoteAddr()","label":{"api":{"HttpServletRequest#getRemoteAddr()":[[23,56]]}}},{"text":"I had a similar problem to yours (except I wasn't dealing with enums, I needed the value of a non-String/non-primitive constant) and got it solved by accessing the source code via the Compiler Tree API","label":{"api":{"Compiler Tree":[[184,196]]}}},{"text":"You need to collect them all in a Map using a HttpSessionListener yourself","label":{"api":{"Map":[[34,36]],"HttpSessionListener":[[46,64]]}}},{"text":"Once you get the HttpServletRequest via the @Context, you can access any of the methods of HttpServletRequest","label":{"api":{"HttpServletRequest":[[17,34],[91,108]],"@Context":[[44,51]]}}},{"text":"To hash a string, use the built-in MessageDigest class","label":{"api":{"MessageDigest":[[35,47]]}}},{"text":"In a JEE6+ environment one could also use JAXB DataTypeConverter","label":{"api":{"DataTypeConverter":[[47,63]]}}},{"text":"Starting from Java 9, there is a new utility method allowing to create an immutable entry which is Map#entry(Object, Object)","label":{"api":{"Map#entry(Object, Object)":[[99,123]]}}},{"text":"The other limitations are the fact that it is not serializable and null as key or value is forbidden, if it is not acceptable for you, you will need to use AbstractMap.SimpleImmutableEntry or AbstractMap.SimpleEntry instead","label":{"api":{"AbstractMap.SimpleImmutableEntry":[[156,187]],"AbstractMap.SimpleEntry":[[192,214]]}}},{"text":"If your need is to create directly a Map with 0 to up to 10 (key, value) pairs, you can instead use the methods of type Map.of(K key1, V value1, ...)","label":{"api":{"Map":[[37,39]],"Map.of(K key1, V value1, ...)":[[120,148]]}}},{"text":"Perhaps extend ArrayBlockingQueue","label":{"api":{"ArrayBlockingQueue":[[15,32]]}}},{"text":"In Java, you can use the BigInteger class to store arbitrarily large integers","label":{"api":{"BigInteger":[[25,34]]}}},{"text":"The file's content is available in the request body by HttpServletRequest#getInputStream()","label":{"api":{"HttpServletRequest#getInputStream()":[[55,89]]}}},{"text":"Just write it to any OutputStream to your taste the usual Java IO way, e.g","label":{"api":{"OutputStream":[[21,32]]}}},{"text":"FileOutputStream to write it to a local file","label":{"api":{"FileOutputStream":[[0,15]]}}},{"text":"An example is RoleList::add(role) that throws an exception when adding a Null value","label":{"api":{"RoleList::add(role)":[[14,32]]}}},{"text":"Just get the session by HttpServletRequest#getSession() and use its setAttribute() method to store objects in session and getAttribute() to get them from session","label":{"api":{"HttpServletRequest#getSession()":[[24,54]],"setAttribute()":[[68,81]],"getAttribute()":[[122,135]]}}},{"text":"Note that java11 now offers a new HTTP api HttpClient, which support fully asynchronous operation, using java's CompletableFuture","label":{"api":{"HttpClient":[[43,52]],"CompletableFuture":[[112,128]]}}},{"text":"It also support a synchronous version, with calls like send, which is synchronous, and sendAsync, which is asynchronous","label":{"api":{"send":[[55,58]],"sendAsync":[[87,95]]}}},{"text":"You will need to use XAResource to wrap the participants in the transaction so that they can be enlisted in the distributed transaction","label":{"api":{"XAResource":[[21,30]]}}},{"text":"The master will need to send commit/rollback messages to the slaves, which will need to use XATerminator to act accordingly","label":{"api":{"XATerminator":[[92,103]]}}},{"text":"If it's JPA, you need to use an entity method with the @PrePersist or @PostPersist annotation","label":{"api":{"@PrePersist":[[55,65]],"@PostPersist":[[70,81]]}}},{"text":"It's helpful to think of a JTree as a view of the underlying TreeModel","label":{"api":{"JTree":[[27,31]],"TreeModel":[[61,69]]}}},{"text":"An example implementation of TreeModel, intended for use with org.netbeans.swing.outline.Outline, illustrates a hierarchical FileTreeModel that may guide you","label":{"api":{"TreeModel":[[29,37]],"org.netbeans.swing.outline.Outline":[[62,95]],"FileTreeModel":[[125,137]]}}},{"text":"As you are using Oracle, you may find the article Dynamic JTree from database query helpful, too","label":{"api":{"JTree":[[58,62]]}}},{"text":"The article Understanding the TreeModel may be helpful, too","label":{"api":{"TreeModel":[[30,38]]}}},{"text":"See also this related example that uses FileTreeModel","label":{"api":{"FileTreeModel":[[40,52]]}}},{"text":"If you are using Java 1.7, you can use java.nio.file.Files.walkFileTree(...)","label":{"api":{"java.nio.file.Files.walkFileTree(...)":[[39,75]]}}},{"text":"If you are using Java 8, you can use the stream interface with java.nio.file.Files.walk(...)","label":{"api":{"java.nio.file.Files.walk(...)":[[63,91]]}}},{"text":"You should prefer the ClassLoader as returned by Thread#getContextClassLoader()","label":{"api":{"ClassLoader":[[22,32]],"Thread#getContextClassLoader()":[[49,78]]}}},{"text":"If you opt for using the Thread#getContextClassLoader(), remove the leading /","label":{"api":{"Thread#getContextClassLoader()":[[25,54]]}}},{"text":"The JSF-specific ExternalContext#getResourceAsStream() which uses ServletContext#getResourceAsStream() \"under the hoods\" only returns resources from the webcontent (there where the /WEB-INF folder is sitting), not from the classpath","label":{"api":{"ExternalContext#getResourceAsStream()":[[17,53]],"ServletContext#getResourceAsStream()":[[66,101]]}}},{"text":"See also javadoc of Connection#close() (emphasis not mine)","label":{"api":{"Connection#close()":[[20,37]]}}},{"text":"I have tried to configure ActiveMQXAConnectionFactory directly in Spring (I am using Spring 3.0.2.RELEASE), but this does not work, because in this case Spring transaction manager (I use annotation  to let Spring configure JtaTransactionManager which simply delegates all the work to Jboss transaction manager) does not enlist XAResource for given ActiveMQXAConnection","label":{"api":{"ActiveMQXAConnectionFactory":[[26,52]],"JtaTransactionManager":[[223,243]],"ActiveMQXAConnection":[[348,367]]}}},{"text":"Since that did not work, I have switched to JCA configuration of ActiveMQ ConnectionFactory (based on this document) and it works for regular ConnectionFactory, but I do not understand how can I configure it to use XAConnectionFactory","label":{"api":{"ActiveMQ ConnectionFactory":[[65,90]],"ConnectionFactory":[[142,158]],"XAConnectionFactory":[[215,233]]}}},{"text":"It seems like Resource Adapter simply does not have proper ManagedConnectionFactory, ManagedConnection, etc","label":{"api":{"Resource Adapter":[[14,29]],"ManagedConnectionFactory":[[59,82]],"ManagedConnection":[[85,101]]}}},{"text":"a @ViewScoped bean in combination with a <h:dataTable> basically already suffices","label":{"api":{"@ViewScoped":[[2,12]]}}},{"text":"To get the <Context path> value from context.xml, use ServletContext#getContextPath()","label":{"api":{"ServletContext#getContextPath()":[[54,84]]}}},{"text":"you are supposed to run your JPA code inside a transaction and it looks like you aren't, hence the TransactionRequiredException","label":{"api":{"TransactionRequiredException":[[99,126]]}}},{"text":"You can specify a ThreadFactory in the ThreadPoolExecutor constructor (or Executors factory method)","label":{"api":{"ThreadFactory":[[18,30]],"ThreadPoolExecutor":[[39,56]],"Executors":[[74,82]]}}},{"text":"If there may be duplicate keys, you can aggregate the values with the toMap overload that takes a value merge function, or you can use groupingBy to collect into a list","label":{"api":{"toMap":[[70,74]],"groupingBy":[[135,144]]}}},{"text":"In that case you might use toConcurrentMap or groupingByConcurrent, as they allow the stream implementation to just blast elements into a ConcurrentMap instead of making separate maps for each thread and then merging them","label":{"api":{"toConcurrentMap":[[27,41]],"groupingByConcurrent":[[46,65]],"ConcurrentMap":[[138,150]]}}},{"text":"Just add your data to a DefaultListModel, and use it to construct your list","label":{"api":{"DefaultListModel":[[24,39]]}}},{"text":"As @nanda suggests, use ExcecutorService.shutdown() to wait until a pool of threads has finished","label":{"api":{"ExcecutorService.shutdown()":[[24,50]]}}},{"text":"In Java 7 you can also use the Path interface","label":{"api":{"Path":[[31,34]]}}},{"text":"You could make use of String#split() taking a limit as 2nd argument","label":{"api":{"String#split()":[[22,35]]}}},{"text":"If java.beans API were available, then you could just do","label":{"api":{"java.beans":[[3,12]]}}},{"text":"In Java, there's the java.net.Socket API for this","label":{"api":{"java.net.Socket":[[21,35]]}}},{"text":"The default implementation in the InputStream class does nothing, as described in the API","label":{"api":{"InputStream":[[34,44]]}}},{"text":"To be sure of this, you should wrap it in a BufferedInputStream, which does supports these methods","label":{"api":{"BufferedInputStream":[[44,62]]}}},{"text":"You are on the right track using ConcurrentHashMap","label":{"api":{"ConcurrentHashMap":[[33,49]]}}},{"text":"Check out the methods putIfAbsent and replace both are threadsafe and combine checking current state of hashmap and updating it into one atomic operation","label":{"api":{"putIfAbsent":[[22,32]],"replace":[[38,44]],"hashmap":[[104,110]]}}},{"text":"The get method is not synchronized internally but will return the most recent value for the specified key available to it (check the ConcurrentHashMap class Javadoc for discussion)","label":{"api":{"get":[[4,6]],"ConcurrentHashMap":[[133,149]]}}},{"text":"The benefit of ConcurrentHashMap over something like Collections.synchronizedMap is the combined methods like putIfAbsent which provide traditional Map get and put logic in an internally synchronized way","label":{"api":{"ConcurrentHashMap":[[15,31]],"Collections.synchronizedMap":[[53,79]],"putIfAbsent":[[110,120]],"Map":[[148,150]]}}},{"text":"Use these methods and do not try to provide your own custom synchronization over ConcurrentHashMap as it will not work","label":{"api":{"ConcurrentHashMap":[[81,97]]}}},{"text":"synchronize(myConcurrentHashMap){} will not block other threads)","label":{"api":{}}},{"text":"You can get all classpath roots by passing an empty String into ClassLoader#getResources()","label":{"api":{"ClassLoader#getResources()":[[64,89]]}}},{"text":"You can construct a File based on URL as follows","label":{"api":{"File":[[20,23]],"URL":[[34,36]]}}},{"text":"You can use File#listFiles() to get a list of all files in the given directory","label":{"api":{"File#listFiles()":[[12,27]]}}},{"text":"You can use the standard java.io.File methods to check if it's a directory and/or to grab the filename","label":{"api":{"java.io.File":[[25,36]]}}},{"text":"UIData components can only iterate over an T[], List<E> or a DataModel<E>, not over a Set<E> because there's no way to identify an element in a Set<E> by an index, while it is required in UIData components","label":{"api":{"List<E>":[[48,54]],"DataModel<E>":[[61,72]],"Set<E>":[[86,91],[144,149]]}}},{"text":"Other ways are to configure JPA to use List<E> instead or to add a getter which wraps it in a List<E> or DataModel<E> and use it instead in UIData component","label":{"api":{"List<E>":[[39,45],[94,100]],"DataModel<E>":[[105,116]]}}},{"text":"in the upcoming JSF 2.2, the UIData will finally support Collection<E>, which thus includes Set<E>","label":{"api":{"UIData":[[29,34]],"Collection<E>":[[57,69]],"Set<E>":[[92,97]]}}},{"text":"You can make use of java.text.Normalizer and a little regex to get rid of the diacritical marks","label":{"api":{"java.text.Normalizer":[[20,39]]}}},{"text":"I understand that the SecurityRequestWrapper you're talking about already implements HttpServletRequestWrapper","label":{"api":{"SecurityRequestWrapper":[[22,43]],"HttpServletRequestWrapper":[[85,109]]}}},{"text":"You could use java.math.BigDecimal and its method divideAndRemainder()","label":{"api":{"java.math.BigDecimal":[[14,33]],"divideAndRemainder()":[[50,69]]}}},{"text":"The System class has a setOut and setErr that can be used to change the output stream to, for example, a new PrintStream with a backing File or, in this case, probably another stream which uses your logging subsystem of choice","label":{"api":{"System":[[4,9]],"setOut":[[23,28]],"setErr":[[34,39]],"PrintStream":[[109,119]],"File":[[136,139]]}}},{"text":"You can make use of List#removeAll()","label":{"api":{"List#removeAll()":[[20,35]]}}},{"text":"For that you can perfectly let the model object representing the logged in user implement HttpSessionBindingListener","label":{"api":{"HttpSessionBindingListener":[[90,115]]}}},{"text":"See the JavaDocs of the List interface","label":{"api":{"List":[[24,27]]}}},{"text":"Let them share a single thread executor and submit the tasks to it instead","label":{"api":{"single thread executor":[[17,38]]}}},{"text":"Update as per the comments on the answer of @extraneon, using new BigInteger(byte[]) is also the wrong solution","label":{"api":{"BigInteger(byte[])":[[66,83]]}}},{"text":"EventListenerList has a method, getListeners(Class<T> t), specifically for the case where you are only interested in one event type","label":{"api":{"EventListenerList":[[0,16]],"getListeners(Class<T> t)":[[32,55]]}}},{"text":"Added to Comparator in Java 8","label":{"api":{"Comparator":[[9,18]]}}},{"text":"You can capture the response body by replacing the passed-in ServletResponse with a HttpServletResponseWrapper implementation which replaces the HttpServletResponse#getWriter() with an own implementation which copies the response body into some buffer","label":{"api":{"ServletResponse":[[61,75]],"HttpServletResponseWrapper":[[84,109]],"HttpServletResponse#getWriter()":[[145,175]]}}},{"text":"In addition, the code relies on the thread safety of append()","label":{"api":{"append()":[[53,60]]}}},{"text":"In Java 7, append() is no longer marked as thread safe; invokeLater() is used in display() to sequence updates","label":{"api":{"append()":[[11,18]],"invokeLater()":[[56,68]],"display()":[[81,89]]}}},{"text":"See also SimpleDateFormat javadoc","label":{"api":{"SimpleDateFormat":[[9,24]]}}},{"text":"The ExceptionInInitializerError is designed for exactly this purpose","label":{"api":{"ExceptionInInitializerError":[[4,30]]}}},{"text":"An ExceptionInInitializerError is thrown to indicate that an exception occurred during evaluation of a static initializer or the initializer for a static variable","label":{"api":{"ExceptionInInitializerError":[[3,29]]}}},{"text":"You can grab generic interfaces of a class by Class#getGenericInterfaces() which you then in turn check if it's a ParameterizedType and then grab the actual type arguments accordingly","label":{"api":{"Class#getGenericInterfaces()":[[46,73]],"ParameterizedType":[[114,130]]}}},{"text":"To send them back in the subsequent requests, you should set them one by one using URLConnection#addRequestProperty()","label":{"api":{"URLConnection#addRequestProperty()":[[83,116]]}}},{"text":"You normally want to use UIViewRoot#getViewId() for this","label":{"api":{"UIViewRoot#getViewId()":[[25,46]]}}},{"text":"Make use of it and create a class which extends InputStream (maybe DataInputStream or better, some Reader since you're actually interested in characters, not in bytes, but ala), add a constructor which takes the original InputStream and override the read() methods to read the original stream in, buffer it to a certain degree (e.g","label":{"api":{"InputStream":[[48,58],[221,231]],"DataInputStream":[[67,81]],"Reader":[[99,104]],"read()":[[250,255]]}}},{"text":"Per the javadoc, MessageFormat objects are not thread-safe","label":{"api":{"MessageFormat":[[17,29]]}}},{"text":"You can use a ThreadLocal to create a separate object for each thread that needs one","label":{"api":{"ThreadLocal":[[14,24]]}}},{"text":"You can then use threadLocalMessageFormat.get() to obtain a MessageFormat for the current thread","label":{"api":{"threadLocalMessageFormat.get()":[[17,46]],"MessageFormat":[[60,72]]}}},{"text":"The print() function in turn can be replaced by just printing this since System.out.println(object) under the hoods returns String.valueOf(object) which in turn under the hoods returns object != null","label":{"api":{"print()":[[4,10]],"System.out.println(object)":[[73,98]],"String.valueOf(object)":[[124,145]]}}},{"text":"When something fails in meanwhile, either throw ServletException (which will end up in a server default error page with status code 500), or use HttpServletResponse#sendError() to send a more specific error status","label":{"api":{"ServletException":[[48,63]],"HttpServletResponse#sendError()":[[145,175]]}}},{"text":"According to Javadocs, file.toURL() is deprecated","label":{"api":{"file.toURL()":[[23,34]]}}},{"text":"ResultSet.getDate() returns a java.sql.Date, not a java.util.Date","label":{"api":{"ResultSet.getDate()":[[0,18]],"java.sql.Date":[[30,42]],"java.util.Date":[[51,64]]}}},{"text":"If you want a timestamp, use ResultSet.getTimestamp()","label":{"api":{"ResultSet.getTimestamp()":[[29,52]]}}},{"text":"You should throw a NoSuchElementException as that's exactly what the Collections.max() method does","label":{"api":{"NoSuchElementException":[[19,40]],"Collections.max()":[[69,85]]}}},{"text":"If you want to wait for all tasks to complete, use the shutdown method instead of wait","label":{"api":{"shutdown":[[55,62]]}}},{"text":"Then follow it with awaitTermination","label":{"api":{"awaitTermination":[[20,35]]}}},{"text":"Also, you can use Runtime.availableProcessors to get the number of hardware threads so you can initialize your threadpool properly","label":{"api":{"Runtime.availableProcessors":[[18,44]]}}},{"text":"If you want to wait for the executor service to finish executing, call shutdown() and then, awaitTermination(units, unitType), e.g","label":{"api":{"shutdown()":[[71,80]],"awaitTermination(units, unitType)":[[92,124]]}}},{"text":"If waiting for all tasks in the ExecutorService to finish isn't precisely your goal, but rather waiting until a specific batch of tasks has completed, you can use a CompletionService â€” specifically, an ExecutorCompletionService","label":{"api":{"ExecutorService":[[32,46]],"CompletionService":[[165,181]],"ExecutorCompletionService":[[202,226]]}}},{"text":"The idea is to create an ExecutorCompletionService wrapping your Executor, submit some known number of tasks through the CompletionService, then draw that same number of results from the completion queue using either take() (which blocks) or poll() (which does not)","label":{"api":{"ExecutorCompletionService":[[25,49]],"submit":[[75,80]],"CompletionService":[[121,137]],"take()":[[217,222]],"poll()":[[242,247]]}}},{"text":"Once you've drawn all the expected results corresponding to the tasks you submitted, you know they're all done","label":{"api":{}}},{"text":"You must know how many things you put into the CompletionService in order to know how many things to try to draw out","label":{"api":{"CompletionService":[[47,63]]}}},{"text":"This matters especially with the take() method","label":{"api":{"take()":[[33,38]]}}},{"text":"call it one time too many and it will block your calling thread until some other thread submits another job to the same CompletionService","label":{"api":{"CompletionService":[[120,136]]}}},{"text":"There are some examples showing how to use CompletionService in the book Java Concurrency in Practice","label":{"api":{"CompletionService":[[43,59]]}}},{"text":"Sounds like you need ForkJoinPool and use the global pool to execute tasks","label":{"api":{"ForkJoinPool":[[21,32]]}}},{"text":"I am not sure about how Grails fits in the picture, but talking in Java Servlet API, you'd like to use HttpSessionListener#sessionDestroyed() for this","label":{"api":{"Servlet":[[72,78]],"HttpSessionListener#sessionDestroyed()":[[103,140]]}}},{"text":"You can also just let the User model implement HttpSessionBindingListener","label":{"api":{"User":[[26,29]],"HttpSessionBindingListener":[[47,72]]}}},{"text":"Else you're not overriding the real Object#equals(), but rather overloading it","label":{"api":{"Object#equals()":[[36,50]]}}},{"text":"Use the System.setProperty() method","label":{"api":{"System.setProperty()":[[8,27]]}}},{"text":"The RequestDispatcher#forward() is entirely server-side","label":{"api":{"RequestDispatcher#forward()":[[4,30]]}}},{"text":"You can however redirect to the given URL using HttpServletResponse#sendRedirect()","label":{"api":{"HttpServletResponse#sendRedirect()":[[48,81]]}}},{"text":"The HttpServletRequest#setCharacterEncoding() has only effect when the request is a POST request and the request body is not processed yet","label":{"api":{"HttpServletRequest#setCharacterEncoding()":[[4,44]]}}},{"text":"There are several of them","label":{"api":{}}},{"text":"Instead of StringBuffer you probably mean StringBuilder","label":{"api":{"StringBuffer":[[11,22]],"StringBuilder":[[42,54]]}}},{"text":"A StringBuffer is like a StringBuilder except that it also offers thread safety","label":{"api":{"StringBuffer":[[2,13]],"StringBuilder":[[25,37]]}}},{"text":"You can add headers using URLConnection#setRequestProperty()","label":{"api":{"URLConnection#setRequestProperty()":[[26,59]]}}},{"text":"That said, I would rather use File#createTempFile() to let the underlying platform do the automatic cleanup work and to avoid potential portability trouble caused by using relative paths in File","label":{"api":{"File#createTempFile()":[[30,50]]}}},{"text":"As you can see I need the mock to implement the interface of javax.persistence.Query, which returns a java.util.List","label":{"api":{"javax.persistence.Query":[[61,83]],"java.util.List":[[102,115]]}}},{"text":"You can also just use ExternalContext#redirect()","label":{"api":{"ExternalContext#redirect()":[[22,47]]}}},{"text":"Using the String.intern() method you can add any string you like to the internally pooled strings, these will be kept in memory until java exits","label":{"api":{"String.intern()":[[10,24]]}}},{"text":"Once you set the Connection#setAutoCommit() to false (or configure it to be by default), then the transaction will start and it will finish when you call Connection#commit()","label":{"api":{"Connection#setAutoCommit()":[[17,42]],"Connection#commit()":[[154,172]]}}},{"text":"The output target can namely be changed using System#setOut()","label":{"api":{"System#setOut()":[[46,60]]}}},{"text":"To be absolutely sure, I would use BigDecimal.divide(BigDecimal, int, int)","label":{"api":{"BigDecimal.divide(BigDecimal, int, int)":[[35,73]]}}},{"text":"You can test expired sessions by checking if HttpServletRequest#getRequestedSessionId() doesn't return null (which means that the client has sent a session cookie and thus assumes that the session is still valid) and HttpServletRequest#isRequestedSessionIdValid() returns false (which means that the session has been expired at the server side)","label":{"api":{"HttpServletRequest#getRequestedSessionId()":[[45,86]],"HttpServletRequest#isRequestedSessionIdValid()":[[217,262]]}}},{"text":"See Java documentation for EventQueue","label":{"api":{"EventQueue":[[27,36]]}}},{"text":"Rather use ScheduledExecutorService#scheduleAtFixedRate() instead of the old fashioned Thread#sleep()","label":{"api":{"ScheduledExecutorService#scheduleAtFixedRate()":[[11,56]],"Thread#sleep()":[[87,100]]}}},{"text":"You can use ServletContextListener to run it on webapp's startup and stop it on webapp's shutdown","label":{"api":{"ServletContextListener":[[12,33]]}}},{"text":"The best what you can control is the thread priority","label":{"api":{}}},{"text":"Change the destination of the stdout using System#setOut() and eventually also the stderr","label":{"api":{"System#setOut()":[[43,57]]}}},{"text":"You can acquire a FileLock via a FileChannel","label":{"api":{"FileLock":[[18,25]],"FileChannel":[[33,43]]}}},{"text":"To obtain a FileChannel","label":{"api":{"FileChannel":[[12,22]]}}},{"text":"In this release a file channel can be obtained from an existing FileInputStream, FileOutputStream, or RandomAccessFile object by invoking that object's getChannel method, which returns a file channel that is connected to the same underlying file","label":{"api":{"FileInputStream":[[64,78]],"FileOutputStream":[[81,96]],"RandomAccessFile":[[102,117]],"getChannel":[[152,161]]}}},{"text":"But I'm going to take a stab in the dark and suggest you look at ServletContextListener","label":{"api":{"ServletContextListener":[[65,86]]}}},{"text":"DocumentBuilderFactory has a newInstance() method where you can specify the class name of the implementation you want to use","label":{"api":{"DocumentBuilderFactory":[[0,21]],"newInstance()":[[29,41]]}}},{"text":"If you still want to restore the original String later on, try something like this","label":{"api":{"String":[[42,47]]}}},{"text":"Collection is the root interface to the java Collections hierarchy","label":{"api":{"Collection":[[0,9]]}}},{"text":"List is  one sub interface which defines an ordered Collection, other sub interfaces are  Queue which typically will store elements ready for processing (e.g","label":{"api":{"List":[[0,3]],"Collection":[[52,61]],"Queue":[[90,94]]}}},{"text":"a List is a Collection","label":{"api":{"List":[[2,5]],"Collection":[[12,21]]}}},{"text":"It is a specialized Collection, however","label":{"api":{"Collection":[[20,29]]}}},{"text":"A Collection is just that","label":{"api":{"Collection":[[2,11]]}}},{"text":"A List adds the information about a defined sequence of stuff to it","label":{"api":{"List":[[2,5]]}}},{"text":"In a Collection you can't do that","label":{"api":{"Collection":[[5,14]]}}},{"text":"There are other specialized Collections as well, for example a Set which adds the feature that it will never contain the same element twice","label":{"api":{"Set":[[63,65]]}}},{"text":"They are located in the java.util.Arrays class","label":{"api":{"java.util.Arrays":[[24,39]]}}},{"text":"Since version 6.0.24, Tomcat ships with a memory leak detection feature, which in turn can lead to this kind of warning messages when there's a JDBC 4.0 compatible driver in the webapp's /WEB-INF/lib which auto-registers itself during webapp's startup using the ServiceLoader API, but which did not auto-deregister itself during webapp's shutdown","label":{"api":{"ServiceLoader":[[262,274]]}}},{"text":"If you still keep it in webapp's /WEB-INF/lib, then you should manually register and deregister it using a ServletContextListener","label":{"api":{"ServletContextListener":[[107,128]]}}},{"text":"Note that Tomcat's builtin DBCP does not deregister drivers properly on close","label":{"api":{}}},{"text":"Use java.text.Normalizer to handle this for you","label":{"api":{"java.text.Normalizer":[[4,23]]}}},{"text":"The <servlet-class> subelement of <servlet> points out a class that implements javax.servlet.Servlet, which is a rudimentary interface for classes handling web requests","label":{"api":{"javax.servlet.Servlet":[[79,99]]}}},{"text":"The class java.awt.BufferedImage has a method setRGB(int x, int y, int rgb) which sets the color of an individual pixel","label":{"api":{"java.awt.BufferedImage":[[10,31]],"setRGB(int x, int y, int rgb)":[[46,74]]}}},{"text":"Additionally, you might want to look at java.awt.Color, especially its getRGB() method, which can convert Colors into integers that you can put into the int rgb parameter of setRGB","label":{"api":{"java.awt.Color":[[40,53]],"getRGB()":[[71,78]],"setRGB":[[174,179]]}}},{"text":"Use byteBufferViewVarHandle or byteArrayViewVarHandle","label":{"api":{"byteBufferViewVarHandle":[[4,26]],"byteArrayViewVarHandle":[[31,52]]}}},{"text":"Java provides concurrent API to avail advantages of multi-core processors of machine","label":{"api":{"concurrent":[[14,23]]}}},{"text":"You can get available processors count from Runtime and use that count to create ExecutorService through many APIs in Executors","label":{"api":{"Runtime":[[44,50]],"ExecutorService":[[81,95]],"Executors":[[118,126]]}}},{"text":"You can also use ThreadPoolExecutor API to achieve the same","label":{"api":{"ThreadPoolExecutor":[[17,34]]}}},{"text":"Java's Fork/Join vs ExecutorService - when to use which","label":{"api":{"Fork":[[7,10]],"Join":[[12,15]],"ExecutorService":[[20,34]]}}},{"text":"Check out the Javadoc for File.list()","label":{"api":{"File.list()":[[26,36]]}}},{"text":"catch the InterruptedException","label":{"api":{"InterruptedException":[[10,29]]}}},{"text":"Java 8 added Map.forEach which you can use like this","label":{"api":{"Map.forEach":[[13,23]]}}},{"text":"There's also replaceAll if you want to update the values","label":{"api":{"replaceAll":[[13,22]]}}},{"text":"Refer to the API specification for the DataInput.readFully method","label":{"api":{"DataInput.readFully":[[39,57]]}}},{"text":"You want to split on every character, so rather use string.split(\"\")","label":{"api":{"string.split(\"\")":[[52,67]]}}},{"text":"Or better, just iterate over every character returned by string.toCharArray()","label":{"api":{"string.toCharArray()":[[57,76]]}}},{"text":"CODe's answer is right, but I'd go with the SwingWorker class","label":{"api":{"SwingWorker":[[44,54]]}}},{"text":"Try ConcurrentLinkedQueue or LinkedBlockingDeque instead if it fits your needs, they are thread safe but slightly different behavior than LinkedList","label":{"api":{"ConcurrentLinkedQueue":[[4,24]],"LinkedBlockingDeque":[[29,47]],"LinkedList":[[138,147]]}}},{"text":"If you create an anonymous subclass new TypeLiteral<List<String>>() {} Guice can call getClass().getGenericSuperclass() on it and get a java.lang.reflect.ParameterizedType on which exists a method getActualTypeArguments() to get List<String> as an instance of ParameterizedType","label":{"api":{"TypeLiteral<List<String>>()":[[40,66]],"getClass().getGenericSuperclass()":[[86,118]],"java.lang.reflect.ParameterizedType":[[136,170]],"getActualTypeArguments()":[[197,220]],"List<String>":[[229,240]]}}},{"text":"There are methods in the InetAddress class for that","label":{"api":{"InetAddress":[[25,35]]}}},{"text":"I think you'll want either getHostName or getCanonicalHostName, depending on your need","label":{"api":{"getHostName":[[27,37]],"getCanonicalHostName":[[42,61]]}}},{"text":"The certificate objects can be created by an instance of CertificateFactory - in particular, one configured to create X509 certificates","label":{"api":{"CertificateFactory":[[57,74]]}}},{"text":"This can be achieved by wrapping your byte array in a ByteArrayInputStream","label":{"api":{"ByteArrayInputStream":[[54,73]]}}},{"text":"Convert it to String and use String#toCharArray() or String#split()","label":{"api":{"String":[[14,19]],"String#toCharArray()":[[29,48]],"String#split()":[[53,66]]}}},{"text":"In case you're already on Java 8 and you happen to want to do some aggregate operations on it afterwards, consider using String#chars() to get an IntStream out of it","label":{"api":{"String#chars()":[[121,134]],"IntStream":[[146,154]]}}},{"text":"As of Java 8, the String class has a static method join","label":{"api":{"String":[[18,23]],"join":[[51,54]]}}},{"text":"Also in Java 8, you could use the new StringJoiner class, for scenarios where you want to start constructing the string before you have the full list of elements to put in it","label":{"api":{"StringJoiner":[[38,49]]}}},{"text":"You may use java.nio.Buffer classes hierarchy, especially java.nio.ByteBuffer which offers buffer abstraction on whole array or sub-ranges","label":{"api":{"java.nio.Buffer":[[12,26]],"java.nio.ByteBuffer":[[58,76]]}}},{"text":"Here is example of wrapping using java.nio.ByteBuffer","label":{"api":{"java.nio.ByteBuffer":[[34,52]]}}},{"text":"To set thousand separator, say 123,456.78 you have to use DecimalFormat","label":{"api":{"DecimalFormat":[[58,70]]}}},{"text":"For example, if you were using BlockingQueue.poll(long, TimeUnit), you could check if the result is null to know if you timed out","label":{"api":{"BlockingQueue.poll(long, TimeUnit)":[[31,64]]}}},{"text":"In JPA you can do similar using Query#setFirstResult() and Query#setMaxResults()","label":{"api":{"Query#setFirstResult()":[[32,53]],"Query#setMaxResults()":[[59,79]]}}},{"text":"You can use java.lang.Runtime.exec to run simple code","label":{"api":{"java.lang.Runtime.exec":[[12,33]]}}},{"text":"println and print are the two overloaded methods which belong to the PrintStream class","label":{"api":{"PrintStream":[[69,79]]}}},{"text":"A static property called out of type PrintStream is created on the System class","label":{"api":{"PrintStream":[[37,47]],"System":[[67,72]]}}},{"text":"You can achieve what you want by using a custom HttpServletResponse","label":{"api":{"HttpServletResponse":[[48,66]]}}},{"text":"You pass this wrapped HttpServletResponse down the filter chain","label":{"api":{"HttpServletResponse":[[22,40]]}}},{"text":"Splitting an empty string with String.split() returns a single element array containing an empty string","label":{"api":{"String.split()":[[31,44]]}}},{"text":"You'd like to override the HttpServletResponse#addHeader() and HttpServletResponse#setHeader() method instead","label":{"api":{"HttpServletResponse#addHeader()":[[27,57]],"HttpServletResponse#setHeader()":[[63,93]]}}},{"text":"Yes, you need to implement a Converter","label":{"api":{"Converter":[[29,37]]}}},{"text":"Thanks to the @FacesConverter it'll register itself automagically","label":{"api":{"@FacesConverter":[[14,28]]}}},{"text":"If your whole expression is case insensitive, you can just specify the CASE_INSENSITIVE flag","label":{"api":{"CASE_INSENSITIVE":[[71,86]]}}},{"text":"You could use the RuntimeMXBean within the application that is launched by eclipse","label":{"api":{"RuntimeMXBean":[[18,30]]}}},{"text":"As of Java 8 we have another option,  \\R","label":{"api":{}}},{"text":"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html There is a way around this, but it is out of scope of this answer","label":{"api":{}}},{"text":"This works because by default put(..) waits until there is capacity in the queue when it is full, see","label":{"api":{"put(..)":[[30,36]]}}},{"text":"Use the Math.atan2 function","label":{"api":{"Math.atan2":[[8,17]]}}},{"text":"In case you can't avoid breaking Law of Demeter (LoD) as stated in the chosen answer, and with Java 8 introducing Optional, it would be probably the best practice to handle nulls in chains of gets such as yours","label":{"api":{"Optional":[[114,121]]}}},{"text":"The Optional type will enable you to pipe multiple map operations (which contain get calls) in a row","label":{"api":{"Optional":[[4,11]]}}},{"text":"The return of it will be something like Optional<Door> which will allow you much safer work without worrying of null exceptions","label":{"api":{"Optional<Door>":[[40,53]]}}},{"text":"FWIW, if you're opening a file in Java 8, you can use the Files.newBufferedReader(Path)","label":{"api":{"Files.newBufferedReader(Path)":[[58,86]]}}},{"text":"With Java 8 you can also use the toString() method of java.time.Duration to format it without external libraries using ISO 8601 seconds based representation such as PT8H6M12.345S","label":{"api":{"toString()":[[33,42]],"java.time.Duration":[[54,71]]}}},{"text":"Use getOutputSize to determine how big the output buffer should be","label":{"api":{"getOutputSize":[[4,16]]}}},{"text":"So if you're allocating the output buffer \"near\" the point where you call the doFinal method, then it would make sense to call getOutputSize and allocate an appropriately-sized buffer","label":{"api":{"doFinal":[[78,84]],"getOutputSize":[[127,139]]}}},{"text":"It would be perfectly legal (at least, according to the public interface of the Java class) for a Cipher implementation to return an output larger than the block size, so long as the getOutputSize method returns the appropriate size","label":{"api":{"Cipher":[[98,103]],"getOutputSize":[[183,195]]}}},{"text":"Note that this takes a regular expression, so remember to escape special characters if necessary","label":{"api":{}}},{"text":"which means \"any character\" in regex, use either backslash \\ to escape the individual special character like so split(\"\\\\.\"), or use character class [] to represent literal character(s) like so split(\"[.]\"), or use Pattern#quote() to escape the entire string like so split(Pattern.quote(\".\"))","label":{"api":{"split(\"\\\\.\")":[[112,123]],"character":[[133,141]],"split(\"[.]\")":[[194,205]],"Pattern#quote()":[[215,229]],"split(Pattern.quote(\".\"))":[[267,291]]}}},{"text":"To test beforehand if the string contains certain character(s), just use String#contains()","label":{"api":{"String#contains()":[[73,89]]}}},{"text":"Note, this does not take a regular expression","label":{"api":{}}},{"text":"For that, use String#matches() instead","label":{"api":{"String#matches()":[[14,29]]}}},{"text":"For simple use cases String.split() should do the job","label":{"api":{"String.split()":[[21,34]]}}},{"text":"Use InputStream as argument to InputSource when you want Sax to autodetect the encoding","label":{"api":{"InputStream":[[4,14]],"InputSource":[[31,41]]}}},{"text":"If you want to set a specific encoding, use Reader with a specified encoding or setEncoding method","label":{"api":{"Reader":[[44,49]],"setEncoding":[[80,90]]}}},{"text":"Here's an excerpt from java.text.CharacterIterator documentation","label":{"api":{"java.text.CharacterIterator":[[23,49]]}}},{"text":"static final char DONE","label":{"api":{"DONE":[[18,21]]}}},{"text":"There's a similar object for each primitive, and they define the methods you're interested in (hashCode,equals)","label":{"api":{"hashCode":[[95,102]],"equals":[[104,109]]}}},{"text":"For earlier versions, you might try addTab() with a suitable implementation of Icon used to indicate progress","label":{"api":{"addTab()":[[36,43]],"Icon":[[79,82]]}}},{"text":"If you wanna have everything into one only piece of code, then you can mix tim's answer with the example's approach found on the API for JTextField, and you'll get something like this","label":{"api":{"JTextField":[[137,146]]}}},{"text":"Then there is no need to add a Document to the JTextFieldLimit due to JTextFieldLimit already have the functionality inside","label":{"api":{"Document":[[31,38]],"JTextFieldLimit":[[47,61],[70,84]]}}},{"text":"Have a look at javax.swing.tree, TreeModel, and TreeNode","label":{"api":{"javax.swing.tree":[[15,30]],"TreeModel":[[33,41]],"TreeNode":[[48,55]]}}},{"text":"Then you can read these properties using standard (though not too practical) Java Properties API","label":{"api":{"Properties":[[82,91]]}}},{"text":"Apache Commons is not acceptable), and I came up with a simple solution using the built-in java.io.StreamTokenizer","label":{"api":{"java.io.StreamTokenizer":[[91,113]]}}},{"text":"By using a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[11,34]]}}},{"text":"It will allow you to created a ScheduledExecutorService which lets you submit Runnables to be executed at regular intervals","label":{"api":{"ScheduledExecutorService":[[31,54]],"Runnable":[[78,85]]}}},{"text":"The common approach would be to check it with a regular expression like it's also suggested inside the Double.valueOf(String) documentation","label":{"api":{"Double.valueOf(String)":[[103,124]]}}},{"text":"This code is based on the JavaDocs at Double","label":{"api":{"Double":[[38,43]]}}},{"text":"The File class contains the following public members that you can use for platform specific file paths","label":{"api":{"File":[[4,7]]}}},{"text":"If you still want to use the system path separator there is the File.separator property which will give you the right one depending on the current system","label":{"api":{"File.separator":[[64,77]]}}},{"text":"For the root, you can use listRoots() which gives you an array of root, there will be only one element on Unix systems, and as many as you have drives on Windows","label":{"api":{"listRoots()":[[26,36]]}}},{"text":"Check SocketChannel class and its related code samples","label":{"api":{"SocketChannel":[[6,18]]}}},{"text":"If you want something quick and dirty, try inputStream.available()","label":{"api":{"inputStream.available()":[[43,65]]}}},{"text":"Following, you can find a complete example on how to adjust the selected rows, using the ListSelectionModel, including MouseEvent#getModifiers checks","label":{"api":{"ListSelectionModel":[[89,106]],"MouseEvent#getModifiers":[[119,141]]}}},{"text":"After that, it is possible to open a (optional) JPopupMenu","label":{"api":{"JPopupMenu":[[48,57]]}}},{"text":"I've been wondering what the exact meaning of  Runtime.getRuntime().totalMemory(), Runtime.getRuntime().freeMemory(), and Runtime.getRuntime().maxMemory() is","label":{"api":{"Runtime.getRuntime().totalMemory()":[[47,80]],"Runtime.getRuntime().freeMemory()":[[83,115]],"Runtime.getRuntime().maxMemory()":[[122,153]]}}},{"text":"My understanding is, Runtime.getRuntime().totalMemory() returns the total memory my process is using","label":{"api":{"Runtime.getRuntime().totalMemory()":[[21,54]]}}},{"text":"Java has a built-in way of dealing with this, in the java.nio.file.Files class, that may work for your needs","label":{"api":{"java.nio.file.Files":[[53,71]]}}},{"text":"My dirty and may tiniest using String.replaceAll","label":{"api":{"String.replaceAll":[[31,47]]}}},{"text":"Something like this may be useful in, say, any of ImageIO's write methods, where the file format has to be passed in","label":{"api":{"ImageIO":[[50,56]]}}},{"text":"See LocalDateTime API","label":{"api":{"LocalDateTime":[[4,16]]}}},{"text":"Or you copy the code from the IDN class","label":{"api":{"IDN":[[30,32]]}}},{"text":"Use the Toolkit to get the system clipboard","label":{"api":{"Toolkit":[[8,14]]}}},{"text":"Create a StringSelection with the String and add it to the Clipboard","label":{"api":{"StringSelection":[[9,23]],"String":[[34,39]],"Clipboard":[[59,67]]}}},{"text":"For further information, read the documentation","label":{"api":{}}},{"text":"From the Socket#setSoTimeout(int timeout) Documentation","label":{"api":{"Socket#setSoTimeout(int timeout)":[[9,40]]}}},{"text":"But I think you will need a Compound-Renderer, which means you have to create your own CellRenderer implementing TableCellRenderer or extending the existing DefaultTableCellRenderer","label":{"api":{"CellRenderer":[[87,98]],"TableCellRenderer":[[113,129]],"DefaultTableCellRenderer":[[157,180]]}}},{"text":"With Java 8 Optional you can do","label":{"api":{"Optional":[[12,19]]}}},{"text":"ArrayList, HashSet, LinkedList, Stack and Vector","label":{"api":{"ArrayList":[[0,8]],"HashSet":[[11,17]],"LinkedList":[[20,29]],"Stack":[[32,36]],"Vector":[[42,47]]}}},{"text":"I'm surprised no one has answered this, but would'nt you have been better off implementing an editable JSpinner with a SpinnerListModel","label":{"api":{"JSpinner":[[103,110]],"SpinnerListModel":[[119,134]]}}},{"text":"Use the isSelected method","label":{"api":{"isSelected":[[8,17]]}}},{"text":"You can also use an ItemListener so you'll be notified when it's checked or unchecked","label":{"api":{"ItemListener":[[20,31]]}}},{"text":"Here is my diagram showing how String is a one of several concrete classes implementing the CharSequence interface","label":{"api":{"String":[[31,36]],"CharSequence":[[92,103]]}}},{"text":"In particular, StringBuilder is commonly used as a faster alternative to concatenation String objects with the + operator, where thread-safety is not needed","label":{"api":{"StringBuilder":[[15,27]],"String":[[87,92]]}}},{"text":"So, String[] is an array of String objects, and CharSequence[] is an array of objects that may or may not be String objects but definitely are objects implementing the CharSequence interface","label":{"api":{"String":[[4,9],[28,33],[109,114]],"CharSequence":[[48,59],[168,179]]}}},{"text":"You want to use a Set or List implementation (e.g","label":{"api":{"Set":[[18,20]],"List":[[25,28]]}}},{"text":"HashSet, TreeSet, etc, or ArrayList, LinkedList, etc..), since Java does not have dynamically sized arrays","label":{"api":{"HashSet":[[0,6]],"TreeSet":[[9,15]],"ArrayList":[[26,34]],"LinkedList":[[37,46]]}}},{"text":"Here is a more succinct way to initialize your List with an arbitrary number of values using varargs","label":{"api":{"List":[[47,50]]}}},{"text":"The Array.newInstance(Class<?> componentType, int length) method is to be used to create an array with dynamically length","label":{"api":{"Array.newInstance(Class<?> componentType, int length)":[[4,56]]}}},{"text":"After having the same problem and none of these answers helped me, I found out that my UI thread was blocked (I used a CountDownLatch.await()) and therefore the onPostExecute() method that is supposed to be called by the UI thread was never called","label":{"api":{"CountDownLatch.await()":[[119,140]],"onPostExecute()":[[161,175]]}}},{"text":"Is there any way to make DateFormat format a date with a full year (eg","label":{"api":{"DateFormat":[[25,34]]}}},{"text":"12/12/2010), when using DateFormat.SHORT as the pattern","label":{"api":{"DateFormat.SHORT":[[24,39]]}}},{"text":"I know I could use DateFormat.MEDIUM, but the date have to be formatted using only numbers and separators, and DateFormat.MEDIUM for en_US produces something like 'Dec 12, 2010'","label":{"api":{"DateFormat.MEDIUM":[[19,35],[111,127]]}}},{"text":"Starting with Java 8 and later this can be done without external dependencies using Stream API","label":{"api":{"Stream API":[[84,93]]}}},{"text":"Unfortunately, that's also what the DateTimeConverter javadoc is telling","label":{"api":{"DateTimeConverter":[[36,52]]}}},{"text":"You can use the java.io.RandomAccessFile to do this","label":{"api":{"java.io.RandomAccessFile":[[16,39]]}}},{"text":"The methods seek(long) and getFilePointer() will help to jump to different offsets in the file and come back to original offsets","label":{"api":{"seek(long)":[[12,21]],"getFilePointer()":[[27,42]]}}},{"text":"You can also use the computeIfAbsent() method in the HashMap class","label":{"api":{"computeIfAbsent()":[[21,37]],"HashMap":[[53,59]]}}},{"text":"If it exists, then the value for the key will be returned by computeIfAbsent()","label":{"api":{"computeIfAbsent()":[[61,77]]}}},{"text":"If you were interested in getting Path from URL, you can do","label":{"api":{"Path":[[34,37]],"URL":[[44,46]]}}},{"text":"With Java 7, you can use Files.createDirectories()","label":{"api":{"Files.createDirectories()":[[25,49]]}}},{"text":"It seems unnecessary to check for existence of the dir or file before creating, from createDirectories javadocs","label":{"api":{"createDirectories":[[85,101]]}}},{"text":"In the server side you just use HttpServletRequest#getParameter() to obtain the rating value","label":{"api":{"HttpServletRequest#getParameter()":[[32,64]]}}},{"text":"With Java 8, you can filter with a lambda expression using Collection.removeIf","label":{"api":{"Collection.removeIf":[[59,77]]}}},{"text":"All actions performed by a thread before it queues an object on a BlockingQueue \"happen-before\" the object is dequeued","label":{"api":{"BlockingQueue":[[66,78]]}}},{"text":"As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread","label":{"api":{"BlockingQueue":[[92,104],[189,201]]}}},{"text":"Assuming your data model derives from AbstractTableModel, you can update your model explicitly and fire the appropriate update method implemented in the abstract parent","label":{"api":{"AbstractTableModel":[[38,55]]}}},{"text":"You might want to look at the DecimalFormat class; it supports different locales (eg","label":{"api":{"DecimalFormat":[[30,42]]}}},{"text":"nextDouble will return a pseudorandom double value between the minimum (inclusive) and the maximum (exclusive)","label":{"api":{"nextDouble":[[0,9]]}}},{"text":"The official reference is the class Formatter","label":{"api":{"Formatter":[[36,44]]}}},{"text":"You can use Float.compare(float f1, float f2)","label":{"api":{"Float.compare(float f1, float f2)":[[12,44]]}}},{"text":"Did you try JComponent.setBackground(Color c)","label":{"api":{"JComponent.setBackground(Color c)":[[12,44]]}}},{"text":"The document says","label":{"api":{}}},{"text":"Use ProcessBuilder e.g","label":{"api":{"ProcessBuilder":[[4,17]]}}},{"text":"Object.hashCode used to be computed based on a memory location where the object is located","label":{"api":{"Object.hashCode":[[0,14]]}}},{"text":"There is however a method Collections.unmodifiableList(..) which creates an unmodifiable view of e.g","label":{"api":{"Collections.unmodifiableList(..)":[[26,57]]}}},{"text":"There's an option in the FileWriter instead of the CSVWriter to append at the end of the file","label":{"api":{"FileWriter":[[25,34]],"CSVWriter":[[51,59]]}}},{"text":"Upon application startup or servlet initialization use the Executors class","label":{"api":{"Executors":[[59,67]]}}},{"text":"If you are trying to do real work, I suggest you forget that and use Scanner","label":{"api":{"Scanner":[[69,75]]}}},{"text":"Check out setParseBigDecimal in DecimalFormat","label":{"api":{"setParseBigDecimal":[[10,27]],"DecimalFormat":[[32,44]]}}},{"text":"With this setter, parse will return a BigDecimal for you","label":{"api":{"parse":[[18,22]],"BigDecimal":[[38,47]]}}},{"text":"Here's a one-liner version which uses Java 8 IntStream to determine the indexes of the slice beginnings","label":{"api":{"IntStream":[[45,53]]}}},{"text":"split does include empty matches in the result, have a look at the docs here","label":{"api":{"split":[[0,4]]}}},{"text":"What is the difference between returning 0, returning 1 and returning -1 in compareTo() in Java","label":{"api":{"compareTo()":[[76,86]]}}},{"text":"Use the replaceFirst function","label":{"api":{"replaceFirst":[[8,19]]}}},{"text":"From sun.misc.VM, it's Runtime.getRuntime.maxMemory(), that's what is configured with -Xmx","label":{"api":{"sun.misc.VM":[[5,15]],"Runtime.getRuntime.maxMemory()":[[23,52]]}}},{"text":"The Java Class Library represents external processes using the java.lang.Process class","label":{"api":{"Class":[[9,13]],"java.lang.Process":[[63,79]]}}},{"text":"Processes can be spawned using a java.lang.ProcessBuilder","label":{"api":{"java.lang.ProcessBuilder":[[33,56]]}}},{"text":"or the older interface exposed by the overloaded exec methods on the java.lang.Runtime class","label":{"api":{"exec":[[49,52]],"java.lang.Runtime":[[69,85]]}}},{"text":"Both of these will code snippets will spawn a new process, which usually executes asynchronously and can be interacted with through the resulting Process object","label":{"api":{"Process":[[146,152]]}}},{"text":"If you need to check that the process has finished (or wait for it to finish), don't forget to check that the exit value (exit code) returned by process.exitValue() or process.waitFor() is as expected (0 for most programs), since no exception is thrown if the process exits abnormally","label":{"api":{"process.exitValue()":[[145,163]],"process.waitFor()":[[168,184]]}}},{"text":"Also note that additional code is often necessary to handle the process's I/O correctly, as described in the documentation for the Process class (emphasis added)","label":{"api":{"Process":[[131,137]]}}},{"text":"I had a feeling that this constructor has to be inherited from java.lang.Exception, isn't it","label":{"api":{"java.lang.Exception":[[63,81]]}}},{"text":"I use the Scanner class for reading multiple similar files","label":{"api":{"Scanner":[[10,16]]}}},{"text":"If you don't mind doing it programmatically, you can investigate the 1.6 Java Compiler API and Compiler Tree API","label":{"api":{"Compiler":[[78,85]],"Compiler Tree":[[95,107]]}}},{"text":"Use java.sql.Timestamp with PreparedStatement#setTimestamp()","label":{"api":{"java.sql.Timestamp":[[4,21]],"PreparedStatement#setTimestamp()":[[28,59]]}}},{"text":"Note that java.sql.Date stores only the date part, not the time part","label":{"api":{"java.sql.Date":[[10,22]]}}},{"text":"The setDate() expects java.sql.Date, not java.util.Date","label":{"api":{"setDate()":[[4,12]],"java.sql.Date":[[22,34]],"java.util.Date":[[41,54]]}}},{"text":"But the java.sql.Date contains only the date part of datetime, not the time part","label":{"api":{"java.sql.Date":[[8,20]]}}},{"text":"You'd like to use java.sql.Timestamp instead","label":{"api":{"java.sql.Timestamp":[[18,35]]}}},{"text":"Java 8 has added java.util.IntSummaryStatistics","label":{"api":{"java.util.IntSummaryStatistics":[[17,46]]}}},{"text":"The class is called java.util.Scanner (with a capital S)","label":{"api":{"java.util.Scanner":[[20,36]]}}},{"text":"If it's just having to execute something after some time, try using a Timer","label":{"api":{"Timer":[[70,74]]}}},{"text":"This implementation does not make use of  threads to remove expired entries, instead it uses DelayQueue that is cleaned up at every operation automatically","label":{"api":{"DelayQueue":[[93,102]]}}},{"text":"Java 8 introduced the methods addExact, subtractExact, multiplyExact and toIntExact","label":{"api":{"addExact":[[30,37]],"subtractExact":[[40,52]],"multiplyExact":[[55,67]],"toIntExact":[[73,82]]}}},{"text":"JDK7's java.nio.file package has a WatchService to support file change notification","label":{"api":{"java.nio.file":[[7,19]],"WatchService":[[35,46]]}}},{"text":"For now, you can try jpathwatch, which is an implementation of the WatchService interface and uses native OS functions, instead of polling","label":{"api":{"jpathwatch":[[21,30]],"WatchService":[[67,78]]}}},{"text":"Another approach is to use a CopyOnWriteArrayList instead of Collections.synchronizedList()","label":{"api":{"CopyOnWriteArrayList":[[29,48]],"Collections.synchronizedList()":[[61,90]]}}},{"text":"Integer.valueOf(int) will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range","label":{"api":{"Integer.valueOf(int)":[[0,19]]}}},{"text":"One of the solutions is to use Javaâ„¢ Smart Card I/O API","label":{"api":{"Smart Card I/O":[[37,50]]}}},{"text":"See the \"Description\" section for a simple usage example","label":{"api":{}}},{"text":"Inject a HttpServletRequest into your Rest Service as such","label":{"api":{"HttpServletRequest":[[9,26]]}}},{"text":"Basically because an Iterable may never end (that is, hasNext() return true forever)","label":{"api":{"hasNext()":[[54,62]]}}},{"text":"If the file is -as the package name hints- is actually a fullworthy properties file (containing key=value lines) with just the \"wrong\" extension, then you could feed the InputStream immediately to the load() method","label":{"api":{"InputStream":[[170,180]],"load()":[[201,206]]}}},{"text":"Since Java 7 BitSet has the toLongArray method, which I believe will do exactly what the question asks for","label":{"api":{"BitSet":[[13,18]],"toLongArray":[[28,38]]}}},{"text":"Java 7 improves on this sorry state of affairs with the Files class (not to be confused with Guava's class of the same name), you can get all lines from a file - without external libraries - with","label":{"api":{"Files":[[56,60]]}}},{"text":"DatabaseMetaData.getProcedureColumns is the generic JDBC method to get the parameters for a procedure","label":{"api":{"DatabaseMetaData.getProcedureColumns":[[0,35]]}}},{"text":"Java converts bytes read from the file into characters using the specified charset, which is the default one (from underlying OS) if nothing is given (source)","label":{"api":{}}},{"text":"A good place to do such cleanup is ServletRequestListener.requestDestroyed()","label":{"api":{"ServletRequestListener.requestDestroyed()":[[35,75]]}}},{"text":"Look at the SimpleDateFormat doc for complete instructions","label":{"api":{"SimpleDateFormat":[[12,27]]}}},{"text":"In Java's perspective (Thread.State), there are two different states","label":{"api":{"Thread.State":[[23,34]]}}},{"text":"Use String.equals(Object) instead","label":{"api":{"String.equals(Object)":[[4,24]]}}},{"text":"You can subclass ScheduledThreadPoolExecutor and override the afterExecute method to handle exceptions and errors for any kind of Runnable that you submit","label":{"api":{"ScheduledThreadPoolExecutor":[[17,43]],"afterExecute":[[62,73]],"Runnable":[[130,137]]}}},{"text":"Perhaps the best way around this is to use the FileOpenService","label":{"api":{"FileOpenService":[[47,61]]}}},{"text":"Of course, you could always just resort to using Iterator.forEachRemaining()","label":{"api":{"Iterator.forEachRemaining()":[[49,75]]}}},{"text":"See https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html for more details","label":{"api":{}}},{"text":"You should replace your getEnumNameForValue by a call to the name() method","label":{"api":{"getEnumNameForValue":[[24,42]],"name()":[[61,66]]}}},{"text":"There is nothing built in, but you could certainly join all of the elements in your array and pass the resulting string into the Scanner constructor","label":{"api":{"Scanner constructor":[[129,147]]}}},{"text":"A solution with better performance but a greater time investment is to implement Readable by wrapping your array, and keeping track of the current element in the array and the current position in that element's string representation","label":{"api":{"Readable":[[81,88]]}}},{"text":"You can then fill the buffer with data from the backing array as the Scanner reads from your Readable object","label":{"api":{"Scanner":[[69,75]],"Readable":[[93,100]]}}},{"text":"See java.util.Collection.stream() and java.util.stream.Collectors.toList()","label":{"api":{"java.util.Collection.stream()":[[4,32]],"java.util.stream.Collectors.toList()":[[38,73]]}}},{"text":"I think you're looking for Field.get()","label":{"api":{"Field.get()":[[27,37]]}}},{"text":"URLConnection is the base class","label":{"api":{"URLConnection":[[0,12]]}}},{"text":"HttpURLConnection is a derived class which you can use when you need the extra API and you are dealing with HTTP or HTTPS only","label":{"api":{"HttpURLConnection":[[0,16]]}}},{"text":"HttpsURLConnection is a 'more derived' class which you can use when you need the 'more extra' API and you are dealing with HTTPS only","label":{"api":{"HttpsURLConnection":[[0,17]]}}},{"text":"How should I choose between ExecutorService's submit or execute, if the returned value is not my concern","label":{"api":{"ExecutorService":[[28,42]],"submit":[[46,51]],"execute":[[56,62]]}}},{"text":"Maybe you are looking for a CompletionService to manage batches of task, see also this answer","label":{"api":{"CompletionService":[[28,44]]}}},{"text":"Integer.toString calls the static method in the class Integer","label":{"api":{"Integer.toString":[[0,15]],"Integer":[[54,60]]}}},{"text":"It does not need an instance of Integer","label":{"api":{"Integer":[[32,38]]}}},{"text":"If you call new Integer(i) you create an instance of type Integer, which is a full Java object encapsulating the value of your int","label":{"api":{"Integer(i)":[[16,25]],"Integer":[[58,64]]}}},{"text":"Another option is the static String.valueOf method","label":{"api":{"String.valueOf":[[29,42]]}}},{"text":"I recently ran into this problem and just wanted to mention that since java 7 the process builder api has been expanded","label":{"api":{"process builder":[[82,96]]}}},{"text":"Since color appears to be a Color, that's a class, and therefore a reference type, which means you need to use equals() to compare the colors","label":{"api":{"Color":[[28,32]],"equals()":[[111,118]]}}},{"text":"However Java 7 will include a new AsynchronousFileChannel class that supports asynchronous file I/O, which is a different mechanism to non-blocking I/O","label":{"api":{"AsynchronousFileChannel":[[34,56]]}}},{"text":"If the input is quite rigid, then you can simply use String#split(), which should make it very clear what you're doing","label":{"api":{"String#split()":[[53,66]]}}},{"text":"Don't use a StringTokenizer (source)","label":{"api":{"StringTokenizer":[[12,26]]}}},{"text":"Java 7 now has a System.lineSeparator() method","label":{"api":{"System.lineSeparator()":[[17,38]]}}},{"text":"When do we use AtomicReference","label":{"api":{"AtomicReference":[[15,29]]}}},{"text":"Provide a simple example where AtomicReference should be used","label":{"api":{"AtomicReference":[[31,45]]}}},{"text":"Refer to the JFrame documentation for more information","label":{"api":{"JFrame":[[13,18]]}}},{"text":"What does the String.offsetByCodePoints(int index, int codePointOffset) method do","label":{"api":{"String.offsetByCodePoints(int index, int codePointOffset)":[[14,70]]}}},{"text":"There is LocalDate class, which has getDayOfMonth() method","label":{"api":{"LocalDate":[[9,17]],"getDayOfMonth()":[[36,50]]}}},{"text":"With the java.time classes you do not need those third party libraries anymore","label":{"api":{"java.time":[[9,17]]}}},{"text":"I would recommend reading about LocalDate and LocalDateTime","label":{"api":{"LocalDate":[[32,40]],"LocalDateTime":[[46,58]]}}},{"text":"If you are using Java 1.5 or later then this is an iterative binary GCD algorithm which uses Integer.numberOfTrailingZeros() to reduce the number of checks and iterations required","label":{"api":{"Integer.numberOfTrailingZeros()":[[93,123]]}}},{"text":"Commons-Math throws an ArithematicException.class only for Integer.MIN_VALUE or Long.MIN_VALUE","label":{"api":{"ArithematicException":[[23,42]],"Integer.MIN_VALUE":[[59,75]],"Long.MIN_VALUE":[[80,93]]}}},{"text":"You can use java.util.prefs package","label":{"api":{"java.util.prefs":[[12,26]]}}},{"text":"Each iteration gives a Map.Entry back which in turn has getKey() and getValue() methods","label":{"api":{"Map.Entry":[[23,31]],"getKey()":[[56,63]],"getValue()":[[69,78]]}}},{"text":"All the format mentioned in SimpleDateFormate API is supported in the below method","label":{"api":{"SimpleDateFormate":[[28,44]]}}},{"text":"That value is coming from Enum#name() method","label":{"api":{"Enum#name()":[[26,36]]}}},{"text":"Starting from Java-11, one can alternatively use the API Collection.toArray(IntFunction<T[]> generator) to achieve the same as","label":{"api":{"Collection.toArray(IntFunction<T[]> generator)":[[57,102]]}}},{"text":"from java.base's  java.util.Collection.toArray()","label":{"api":{"java.base":[[5,13]],"java.util.Collection.toArray()":[[18,47]]}}},{"text":"Can you guarantee that the BigDecimal will never contain a value larger than Integer.MAX_VALUE","label":{"api":{"BigDecimal":[[27,36]],"Integer.MAX_VALUE":[[77,93]]}}},{"text":"If yes, then here's your code calling intValue","label":{"api":{"intValue":[[38,45]]}}},{"text":"You would call myBigDecimal.intValueExact() (or just intValue()) and it will even throw an exception if you would lose information","label":{"api":{"myBigDecimal.intValueExact()":[[15,42]],"intValue()":[[53,62]]}}},{"text":"A slightly shorter version that relies on Color.getRGB()","label":{"api":{"Color.getRGB()":[[42,55]]}}},{"text":"While you can indeed use Collections.newSetFromMap() to get a WeakSet, it's use cases are actually quite limited","label":{"api":{"Collections.newSetFromMap()":[[25,51]],"WeakSet":[[62,68]]}}},{"text":"You can just add those spreedsheets to resources under test folder and can use reource loader to load test sheets","label":{"api":{"reource loader":[[79,92]]}}},{"text":"For checking if a string contains whitespace use a Matcher and call it's find method","label":{"api":{"Matcher":[[51,57]]}}},{"text":"If you want to check if it only consists of whitespace then you can use String.matches","label":{"api":{"String.matches":[[72,85]]}}},{"text":"I purpose to you a very simple method who use String.contains","label":{"api":{"String.contains":[[46,60]]}}},{"text":"You can use chatAt() function to find out spaces in string","label":{"api":{"chatAt()":[[12,19]]}}},{"text":"By design it is to be done this way","label":{"api":{}}},{"text":"Is a listener available for java.awt.print.PrinterJob","label":{"api":{"java.awt.print.PrinterJob":[[28,52]]}}},{"text":"I could only find PrintJobListener in javax.print.DocPrintJob","label":{"api":{"PrintJobListener":[[18,33]],"javax.print.DocPrintJob":[[38,60]]}}},{"text":"I am looking for its equivalent in java.awt.print.PrinterJob, so that I could track if there are issues in printing","label":{"api":{"java.awt.print.PrinterJob":[[35,59]]}}},{"text":"You could use MemoryMXBean that comes with JDK","label":{"api":{"MemoryMXBean":[[14,25]]}}},{"text":"Docs about MemoryMXBean","label":{"api":{"MemoryMXBean":[[11,22]]}}},{"text":"But usually the only used class loader is UrlClassLoader from which we can retrieve the list of directories and jar files (see getURLs) and open them one by one to list available classes","label":{"api":{"UrlClassLoader":[[42,55]],"getURLs":[[127,133]]}}},{"text":"Another approach is to use Java Pluggable Annotation Processing API to write annotation processor which will collect all annotated classes at compile time and build the index file for runtime use","label":{"api":{"Pluggable Annotation Processing":[[32,62]]}}},{"text":"If you are using Java 8, you may want to use java.time.format.DateTimeFormatter","label":{"api":{"java.time.format.DateTimeFormatter":[[45,78]]}}},{"text":"When your class implements Comparable, the compareTo method of the class is defining the \"natural\" ordering of that object","label":{"api":{"Comparable":[[27,36]],"compareTo":[[43,51]]}}},{"text":"A Comparator is its own definition of how to compare two objects, and can be used to compare objects in a way that might not align with the natural ordering","label":{"api":{"Comparator":[[2,11]]}}},{"text":"EhCache provides a SizeOf class that will try to use the Instrumentation agent and will fall back to a different approach if the agent is not loaded or cannot be loaded (details here)","label":{"api":{"SizeOf":[[19,24]],"Instrumentation":[[57,71]]}}},{"text":"How about Arrays.deepToString()","label":{"api":{"Arrays.deepToString()":[[10,30]]}}},{"text":"When running without prohibitive security manager, you can obtain instance of corresponding method or field trough reflection and call setAccessible() on it","label":{"api":{"setAccessible()":[[135,149]]}}},{"text":"From the JavaDoc of the Serializable interface","label":{"api":{"Serializable":[[24,35]]}}},{"text":"See SimpleDateFormat for a description of other format strings that the class accepts","label":{"api":{"SimpleDateFormat":[[4,19]]}}},{"text":"JTable.convertRowIndexToView() will return you an index of the row in the view based on its index in the model","label":{"api":{"JTable.convertRowIndexToView()":[[0,29]]}}},{"text":"JTable.convertRowIndexToModel() will do the opposite","label":{"api":{"JTable.convertRowIndexToModel()":[[0,30]]}}},{"text":"If it's affordable to check the content type based on just the file extension, then use ServletContext#getMimeType() to get the mime type (content type)","label":{"api":{"ServletContext#getMimeType()":[[88,115]]}}},{"text":"If it's affordable to check for only BMP, GIF, JPG or PNG types (but not TIF, PSD, SVG, etc), then you can just feed it directly to ImageIO#read() and check if it doesn't throw an exception","label":{"api":{"ImageIO#read()":[[132,145]]}}},{"text":"As you can't cast NamedNodeMap to a Map, I suggest to loop using a classic for loop like that","label":{"api":{"NamedNodeMap":[[18,29]],"Map":[[36,38]]}}},{"text":"Check out JButton documentation","label":{"api":{"JButton":[[10,16]]}}},{"text":"From Object in one of the JVM implementations","label":{"api":{"Object":[[5,10]]}}},{"text":"Another option is the javax.xml.stream.isCoalescing option (documented in XMLStreamReader.next()  or Using StAX), which automatically concatenates long text into a single string","label":{"api":{"javax.xml.stream.isCoalescing":[[22,50]],"XMLStreamReader.next()":[[74,95]],"StAX":[[107,110]]}}},{"text":"Here's more documentation on Scanner from Oracle","label":{"api":{"Scanner":[[29,35]]}}},{"text":"AffineTransformOp offers the additional flexibility of choosing the interpolation type","label":{"api":{"AffineTransformOp":[[0,16]]}}},{"text":"If you do not mind using an external library, Thumbnailator can perform scaling of BufferedImages","label":{"api":{"Thumbnailator":[[46,58]],"BufferedImage":[[83,95]]}}},{"text":"Thumbnailator will take care of handling the Java 2D processing (such as using Graphics2D and setting appropriate rendering hints) so that a simple fluent API call can be used to resize images","label":{"api":{"Thumbnailator":[[0,12]],"Graphics2D":[[79,88]]}}},{"text":"LocalDate is the standard Java 8 class for representing a date (without time)","label":{"api":{"LocalDate":[[0,8]]}}},{"text":"If you want to parse values that contain date and time information you should use LocalDateTime","label":{"api":{"LocalDateTime":[[82,94]]}}},{"text":"For values with timezones use ZonedDateTime","label":{"api":{"ZonedDateTime":[[30,42]]}}},{"text":"Both provide a parse() method similar to LocalDate","label":{"api":{"parse()":[[15,21]],"LocalDate":[[41,49]]}}},{"text":"The list formatting characters from DateTimeFormatter Javadoc","label":{"api":{"DateTimeFormatter":[[36,52]]}}},{"text":"If you are just writing bits to a file, Java's BitSet class might be worth a look at","label":{"api":{"BitSet":[[47,52]]}}},{"text":"I have a class that extends a JPanel called Row","label":{"api":{"JPanel":[[30,35]],"Row":[[44,46]]}}},{"text":"I have a bunch of Row added to a JLabel, the code is the following","label":{"api":{"Row":[[18,20]],"JLabel":[[33,38]]}}},{"text":"Check out the JOptionPane documentation","label":{"api":{"JOptionPane":[[14,24]]}}},{"text":"Obviously java.lang.StrictMath contains additional functions (hyperbolics etc.) which java.lang.Math doesn't, but is there a difference in the functions which are found in both libraries","label":{"api":{"java.lang.StrictMath":[[10,29]],"java.lang.Math":[[86,99]]}}},{"text":"Futures can also be given a look for your project","label":{"api":{"Futures":[[0,6]]}}},{"text":"You will need to use String.replaceAll(...) and not String.replace(...)","label":{"api":{"String.replaceAll(...)":[[21,42]],"String.replace(...)":[[52,70]]}}},{"text":"If you want to modify the list while you're looping through it, consider looping backward to avoid that, or using an Iterator","label":{"api":{"Iterator":[[117,124]]}}},{"text":"Alternatively you can use a JScrollPane","label":{"api":{"JScrollPane":[[28,38]]}}},{"text":"Read the Socket class Javadoc carefully","label":{"api":{"Socket":[[9,14]]}}},{"text":"isConnected is true if the socket was able to connect","label":{"api":{"isConnected":[[0,10]]}}},{"text":"Same thing for isBound","label":{"api":{"isBound":[[15,21]]}}},{"text":"I recently discovered the CachedRowSet, which does exactly what OP needs","label":{"api":{"CachedRowSet":[[26,37]]}}},{"text":"What is the difference between ResultSetMetaData.getColumnLabel and  ResultSetMetaData.getColumnName","label":{"api":{"ResultSetMetaData.getColumnLabel":[[31,62]],"ResultSetMetaData.getColumnName":[[69,99]]}}},{"text":"The class Cursor as a few predefined cursors","label":{"api":{"Cursor":[[10,15]]}}},{"text":"First alternative, compute","label":{"api":{}}},{"text":"Or use the merge method (which I would prefer)","label":{"api":{"merge":[[11,15]]}}},{"text":"The Method request.getRequestURI() returns URI with context path","label":{"api":{"request.getRequestURI()":[[11,33]],"URI":[[43,45]]}}},{"text":"the context path is myapp), and I call request.getRequestURI() for http://localhost:8080/myapp/secure/users, it will return /myapp/secure/users","label":{"api":{"request.getRequestURI()":[[39,61]]}}},{"text":"With Java8 stream introduction you can do it the following way","label":{"api":{"stream":[[11,16]]}}},{"text":"The two most important methods are inferBinaryName() and list()","label":{"api":{"inferBinaryName()":[[35,51]],"list()":[[57,62]]}}},{"text":"inferBinaryName() must return the class' simple name (e.g","label":{"api":{"inferBinaryName()":[[0,16]]}}},{"text":"list() is a little bit more complicated because you have to be careful to play along nicely with your delegate file manager","label":{"api":{"list()":[[0,5]]}}},{"text":"See Java Documents to learn about New IO package's Files class' createFile method","label":{"api":{"IO":[[38,39]],"Files":[[51,55]],"createFile":[[64,73]]}}},{"text":"An example of this pattern being used in Java's standard library would be the DataOutputStream","label":{"api":{"DataOutputStream":[[78,93]]}}},{"text":"Since Java 7, you can use java.nio.file.Files.getLastModifiedTime(Path path)","label":{"api":{"java.nio.file.Files.getLastModifiedTime(Path path)":[[26,75]]}}},{"text":"You have to extend a class with HttpServlet and setting the following stuff to your web.xml","label":{"api":{"HttpServlet":[[32,42]]}}},{"text":"You need to use SDF (SimpleDateFormat) to process the output too","label":{"api":{"SimpleDateFormat":[[21,36]]}}},{"text":"You can use a LookupOp with a four-component LookupTable that sets the alpha component to zero for colors that match the background","label":{"api":{"LookupOp":[[14,21]],"LookupTable":[[45,55]]}}},{"text":"Examples may be found in Using the Java 2D LookupOp Filter Class to Process Images and Image processing with Java 2D","label":{"api":{"Java 2D LookupOp Filter":[[35,57]]}}},{"text":"Java does not have the exact syntax but as of JDK-8, we have the Optional API with various methods at our disposal","label":{"api":{"Optional":[[65,72]]}}},{"text":"can be written as follows in Java with the Optional API","label":{"api":{"Optional":[[43,50]]}}},{"text":"Hibernate seems to follow that philosophy and since you are using JDK logging just configure the log level with a property file","label":{"api":{}}},{"text":"you can extend LinkedHashSet adding your desired getIndex() method","label":{"api":{"LinkedHashSet":[[15,27]],"getIndex()":[[49,58]]}}},{"text":"As of Java 8, you can use Math.floorMod(int x, int y) and Math.floorMod(long x, long y)","label":{"api":{"Math.floorMod(int x, int y)":[[26,52]],"Math.floorMod(long x, long y)":[[58,86]]}}},{"text":"It really seemed like Utilities.drawTabbedText() was promising, but I couldn't figure out what it needed as input","label":{"api":{"Utilities.drawTabbedText()":[[22,47]]}}},{"text":"Yes, it's called System.arraycopy(Object, int, Object, int, int)","label":{"api":{"System.arraycopy(Object, int, Object, int, int)":[[17,63]]}}},{"text":"I am trying to understand the difference between matches() and find()","label":{"api":{"matches()":[[49,57]],"find()":[[63,68]]}}},{"text":"According to the Javadoc, (from what I understand), matches() will search the entire string even if it finds what it is looking for, and find() will stop when it finds what it is looking for","label":{"api":{"matches()":[[52,60]],"find()":[[137,142]]}}},{"text":"If that assumption is correct, I cannot see whenever you would want to use matches() instead of find(), unless you want to count the number of matches it finds","label":{"api":{"matches()":[[75,83]],"find()":[[96,101]]}}},{"text":"In my opinion the String class should then have find() instead of matches() as an inbuilt method","label":{"api":{"String":[[18,23]],"find()":[[48,53]],"matches()":[[66,74]]}}},{"text":"When is it useful to use matches() instead of find()","label":{"api":{"matches()":[[25,33]],"find()":[[46,51]]}}},{"text":"The Java documentation for Class says","label":{"api":{"Class":[[27,31]]}}},{"text":"Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader","label":{"api":{"Class":[[0,4]],"defineClass":[[114,124]],"class loader":[[140,151]]}}},{"text":"What are these Class objects","label":{"api":{"Class":[[15,19]]}}},{"text":"Also, for example object.getClass().getName() how can everything be typecasted to superclass Class, even if I don't inherit from java.lang.Class","label":{"api":{"object.getClass().getName()":[[18,44]],"Class":[[93,97]],"java.lang.Class":[[129,143]]}}},{"text":"Even if using an ArrayList is probably a good advice in many circumstances, there are perfectly legitimate occasions for using plain old arrays","label":{"api":{"ArrayList":[[17,25]]}}},{"text":"In that case, if you need to resize your array, you might want to investigate one of the java.utils.Arrays.copyOf methods","label":{"api":{"java.utils.Arrays.copyOf":[[89,112]]}}},{"text":"Note that the toUnsignedLong is from the Integer class and the first call to toUnsignedLong may be superfluous","label":{"api":{"toUnsignedLong":[[14,27],[77,90]],"Integer":[[41,47]]}}},{"text":"According to Thread.setDaemon(boolean) documentation","label":{"api":{"Thread.setDaemon(boolean)":[[13,37]]}}},{"text":"Starting from Java 8, it can be done thanks to the Stream API using an appopriate mapper Function that we will use to convert our instances of class A to instances of class B","label":{"api":{"Stream":[[51,56]],"Function":[[89,96]]}}},{"text":"Here is a concrete example that will convert a List of String to a List of Integer using Integer.valueOf(String) as mapper function","label":{"api":{"String":[[55,60]],"Integer":[[75,81]],"Integer.valueOf(String)":[[89,111]]}}},{"text":"For previous versions of Java, you can still use FluentIterable from Google Guava to replace the Stream and use com.google.common.base.Function instead of java.util.function.Function as mapper function","label":{"api":{"FluentIterable":[[49,62]],"Stream":[[97,102]],"com.google.common.base.Function":[[112,142]],"java.util.function.Function":[[155,181]]}}},{"text":"You can now do this with Streams.generate(Supplier<T> s)","label":{"api":{"Streams.generate(Supplier<T> s)":[[25,55]]}}},{"text":"Use the substring() function with an argument of 1 to get the substring from position 1 (after the first character) to the end of the string (leaving the second argument out defaults to the full length of the string)","label":{"api":{"substring()":[[8,18]]}}},{"text":"As a specific case, Java 8 added UncheckedIOException for wrapping and rethrowing IOException","label":{"api":{"UncheckedIOException":[[33,52]],"IOException":[[82,92]]}}},{"text":"The CLASSPATH separator is platform dependent, and is the same as the character returned by java.io.File.pathSeparatorChar","label":{"api":{"java.io.File.pathSeparatorChar":[[92,121]]}}},{"text":"Here's the legacy java.util.Calendar approach in case you aren't on Java8 yet","label":{"api":{"java.util.Calendar":[[18,35]]}}},{"text":"And here's Java8's java.time.LocalDate approach, basically exactly the JodaTime approach","label":{"api":{"java.time.LocalDate":[[19,37]]}}},{"text":"Java 8 style, using the java.time classes","label":{"api":{"java.time":[[24,32]]}}},{"text":"Java 9 added the datesUntil() method","label":{"api":{"datesUntil()":[[17,28]]}}},{"text":"As of Java 8, one can use DateTimeFormatter along with the the Java 8 Time API to both parse and format dates","label":{"api":{"DateTimeFormatter":[[26,42]],"Time":[[70,73]]}}},{"text":"The javadoc for java.net.CookieManager gives a pretty good overview of how CookieHandler fits in","label":{"api":{"java.net.CookieManager":[[16,37]],"CookieHandler":[[75,87]]}}},{"text":"Assuming that you're running in Java 6 or higher, you can use the standard JDBC method Connection.isValid(int timeoutInSecs)","label":{"api":{"Connection.isValid(int timeoutInSecs)":[[87,123]]}}},{"text":"SeeTextual representation of IP addresses in the Java specifications","label":{"api":{}}},{"text":"Let it implement HttpSessionBindingListener and add/remove the user from the Set when it's about to be bound/unbound in the session","label":{"api":{"HttpSessionBindingListener":[[17,42]],"Set":[[77,79]]}}},{"text":"You could do that in the same methods by a nullcheck, or with help of ServletContextListener#contextInitialized()","label":{"api":{"ServletContextListener#contextInitialized()":[[70,112]]}}},{"text":"You can use DateTimeFormatterBuilder in Java 8","label":{"api":{"DateTimeFormatterBuilder":[[12,35]]}}},{"text":"Try setOpaque(true) on the Label, this should cause it to clear its background","label":{"api":{"setOpaque(true)":[[4,18]]}}},{"text":"Using Files.write (small files)","label":{"api":{"Files.write":[[6,16]]}}},{"text":"Using Files.newBufferedWriter(text files)","label":{"api":{"Files.newBufferedWriter":[[6,28]]}}},{"text":"Using Files.newOutputStream (interoperable with java.io APIs)","label":{"api":{"Files.newOutputStream":[[6,26]],"java.io":[[48,54]]}}},{"text":"Using Files.newByteChannel (random access files)","label":{"api":{"Files.newByteChannel":[[6,25]]}}},{"text":"Using FileChannel.open (random access files)","label":{"api":{"FileChannel.open":[[6,21]]}}},{"text":"This would easily be accomplished by using a PriorityQueue or PriorityBlockingQueue in which the most recently queued items get highest priority","label":{"api":{"PriorityQueue":[[45,57]],"PriorityBlockingQueue":[[62,82]]}}},{"text":"Java 8 now supplies an appropriate date formatter, DateTimeFormatter.RFC_1123_DATE_TIME","label":{"api":{"DateTimeFormatter.RFC_1123_DATE_TIME":[[51,86]]}}},{"text":"As of Java 7 you can use Locale.forLanguageTag(String) and toLanguageTag() to convert between language tags and Locale objects","label":{"api":{"Locale.forLanguageTag(String)":[[25,53]],"toLanguageTag()":[[59,73]],"Locale":[[112,117]]}}},{"text":"Java 1.8 added the java.time package to the core JDK to clean up many of the frustrations with the state of date & time in Java","label":{"api":{"java.time":[[19,27]]}}},{"text":"Since java.time is now a widely available part of core Java with a much improved API, I would encourage you to give it the first look when writing new date & time code","label":{"api":{"java.time":[[6,14]]}}},{"text":"Why does InputStream#read() return an int and not a byte","label":{"api":{"InputStream#read()":[[9,26]]}}},{"text":"as the Java doc says in InputStream#read, The value byte is returned as an int in the range 0 to 255","label":{"api":{"InputStream#read":[[24,39]]}}},{"text":"Building off Mateusz's Java 8 example, there's an example in the StringJoiner JavaDoc that nearly does what OP wants","label":{"api":{"StringJoiner":[[65,76]]}}},{"text":"String.split() will do most of what you want","label":{"api":{"String.split()":[[0,13]]}}},{"text":"The support for streams and Lambdas in java-8 and Try-With-Resources of java-7 allows you to achive what you want in more compact syntax","label":{"api":{"streams":[[16,22]]}}},{"text":"Thread has a method that does that for you join which will block until the thread has finished executing","label":{"api":{"Thread":[[0,5]],"join":[[43,46]]}}},{"text":"Better alternatives to join() method have been evolved over a period of time","label":{"api":{"join()":[[23,28]]}}},{"text":"ExecutorService.html#invokeAll is one alternative","label":{"api":{"ExecutorService.html#invokeAll":[[0,29]]}}},{"text":"ForkJoinPool or Executors.html#newWorkStealingPool provides other alternatives to achieve the same purpose","label":{"api":{"ForkJoinPool":[[0,11]],"Executors.html#newWorkStealingPool":[[16,49]]}}},{"text":"When a Component is created, the current LookAndFeel will be used to display that Component","label":{"api":{"Component":[[7,15],[82,90]],"LookAndFeel":[[41,51]]}}},{"text":"But flush() can throw an IOException","label":{"api":{"flush()":[[4,10]],"IOException":[[25,35]]}}},{"text":"but you need to make sure you are using the right Locale to properly parse the month name","label":{"api":{"Locale":[[50,55]]}}},{"text":"I know you can include general texts inside the SimpleDateFormat pattern","label":{"api":{"SimpleDateFormat":[[48,63]]}}},{"text":"ConcurrentLinkedQueue is a superb lock free queue and does what a concurrent single linked list can do","label":{"api":{"ConcurrentLinkedQueue":[[0,20]],"concurrent single linked list":[[66,94]]}}},{"text":"It's an outstanding Queue","label":{"api":{"Queue":[[20,24]]}}},{"text":"The MouseListener in the Java API","label":{"api":{"MouseListener":[[4,16]]}}},{"text":"The MemoryHandler in the Java API","label":{"api":{"MemoryHandler":[[4,16]]}}},{"text":"For a system monitoring Java application which currently runs on the command line and uses ScheduledExecutorService, I would like to write a simple web application version, to be run in a Servlet container like Apache Tomcat or Eclipse Jetty","label":{"api":{"ScheduledExecutorService":[[91,114]]}}},{"text":"Would it be better (maybe because of better servlet container integration) to port this application from ScheduledExecutorService to Quartz","label":{"api":{"ScheduledExecutorService":[[105,128]]}}},{"text":"Adding another library dependency to the application is not a problem, I am interested in technical reasons against usage of ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[125,148]]}}},{"text":"Math.round() returns the nearest integer to your given input value","label":{"api":{"Math.round()":[[0,11]]}}},{"text":"If your float already has an integer value the \"nearest\" integer will be that same value, so all you need to do is check whether Math.round() changes the value or not","label":{"api":{"Math.round()":[[129,140]]}}},{"text":"You can use something like Runtime.getRuntime().totalMemory() and its counterpart Runtime.getRuntime().freeMemory() to get an educated guess, but that doesn't account for objects that are GC'ed between calls","label":{"api":{"Runtime.getRuntime().totalMemory()":[[27,60]],"Runtime.getRuntime().freeMemory()":[[82,114]]}}},{"text":"For Java 1.7+ you can use the Files.copy(Path, OutputStream), e.g","label":{"api":{"Files.copy(Path, OutputStream)":[[30,59]]}}}]