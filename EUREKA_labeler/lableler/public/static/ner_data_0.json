[{"text": "In Java 9 and afterward, if there's a declared zero-parameter (\"nullary\") constructor, you'd use Class.getDeclaredConstructor() to get it, then call newInstance() on it", "label": {"api": {"Class.getDeclaredConstructor()": [[97, 126]], "newInstance()": [[149, 161]]}}}, {"text": "Prior to Java 9, you would have used Class.newInstance", "label": {"api": {"Class.newInstance": [[37, 53]]}}}, {"text": "A more robust route is to go through Class.getDeclaredConstructors or Class.getConstructors, which takes you into using the Reflection stuff in the java.lang.reflect package, to find a constructor with the parameter types matching the arguments you intend to give it", "label": {"api": {"Class.getDeclaredConstructors": [[37, 65]], "Class.getConstructors": [[70, 90]], "java.lang.reflect": [[148, 164]]}}}, {"text": "There's no other feasible option than ServletContextListener", "label": {"api": {"ServletContextListener": [[38, 59]]}}}, {"text": "If you're already on Servlet 3.0, then you could just annotate it with @WebListener, ship it with the webapp and it will be automagically loaded", "label": {"api": {"@WebListener": [[71, 82]]}}}, {"text": "You can try to catch InterruptedIOException", "label": {"api": {"InterruptedIOException": [[21, 42]]}}}, {"text": "Use a collection such as Vector<T> instead", "label": {"api": {"Vector<T>": [[25, 33]]}}}, {"text": "Set.copyOf returns an unmodifiable Set containing the elements of the given Collection", "label": {"api": {"Set.copyOf": [[0, 9]]}}}, {"text": "A third option is to use a PropertyChangeListener, as shown here and here", "label": {"api": {"PropertyChangeListener": [[27, 48]]}}}, {"text": "After converting all my code to use java.nio.Path EVERYTHING started working", "label": {"api": {"java.nio.Path": [[36, 48]]}}}, {"text": "And I replaced apache FileUtils (which has the same problem) with java.nio.Files..", "label": {"api": {"java.nio.Files": [[66, 79]]}}}, {"text": "An Executor needs to be set in order to make an Endpoint multi-threaded", "label": {"api": {"Executor needs to be set": [[3, 26]]}}}, {"text": "Write a ServletContextListener which populates the database and does the work in the contextInitialized() method", "label": {"api": {"ServletContextListener": [[8, 29]], "contextInitialized()": [[85, 104]]}}}, {"text": "If the listener is configured in your web.xml, the servlet container will invoke your listener's contextInitialized() method when the webapp is started", "label": {"api": {"contextInitialized()": [[97, 116]]}}}, {"text": "Taking another approach to this using Java 8's Stream functionality, for any number of booleans with an arbitrary required amount", "label": {"api": {"Stream": [[47, 52]]}}}, {"text": "The Stream short circuits if it hits the limit before processing all of the elements", "label": {"api": {"Stream": [[4, 9]]}}}, {"text": "Some frameworks may support @ConstructorProperties as an alternative", "label": {"api": {"@ConstructorProperties": [[28, 49]]}}}, {"text": "It's then available by HttpServletRequest#getRemoteAddr()", "label": {"api": {"HttpServletRequest#getRemoteAddr()": [[23, 56]]}}}, {"text": "I had a similar problem to yours (except I wasn't dealing with enums, I needed the value of a non-String/non-primitive constant) and got it solved by accessing the source code via the Compiler Tree API", "label": {"api": {"Compiler Tree API": [[184, 200]]}}}, {"text": "You need to collect them all in a Map using a HttpSessionListener yourself", "label": {"api": {"Map": [[34, 36]], "HttpSessionListener": [[46, 64]]}}}, {"text": "Once you get the HttpServletRequest via the @Context, you can access any of the methods of HttpServletRequest", "label": {"api": {"HttpServletRequest": [[17, 34], [91, 108]]}}}, {"text": "To hash a string, use the built-in MessageDigest class", "label": {"api": {"MessageDigest": [[35, 47]]}}}, {"text": "In a JEE6+ environment one could also use JAXB DataTypeConverter", "label": {"api": {"DataTypeConverter": [[47, 63]]}}}, {"text": "Starting from Java 9, there is a new utility method allowing to create an immutable entry which is Map#entry(Object, Object)", "label": {"api": {"Map#entry(Object, Object)": [[99, 123]]}}}, {"text": "The other limitations are the fact that it is not serializable and null as key or value is forbidden, if it is not acceptable for you, you will need to use AbstractMap.SimpleImmutableEntry or AbstractMap.SimpleEntry instead", "label": {"api": {"AbstractMap.SimpleImmutableEntry": [[156, 187]], "AbstractMap.SimpleEntry": [[192, 214]]}}}, {"text": "If your need is to create directly a Map with 0 to up to 10 (key, value) pairs, you can instead use the methods of type Map.of(K key1, V value1, ...)", "label": {"api": {"Map.of(K key1, V value1, ...)": [[120, 148]]}}}, {"text": "Perhaps extend ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[15, 32]]}}}, {"text": "In Java, you can use the BigInteger class to store arbitrarily large integers", "label": {"api": {"BigInteger": [[25, 34]]}}}, {"text": "The file's content is available in the request body by HttpServletRequest#getInputStream()", "label": {"api": {"HttpServletRequest#getInputStream()": [[55, 89]]}}}, {"text": "Just write it to any OutputStream to your taste the usual Java IO way, e.g", "label": {"api": {"OutputStream": [[21, 32]]}}}, {"text": "FileOutputStream to write it to a local file", "label": {"api": {"OutputStream": [[4, 15]], "FileOutputStream": [[0, 15]]}}}, {"text": "An example is RoleList::add(role) that throws an exception when adding a Null value", "label": {"api": {"RoleList::add(role)": [[14, 32]]}}}, {"text": "Just get the session by HttpServletRequest#getSession() and use its setAttribute() method to store objects in session and getAttribute() to get them from session", "label": {"api": {"HttpServletRequest#getSession()": [[24, 54]], "setAttribute()": [[68, 81]], "getAttribute()": [[122, 135]]}}}, {"text": "Note that java11 now offers a new HTTP api HttpClient, which support fully asynchronous operation, using java's CompletableFuture", "label": {"api": {"HttpClient": [[43, 52]], "CompletableFuture": [[112, 128]]}}}, {"text": "It also support a synchronous version, with calls like send, which is synchronous, and sendAsync, which is asynchronous", "label": {"api": {"send": [[55, 58], [87, 90]], "sendAsync": [[87, 95]]}}}, {"text": "You will need to use XAResource to wrap the participants in the transaction so that they can be enlisted in the distributed transaction", "label": {"api": {"XAResource": [[21, 30]]}}}, {"text": "The master will need to send commit/rollback messages to the slaves, which will need to use XATerminator to act accordingly", "label": {"api": {"XATerminator": [[92, 103]]}}}, {"text": "If it's JPA, you need to use an entity method with the @PrePersist or @PostPersist annotation", "label": {"api": {"@PrePersist": [[55, 65]], "@PostPersist": [[70, 81]]}}}, {"text": "It's helpful to think of a JTree as a view of the underlying TreeModel", "label": {"api": {"JTree": [[27, 31]], "TreeModel": [[61, 69]]}}}, {"text": "An example implementation of TreeModel, intended for use with org.netbeans.swing.outline.Outline, illustrates a hierarchical FileTreeModel that may guide you", "label": {"api": {"TreeModel": [[29, 37], [129, 137]]}}}, {"text": "As you are using Oracle, you may find the article Dynamic JTree from database query helpful, too", "label": {"api": {"JTree": [[58, 62]]}}}, {"text": "The article Understanding the TreeModel may be helpful, too", "label": {"api": {"TreeModel": [[30, 38]]}}}, {"text": "See also this related example that uses FileTreeModel", "label": {"api": {"TreeModel": [[44, 52]]}}}, {"text": "If you are using Java 1.7, you can use java.nio.file.Files.walkFileTree(...)", "label": {"api": {"java.nio.file.Files.walkFileTree(...)": [[39, 75]]}}}, {"text": "If you are using Java 8, you can use the stream interface with java.nio.file.Files.walk(...)", "label": {"api": {"java.nio.file.Files.walk(...)": [[63, 91]]}}}, {"text": "You should prefer the ClassLoader as returned by Thread#getContextClassLoader()", "label": {"api": {"Thread#getContextClassLoader()": [[49, 78]]}}}, {"text": "If you opt for using the Thread#getContextClassLoader(), remove the leading /", "label": {"api": {"Thread#getContextClassLoader()": [[25, 54]]}}}, {"text": "The JSF-specific ExternalContext#getResourceAsStream() which uses ServletContext#getResourceAsStream() \"under the hoods\" only returns resources from the webcontent (there where the /WEB-INF folder is sitting), not from the classpath", "label": {"api": {"ExternalContext#getResourceAsStream()": [[17, 53]], "ServletContext#getResourceAsStream()": [[66, 101]]}}}, {"text": "See also javadoc of Connection#close() (emphasis not mine)", "label": {"api": {"Connection#close()": [[20, 37]]}}}, {"text": "I have tried to configure ActiveMQXAConnectionFactory directly in Spring (I am using Spring 3.0.2.RELEASE), but this does not work, because in this case Spring transaction manager (I use annotation  to let Spring configure JtaTransactionManager which simply delegates all the work to Jboss transaction manager) does not enlist XAResource for given ActiveMQXAConnection", "label": {"api": {"ConnectionFactory": [[36, 52]]}}}, {"text": "Since that did not work, I have switched to JCA configuration of ActiveMQ ConnectionFactory (based on this document) and it works for regular ConnectionFactory, but I do not understand how can I configure it to use XAConnectionFactory", "label": {"api": {"ConnectionFactory": [[74, 90], [142, 158], [217, 233]]}}}, {"text": "It seems like Resource Adapter simply does not have proper ManagedConnectionFactory, ManagedConnection, etc", "label": {"api": {"ConnectionFactory": [[66, 82]]}}}, {"text": "a @ViewScoped bean in combination with a <h:dataTable> basically already suffices", "label": {"api": {"@ViewScoped": [[2, 12]]}}}, {"text": "To get the <Context path> value from context.xml, use ServletContext#getContextPath()", "label": {"api": {"ServletContext#getContextPath()": [[54, 84]]}}}, {"text": "you are supposed to run your JPA code inside a transaction and it looks like you aren't, hence the TransactionRequiredException", "label": {"api": {"TransactionRequiredException": [[99, 126]]}}}, {"text": "You can specify a ThreadFactory in the ThreadPoolExecutor constructor (or Executors factory method)", "label": {"api": {"ThreadFactory": [[18, 30]]}}}, {"text": "If there may be duplicate keys, you can aggregate the values with the toMap overload that takes a value merge function, or you can use groupingBy to collect into a list", "label": {"api": {"toMap overload that takes a value merge function": [[70, 117]], "groupingBy": [[135, 144]]}}}, {"text": "In that case you might use toConcurrentMap or groupingByConcurrent, as they allow the stream implementation to just blast elements into a ConcurrentMap instead of making separate maps for each thread and then merging them", "label": {"api": {"groupingBy": [[46, 55]], "toConcurrentMap": [[27, 41]], "groupingByConcurrent": [[46, 65]]}}}, {"text": "Just add your data to a DefaultListModel, and use it to construct your list", "label": {"api": {"DefaultListModel": [[24, 39]]}}}, {"text": "As @nanda suggests, use ExcecutorService.shutdown() to wait until a pool of threads has finished", "label": {"api": {"ExcecutorService.shutdown()": [[24, 50]]}}}, {"text": "In Java 7 you can also use the Path interface", "label": {"api": {"Path": [[31, 34]]}}}, {"text": "You could make use of String#split() taking a limit as 2nd argument", "label": {"api": {"String#split()": [[22, 35]]}}}, {"text": "If java.beans API were available, then you could just do", "label": {"api": {"java.beans": [[3, 12]]}}}, {"text": "In Java, there's the java.net.Socket API for this", "label": {"api": {"java.net.Socket": [[21, 35]]}}}, {"text": "The default implementation in the InputStream class does nothing, as described in the API", "label": {"api": {"described in the API": [[69, 88]]}}}, {"text": "To be sure of this, you should wrap it in a BufferedInputStream, which does supports these methods", "label": {"api": {"BufferedInputStream": [[44, 62]]}}}, {"text": "You are on the right track using ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[33, 49]]}}}, {"text": "Check out the methods putIfAbsent and replace both are threadsafe and combine checking current state of hashmap and updating it into one atomic operation", "label": {"api": {"putIfAbsent": [[22, 32]], "replace": [[38, 44]]}}}, {"text": "The get method is not synchronized internally but will return the most recent value for the specified key available to it (check the ConcurrentHashMap class Javadoc for discussion)", "label": {"api": {"ConcurrentHashMap": [[133, 149]], "get": [[4, 6]], "ConcurrentHashMap class Javadoc for discussion": [[133, 178]]}}}, {"text": "The benefit of ConcurrentHashMap over something like Collections.synchronizedMap is the combined methods like putIfAbsent which provide traditional Map get and put logic in an internally synchronized way", "label": {"api": {"ConcurrentHashMap": [[15, 31]], "putIfAbsent": [[110, 120]], "get": [[152, 154]], "Collections.synchronizedMap": [[53, 79]]}}}, {"text": "Use these methods and do not try to provide your own custom synchronization over ConcurrentHashMap as it will not work", "label": {"api": {"ConcurrentHashMap": [[81, 97]]}}}, {"text": "synchronize(myConcurrentHashMap){} will not block other threads)", "label": {"api": {"ConcurrentHashMap": [[14, 30]]}}}, {"text": "You can get all classpath roots by passing an empty String into ClassLoader#getResources()", "label": {"api": {"ClassLoader#getResources()": [[64, 89]]}}}, {"text": "You can construct a File based on URL as follows", "label": {"api": {"File": [[20, 23]], "URL": [[34, 36]]}}}, {"text": "You can use File#listFiles() to get a list of all files in the given directory", "label": {"api": {"File": [[12, 15], [21, 24]], "File#listFiles()": [[12, 27]]}}}, {"text": "You can use the standard java.io.File methods to check if it's a directory and/or to grab the filename", "label": {"api": {"File": [[33, 36]], "java.io.File": [[25, 36]]}}}, {"text": "UIData components can only iterate over an T[], List<E> or a DataModel<E>, not over a Set<E> because there's no way to identify an element in a Set<E> by an index, while it is required in UIData components", "label": {"api": {"List<E>": [[48, 54]], "DataModel<E>": [[61, 72]], "Set<E>": [[86, 91], [144, 149]]}}}, {"text": "Other ways are to configure JPA to use List<E> instead or to add a getter which wraps it in a List<E> or DataModel<E> and use it instead in UIData component", "label": {"api": {"List<E>": [[39, 45], [94, 100]], "DataModel<E>": [[105, 116]]}}}, {"text": "in the upcoming JSF 2.2, the UIData will finally support Collection<E>, which thus includes Set<E>", "label": {"api": {"Set<E>": [[92, 97]], "Collection<E>": [[57, 69]]}}}, {"text": "You can make use of java.text.Normalizer and a little regex to get rid of the diacritical marks", "label": {"api": {"java.text.Normalizer": [[20, 39]]}}}, {"text": "I understand that the SecurityRequestWrapper you're talking about already implements HttpServletRequestWrapper", "label": {"api": {"HttpServletRequestWrapper": [[85, 109]]}}}, {"text": "You could use java.math.BigDecimal and its method divideAndRemainder()", "label": {"api": {"divideAndRemainder": [[50, 67]]}}}, {"text": "The System class has a setOut and setErr that can be used to change the output stream to, for example, a new PrintStream with a backing File or, in this case, probably another stream which uses your logging subsystem of choice", "label": {"api": {"setOut": [[23, 28]], "setErr": [[34, 39]]}}}, {"text": "You can make use of List#removeAll()", "label": {"api": {"List#removeAll()": [[20, 35]]}}}, {"text": "For that you can perfectly let the model object representing the logged in user implement HttpSessionBindingListener", "label": {"api": {"HttpSessionBindingListener": [[90, 115]]}}}, {"text": "See the JavaDocs of the List interface", "label": {"api": {"JavaDocs of the List interface": [[8, 37]]}}}, {"text": "Let them share a single thread executor and submit the tasks to it instead", "label": {"api": {"single thread executor": [[17, 38]], "submit": [[44, 49]]}}}, {"text": "Update as per the comments on the answer of @extraneon, using new BigInteger(byte[]) is also the wrong solution", "label": {"api": {"new BigInteger(byte[])": [[62, 83]]}}}, {"text": "EventListenerList has a method, getListeners(Class<T> t), specifically for the case where you are only interested in one event type", "label": {"api": {"method": [[24, 29]]}}}, {"text": "Added to Comparator in Java 8", "label": {"api": {"Comparator in Java 8": [[9, 28]]}}}, {"text": "You can capture the response body by replacing the passed-in ServletResponse with a HttpServletResponseWrapper implementation which replaces the HttpServletResponse#getWriter() with an own implementation which copies the response body into some buffer", "label": {"api": {"HttpServletResponseWrapper": [[84, 109]]}}}, {"text": "In addition, the code relies on the thread safety of append()", "label": {"api": {"append()": [[53, 60]]}}}, {"text": "In Java 7, append() is no longer marked as thread safe; invokeLater() is used in display() to sequence updates", "label": {"api": {"append()": [[11, 18]]}}}, {"text": "See also SimpleDateFormat javadoc", "label": {"api": {"SimpleDateFormat javadoc": [[9, 32]]}}}, {"text": "The ExceptionInInitializerError is designed for exactly this purpose", "label": {"api": {"ExceptionInInitializerError": [[4, 30]]}}}, {"text": "An ExceptionInInitializerError is thrown to indicate that an exception occurred during evaluation of a static initializer or the initializer for a static variable", "label": {"api": {"ExceptionInInitializerError": [[3, 29]]}}}, {"text": "You can grab generic interfaces of a class by Class#getGenericInterfaces() which you then in turn check if it's a ParameterizedType and then grab the actual type arguments accordingly", "label": {"api": {"Class#getGenericInterfaces()": [[46, 73]], "ParameterizedType": [[114, 130]], "actual type arguments": [[150, 170]]}}}, {"text": "To send them back in the subsequent requests, you should set them one by one using URLConnection#addRequestProperty()", "label": {"api": {"URLConnection#addRequestProperty()": [[83, 116]]}}}, {"text": "You normally want to use UIViewRoot#getViewId() for this", "label": {"api": {"UIViewRoot#getViewId()": [[25, 46]]}}}, {"text": "Make use of it and create a class which extends InputStream (maybe DataInputStream or better, some Reader since you're actually interested in characters, not in bytes, but ala), add a constructor which takes the original InputStream and override the read() methods to read the original stream in, buffer it to a certain degree (e.g", "label": {"api": {"DataInputStream": [[67, 81]], "Reader": [[99, 104]]}}}, {"text": "Per the javadoc, MessageFormat objects are not thread-safe", "label": {"api": {"MessageFormat": [[17, 29]]}}}, {"text": "You can use a ThreadLocal to create a separate object for each thread that needs one", "label": {"api": {"ThreadLocal": [[14, 24]]}}}, {"text": "You can then use threadLocalMessageFormat.get() to obtain a MessageFormat for the current thread", "label": {"api": {"MessageFormat": [[28, 40], [60, 72]]}}}, {"text": "The print() function in turn can be replaced by just printing this since System.out.println(object) under the hoods returns String.valueOf(object) which in turn under the hoods returns object != null", "label": {"api": {"System.out.println(object)": [[73, 98]], "String.valueOf(object)": [[124, 145]]}}}, {"text": "When something fails in meanwhile, either throw ServletException (which will end up in a server default error page with status code 500), or use HttpServletResponse#sendError() to send a more specific error status", "label": {"api": {"HttpServletResponse#sendError()": [[145, 175]]}}}, {"text": "According to Javadocs, file.toURL() is deprecated", "label": {"api": {"deprecated": [[39, 48]]}}}, {"text": "ResultSet.getDate() returns a java.sql.Date, not a java.util.Date", "label": {"api": {"ResultSet.getDate()": [[0, 18]], "java.sql.Date": [[30, 42]], "java.util.Date": [[51, 64]]}}}, {"text": "If you want a timestamp, use ResultSet.getTimestamp()", "label": {"api": {"ResultSet.getTimestamp()": [[29, 52]]}}}, {"text": "You should throw a NoSuchElementException as that's exactly what the Collections.max() method does", "label": {"api": {"NoSuchElementException": [[19, 40]], "Collections.max()": [[69, 85]]}}}, {"text": "If you want to wait for all tasks to complete, use the shutdown method instead of wait", "label": {"api": {"shutdown": [[55, 62]]}}}, {"text": "Then follow it with awaitTermination", "label": {"api": {"awaitTermination": [[20, 35]]}}}, {"text": "Also, you can use Runtime.availableProcessors to get the number of hardware threads so you can initialize your threadpool properly", "label": {"api": {"Runtime.availableProcessors": [[18, 44]]}}}, {"text": "If you want to wait for the executor service to finish executing, call shutdown() and then, awaitTermination(units, unitType), e.g", "label": {"api": {"awaitTermination(units, unitType)": [[92, 124]]}}}, {"text": "If waiting for all tasks in the ExecutorService to finish isn't precisely your goal, but rather waiting until a specific batch of tasks has completed, you can use a CompletionService â€” specifically, an ExecutorCompletionService", "label": {"api": {"CompletionService": [[165, 181], [210, 226]], "ExecutorCompletionService": [[202, 226]]}}}, {"text": "The idea is to create an ExecutorCompletionService wrapping your Executor, submit some known number of tasks through the CompletionService, then draw that same number of results from the completion queue using either take() (which blocks) or poll() (which does not)", "label": {"api": {"CompletionService": [[33, 49], [121, 137]], "ExecutorCompletionService": [[25, 49]], "submit": [[75, 80]], "take()": [[217, 222]], "poll()": [[242, 247]]}}}, {"text": "Once you've drawn all the expected results corresponding to the tasks you submitted, you know they're all done", "label": {"api": {"submit": [[74, 79]]}}}, {"text": "You must know how many things you put into the CompletionService in order to know how many things to try to draw out", "label": {"api": {"CompletionService": [[47, 63]]}}}, {"text": "This matters especially with the take() method", "label": {"api": {"take()": [[33, 38]]}}}, {"text": "call it one time too many and it will block your calling thread until some other thread submits another job to the same CompletionService", "label": {"api": {"CompletionService": [[120, 136]], "submit": [[88, 93]]}}}, {"text": "There are some examples showing how to use CompletionService in the book Java Concurrency in Practice", "label": {"api": {"CompletionService": [[43, 59]]}}}, {"text": "Sounds like you need ForkJoinPool and use the global pool to execute tasks", "label": {"api": {"ForkJoinPool": [[21, 32]]}}}, {"text": "I am not sure about how Grails fits in the picture, but talking in Java Servlet API, you'd like to use HttpSessionListener#sessionDestroyed() for this", "label": {"api": {"HttpSessionListener#sessionDestroyed()": [[103, 140]]}}}, {"text": "You can also just let the User model implement HttpSessionBindingListener", "label": {"api": {"HttpSessionBindingListener": [[47, 72]]}}}, {"text": "Else you're not overriding the real Object#equals(), but rather overloading it", "label": {"api": {"Object#equals()": [[36, 50]]}}}, {"text": "Use the System.setProperty() method", "label": {"api": {"System.setProperty()": [[8, 27]]}}}, {"text": "The RequestDispatcher#forward() is entirely server-side", "label": {"api": {"RequestDispatcher#forward()": [[4, 30]]}}}, {"text": "You can however redirect to the given URL using HttpServletResponse#sendRedirect()", "label": {"api": {"HttpServletResponse#sendRedirect()": [[48, 81]]}}}, {"text": "The HttpServletRequest#setCharacterEncoding() has only effect when the request is a POST request and the request body is not processed yet", "label": {"api": {"HttpServletRequest#setCharacterEncoding()": [[4, 44]]}}}, {"text": "There are several of them", "label": {"api": {"several": [[10, 16]]}}}, {"text": "Instead of StringBuffer you probably mean StringBuilder", "label": {"api": {"StringBuilder": [[42, 54]]}}}, {"text": "A StringBuffer is like a StringBuilder except that it also offers thread safety", "label": {"api": {"StringBuilder": [[25, 37]]}}}, {"text": "You can add headers using URLConnection#setRequestProperty()", "label": {"api": {"URLConnection#setRequestProperty()": [[26, 59]]}}}, {"text": "That said, I would rather use File#createTempFile() to let the underlying platform do the automatic cleanup work and to avoid potential portability trouble caused by using relative paths in File", "label": {"api": {"File#createTempFile()": [[30, 50]]}}}, {"text": "As you can see I need the mock to implement the interface of javax.persistence.Query, which returns a java.util.List", "label": {"api": {"javax.persistence.Query": [[61, 83]]}}}, {"text": "You can also just use ExternalContext#redirect()", "label": {"api": {"ExternalContext#redirect()": [[22, 47]]}}}, {"text": "Using the String.intern() method you can add any string you like to the internally pooled strings, these will be kept in memory until java exits", "label": {"api": {"String.intern()": [[10, 24]]}}}, {"text": "Once you set the Connection#setAutoCommit() to false (or configure it to be by default), then the transaction will start and it will finish when you call Connection#commit()", "label": {"api": {"Connection#setAutoCommit()": [[17, 42]], "Connection#commit()": [[154, 172]]}}}, {"text": "The output target can namely be changed using System#setOut()", "label": {"api": {"System#setOut()": [[46, 60]]}}}, {"text": "To be absolutely sure, I would use BigDecimal.divide(BigDecimal, int, int)", "label": {"api": {"BigDecimal.divide(BigDecimal, int, int)": [[35, 73]]}}}, {"text": "You can test expired sessions by checking if HttpServletRequest#getRequestedSessionId() doesn't return null (which means that the client has sent a session cookie and thus assumes that the session is still valid) and HttpServletRequest#isRequestedSessionIdValid() returns false (which means that the session has been expired at the server side)", "label": {"api": {"HttpServletRequest#getRequestedSessionId()": [[45, 86]], "HttpServletRequest#isRequestedSessionIdValid()": [[217, 262]]}}}, {"text": "See Java documentation for EventQueue", "label": {"api": {"See Java documentation for EventQueue": [[0, 36]]}}}, {"text": "Rather use ScheduledExecutorService#scheduleAtFixedRate() instead of the old fashioned Thread#sleep()", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate()": [[11, 56]]}}}, {"text": "You can use ServletContextListener to run it on webapp's startup and stop it on webapp's shutdown", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "The best what you can control is the thread priority", "label": {"api": {"thread priority": [[37, 51]]}}}, {"text": "Change the destination of the stdout using System#setOut() and eventually also the stderr", "label": {"api": {"System#setOut()": [[43, 57]]}}}, {"text": "You can acquire a FileLock via a FileChannel", "label": {"api": {"FileLock": [[18, 25]], "FileChannel": [[33, 43]]}}}, {"text": "To obtain a FileChannel", "label": {"api": {"FileChannel": [[12, 22]]}}}, {"text": "In this release a file channel can be obtained from an existing FileInputStream, FileOutputStream, or RandomAccessFile object by invoking that object's getChannel method, which returns a file channel that is connected to the same underlying file", "label": {"api": {"FileInputStream": [[64, 78]], "FileOutputStream": [[81, 96]], "RandomAccessFile": [[102, 117]]}}}, {"text": "But I'm going to take a stab in the dark and suggest you look at ServletContextListener", "label": {"api": {"ServletContextListener": [[65, 86]]}}}, {"text": "DocumentBuilderFactory has a newInstance() method where you can specify the class name of the implementation you want to use", "label": {"api": {"newInstance()": [[29, 41]]}}}, {"text": "If you still want to restore the original String later on, try something like this", "label": {"api": {"String": [[42, 47]]}}}, {"text": "Collection is the root interface to the java Collections hierarchy", "label": {"api": {"Collection": [[0, 9], [45, 54]]}}}, {"text": "List is  one sub interface which defines an ordered Collection, other sub interfaces are  Queue which typically will store elements ready for processing (e.g", "label": {"api": {"Collection": [[52, 61]], "List": [[0, 3]], "Queue": [[90, 94]]}}}, {"text": "a List is a Collection", "label": {"api": {"List": [[2, 5]], "Collection": [[12, 21]]}}}, {"text": "It is a specialized Collection, however", "label": {"api": {"Collection": [[20, 29]]}}}, {"text": "A Collection is just that", "label": {"api": {"Collection": [[2, 11]]}}}, {"text": "A List adds the information about a defined sequence of stuff to it", "label": {"api": {"List": [[2, 5]]}}}, {"text": "In a Collection you can't do that", "label": {"api": {"Collection": [[5, 14]]}}}, {"text": "There are other specialized Collections as well, for example a Set which adds the feature that it will never contain the same element twice", "label": {"api": {"Collection": [[28, 37]], "Set": [[63, 65]]}}}, {"text": "They are located in the java.util.Arrays class", "label": {"api": {"java.util.Arrays": [[24, 39]]}}}, {"text": "Since version 6.0.24, Tomcat ships with a memory leak detection feature, which in turn can lead to this kind of warning messages when there's a JDBC 4.0 compatible driver in the webapp's /WEB-INF/lib which auto-registers itself during webapp's startup using the ServiceLoader API, but which did not auto-deregister itself during webapp's shutdown", "label": {"api": {"registers": [[211, 219]], "ServiceLoader API": [[262, 278]], "deregister": [[304, 313]]}}}, {"text": "If you still keep it in webapp's /WEB-INF/lib, then you should manually register and deregister it using a ServletContextListener", "label": {"api": {"deregister": [[85, 94]]}}}, {"text": "Note that Tomcat's builtin DBCP does not deregister drivers properly on close", "label": {"api": {"deregister": [[41, 50]]}}}, {"text": "Use java.text.Normalizer to handle this for you", "label": {"api": {"java.text.Normalizer": [[4, 23]]}}}, {"text": "The <servlet-class> subelement of <servlet> points out a class that implements javax.servlet.Servlet, which is a rudimentary interface for classes handling web requests", "label": {"api": {"javax.servlet.Servlet": [[79, 99]]}}}, {"text": "The class java.awt.BufferedImage has a method setRGB(int x, int y, int rgb) which sets the color of an individual pixel", "label": {"api": {"java.awt.BufferedImage": [[10, 31]]}}}, {"text": "Additionally, you might want to look at java.awt.Color, especially its getRGB() method, which can convert Colors into integers that you can put into the int rgb parameter of setRGB", "label": {"api": {"java.awt.Color": [[40, 53]]}}}, {"text": "Use byteBufferViewVarHandle or byteArrayViewVarHandle", "label": {"api": {"byteBufferViewVarHandle": [[4, 26]]}}}, {"text": "Java provides concurrent API to avail advantages of multi-core processors of machine", "label": {"api": {"concurrent API": [[14, 27]]}}}, {"text": "You can get available processors count from Runtime and use that count to create ExecutorService through many APIs in Executors", "label": {"api": {"ExecutorService": [[81, 95]], "Executors": [[118, 126]]}}}, {"text": "You can also use ThreadPoolExecutor API to achieve the same", "label": {"api": {"ThreadPoolExecutor": [[17, 34]]}}}, {"text": "Java's Fork/Join vs ExecutorService - when to use which", "label": {"api": {"ExecutorService": [[20, 34]]}}}, {"text": "Check out the Javadoc for File.list()", "label": {"api": {"Javadoc for File.list()": [[14, 36]]}}}, {"text": "catch the InterruptedException", "label": {"api": {"InterruptedException": [[10, 29]]}}}, {"text": "Java 8 added Map.forEach which you can use like this", "label": {"api": {"Map.forEach": [[13, 23]]}}}, {"text": "There's also replaceAll if you want to update the values", "label": {"api": {"replaceAll": [[13, 22]]}}}, {"text": "Refer to the API specification for the DataInput.readFully method", "label": {"api": {"API specification": [[13, 29]]}}}, {"text": "You want to split on every character, so rather use string.split(\"\")", "label": {"api": {"string.split(\"\")": [[52, 67]]}}}, {"text": "Or better, just iterate over every character returned by string.toCharArray()", "label": {"api": {"string.toCharArray()": [[57, 76]]}}}, {"text": "CODe's answer is right, but I'd go with the SwingWorker class", "label": {"api": {"SwingWorker": [[44, 54]]}}}, {"text": "Try ConcurrentLinkedQueue or LinkedBlockingDeque instead if it fits your needs, they are thread safe but slightly different behavior than LinkedList", "label": {"api": {"LinkedBlockingDeque": [[29, 47]]}}}, {"text": "If you create an anonymous subclass new TypeLiteral<List<String>>() {} Guice can call getClass().getGenericSuperclass() on it and get a java.lang.reflect.ParameterizedType on which exists a method getActualTypeArguments() to get List<String> as an instance of ParameterizedType", "label": {"api": {"getClass().getGenericSuperclass()": [[86, 118]], "java.lang.reflect.ParameterizedType": [[136, 170]], "getActualTypeArguments()": [[197, 220]]}}}, {"text": "There are methods in the InetAddress class for that", "label": {"api": {"InetAddress": [[25, 35]]}}}, {"text": "I think you'll want either getHostName or getCanonicalHostName, depending on your need", "label": {"api": {"getHostName": [[27, 37]], "getCanonicalHostName": [[42, 61]]}}}, {"text": "The certificate objects can be created by an instance of CertificateFactory - in particular, one configured to create X509 certificates", "label": {"api": {"CertificateFactory": [[57, 74]]}}}, {"text": "This can be achieved by wrapping your byte array in a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[54, 73]]}}}, {"text": "Convert it to String and use String#toCharArray() or String#split()", "label": {"api": {"String": [[14, 19], [29, 34], [53, 58]], "String#toCharArray()": [[29, 48]], "String#split()": [[53, 66]]}}}, {"text": "In case you're already on Java 8 and you happen to want to do some aggregate operations on it afterwards, consider using String#chars() to get an IntStream out of it", "label": {"api": {"String": [[121, 126]], "String#chars()": [[121, 134]], "IntStream": [[146, 154]]}}}, {"text": "As of Java 8, the String class has a static method join", "label": {"api": {"join": [[51, 54]]}}}, {"text": "Also in Java 8, you could use the new StringJoiner class, for scenarios where you want to start constructing the string before you have the full list of elements to put in it", "label": {"api": {"StringJoiner": [[38, 49]]}}}, {"text": "You may use java.nio.Buffer classes hierarchy, especially java.nio.ByteBuffer which offers buffer abstraction on whole array or sub-ranges", "label": {"api": {"java.nio.ByteBuffer": [[58, 76]]}}}, {"text": "Here is example of wrapping using java.nio.ByteBuffer", "label": {"api": {"java.nio.ByteBuffer": [[34, 52]]}}}, {"text": "To set thousand separator, say 123,456.78 you have to use DecimalFormat", "label": {"api": {"DecimalFormat": [[58, 70]]}}}, {"text": "For example, if you were using BlockingQueue.poll(long, TimeUnit), you could check if the result is null to know if you timed out", "label": {"api": {"BlockingQueue.poll(long, TimeUnit)": [[31, 64]]}}}, {"text": "In JPA you can do similar using Query#setFirstResult() and Query#setMaxResults()", "label": {"api": {"Query#setFirstResult()": [[32, 53]], "Query#setMaxResults()": [[59, 79]]}}}, {"text": "You can use java.lang.Runtime.exec to run simple code", "label": {"api": {"java.lang.Runtime.exec": [[12, 33]]}}}, {"text": "println and print are the two overloaded methods which belong to the PrintStream class", "label": {"api": {"PrintStream": [[69, 79]]}}}, {"text": "A static property called out of type PrintStream is created on the System class", "label": {"api": {"PrintStream": [[37, 47]], "System": [[67, 72]]}}}, {"text": "You can achieve what you want by using a custom HttpServletResponse", "label": {"api": {"HttpServletResponse": [[48, 66]]}}}, {"text": "You pass this wrapped HttpServletResponse down the filter chain", "label": {"api": {"HttpServletResponse": [[22, 40]]}}}, {"text": "Splitting an empty string with String.split() returns a single element array containing an empty string", "label": {"api": {"String.split()": [[31, 44]]}}}, {"text": "You'd like to override the HttpServletResponse#addHeader() and HttpServletResponse#setHeader() method instead", "label": {"api": {"HttpServletResponse#addHeader()": [[27, 57]], "HttpServletResponse#setHeader()": [[63, 93]]}}}, {"text": "Yes, you need to implement a Converter", "label": {"api": {"Converter": [[29, 37]]}}}, {"text": "Thanks to the @FacesConverter it'll register itself automagically", "label": {"api": {"Converter": [[20, 28]], "@FacesConverter": [[14, 28]]}}}, {"text": "If your whole expression is case insensitive, you can just specify the CASE_INSENSITIVE flag", "label": {"api": {"CASE_INSENSITIVE": [[71, 86]]}}}, {"text": "You could use the RuntimeMXBean within the application that is launched by eclipse", "label": {"api": {"RuntimeMXBean": [[18, 30]]}}}, {"text": "As of Java 8 we have another option,  \\R", "label": {"api": {"\\R": [[38, 39]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html There is a way around this, but it is out of scope of this answer", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html": [[0, 85]]}}}, {"text": "This works because by default put(..) waits until there is capacity in the queue when it is full, see", "label": {"api": {"see": [[98, 100]]}}}, {"text": "Use the Math.atan2 function", "label": {"api": {"Math.atan2": [[8, 17]]}}}, {"text": "In case you can't avoid breaking Law of Demeter (LoD) as stated in the chosen answer, and with Java 8 introducing Optional, it would be probably the best practice to handle nulls in chains of gets such as yours", "label": {"api": {"Optional": [[114, 121]]}}}, {"text": "The Optional type will enable you to pipe multiple map operations (which contain get calls) in a row", "label": {"api": {"Optional": [[4, 11]]}}}, {"text": "The return of it will be something like Optional<Door> which will allow you much safer work without worrying of null exceptions", "label": {"api": {"Optional": [[40, 47]]}}}, {"text": "FWIW, if you're opening a file in Java 8, you can use the Files.newBufferedReader(Path)", "label": {"api": {"Files.newBufferedReader(Path)": [[58, 86]]}}}, {"text": "With Java 8 you can also use the toString() method of java.time.Duration to format it without external libraries using ISO 8601 seconds based representation such as PT8H6M12.345S", "label": {"api": {"toString()": [[33, 42]], "java.time.Duration": [[54, 71]]}}}, {"text": "Use getOutputSize to determine how big the output buffer should be", "label": {"api": {"getOutputSize": [[4, 16]]}}}, {"text": "So if you're allocating the output buffer \"near\" the point where you call the doFinal method, then it would make sense to call getOutputSize and allocate an appropriately-sized buffer", "label": {"api": {"getOutputSize": [[127, 139]]}}}, {"text": "It would be perfectly legal (at least, according to the public interface of the Java class) for a Cipher implementation to return an output larger than the block size, so long as the getOutputSize method returns the appropriate size", "label": {"api": {"getOutputSize": [[183, 195]]}}}, {"text": "Note that this takes a regular expression, so remember to escape special characters if necessary", "label": {"api": {"regular expression": [[23, 40]]}}}, {"text": "which means \"any character\" in regex, use either backslash \\ to escape the individual special character like so split(\"\\\\.\"), or use character class [] to represent literal character(s) like so split(\"[.]\"), or use Pattern#quote() to escape the entire string like so split(Pattern.quote(\".\"))", "label": {"api": {"Pattern#quote()": [[215, 229]]}}}, {"text": "To test beforehand if the string contains certain character(s), just use String#contains()", "label": {"api": {"String#contains()": [[73, 89]]}}}, {"text": "Note, this does not take a regular expression", "label": {"api": {"regular expression": [[27, 44]]}}}, {"text": "For that, use String#matches() instead", "label": {"api": {"String#matches()": [[14, 29]]}}}, {"text": "For simple use cases String.split() should do the job", "label": {"api": {"String.split()": [[21, 34]]}}}, {"text": "Use InputStream as argument to InputSource when you want Sax to autodetect the encoding", "label": {"api": {"InputSource": [[31, 41]]}}}, {"text": "If you want to set a specific encoding, use Reader with a specified encoding or setEncoding method", "label": {"api": {"setEncoding": [[80, 90]]}}}, {"text": "Here's an excerpt from java.text.CharacterIterator documentation", "label": {"api": {"java.text.CharacterIterator": [[23, 49]]}}}, {"text": "static final char DONE", "label": {"api": {"static final char DONE": [[0, 21]]}}}, {"text": "There's a similar object for each primitive, and they define the methods you're interested in (hashCode,equals)", "label": {"api": {"hashCode": [[95, 102]], "equals": [[104, 109]]}}}, {"text": "For earlier versions, you might try addTab() with a suitable implementation of Icon used to indicate progress", "label": {"api": {"addTab()": [[36, 43]]}}}, {"text": "If you wanna have everything into one only piece of code, then you can mix tim's answer with the example's approach found on the API for JTextField, and you'll get something like this", "label": {"api": {"JTextField": [[137, 146]]}}}, {"text": "Then there is no need to add a Document to the JTextFieldLimit due to JTextFieldLimit already have the functionality inside", "label": {"api": {"JTextField": [[47, 56], [70, 79]]}}}, {"text": "Have a look at javax.swing.tree, TreeModel, and TreeNode", "label": {"api": {"TreeModel": [[33, 41]], "TreeNode": [[48, 55]]}}}, {"text": "Then you can read these properties using standard (though not too practical) Java Properties API", "label": {"api": {"Java Properties API": [[77, 95]]}}}, {"text": "Apache Commons is not acceptable), and I came up with a simple solution using the built-in java.io.StreamTokenizer", "label": {"api": {"java.io.StreamTokenizer": [[91, 113]]}}}, {"text": "By using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[11, 34]]}}}, {"text": "It will allow you to created a ScheduledExecutorService which lets you submit Runnables to be executed at regular intervals", "label": {"api": {"ScheduledExecutorService": [[31, 54]]}}}, {"text": "The common approach would be to check it with a regular expression like it's also suggested inside the Double.valueOf(String) documentation", "label": {"api": {"Double.valueOf(String)": [[103, 124]]}}}, {"text": "This code is based on the JavaDocs at Double", "label": {"api": {"Double": [[38, 43]]}}}, {"text": "The File class contains the following public members that you can use for platform specific file paths", "label": {"api": {"File": [[4, 7]]}}}, {"text": "If you still want to use the system path separator there is the File.separator property which will give you the right one depending on the current system", "label": {"api": {"File.separator": [[64, 77]]}}}, {"text": "For the root, you can use listRoots() which gives you an array of root, there will be only one element on Unix systems, and as many as you have drives on Windows", "label": {"api": {"listRoots()": [[26, 36]]}}}, {"text": "Check SocketChannel class and its related code samples", "label": {"api": {"SocketChannel": [[6, 18]]}}}, {"text": "If you want something quick and dirty, try inputStream.available()", "label": {"api": {"inputStream.available()": [[43, 65]]}}}, {"text": "Following, you can find a complete example on how to adjust the selected rows, using the ListSelectionModel, including MouseEvent#getModifiers checks", "label": {"api": {"ListSelectionModel": [[89, 106]], "MouseEvent#getModifiers": [[119, 141]]}}}, {"text": "After that, it is possible to open a (optional) JPopupMenu", "label": {"api": {"JPopupMenu": [[48, 57]]}}}, {"text": "I've been wondering what the exact meaning of  Runtime.getRuntime().totalMemory(), Runtime.getRuntime().freeMemory(), and Runtime.getRuntime().maxMemory() is", "label": {"api": {"Runtime.getRuntime().totalMemory()": [[47, 80]], "Runtime.getRuntime().freeMemory()": [[83, 115]], "Runtime.getRuntime().maxMemory()": [[122, 153]]}}}, {"text": "My understanding is, Runtime.getRuntime().totalMemory() returns the total memory my process is using", "label": {"api": {"Runtime.getRuntime().totalMemory()": [[21, 54]]}}}, {"text": "Java has a built-in way of dealing with this, in the java.nio.file.Files class, that may work for your needs", "label": {"api": {"java.nio.file.Files class": [[53, 77]]}}}, {"text": "My dirty and may tiniest using String.replaceAll", "label": {"api": {"String.replaceAll": [[31, 47]]}}}, {"text": "Something like this may be useful in, say, any of ImageIO's write methods, where the file format has to be passed in", "label": {"api": {"any of ImageIO's write methods": [[43, 72]]}}}, {"text": "See LocalDateTime API", "label": {"api": {"LocalDateTime API": [[4, 20]]}}}, {"text": "Or you copy the code from the IDN class", "label": {"api": {"IDN": [[30, 32]]}}}, {"text": "Use the Toolkit to get the system clipboard", "label": {"api": {"Toolkit": [[8, 14]], "system clipboard": [[27, 42]]}}}, {"text": "Create a StringSelection with the String and add it to the Clipboard", "label": {"api": {"StringSelection": [[9, 23]]}}}, {"text": "For further information, read the documentation", "label": {"api": {"read the documentation": [[25, 46]]}}}, {"text": "From the Socket#setSoTimeout(int timeout) Documentation", "label": {"api": {"Socket#setSoTimeout(int timeout) Documentation": [[9, 54]]}}}, {"text": "But I think you will need a Compound-Renderer, which means you have to create your own CellRenderer implementing TableCellRenderer or extending the existing DefaultTableCellRenderer", "label": {"api": {"TableCellRenderer": [[113, 129], [164, 180]], "DefaultTableCellRenderer": [[157, 180]]}}}, {"text": "With Java 8 Optional you can do", "label": {"api": {"Java 8 Optional": [[5, 19]]}}}, {"text": "ArrayList, HashSet, LinkedList, Stack and Vector", "label": {"api": {"ArrayList": [[0, 8]], "HashSet": [[11, 17]], "LinkedList": [[20, 29]], "Stack": [[32, 36]], "Vector": [[42, 47]]}}}, {"text": "I'm surprised no one has answered this, but would'nt you have been better off implementing an editable JSpinner with a SpinnerListModel", "label": {"api": {"SpinnerListModel": [[119, 134]]}}}, {"text": "Use the isSelected method", "label": {"api": {"isSelected": [[8, 17]]}}}, {"text": "You can also use an ItemListener so you'll be notified when it's checked or unchecked", "label": {"api": {"ItemListener": [[20, 31]]}}}, {"text": "Here is my diagram showing how String is a one of several concrete classes implementing the CharSequence interface", "label": {"api": {"String": [[31, 36]], "CharSequence": [[92, 103]]}}}, {"text": "In particular, StringBuilder is commonly used as a faster alternative to concatenation String objects with the + operator, where thread-safety is not needed", "label": {"api": {"String": [[15, 20], [87, 92]], "StringBuilder": [[15, 27]]}}}, {"text": "So, String[] is an array of String objects, and CharSequence[] is an array of objects that may or may not be String objects but definitely are objects implementing the CharSequence interface", "label": {"api": {"String": [[4, 9], [28, 33], [109, 114]], "CharSequence": [[48, 59], [168, 179]]}}}, {"text": "You want to use a Set or List implementation (e.g", "label": {"api": {"Set": [[18, 20]], "List": [[25, 28]]}}}, {"text": "HashSet, TreeSet, etc, or ArrayList, LinkedList, etc..), since Java does not have dynamically sized arrays", "label": {"api": {"Set": [[4, 6], [13, 15]], "List": [[31, 34], [43, 46]], "HashSet": [[0, 6]], "TreeSet": [[9, 15]], "ArrayList": [[26, 34]], "LinkedList": [[37, 46]]}}}, {"text": "Here is a more succinct way to initialize your List with an arbitrary number of values using varargs", "label": {"api": {"List": [[47, 50]]}}}, {"text": "The Array.newInstance(Class<?> componentType, int length) method is to be used to create an array with dynamically length", "label": {"api": {"Array.newInstance(Class<?> componentType, int length)": [[4, 56]]}}}, {"text": "After having the same problem and none of these answers helped me, I found out that my UI thread was blocked (I used a CountDownLatch.await()) and therefore the onPostExecute() method that is supposed to be called by the UI thread was never called", "label": {"api": {"CountDownLatch.await()": [[119, 140]]}}}, {"text": "Is there any way to make DateFormat format a date with a full year (eg", "label": {"api": {"DateFormat": [[25, 34]]}}}, {"text": "12/12/2010), when using DateFormat.SHORT as the pattern", "label": {"api": {"DateFormat": [[24, 33]], "DateFormat.SHORT": [[24, 39]]}}}, {"text": "I know I could use DateFormat.MEDIUM, but the date have to be formatted using only numbers and separators, and DateFormat.MEDIUM for en_US produces something like 'Dec 12, 2010'", "label": {"api": {"DateFormat": [[19, 28], [111, 120]], "DateFormat.MEDIUM": [[19, 35], [111, 127]]}}}, {"text": "Starting with Java 8 and later this can be done without external dependencies using Stream API", "label": {"api": {"Stream API": [[84, 93]]}}}, {"text": "Unfortunately, that's also what the DateTimeConverter javadoc is telling", "label": {"api": {"DateTimeConverter javadoc": [[36, 60]]}}}, {"text": "You can use the java.io.RandomAccessFile to do this", "label": {"api": {"java.io.RandomAccessFile": [[16, 39]]}}}, {"text": "The methods seek(long) and getFilePointer() will help to jump to different offsets in the file and come back to original offsets", "label": {"api": {"seek(long)": [[12, 21]], "getFilePointer()": [[27, 42]]}}}, {"text": "You can also use the computeIfAbsent() method in the HashMap class", "label": {"api": {"computeIfAbsent()": [[21, 37]]}}}, {"text": "If it exists, then the value for the key will be returned by computeIfAbsent()", "label": {"api": {"computeIfAbsent()": [[61, 77]]}}}, {"text": "If you were interested in getting Path from URL, you can do", "label": {"api": {"Path": [[34, 37]]}}}, {"text": "With Java 7, you can use Files.createDirectories()", "label": {"api": {"Files.createDirectories()": [[25, 49]]}}}, {"text": "It seems unnecessary to check for existence of the dir or file before creating, from createDirectories javadocs", "label": {"api": {"from createDirectories javadocs": [[80, 110]]}}}, {"text": "In the server side you just use HttpServletRequest#getParameter() to obtain the rating value", "label": {"api": {"HttpServletRequest#getParameter()": [[32, 64]]}}}, {"text": "With Java 8, you can filter with a lambda expression using Collection.removeIf", "label": {"api": {"Collection.removeIf": [[59, 77]]}}}, {"text": "All actions performed by a thread before it queues an object on a BlockingQueue \"happen-before\" the object is dequeued", "label": {"api": {"happen-before": [[81, 93]]}}}, {"text": "As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread", "label": {"api": {"happen-before": [[106, 118]]}}}, {"text": "Assuming your data model derives from AbstractTableModel, you can update your model explicitly and fire the appropriate update method implemented in the abstract parent", "label": {"api": {"AbstractTableModel": [[38, 55]]}}}, {"text": "You might want to look at the DecimalFormat class; it supports different locales (eg", "label": {"api": {"DecimalFormat": [[30, 42]]}}}, {"text": "nextDouble will return a pseudorandom double value between the minimum (inclusive) and the maximum (exclusive)", "label": {"api": {"nextDouble": [[0, 9]]}}}, {"text": "The official reference is the class Formatter", "label": {"api": {"Formatter": [[36, 44]]}}}, {"text": "You can use Float.compare(float f1, float f2)", "label": {"api": {"Float.compare(float f1, float f2)": [[12, 44]]}}}, {"text": "Did you try JComponent.setBackground(Color c)", "label": {"api": {"setBackground(Color c)": [[23, 44]]}}}, {"text": "The document says", "label": {"api": {"document": [[4, 11]]}}}, {"text": "Use ProcessBuilder e.g", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Object.hashCode used to be computed based on a memory location where the object is located", "label": {"api": {"Object.hashCode": [[0, 14]]}}}, {"text": "There is however a method Collections.unmodifiableList(..) which creates an unmodifiable view of e.g", "label": {"api": {"Collections.unmodifiableList(..)": [[26, 57]]}}}, {"text": "There's an option in the FileWriter instead of the CSVWriter to append at the end of the file", "label": {"api": {"FileWriter": [[25, 34]]}}}, {"text": "Upon application startup or servlet initialization use the Executors class", "label": {"api": {"Executors": [[59, 67]]}}}, {"text": "If you are trying to do real work, I suggest you forget that and use Scanner", "label": {"api": {"Scanner": [[69, 75]]}}}, {"text": "Check out setParseBigDecimal in DecimalFormat", "label": {"api": {"setParseBigDecimal": [[10, 27]]}}}, {"text": "With this setter, parse will return a BigDecimal for you", "label": {"api": {"parse": [[18, 22]]}}}, {"text": "Here's a one-liner version which uses Java 8 IntStream to determine the indexes of the slice beginnings", "label": {"api": {"IntStream": [[45, 53]]}}}, {"text": "split does include empty matches in the result, have a look at the docs here", "label": {"api": {"docs here": [[67, 75]]}}}, {"text": "What is the difference between returning 0, returning 1 and returning -1 in compareTo() in Java", "label": {"api": {"compareTo()": [[76, 86]]}}}, {"text": "Use the replaceFirst function", "label": {"api": {"replaceFirst": [[8, 19]]}}}, {"text": "From sun.misc.VM, it's Runtime.getRuntime.maxMemory(), that's what is configured with -Xmx", "label": {"api": {"Runtime.getRuntime.maxMemory()": [[23, 52]]}}}, {"text": "The Java Class Library represents external processes using the java.lang.Process class", "label": {"api": {"java.lang.Process": [[63, 79]], "Process": [[73, 79]]}}}, {"text": "Processes can be spawned using a java.lang.ProcessBuilder", "label": {"api": {"java.lang.Process": [[33, 49]], "java.lang.ProcessBuilder": [[33, 56]], "Process": [[0, 6], [43, 49]]}}}, {"text": "or the older interface exposed by the overloaded exec methods on the java.lang.Runtime class", "label": {"api": {"java.lang.Runtime": [[69, 85]]}}}, {"text": "Both of these will code snippets will spawn a new process, which usually executes asynchronously and can be interacted with through the resulting Process object", "label": {"api": {"Process": [[146, 152]]}}}, {"text": "If you need to check that the process has finished (or wait for it to finish), don't forget to check that the exit value (exit code) returned by process.exitValue() or process.waitFor() is as expected (0 for most programs), since no exception is thrown if the process exits abnormally", "label": {"api": {"process.exitValue()": [[145, 163]], "process.waitFor()": [[168, 184]]}}}, {"text": "Also note that additional code is often necessary to handle the process's I/O correctly, as described in the documentation for the Process class (emphasis added)", "label": {"api": {"Process": [[131, 137]], "documentation for the Process class": [[109, 143]]}}}, {"text": "I had a feeling that this constructor has to be inherited from java.lang.Exception, isn't it", "label": {"api": {"java.lang.Exception": [[63, 81]]}}}, {"text": "I use the Scanner class for reading multiple similar files", "label": {"api": {"Scanner class": [[10, 22]]}}}, {"text": "If you don't mind doing it programmatically, you can investigate the 1.6 Java Compiler API and Compiler Tree API", "label": {"api": {"Java Compiler API": [[73, 89]], "Compiler Tree API": [[95, 111]]}}}, {"text": "Use java.sql.Timestamp with PreparedStatement#setTimestamp()", "label": {"api": {"java.sql.Timestamp": [[4, 21]], "PreparedStatement#setTimestamp()": [[28, 59]]}}}, {"text": "Note that java.sql.Date stores only the date part, not the time part", "label": {"api": {"java.sql.Date": [[10, 22]]}}}, {"text": "The setDate() expects java.sql.Date, not java.util.Date", "label": {"api": {"setDate()": [[4, 12]], "java.sql.Date": [[22, 34]], "java.util.Date": [[41, 54]]}}}, {"text": "But the java.sql.Date contains only the date part of datetime, not the time part", "label": {"api": {"java.sql.Date": [[8, 20]]}}}, {"text": "You'd like to use java.sql.Timestamp instead", "label": {"api": {"java.sql.Timestamp": [[18, 35]]}}}, {"text": "Java 8 has added java.util.IntSummaryStatistics", "label": {"api": {"java.util.IntSummaryStatistics": [[17, 46]]}}}, {"text": "The class is called java.util.Scanner (with a capital S)", "label": {"api": {"java.util.Scanner": [[20, 36]]}}}, {"text": "If it's just having to execute something after some time, try using a Timer", "label": {"api": {"Timer": [[70, 74]]}}}, {"text": "This implementation does not make use of  threads to remove expired entries, instead it uses DelayQueue that is cleaned up at every operation automatically", "label": {"api": {"DelayQueue": [[93, 102]]}}}, {"text": "Java 8 introduced the methods addExact, subtractExact, multiplyExact and toIntExact", "label": {"api": {"addExact": [[30, 37]], "subtractExact": [[40, 52]], "multiplyExact": [[55, 67]], "toIntExact": [[73, 82]]}}}, {"text": "JDK7's java.nio.file package has a WatchService to support file change notification", "label": {"api": {"WatchService": [[35, 46]]}}}, {"text": "For now, you can try jpathwatch, which is an implementation of the WatchService interface and uses native OS functions, instead of polling", "label": {"api": {"WatchService": [[67, 78]]}}}, {"text": "Another approach is to use a CopyOnWriteArrayList instead of Collections.synchronizedList()", "label": {"api": {"CopyOnWriteArrayList": [[29, 48]]}}}, {"text": "Integer.valueOf(int) will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range", "label": {"api": {"Integer.valueOf(int)": [[0, 19]]}}}, {"text": "One of the solutions is to use Javaâ„¢ Smart Card I/O API", "label": {"api": {"Javaâ„¢ Smart Card I/O API": [[31, 54]]}}}, {"text": "See the \"Description\" section for a simple usage example", "label": {"api": {"\"Description\"": [[8, 20]]}}}, {"text": "Inject a HttpServletRequest into your Rest Service as such", "label": {"api": {"HttpServletRequest": [[9, 26]]}}}, {"text": "Basically because an Iterable may never end (that is, hasNext() return true forever)", "label": {"api": {"hasNext()": [[54, 62]]}}}, {"text": "If the file is -as the package name hints- is actually a fullworthy properties file (containing key=value lines) with just the \"wrong\" extension, then you could feed the InputStream immediately to the load() method", "label": {"api": {"load()": [[201, 206]]}}}, {"text": "Since Java 7 BitSet has the toLongArray method, which I believe will do exactly what the question asks for", "label": {"api": {"toLongArray": [[28, 38]]}}}, {"text": "Java 7 improves on this sorry state of affairs with the Files class (not to be confused with Guava's class of the same name), you can get all lines from a file - without external libraries - with", "label": {"api": {"Files": [[56, 60]]}}}, {"text": "DatabaseMetaData.getProcedureColumns is the generic JDBC method to get the parameters for a procedure", "label": {"api": {"DatabaseMetaData.getProcedureColumns": [[0, 35]]}}}, {"text": "Java converts bytes read from the file into characters using the specified charset, which is the default one (from underlying OS) if nothing is given (source)", "label": {"api": {"source": [[151, 156]]}}}, {"text": "A good place to do such cleanup is ServletRequestListener.requestDestroyed()", "label": {"api": {"ServletRequestListener.requestDestroyed()": [[35, 75]]}}}, {"text": "Look at the SimpleDateFormat doc for complete instructions", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "In Java's perspective (Thread.State), there are two different states", "label": {"api": {"Thread.State": [[23, 34]]}}}, {"text": "Use String.equals(Object) instead", "label": {"api": {"String.equals(Object)": [[4, 24]]}}}, {"text": "You can subclass ScheduledThreadPoolExecutor and override the afterExecute method to handle exceptions and errors for any kind of Runnable that you submit", "label": {"api": {"afterExecute": [[62, 73]]}}}, {"text": "Perhaps the best way around this is to use the FileOpenService", "label": {"api": {"FileOpenService": [[47, 61]]}}}, {"text": "Of course, you could always just resort to using Iterator.forEachRemaining()", "label": {"api": {"Iterator.forEachRemaining()": [[49, 75]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html for more details", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html": [[4, 79]]}}}, {"text": "You should replace your getEnumNameForValue by a call to the name() method", "label": {"api": {"name()": [[61, 66]]}}}, {"text": "There is nothing built in, but you could certainly join all of the elements in your array and pass the resulting string into the Scanner constructor", "label": {"api": {"Scanner constructor": [[129, 147]]}}}, {"text": "A solution with better performance but a greater time investment is to implement Readable by wrapping your array, and keeping track of the current element in the array and the current position in that element's string representation", "label": {"api": {"Readable": [[81, 88]]}}}, {"text": "You can then fill the buffer with data from the backing array as the Scanner reads from your Readable object", "label": {"api": {"Readable": [[93, 100]], "reads": [[77, 81]]}}}, {"text": "See java.util.Collection.stream() and java.util.stream.Collectors.toList()", "label": {"api": {"java.util.Collection.stream()": [[4, 32]], "java.util.stream.Collectors.toList()": [[38, 73]]}}}, {"text": "I think you're looking for Field.get()", "label": {"api": {"Field.get()": [[27, 37]]}}}, {"text": "URLConnection is the base class", "label": {"api": {"URLConnection": [[0, 12]]}}}, {"text": "HttpURLConnection is a derived class which you can use when you need the extra API and you are dealing with HTTP or HTTPS only", "label": {"api": {"URLConnection": [[4, 16]], "HttpURLConnection": [[0, 16]]}}}, {"text": "HttpsURLConnection is a 'more derived' class which you can use when you need the 'more extra' API and you are dealing with HTTPS only", "label": {"api": {"URLConnection": [[5, 17]], "HttpsURLConnection": [[0, 17]]}}}, {"text": "How should I choose between ExecutorService's submit or execute, if the returned value is not my concern", "label": {"api": {"submit": [[46, 51]], "execute": [[56, 62]]}}}, {"text": "Maybe you are looking for a CompletionService to manage batches of task, see also this answer", "label": {"api": {"CompletionService": [[28, 44]]}}}, {"text": "Integer.toString calls the static method in the class Integer", "label": {"api": {"Integer.toString": [[0, 15]], "Integer": [[0, 6], [54, 60]]}}}, {"text": "It does not need an instance of Integer", "label": {"api": {"Integer": [[32, 38]]}}}, {"text": "If you call new Integer(i) you create an instance of type Integer, which is a full Java object encapsulating the value of your int", "label": {"api": {"Integer": [[16, 22], [58, 64]], "new Integer(i)": [[12, 25]]}}}, {"text": "Another option is the static String.valueOf method", "label": {"api": {"String.valueOf": [[29, 42]]}}}, {"text": "I recently ran into this problem and just wanted to mention that since java 7 the process builder api has been expanded", "label": {"api": {"process builder api": [[82, 100]]}}}, {"text": "Since color appears to be a Color, that's a class, and therefore a reference type, which means you need to use equals() to compare the colors", "label": {"api": {"Color": [[28, 32]]}}}, {"text": "However Java 7 will include a new AsynchronousFileChannel class that supports asynchronous file I/O, which is a different mechanism to non-blocking I/O", "label": {"api": {"AsynchronousFileChannel": [[34, 56]]}}}, {"text": "If the input is quite rigid, then you can simply use String#split(), which should make it very clear what you're doing", "label": {"api": {"String#split()": [[53, 66]]}}}, {"text": "Don't use a StringTokenizer (source)", "label": {"api": {"source": [[29, 34]]}}}, {"text": "Java 7 now has a System.lineSeparator() method", "label": {"api": {"System.lineSeparator()": [[17, 38]]}}}, {"text": "When do we use AtomicReference", "label": {"api": {"AtomicReference": [[15, 29]]}}}, {"text": "Provide a simple example where AtomicReference should be used", "label": {"api": {"AtomicReference": [[31, 45]]}}}, {"text": "Refer to the JFrame documentation for more information", "label": {"api": {"JFrame documentation": [[13, 32]]}}}, {"text": "What does the String.offsetByCodePoints(int index, int codePointOffset) method do", "label": {"api": {"String.offsetByCodePoints(int index, int codePointOffset)": [[14, 70]]}}}, {"text": "There is LocalDate class, which has getDayOfMonth() method", "label": {"api": {"LocalDate": [[9, 17]]}}}, {"text": "With the java.time classes you do not need those third party libraries anymore", "label": {"api": {"java.time": [[9, 17]]}}}, {"text": "I would recommend reading about LocalDate and LocalDateTime", "label": {"api": {"LocalDate": [[32, 40], [46, 54]], "LocalDateTime": [[46, 58]]}}}, {"text": "If you are using Java 1.5 or later then this is an iterative binary GCD algorithm which uses Integer.numberOfTrailingZeros() to reduce the number of checks and iterations required", "label": {"api": {"Integer.numberOfTrailingZeros()": [[93, 123]]}}}, {"text": "Commons-Math throws an ArithematicException.class only for Integer.MIN_VALUE or Long.MIN_VALUE", "label": {"api": {"ArithematicException.class": [[23, 48]]}}}, {"text": "You can use java.util.prefs package", "label": {"api": {"java.util.prefs": [[12, 26]]}}}, {"text": "Each iteration gives a Map.Entry back which in turn has getKey() and getValue() methods", "label": {"api": {"Map.Entry": [[23, 31]]}}}, {"text": "All the format mentioned in SimpleDateFormate API is supported in the below method", "label": {"api": {"SimpleDateFormate": [[28, 44]]}}}, {"text": "That value is coming from Enum#name() method", "label": {"api": {"Enum#name()": [[26, 36]]}}}, {"text": "Starting from Java-11, one can alternatively use the API Collection.toArray(IntFunction<T[]> generator) to achieve the same as", "label": {"api": {"Collection.toArray(IntFunction<T[]> generator)": [[57, 102]]}}}, {"text": "from java.base's  java.util.Collection.toArray()", "label": {"api": {"java.base's  java.util.Collection.toArray()": [[5, 47]]}}}, {"text": "Can you guarantee that the BigDecimal will never contain a value larger than Integer.MAX_VALUE", "label": {"api": {"BigDecimal": [[27, 36]], "Integer.MAX_VALUE": [[77, 93]]}}}, {"text": "If yes, then here's your code calling intValue", "label": {"api": {"intValue": [[38, 45]]}}}, {"text": "You would call myBigDecimal.intValueExact() (or just intValue()) and it will even throw an exception if you would lose information", "label": {"api": {"myBigDecimal.intValueExact()": [[15, 42]], "intValue()": [[53, 62]]}}}, {"text": "A slightly shorter version that relies on Color.getRGB()", "label": {"api": {"Color.getRGB()": [[42, 55]]}}}, {"text": "While you can indeed use Collections.newSetFromMap() to get a WeakSet, it's use cases are actually quite limited", "label": {"api": {"Collections.newSetFromMap()": [[25, 51]]}}}, {"text": "You can just add those spreedsheets to resources under test folder and can use reource loader to load test sheets", "label": {"api": {"reource loader": [[79, 92]]}}}, {"text": "For checking if a string contains whitespace use a Matcher and call it's find method", "label": {"api": {"Matcher": [[51, 57]]}}}, {"text": "If you want to check if it only consists of whitespace then you can use String.matches", "label": {"api": {"String.matches": [[72, 85]]}}}, {"text": "I purpose to you a very simple method who use String.contains", "label": {"api": {"String.contains": [[46, 60]]}}}, {"text": "You can use chatAt() function to find out spaces in string", "label": {"api": {"chatAt()": [[12, 19]]}}}, {"text": "By design it is to be done this way", "label": {"api": {"By design": [[0, 8]]}}}, {"text": "Is a listener available for java.awt.print.PrinterJob", "label": {"api": {"java.awt.print.PrinterJob": [[28, 52]]}}}, {"text": "I could only find PrintJobListener in javax.print.DocPrintJob", "label": {"api": {"PrintJobListener": [[18, 33]], "javax.print.DocPrintJob": [[38, 60]]}}}, {"text": "I am looking for its equivalent in java.awt.print.PrinterJob, so that I could track if there are issues in printing", "label": {"api": {"java.awt.print.PrinterJob": [[35, 59]]}}}, {"text": "You could use MemoryMXBean that comes with JDK", "label": {"api": {"MemoryMXBean": [[14, 25]]}}}, {"text": "Docs about MemoryMXBean", "label": {"api": {"MemoryMXBean": [[11, 22]]}}}, {"text": "But usually the only used class loader is UrlClassLoader from which we can retrieve the list of directories and jar files (see getURLs) and open them one by one to list available classes", "label": {"api": {"getURLs": [[127, 133]]}}}, {"text": "Another approach is to use Java Pluggable Annotation Processing API to write annotation processor which will collect all annotated classes at compile time and build the index file for runtime use", "label": {"api": {"Java Pluggable Annotation Processing API": [[27, 66]]}}}, {"text": "If you are using Java 8, you may want to use java.time.format.DateTimeFormatter", "label": {"api": {"java.time.format.DateTimeFormatter": [[45, 78]]}}}, {"text": "When your class implements Comparable, the compareTo method of the class is defining the \"natural\" ordering of that object", "label": {"api": {"Comparable": [[27, 36]]}}}, {"text": "A Comparator is its own definition of how to compare two objects, and can be used to compare objects in a way that might not align with the natural ordering", "label": {"api": {"Comparator": [[2, 11]]}}}, {"text": "EhCache provides a SizeOf class that will try to use the Instrumentation agent and will fall back to a different approach if the agent is not loaded or cannot be loaded (details here)", "label": {"api": {"Instrumentation": [[57, 71]]}}}, {"text": "How about Arrays.deepToString()", "label": {"api": {"Arrays.deepToString()": [[10, 30]]}}}, {"text": "When running without prohibitive security manager, you can obtain instance of corresponding method or field trough reflection and call setAccessible() on it", "label": {"api": {"setAccessible()": [[135, 149]]}}}, {"text": "From the JavaDoc of the Serializable interface", "label": {"api": {"the JavaDoc of the Serializable interface": [[5, 45]]}}}, {"text": "See SimpleDateFormat for a description of other format strings that the class accepts", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "JTable.convertRowIndexToView() will return you an index of the row in the view based on its index in the model", "label": {"api": {"JTable.convertRowIndexToView()": [[0, 29]]}}}, {"text": "JTable.convertRowIndexToModel() will do the opposite", "label": {"api": {"JTable.convertRowIndexToModel()": [[0, 30]]}}}, {"text": "If it's affordable to check the content type based on just the file extension, then use ServletContext#getMimeType() to get the mime type (content type)", "label": {"api": {"ServletContext#getMimeType()": [[88, 115]]}}}, {"text": "If it's affordable to check for only BMP, GIF, JPG or PNG types (but not TIF, PSD, SVG, etc), then you can just feed it directly to ImageIO#read() and check if it doesn't throw an exception", "label": {"api": {"ImageIO#read()": [[132, 145]]}}}, {"text": "As you can't cast NamedNodeMap to a Map, I suggest to loop using a classic for loop like that", "label": {"api": {"Map": [[27, 29], [36, 38]]}}}, {"text": "Check out JButton documentation", "label": {"api": {"JButton": [[10, 16]]}}}, {"text": "From Object in one of the JVM implementations", "label": {"api": {"Object": [[5, 10]]}}}, {"text": "Another option is the javax.xml.stream.isCoalescing option (documented in XMLStreamReader.next()  or Using StAX), which automatically concatenates long text into a single string", "label": {"api": {"XMLStreamReader.next()": [[74, 95]]}}}, {"text": "Here's more documentation on Scanner from Oracle", "label": {"api": {"more documentation on Scanner from Oracle": [[7, 47]]}}}, {"text": "AffineTransformOp offers the additional flexibility of choosing the interpolation type", "label": {"api": {"AffineTransformOp": [[0, 16]]}}}, {"text": "If you do not mind using an external library, Thumbnailator can perform scaling of BufferedImages", "label": {"api": {"BufferedImage": [[83, 95]]}}}, {"text": "Thumbnailator will take care of handling the Java 2D processing (such as using Graphics2D and setting appropriate rendering hints) so that a simple fluent API call can be used to resize images", "label": {"api": {"Graphics2D": [[79, 88]], "rendering hints": [[114, 128]]}}}, {"text": "LocalDate is the standard Java 8 class for representing a date (without time)", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "If you want to parse values that contain date and time information you should use LocalDateTime", "label": {"api": {"LocalDate": [[82, 90]], "LocalDateTime": [[82, 94]]}}}, {"text": "For values with timezones use ZonedDateTime", "label": {"api": {"ZonedDateTime": [[30, 42]]}}}, {"text": "Both provide a parse() method similar to LocalDate", "label": {"api": {"LocalDate": [[41, 49]]}}}, {"text": "The list formatting characters from DateTimeFormatter Javadoc", "label": {"api": {"DateTimeFormatter Javadoc": [[36, 60]]}}}, {"text": "If you are just writing bits to a file, Java's BitSet class might be worth a look at", "label": {"api": {"BitSet class": [[47, 58]]}}}, {"text": "I have a class that extends a JPanel called Row", "label": {"api": {"JPanel": [[30, 35]]}}}, {"text": "I have a bunch of Row added to a JLabel, the code is the following", "label": {"api": {"JLabel": [[33, 38]]}}}, {"text": "Check out the JOptionPane documentation", "label": {"api": {"JOptionPane documentation": [[14, 38]]}}}, {"text": "Obviously java.lang.StrictMath contains additional functions (hyperbolics etc.) which java.lang.Math doesn't, but is there a difference in the functions which are found in both libraries", "label": {"api": {"java.lang.StrictMath": [[10, 29]], "java.lang.Math": [[86, 99]]}}}, {"text": "Futures can also be given a look for your project", "label": {"api": {"Futures": [[0, 6]]}}}, {"text": "You will need to use String.replaceAll(...) and not String.replace(...)", "label": {"api": {"String.replaceAll(...)": [[21, 42]]}}}, {"text": "If you want to modify the list while you're looping through it, consider looping backward to avoid that, or using an Iterator", "label": {"api": {"Iterator": [[117, 124]]}}}, {"text": "Alternatively you can use a JScrollPane", "label": {"api": {"JScrollPane": [[28, 38]]}}}, {"text": "Read the Socket class Javadoc carefully", "label": {"api": {"Socket class Javadoc": [[9, 28]]}}}, {"text": "isConnected is true if the socket was able to connect", "label": {"api": {"isConnected": [[0, 10]]}}}, {"text": "Same thing for isBound", "label": {"api": {"isBound": [[15, 21]]}}}, {"text": "I recently discovered the CachedRowSet, which does exactly what OP needs", "label": {"api": {"CachedRowSet": [[26, 37]]}}}, {"text": "What is the difference between ResultSetMetaData.getColumnLabel and  ResultSetMetaData.getColumnName", "label": {"api": {"ResultSetMetaData.getColumnLabel": [[31, 62]], "ResultSetMetaData.getColumnName": [[69, 99]]}}}, {"text": "The class Cursor as a few predefined cursors", "label": {"api": {"Cursor": [[10, 15]]}}}, {"text": "First alternative, compute", "label": {"api": {"compute": [[19, 25]]}}}, {"text": "Or use the merge method (which I would prefer)", "label": {"api": {"merge": [[11, 15]]}}}, {"text": "The Method request.getRequestURI() returns URI with context path", "label": {"api": {"request.getRequestURI()": [[11, 33]]}}}, {"text": "the context path is myapp), and I call request.getRequestURI() for http://localhost:8080/myapp/secure/users, it will return /myapp/secure/users", "label": {"api": {"request.getRequestURI()": [[39, 61]]}}}, {"text": "With Java8 stream introduction you can do it the following way", "label": {"api": {"Java8": [[5, 9]]}}}, {"text": "The two most important methods are inferBinaryName() and list()", "label": {"api": {"inferBinaryName()": [[35, 51]], "list()": [[57, 62]]}}}, {"text": "inferBinaryName() must return the class' simple name (e.g", "label": {"api": {"inferBinaryName()": [[0, 16]], "simple name": [[41, 51]]}}}, {"text": "list() is a little bit more complicated because you have to be careful to play along nicely with your delegate file manager", "label": {"api": {"list()": [[0, 5]]}}}, {"text": "See Java Documents to learn about New IO package's Files class' createFile method", "label": {"api": {"Java Documents": [[4, 17]]}}}, {"text": "An example of this pattern being used in Java's standard library would be the DataOutputStream", "label": {"api": {"DataOutputStream": [[78, 93]]}}}, {"text": "Since Java 7, you can use java.nio.file.Files.getLastModifiedTime(Path path)", "label": {"api": {"java.nio.file.Files.getLastModifiedTime(Path path)": [[26, 75]]}}}, {"text": "You have to extend a class with HttpServlet and setting the following stuff to your web.xml", "label": {"api": {"HttpServlet": [[32, 42]]}}}, {"text": "You need to use SDF (SimpleDateFormat) to process the output too", "label": {"api": {"SimpleDateFormat": [[21, 36]]}}}, {"text": "You can use a LookupOp with a four-component LookupTable that sets the alpha component to zero for colors that match the background", "label": {"api": {"LookupOp": [[14, 21]]}}}, {"text": "Examples may be found in Using the Java 2D LookupOp Filter Class to Process Images and Image processing with Java 2D", "label": {"api": {"LookupOp": [[43, 50]]}}}, {"text": "Java does not have the exact syntax but as of JDK-8, we have the Optional API with various methods at our disposal", "label": {"api": {"Optional API": [[65, 76]]}}}, {"text": "can be written as follows in Java with the Optional API", "label": {"api": {"Optional API": [[43, 54]]}}}, {"text": "Hibernate seems to follow that philosophy and since you are using JDK logging just configure the log level with a property file", "label": {"api": {"configure the log level with a property file": [[83, 126]]}}}, {"text": "you can extend LinkedHashSet adding your desired getIndex() method", "label": {"api": {"LinkedHashSet": [[15, 27]]}}}, {"text": "As of Java 8, you can use Math.floorMod(int x, int y) and Math.floorMod(long x, long y)", "label": {"api": {"Math.floorMod(int x, int y)": [[26, 52]], "Math.floorMod(long x, long y)": [[58, 86]]}}}, {"text": "It really seemed like Utilities.drawTabbedText() was promising, but I couldn't figure out what it needed as input", "label": {"api": {"Utilities.drawTabbedText()": [[22, 47]]}}}, {"text": "Yes, it's called System.arraycopy(Object, int, Object, int, int)", "label": {"api": {"System.arraycopy(Object, int, Object, int, int)": [[17, 63]]}}}, {"text": "I am trying to understand the difference between matches() and find()", "label": {"api": {"matches()": [[49, 57]], "find()": [[63, 68]]}}}, {"text": "According to the Javadoc, (from what I understand), matches() will search the entire string even if it finds what it is looking for, and find() will stop when it finds what it is looking for", "label": {"api": {"matches()": [[52, 60]], "find()": [[137, 142]]}}}, {"text": "If that assumption is correct, I cannot see whenever you would want to use matches() instead of find(), unless you want to count the number of matches it finds", "label": {"api": {"matches()": [[75, 83]], "find()": [[96, 101]]}}}, {"text": "In my opinion the String class should then have find() instead of matches() as an inbuilt method", "label": {"api": {"matches()": [[66, 74]], "find()": [[48, 53]]}}}, {"text": "When is it useful to use matches() instead of find()", "label": {"api": {"matches()": [[25, 33]], "find()": [[46, 51]]}}}, {"text": "The Java documentation for Class says", "label": {"api": {"Class": [[27, 31]]}}}, {"text": "Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader", "label": {"api": {"Class": [[0, 4], [120, 124]]}}}, {"text": "What are these Class objects", "label": {"api": {"Class": [[15, 19]]}}}, {"text": "Also, for example object.getClass().getName() how can everything be typecasted to superclass Class, even if I don't inherit from java.lang.Class", "label": {"api": {"Class": [[28, 32], [93, 97], [139, 143]]}}}, {"text": "Even if using an ArrayList is probably a good advice in many circumstances, there are perfectly legitimate occasions for using plain old arrays", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "In that case, if you need to resize your array, you might want to investigate one of the java.utils.Arrays.copyOf methods", "label": {"api": {"java.utils.Arrays.copyOf": [[89, 112]]}}}, {"text": "Note that the toUnsignedLong is from the Integer class and the first call to toUnsignedLong may be superfluous", "label": {"api": {"toUnsignedLong": [[14, 27], [77, 90]]}}}, {"text": "According to Thread.setDaemon(boolean) documentation", "label": {"api": {"Thread.setDaemon(boolean)": [[13, 37]]}}}, {"text": "Starting from Java 8, it can be done thanks to the Stream API using an appopriate mapper Function that we will use to convert our instances of class A to instances of class B", "label": {"api": {"Stream API": [[51, 60]], "Function": [[89, 96]]}}}, {"text": "Here is a concrete example that will convert a List of String to a List of Integer using Integer.valueOf(String) as mapper function", "label": {"api": {"Integer.valueOf(String)": [[89, 111]]}}}, {"text": "For previous versions of Java, you can still use FluentIterable from Google Guava to replace the Stream and use com.google.common.base.Function instead of java.util.function.Function as mapper function", "label": {"api": {"Function": [[135, 142], [174, 181]]}}}, {"text": "You can now do this with Streams.generate(Supplier<T> s)", "label": {"api": {"Streams.generate(Supplier<T> s)": [[25, 55]]}}}, {"text": "Use the substring() function with an argument of 1 to get the substring from position 1 (after the first character) to the end of the string (leaving the second argument out defaults to the full length of the string)", "label": {"api": {"substring()": [[8, 18]]}}}, {"text": "As a specific case, Java 8 added UncheckedIOException for wrapping and rethrowing IOException", "label": {"api": {"UncheckedIOException": [[33, 52]]}}}, {"text": "The CLASSPATH separator is platform dependent, and is the same as the character returned by java.io.File.pathSeparatorChar", "label": {"api": {"java.io.File.pathSeparatorChar": [[92, 121]]}}}, {"text": "Here's the legacy java.util.Calendar approach in case you aren't on Java8 yet", "label": {"api": {"java.util.Calendar": [[18, 35]]}}}, {"text": "And here's Java8's java.time.LocalDate approach, basically exactly the JodaTime approach", "label": {"api": {"java.time.LocalDate": [[19, 37]]}}}, {"text": "Java 8 style, using the java.time classes", "label": {"api": {"java.time": [[24, 32]]}}}, {"text": "Java 9 added the datesUntil() method", "label": {"api": {"datesUntil()": [[17, 28]]}}}, {"text": "As of Java 8, one can use DateTimeFormatter along with the the Java 8 Time API to both parse and format dates", "label": {"api": {"DateTimeFormatter": [[26, 42]], "Java 8 Time API": [[63, 77]]}}}, {"text": "The javadoc for java.net.CookieManager gives a pretty good overview of how CookieHandler fits in", "label": {"api": {"javadoc for java.net.CookieManager": [[4, 37]]}}}, {"text": "Assuming that you're running in Java 6 or higher, you can use the standard JDBC method Connection.isValid(int timeoutInSecs)", "label": {"api": {"Connection.isValid(int timeoutInSecs)": [[87, 123]]}}}, {"text": "SeeTextual representation of IP addresses in the Java specifications", "label": {"api": {"Textual representation of IP addresses": [[3, 40]]}}}, {"text": "Let it implement HttpSessionBindingListener and add/remove the user from the Set when it's about to be bound/unbound in the session", "label": {"api": {"HttpSessionBindingListener": [[17, 42]]}}}, {"text": "You could do that in the same methods by a nullcheck, or with help of ServletContextListener#contextInitialized()", "label": {"api": {"ServletContextListener#contextInitialized()": [[70, 112]]}}}, {"text": "You can use DateTimeFormatterBuilder in Java 8", "label": {"api": {"DateTimeFormatterBuilder": [[12, 35]]}}}, {"text": "Try setOpaque(true) on the Label, this should cause it to clear its background", "label": {"api": {"setOpaque(true)": [[4, 18]]}}}, {"text": "Using Files.write (small files)", "label": {"api": {"Files.write": [[6, 16]]}}}, {"text": "Using Files.newBufferedWriter(text files)", "label": {"api": {"Files.newBufferedWriter": [[6, 28]]}}}, {"text": "Using Files.newOutputStream (interoperable with java.io APIs)", "label": {"api": {"Files.newOutputStream": [[6, 26]]}}}, {"text": "Using Files.newByteChannel (random access files)", "label": {"api": {"Files.newByteChannel": [[6, 25]]}}}, {"text": "Using FileChannel.open (random access files)", "label": {"api": {"FileChannel.open": [[6, 21]]}}}, {"text": "This would easily be accomplished by using a PriorityQueue or PriorityBlockingQueue in which the most recently queued items get highest priority", "label": {"api": {"PriorityQueue": [[45, 57]], "PriorityBlockingQueue": [[62, 82]]}}}, {"text": "Java 8 now supplies an appropriate date formatter, DateTimeFormatter.RFC_1123_DATE_TIME", "label": {"api": {"DateTimeFormatter.RFC_1123_DATE_TIME": [[51, 86]]}}}, {"text": "As of Java 7 you can use Locale.forLanguageTag(String) and toLanguageTag() to convert between language tags and Locale objects", "label": {"api": {"Locale.forLanguageTag(String)": [[25, 53]], "toLanguageTag()": [[59, 73]]}}}, {"text": "Java 1.8 added the java.time package to the core JDK to clean up many of the frustrations with the state of date & time in Java", "label": {"api": {"java.time": [[19, 27]]}}}, {"text": "Since java.time is now a widely available part of core Java with a much improved API, I would encourage you to give it the first look when writing new date & time code", "label": {"api": {"java.time": [[6, 14]]}}}, {"text": "Why does InputStream#read() return an int and not a byte", "label": {"api": {"InputStream#read()": [[9, 26]]}}}, {"text": "as the Java doc says in InputStream#read, The value byte is returned as an int in the range 0 to 255", "label": {"api": {"InputStream#read": [[24, 39]]}}}, {"text": "Building off Mateusz's Java 8 example, there's an example in the StringJoiner JavaDoc that nearly does what OP wants", "label": {"api": {"StringJoiner": [[65, 76]]}}}, {"text": "String.split() will do most of what you want", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "The support for streams and Lambdas in java-8 and Try-With-Resources of java-7 allows you to achive what you want in more compact syntax", "label": {"api": {"streams": [[16, 22]]}}}, {"text": "Thread has a method that does that for you join which will block until the thread has finished executing", "label": {"api": {"join": [[43, 46]]}}}, {"text": "Better alternatives to join() method have been evolved over a period of time", "label": {"api": {"join()": [[23, 28]]}}}, {"text": "ExecutorService.html#invokeAll is one alternative", "label": {"api": {"ExecutorService.html#invokeAll": [[0, 29]]}}}, {"text": "ForkJoinPool or Executors.html#newWorkStealingPool provides other alternatives to achieve the same purpose", "label": {"api": {"ForkJoinPool": [[0, 11]], "Executors.html#newWorkStealingPool": [[16, 49]]}}}, {"text": "When a Component is created, the current LookAndFeel will be used to display that Component", "label": {"api": {"Component": [[7, 15], [82, 90]], "LookAndFeel": [[41, 51]]}}}, {"text": "But flush() can throw an IOException", "label": {"api": {"can throw an IOException": [[12, 35]]}}}, {"text": "but you need to make sure you are using the right Locale to properly parse the month name", "label": {"api": {"Locale": [[50, 55]]}}}, {"text": "I know you can include general texts inside the SimpleDateFormat pattern", "label": {"api": {"SimpleDateFormat": [[48, 63]]}}}, {"text": "ConcurrentLinkedQueue is a superb lock free queue and does what a concurrent single linked list can do", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]], "Queue": [[16, 20]]}}}, {"text": "It's an outstanding Queue", "label": {"api": {"Queue": [[20, 24]]}}}, {"text": "The MouseListener in the Java API", "label": {"api": {"MouseListener": [[4, 16]]}}}, {"text": "The MemoryHandler in the Java API", "label": {"api": {"MemoryHandler": [[4, 16]]}}}, {"text": "For a system monitoring Java application which currently runs on the command line and uses ScheduledExecutorService, I would like to write a simple web application version, to be run in a Servlet container like Apache Tomcat or Eclipse Jetty", "label": {"api": {"ScheduledExecutorService": [[91, 114]]}}}, {"text": "Would it be better (maybe because of better servlet container integration) to port this application from ScheduledExecutorService to Quartz", "label": {"api": {"ScheduledExecutorService": [[105, 128]]}}}, {"text": "Adding another library dependency to the application is not a problem, I am interested in technical reasons against usage of ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[125, 148]]}}}, {"text": "Math.round() returns the nearest integer to your given input value", "label": {"api": {"Math.round()": [[0, 11]]}}}, {"text": "If your float already has an integer value the \"nearest\" integer will be that same value, so all you need to do is check whether Math.round() changes the value or not", "label": {"api": {"Math.round()": [[129, 140]]}}}, {"text": "You can use something like Runtime.getRuntime().totalMemory() and its counterpart Runtime.getRuntime().freeMemory() to get an educated guess, but that doesn't account for objects that are GC'ed between calls", "label": {"api": {"Runtime.getRuntime().totalMemory()": [[27, 60]], "Runtime.getRuntime().freeMemory()": [[82, 114]]}}}, {"text": "For Java 1.7+ you can use the Files.copy(Path, OutputStream), e.g", "label": {"api": {"Files.copy(Path, OutputStream)": [[30, 59]]}}}, {"text": "For the db schema you described, you can use @MapsId annotation on the dependent class (your Child class) to achieve the mapping back to the parent, like so", "label": {"api": {"@MapsId": [[45, 51]]}}}, {"text": "Also see the last bit of section 2.2.3.1 here for another example of @MapsId", "label": {"api": {"@MapsId": [[69, 75]]}}}, {"text": "Only and only if your POJO is running in the same thread as the HttpServletRequest is running in, then you'll be able to achieve this with help of ThreadLocal<T>", "label": {"api": {"ThreadLocal<T>": [[147, 160]]}}}, {"text": "Implement javax.servlet.Filter which does the following in doFilter() method and is mapped on an url-pattern of interest, e.g", "label": {"api": {"javax.servlet.Filter": [[10, 29]]}}}, {"text": "This all is basically also how the Context objects of the average MVC framework works, like JSF's FacesContext and the one in Wicket", "label": {"api": {"FacesContext": [[98, 109]]}}}, {"text": "Since JDK 11 there is OutputStream.nullOutputStream()", "label": {"api": {"OutputStream.nullOutputStream()": [[22, 52]]}}}, {"text": "Collections.singletonList will create an immutable List", "label": {"api": {"Collections.singletonList": [[0, 24]]}}}, {"text": "Thread(Runnable, String) creates a Thread, assigns its name to the String and specifies that it should run the Runnable", "label": {"api": {"Thread(Runnable, String)": [[0, 23]]}}}, {"text": "Thread(String) calls the general constructor with special magic arguments of Thread (null, null, name)", "label": {"api": {"Thread(String)": [[0, 13]], "Thread (null, null, name)": [[77, 101]]}}}, {"text": "In Java 8 you can use getAndUpdate (and updateAndGet) in AtomicInteger", "label": {"api": {"getAndUpdate": [[22, 33]]}}}, {"text": "Read the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "Or you could use a ByteArrayOutputStream (Although it creates the resulting array for you, rather than copying into an existing array as you asked)", "label": {"api": {"ByteArrayOutputStream": [[19, 39]]}}}, {"text": "Here is another solution which also uses ByteBuffer", "label": {"api": {"ByteBuffer": [[41, 50]]}}}, {"text": "Also java 8 introduced to Map interface nice computeIfAbsent default method which doesn't break map contract and features lazy evaluation", "label": {"api": {"computeIfAbsent": [[45, 59]]}}}, {"text": "Thanks to default methods, Java 8 now has this built in with Map::getOrDefault", "label": {"api": {"Map::getOrDefault": [[61, 77]]}}}, {"text": "In case you're on Java 8 already and it's no problem to end up with double[] instead of float[], consider Stream#mapToDouble() (no there's no such method as mapToFloat())", "label": {"api": {"Stream#mapToDouble()": [[106, 125]]}}}, {"text": "What are example applications for a ByteBuffer in Java", "label": {"api": {"ByteBuffer": [[36, 45]]}}}, {"text": "Leave off the @GeneratedValue and I believe you can just use Java's UUID.randomUUID() to generate a RFC 4122 compliant UUID like Hibernate's 'uuid2' generator", "label": {"api": {"UUID.randomUUID()": [[68, 84]]}}}, {"text": "Calling PrintWriter.checkError() will tell you if any error has occurred", "label": {"api": {"PrintWriter.checkError()": [[8, 31]]}}}, {"text": "You can obtain CodeSource by ProtectionDomain#getCodeSource() and the ProtectionDomain in turn can be obtained by Class#getProtectionDomain()", "label": {"api": {"ProtectionDomain#getCodeSource()": [[29, 60]], "Class#getProtectionDomain()": [[114, 140]]}}}, {"text": "The JDK 7 includes (via NIO.2) a class called Files that provides a createSymbolicLink() method", "label": {"api": {"Files": [[46, 50]], "createSymbolicLink()": [[68, 87]]}}}, {"text": "I have the name of a variable/identifier, say, x, and the JCCompilationUnit and Scope", "label": {"api": {"Scope": [[80, 84]]}}}, {"text": "The cardinality() method returns the number of set bits", "label": {"api": {"cardinality()": [[4, 16]]}}}, {"text": "Take a look at the documentation on Container.findComponentAt(int x, int y), if you are going to add Components on the dragP Container, other than \"draggable\" labels", "label": {"api": {"documentation on Container.findComponentAt(int x, int y)": [[19, 74]]}}}, {"text": "Also, you can instead use Container.getComponentAt(int x, int y), in this case", "label": {"api": {"Container.getComponentAt(int x, int y)": [[26, 63]]}}}, {"text": "Look at the documentation for FileHandler  and you will see a number is added for file conflict resolution", "label": {"api": {"documentation for FileHandler": [[12, 40]]}}}, {"text": "In Java 7, there is a new method Locale.forLanguageTag(String), which assumes the hyphen as a separator", "label": {"api": {"Locale": [[33, 38]]}}}, {"text": "Check the documentation of Locale for more information", "label": {"api": {"Locale": [[27, 32]]}}}, {"text": "Just wanted to add my two cents, an elegant solution using Executors and the double colon operator (::) that hasn't been mentioned yet", "label": {"api": {"Executors": [[59, 67]]}}}, {"text": "According to this post, you can call purge on the executor", "label": {"api": {"purge": [[37, 41]]}}}, {"text": "Collectors can join Streams which is very useful if you want to filter or map your data", "label": {"api": {"Collectors": [[0, 9]], "Streams": [[20, 26]]}}}, {"text": "To get a Stream from a Collection, call stream() on it", "label": {"api": {"stream()": [[40, 47]]}}}, {"text": "Since Java 1.7 you can use the Watch Service API to register for directory events", "label": {"api": {"Watch Service API": [[31, 47]]}}}, {"text": "It is part of Java's New I/O (NIO) library and does not require any additional resources", "label": {"api": {"New I/O": [[21, 27]]}}}, {"text": "For Java specific documentation see the Pattern class", "label": {"api": {"the Pattern class": [[36, 52]]}}}, {"text": "For some uses of regular expressions (such as in the sample above), there are shortcut methods in String", "label": {"api": {"String": [[98, 103]]}}}, {"text": "matches(), replaceAll()/replaceFirst() and split()", "label": {"api": {"matches()": [[0, 8]], "replaceAll()": [[11, 22]], "replaceFirst()": [[24, 37]], "split()": [[43, 49]]}}}, {"text": "Pass the CountDownLatch object to each of your tasks and code your tasks something like below", "label": {"api": {"CountDownLatch": [[9, 22]]}}}, {"text": "Use a Future for your tasks (instead of submitting Runnable's), a callback updates  it's state when it's completed, so you can use Future.isDone to track the sate of all your tasks", "label": {"api": {"Future": [[6, 11], [131, 136]], "Future.isDone": [[131, 143]]}}}, {"text": "You could create your own thread pool which extends ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[52, 69]]}}}, {"text": "CountDownLatch and example there", "label": {"api": {"CountDownLatch": [[0, 13]]}}}, {"text": "Human resources CountDownLatch", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "Of course, latch can be set on the different value than 2 (in constructor of CountDownLatch), as well as the number of runnable objects can be established in iteration i.e", "label": {"api": {"CountDownLatch": [[77, 90]]}}}, {"text": "ArrayList, but it must correspond (number of count downs must be equal the parameter in CountDownLatch constructor)", "label": {"api": {"CountDownLatch": [[88, 101]]}}}, {"text": "You can create an unconnected socket using the noarg constructor Socket() and then call connect(SocketAddress endpoint, int timeout) with a small timeout value", "label": {"api": {"Socket()": [[65, 72]], "connect(SocketAddress endpoint, int timeout)": [[88, 131]]}}}, {"text": "Set the content type to application/octet-stream", "label": {"api": {"application/octet-stream": [[24, 47]]}}}, {"text": "How about using a CountDownLatch", "label": {"api": {"CountDownLatch": [[18, 31]]}}}, {"text": "Another different solution to the already posted answers would be using DoubleStream.of", "label": {"api": {"DoubleStream.of": [[72, 86]]}}}, {"text": "You can specify the start index with indexOf", "label": {"api": {"indexOf": [[37, 43]]}}}, {"text": "If you just want something to iterate over in a for-each loop (so an Iterable and not only an Iterator), there's always java.util.Collections.list(Enumeration<T> e) (without using any external libraries)", "label": {"api": {"there's always": [[105, 118]]}}}, {"text": "You can parse such URLs with java.net.URI", "label": {"api": {"java.net.URI": [[29, 40]]}}}, {"text": "Call MimeMessage.saveChanges() on the enclosing message, which will update the headers by cascading down the MIME structure into a call to MimeBodyPart.updateHeaders() on your body part", "label": {"api": {"MimeMessage.saveChanges()": [[5, 29]]}}}, {"text": "In Java 8 there is a new compiler flag that allows additional metadata to be stored with byte code and these parameter names can be extracted using the Parameter object in reflection", "label": {"api": {"Parameter": [[152, 160]]}}}, {"text": "In newer versions of hibernate org.springframework.core.ParameterNameDiscoverer uses this feature", "label": {"api": {"Parameter": [[56, 64]]}}}, {"text": "Access parameters using reflection's Parameter class", "label": {"api": {"Parameter": [[37, 45]]}}}, {"text": "In such case, also compare run time types with a call to Object#getClass() which of course will make it impossible that two different types are considered equal", "label": {"api": {"Object#getClass()": [[57, 73]]}}}, {"text": "This can be achieved by combining TeeInputStream from Apache Commons and a PipedInputStream and PipedOutputStream as follows", "label": {"api": {"PipedInputStream": [[75, 90]], "PipedOutputStream": [[96, 112]]}}}, {"text": "Since Java 7 there are helper methods for equals and hashCode in the standard library", "label": {"api": {"equals": [[42, 47]], "hashCode": [[53, 60]]}}}, {"text": "Note that the getBoolean method delegates the system property value, simplifying the code to", "label": {"api": {"getBoolean": [[14, 23]]}}}, {"text": "You can simply use StandardCharsets.UTF_8 instead", "label": {"api": {"StandardCharsets.UTF_8": [[19, 40]]}}}, {"text": "the get method in Guava's LoadingCache wraps all checked exceptions into ExecutionException", "label": {"api": {"ExecutionException": [[73, 90]]}}}, {"text": "The documentation states that the exception can be inspected using getCause()", "label": {"api": {"getCause()": [[67, 76]]}}}, {"text": "I had a similar problem in my implementation using Java EE7, JSF2.2, JPA2 and @NamedStoredProcedureQuery which @axtavt solution helped solve (+1)", "label": {"api": {"@NamedStoredProcedureQuery": [[78, 103]]}}}, {"text": "The easiest way to do this is by using the built in MaskFormatter in the javax.swing.text library", "label": {"api": {"javax.swing.text library": [[73, 96]]}}}, {"text": "The general way is to use the File class getCanonicalPath() method", "label": {"api": {"getCanonicalPath()": [[41, 58]]}}}, {"text": "Use the substring method of the String class", "label": {"api": {"substring": [[8, 16]], "String": [[32, 37]]}}}, {"text": "It's possible to do this using the SepiaTone Effect class in the JavaFX library", "label": {"api": {"SepiaTone": [[35, 43]]}}}, {"text": "If you don't have access to java 8 and the API java.time, here is my simple function to copy the time of one date to another date using the old java.util.Calendar (inspire by Jigar Joshi)", "label": {"api": {"API java.time": [[43, 55]]}}}, {"text": "The class ByteBuffer  provides methods for putting all primitive data types, in little endian or big endian byte order, as you wish", "label": {"api": {"ByteBuffer ": [[10, 20]]}}}, {"text": "Java 1.6 added a constant Locale.ROOT to specify a language/country neutral locale", "label": {"api": {"Locale.ROOT": [[26, 36]]}}}, {"text": "The List interface would be broken without int", "label": {"api": {"List interface": [[4, 17]]}}}, {"text": "The problem is the overloaded remove() method (remove(int) vs", "label": {"api": {"remove(int)": [[47, 57]]}}}, {"text": "You can actually get a list of JVMs using the Attach API, without resorting to using jconsole.jar", "label": {"api": {"Attach API": [[46, 55]]}}}, {"text": "The complete documentation is available in the documentation for the package javax.annotation.processing", "label": {"api": {"package javax.annotation.processing": [[69, 103]]}}}, {"text": "Turns out that if you need to check expiration you can call X509Certificate.checkValidity() and it will throw either a CertificateExpiredException or a CertificateNotYetValidException", "label": {"api": {"X509Certificate.checkValidity()": [[60, 90]]}}}, {"text": "If you want to use ArrayList or LinkedList, it seems that the answer is no", "label": {"api": {"ArrayList": [[19, 27]], "LinkedList": [[32, 41]]}}}, {"text": "Although there are some classes in java that you can set them fixed size, like PriorityQueue, ArrayList and LinkedList can't, because there is no constructor for these two to specify capacity", "label": {"api": {"ArrayList": [[94, 102]], "LinkedList": [[108, 117]], "PriorityQueue": [[79, 91]]}}}, {"text": "If you want to stick to ArrayList/LinkedList, one easy solution is to check the size manually each time", "label": {"api": {"ArrayList": [[24, 32]], "LinkedList": [[34, 43]]}}}, {"text": "LinkedList is better than ArrayList in this situation", "label": {"api": {"ArrayList": [[26, 34]], "LinkedList": [[0, 9]]}}}, {"text": "The reason is that the cost of removing from ArrayList is O(N), but only O(1) for LinkedList", "label": {"api": {"ArrayList": [[45, 53]], "LinkedList": [[82, 91]]}}}, {"text": "The public java.util.List subclasses of the JDK don't provide a fixed size feature that   doesn't make part of the List specification", "label": {"api": {"List specification": [[115, 132]]}}}, {"text": "Since Java 8 you can use CompletableFuture<T>", "label": {"api": {"CompletableFuture<T>": [[25, 44]]}}}, {"text": "java.awt.Desktop is the class you're looking for", "label": {"api": {"java.awt.Desktop": [[0, 15]]}}}, {"text": "When I changed it to \"http://docs.oracle.com/javase/6/docs/api/\" the tooltips started showing up again", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/": [[22, 62]]}}}, {"text": "One way to test whether a character is tokenizable is to check whether it fails Character.isIdentifierIgnorable()", "label": {"api": {"Character.isIdentifierIgnorable()": [[80, 112]]}}}, {"text": "For that I try to use Java Comparator and Comparable but it allows to sort in alphabetic order only", "label": {"api": {"Comparator": [[27, 36]], "Comparable": [[42, 51]]}}}, {"text": "From a JDBC Connection, call getMetaData and getColumns drill down from there to get information for schemas, tables and, columns", "label": {"api": {"getMetaData": [[29, 39]], "getColumns": [[45, 54]]}}}, {"text": "Cloning HTTP request and response is possible via HttpServletResponseWrapper class http://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpServletResponseWrapper.html", "label": {"api": {"http://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpServletResponseWrapper.html": [[83, 170]]}}}, {"text": "Collection (so ArrayList also) have", "label": {"api": {"Collection": [[0, 9]]}}}, {"text": "You can get user input using BufferedReader", "label": {"api": {"BufferedReader": [[29, 42]]}}}, {"text": "It will store a String value in accStr so you have to parse it to an int using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[79, 94]]}}}, {"text": "I know this question is a few years old, but as Java 8 has, in the meantime, brought us Optional, I thought I'd offer up a solution using it (and Stream and Collectors)", "label": {"api": {"Optional": [[88, 95]], "Stream": [[146, 151]], "Collectors": [[157, 166]]}}}, {"text": "Optional is like null", "label": {"api": {"Optional": [[0, 7]]}}}, {"text": "In contrast, you cannot assign an Optional<PcapLinkType> value to a variable of type PcapLinkType", "label": {"api": {"Optional": [[34, 41]]}}}, {"text": "Optional makes you check for a valid value first", "label": {"api": {"Optional": [[0, 7]]}}}, {"text": "Of course, if you want to retain DLT_UNKNOWN for backward compatibility or whatever other reason, you can still use Optional even in that case, using orElse() to specify it as the default value", "label": {"api": {"Optional": [[116, 123]]}}}, {"text": "Take a look at SimpleDateFormat, it will turn the String into a Date and you can set the Date into a Calendar instance", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "You can use the java.util.jar.JarFile class, and use the getJarEntry method to see if the file exists", "label": {"api": {"java.util.jar.JarFile class": [[16, 42]], "getJarEntry": [[57, 67]]}}}, {"text": "ArrayList documentation, and Examples", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "You may want to look at Vector or ArrayList as other suggested", "label": {"api": {"Vector": [[24, 29]], "ArrayList": [[34, 42]]}}}, {"text": "Just define a different TableCellRenderer to each column", "label": {"api": {"TableCellRenderer": [[24, 40]]}}}, {"text": "You can use the String.valueOf() method to accomplish this", "label": {"api": {"String.valueOf()": [[16, 31]]}}}, {"text": "if you are attempting to have the procedure process the data as an int, you need to pass the data in as such using the appropriate method in CallableStatement (in this example, setInt())", "label": {"api": {"setInt()": [[177, 184]]}}}, {"text": "You can use the AWT Robot to generate key press events", "label": {"api": {"AWT Robot": [[16, 24]]}}}, {"text": "The focus problem mentioned in the comments can be solved by setting the window to not receive the focus via Window.setFocusableWindowState with an argument of false", "label": {"api": {"Window.setFocusableWindowState": [[109, 138]]}}}, {"text": "You can accomplish it with DecimalFormat", "label": {"api": {"DecimalFormat": [[27, 39]]}}}, {"text": "Or you can use String.format() as well", "label": {"api": {"String.format()": [[15, 29]]}}}, {"text": "Call st.execute(); or st.executeUpdate(); to execute it", "label": {"api": {"st.execute();": [[5, 17]], "st.executeUpdate();": [[22, 40]]}}}, {"text": "Have you considered using synchronizedList", "label": {"api": {"synchronizedList": [[26, 41]]}}}, {"text": "I would suggest using an ArrayList instead, but my code for you uses the same array you created", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "You are probably looking for System.currentTimeMillis to record the time at the beginning and then again at the end and take the difference to get the \"time that it took\"", "label": {"api": {"System.currentTimeMillis": [[29, 52]]}}}, {"text": "System.nanoTime is more trustworthy because it is resilient to user changes of the system time and provides a higher resolution", "label": {"api": {"System.nanoTime": [[0, 14]]}}}, {"text": "Be aware though, as it states in the documentation", "label": {"api": {"in the documentation": [[30, 49]]}}}, {"text": "You can make a JFrame partially transparent using the frame.setOpacity(float opacity) method", "label": {"api": {"frame.setOpacity(float opacity)": [[54, 84]]}}}, {"text": "Instead of calling Thread.sleep(n) implement a Swing Timer for repeating tasks, or a single shot Timer for a 'delayed effect'", "label": {"api": {"Timer": [[53, 57], [97, 101]]}}}, {"text": "To solve this, try to use Collections.synchronizedList(List list) to create synchronized list", "label": {"api": {"Collections.synchronizedList(List list)": [[26, 64]]}}}, {"text": "The API for DefaultTableCellRenderer will show you that this class in fact derives from JLabel which has the method that you're interested in", "label": {"api": {"DefaultTableCellRenderer": [[12, 35]]}}}, {"text": "If you are unsure of which characters need escaping, try to write the property set to a file using one of the the Properties.store methods", "label": {"api": {"Properties.store": [[114, 129]]}}}, {"text": "You're probably looking for Integer.parseInt() which takes a String and outputs an integer value", "label": {"api": {"Integer.parseInt()": [[28, 45]]}}}, {"text": "You should probably use a ProcessBuilder (instead of Runtime.exec)", "label": {"api": {"ProcessBuilder": [[26, 39]]}}}, {"text": "XMLEncoder uses the JavaBean pattern to serialize an object", "label": {"api": {"XMLEncoder": [[0, 9]]}}}, {"text": "If you want to always write XML for every property, you may want to consider using JAXB instead of XMLEncoder", "label": {"api": {"JAXB": [[83, 86]]}}}, {"text": "As a side note, I noticed it looks like you are trying to \"cap\" the input values with the Scanner#nextInt(int) method but I don't think this will give you the results you are expecting", "label": {"api": {"Scanner#nextInt(int)": [[90, 109]]}}}, {"text": "Once you have the images, you can override paintComponent and use the Graphics.drawImage method to let the EDT display the full or a partial view, by stitching the images of the corresponding patches together", "label": {"api": {"Graphics.drawImage method": [[70, 94]]}}}, {"text": "You can do it with reflection using Class.getMethod and Method.invoke", "label": {"api": {"Class.getMethod": [[36, 50]], "Method.invoke": [[56, 68]]}}}, {"text": "The Java Communications API provides ways for communicating with the underlying system's serial but also parallel ports, as you can quickly see from this documentation page", "label": {"api": {"documentation page": [[154, 171]]}}}, {"text": "The closest thing in the JDK is using TimeUnit", "label": {"api": {"TimeUnit": [[38, 45]]}}}, {"text": "It is interesting to note that (quite unbelievably) Date is not immutable", "label": {"api": {"Date": [[52, 55]]}}}, {"text": "Swing has an interface, Scrollable, specifically intended for this purpose", "label": {"api": {"Scrollable": [[24, 33]]}}}, {"text": "The method Object.equals(Object obj) takes another Object instance as a parameter", "label": {"api": {"Object.equals(Object obj)": [[11, 35]]}}}, {"text": "Don't do it yourself, use System.arrayCopy() to copy both arrays into a new array of the combined size", "label": {"api": {"System.arrayCopy()": [[26, 43]]}}}, {"text": "This is an automated warning Eclipse is giving related to Closeable and AutoCloseable and can be ignored if the underlying resource is System.in, System.out or System.err", "label": {"api": {"Closeable": [[58, 66], [76, 84]], "AutoCloseable": [[72, 84]]}}}, {"text": "Arrays#asList() returns a fixed-size list backed by the specified array -- any call to set will work, but remove() and other methods will throw an UnsupportedOperationException", "label": {"api": {"Arrays#asList()": [[0, 14]]}}}, {"text": "Based on the short snippet above (and assuming everything else is correct) you should check the image load status of the ImageIcon using the getImageLoadStatus() method", "label": {"api": {"getImageLoadStatus()": [[141, 160]]}}}, {"text": "If it returns MediaTracker.COMPLETE then you're good to go and the error is somewhere outside this code", "label": {"api": {"MediaTracker.COMPLETE": [[14, 34]]}}}, {"text": "For intelligible output when you print out an object, you need to override Object.toString() on your class, as described in \"Object as a Superclass\"", "label": {"api": {"Object.toString()": [[75, 91]]}}}, {"text": "You should check the javadoc for hasNext(pattern)", "label": {"api": {"javadoc for hasNext(pattern)": [[21, 48]]}}}, {"text": "Java's Shape class has a getBounds() method that can be used to obtain a Rectangle object that includes an X and Y coordinate", "label": {"api": {"getBounds() method": [[25, 42]]}}}, {"text": "You'll also want to be certain that your usage is consistent with what the API mandates for RandomAccessFile", "label": {"api": {"what the API mandates": [[66, 86]]}}}, {"text": "ResultSet   is a interface, It doesn't have any method implementation", "label": {"api": {"ResultSet": [[0, 8]]}}}, {"text": "I would use a Map<Integer, ArrayList<String>> to store your team members with their corresponding teams", "label": {"api": {"Map<Integer, ArrayList<String>>": [[14, 44]]}}}, {"text": "Use a BufferedReader if you do not already use a buffer", "label": {"api": {"BufferedReader": [[6, 19]]}}}, {"text": "To run concurrent tasks, you should use an ExecutorService that you instanciate thanks to Executors", "label": {"api": {"ExecutorService": [[43, 57]], "Executors": [[90, 98]]}}}, {"text": "You have the @JoinColumn for that", "label": {"api": {"@JoinColumn": [[13, 23]]}}}, {"text": "Also if you need to set the Join Table, use the @JoinTable annotation", "label": {"api": {"@JoinTable": [[48, 57]]}}}, {"text": "Add the standard regex case-insensitivity flag", "label": {"api": {"regex case-insensitivity flag": [[17, 45]]}}}, {"text": "When you print a Date, java uses Date.toString() method", "label": {"api": {"Date.toString()": [[33, 47]]}}}, {"text": "In Java 8 and later, use java.time classes", "label": {"api": {"java.time": [[25, 33]]}}}, {"text": "a plain thread, see the get() methods inheritted by FutureTask (ref)", "label": {"api": {"ref": [[64, 66]]}}}, {"text": "It may be more appropriate to use the Service class (ref) as described here or Java's standard concurrency (e.g", "label": {"api": {"ref": [[53, 55]]}}}, {"text": "You should look into locks when using a shared resource instead of using synchonize, specifically something like a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[115, 127]]}}}, {"text": "If you use the CASE_INSENSITIVE flag, you can simplify this to", "label": {"api": {"CASE_INSENSITIVE": [[15, 30]]}}}, {"text": "Also consider using Preferences instead", "label": {"api": {"Preferences": [[20, 30]]}}}, {"text": "This package might help you", "label": {"api": {"This package": [[0, 11]]}}}, {"text": "I believe this functionality can be achieved through the Task's messageProperty", "label": {"api": {"messageProperty": [[64, 78]]}}}, {"text": "To scroll the scroll pane to the bottom completely, set its vvalue property to 1.0", "label": {"api": {"vvalue property": [[60, 74]]}}}, {"text": "In such a case, if delaying the call via Platform.runLater() doesn't fix the problem, consider setting the property's value in response to the content height property invalidation event", "label": {"api": {"height property": [[151, 165]]}}}, {"text": "In that case you can use  String#equales() method", "label": {"api": {"String#equales()": [[26, 41]]}}}, {"text": "For sample name to match use String#equales() method and do you operations accordingly", "label": {"api": {"String#equales()": [[29, 44]]}}}, {"text": "If you look at String Class then you will find many useful methods", "label": {"api": {"String Class": [[15, 26]]}}}, {"text": "Because you can think of multimap as map key -> collection, just use JDK's TreeMap which is sorted according to the natural ordering of its keys", "label": {"api": {"TreeMap": [[75, 81]]}}}, {"text": "Cleanest might maybe to write your own ListResourceBundle child or such", "label": {"api": {"ListResourceBundle": [[39, 56]]}}}, {"text": "Construct a HashSet as follows", "label": {"api": {"HashSet": [[12, 18]]}}}, {"text": "In real-world application you can use LinkedHashSet to achieve the same functionality", "label": {"api": {"LinkedHashSet": [[38, 50]]}}}, {"text": "Methods defined for Object like wait and notify could help you too", "label": {"api": {"Object": [[20, 25]]}}}, {"text": "This method has no arguments - so I tend to skip the IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[53, 76]]}}}, {"text": "I'm actually going over the list every-once-in-a-while, when this pops-up, and just go with IllegalStateException or with InternalError", "label": {"api": {"IllegalStateException": [[92, 112]], "InternalError": [[122, 134]]}}}, {"text": "Yours is a very basic question, so I suggest you give a look at the TreeMap documentation for more information", "label": {"api": {"TreeMap": [[68, 74]]}}}, {"text": "All overloads of the println method append a newline following whatever you want to print; all overloads of the print method don't", "label": {"api": {"println method": [[21, 34]]}}}, {"text": "If all you want is a newline, then you don't even have to supply an argument -- call the no-argument println overload", "label": {"api": {"no-argument println overload": [[89, 116]]}}}, {"text": "Since the documentation for InputStream.read(byte[]) states", "label": {"api": {"InputStream.read(byte[])": [[28, 51]]}}}, {"text": "To do that, use the String constructor overload that takes in an array offset/length and a charset", "label": {"api": {"String constructor overload": [[20, 46]]}}}, {"text": "This is because trim removes all leading/trailing characters with values less than or equal to 0x20 (Space) - including NUL characters", "label": {"api": {"trim": [[16, 19]]}}}, {"text": "You have to set Javascript disabled on the WebEngine itself that the WebView controls", "label": {"api": {"WebEngine": [[43, 51]]}}}, {"text": "You can easily do that in java with the help of a this class", "label": {"api": {"this class": [[50, 59]]}}}, {"text": "As you can see in the documentation of (Java-Map) the get method does not use the generic injection, but instead Object as input parameter", "label": {"api": {"Java-Map": [[40, 47]]}}}, {"text": "Otherwise you will loose some input in arr, see the split(String) API doc", "label": {"api": {"the split(String) API doc": [[48, 72]]}}}, {"text": "See the split(String, int) API doc for further explanations", "label": {"api": {"the split(String, int) API doc": [[4, 33]]}}}, {"text": "Use instanceof and the Inet4Address type", "label": {"api": {"Inet4Address": [[23, 34]]}}}, {"text": "With the Introspector you can get the BeanInfo and this gives you access to the bean's PropertyDescriptors", "label": {"api": {"Introspector": [[9, 20]], "BeanInfo": [[38, 45]], "PropertyDescriptors": [[87, 105]]}}}, {"text": "Check out the Charset documentation", "label": {"api": {"Charset": [[14, 20]]}}}, {"text": "To avoid this I had to check if the value was null and use #setNull(index, class) in these cases", "label": {"api": {"#setNull(index, class)": [[59, 80]]}}}, {"text": "The org.w3c.dom.ls interfaces can help you here", "label": {"api": {"org.w3c.dom.ls interfaces": [[4, 28]]}}}, {"text": "Java provides a managed bit-based data structure called a BitSet", "label": {"api": {"BitSet": [[58, 63]]}}}, {"text": "I say this is managed because Java does not have a native type for storing bits, instead, a BitSet stores individual bits as a component of a long, and keeps a long[] to back the set", "label": {"api": {"BitSet": [[92, 97]]}}}, {"text": "This is a pretty storage-efficient approach, but the implementation of BitSet reserves 6 bits out of every 64 for \"addressing\", which amounts to a 10% overhead just in the raw storage layer", "label": {"api": {"BitSet": [[71, 76]]}}}, {"text": "This means you can likely beat BitSet on storage by keeping and carefully addressing your own long[], at the cost of some complexity and risk in your code", "label": {"api": {"BitSet": [[31, 36]]}}}, {"text": "Unless you're extremely constrained on space, it's probably not worth saving the ~10% raw overhead of a BitSet", "label": {"api": {"BitSet": [[104, 109]]}}}, {"text": "If you just need to wait for the thread to finish try Thread.join()", "label": {"api": {"Thread.join()": [[54, 66]]}}}, {"text": "However, its generally unwise to manage the threading yourself, try using an executor and submit the work you need as a future task that you can manage independently of the thread", "label": {"api": {"future task": [[120, 130]]}}}, {"text": "I think you could try using the keySet()-Method of your outer map", "label": {"api": {"keySet()": [[32, 39]]}}}, {"text": "You can convert it to a java.sql.Date, java.sql.Time, or java.sql.Timestamp by first parsing the date with a SimpleDateFormat, and creating the appropriate object, and calling setDate, setTime, or setTimestamp instead of setString", "label": {"api": {"SimpleDateFormat": [[109, 124]]}}}, {"text": "Instead of checking the direct supertypes, you should use Types.isAssignable to check if Serializable is one of the supertypes of the TypeMirror", "label": {"api": {"Types.isAssignable": [[58, 75]]}}}, {"text": "In order to achieve what you're trying to do, look into the Collection's Map interface", "label": {"api": {"Map interface": [[73, 85]]}}}, {"text": "Here is an example which prints all elements and their values of the @Resource annotation of a class", "label": {"api": {"@Resource": [[69, 77]]}}}, {"text": "Moreover I'd recommend you to use PreparedStatement instead", "label": {"api": {"PreparedStatement": [[34, 50]]}}}, {"text": "Based on Collectors documentation it's as simple as", "label": {"api": {"Collectors documentation": [[9, 32]]}}}, {"text": "A Java String uses UTF-16 as an internal encoding", "label": {"api": {"String": [[7, 12]]}}}, {"text": "There is an API for accessing a String as a sequence of Unicode code points which handles encoding and decoding these \"surrogate pairs\" transparently", "label": {"api": {"String": [[32, 37]], "accessing": [[20, 28]]}}}, {"text": "Use Scanner.nextLine() to read each line and then Ignore the ones which starts with // like following", "label": {"api": {"Scanner.nextLine()": [[4, 21]]}}}, {"text": "For some insane reason, Calendar class uses a zero-based index for month (Jan==0, Feb==1, etc), but all other date parts are one-based (matching their actual numbers)", "label": {"api": {"Calendar": [[24, 31]]}}}, {"text": "My advice is to never use Calendar", "label": {"api": {"Calendar": [[26, 33]]}}}, {"text": "Try using new date and time library provided by Java 8, which are inspired by Joda-Time and they are easy to use", "label": {"api": {"Java 8": [[48, 53]]}}}, {"text": "You probably want to use a SimpleDateFormat to parse the string as a Date and do the time arithmetic on that", "label": {"api": {"SimpleDateFormat": [[27, 42]]}}}, {"text": "You can use the List#get(int index) method", "label": {"api": {"List#get(int index)": [[16, 34]]}}}, {"text": "You can use the List#get(index) for this", "label": {"api": {"List#get(index)": [[16, 30]]}}}, {"text": "Use PrepredStatement  instead of Statement", "label": {"api": {"PrepredStatement": [[4, 19]]}}}, {"text": "PIG internally uses JAVA REGEX specifications only", "label": {"api": {"JAVA REGEX specifications": [[20, 44]]}}}, {"text": "For sync points, if you use the standard logging facility, you would have to write a handler that first collects all output in a PriorityQueue with a given sorting function that includes the time and thread source (e.g", "label": {"api": {"PriorityQueue": [[129, 141]]}}}, {"text": "If you need a more fine-grain control, then you need to adjust your architecture and use the classes from the concurrent package in a proper way", "label": {"api": {"concurrent package": [[110, 127]]}}}, {"text": "You should use a collection, like a List or an ArrayList or even a LinkedList, for example", "label": {"api": {"List": [[36, 39], [52, 55], [73, 76]]}}}, {"text": "For example, in a List, you can add a new item or remove an existing one, in this way", "label": {"api": {"List": [[18, 21]]}}}, {"text": "The first is your Waiter, which will just listen for events and put them into a Queue of some sort (see the \"All Known Implementing Classes\" section)", "label": {"api": {"Queue": [[80, 84]]}}}, {"text": "ProgressMonitor is designed to handle long operations, but if used directly, then it does not refresh", "label": {"api": {"ProgressMonitor": [[0, 14]]}}}, {"text": "I have made an app using Java FX and WebView", "label": {"api": {"WebView": [[37, 43]]}}}, {"text": "Do I have to obtain a secure certificate for running WebView in browser", "label": {"api": {"WebView": [[53, 59]]}}}, {"text": "You can use IntStream ints() or DoubleStream doubles() available as of java 8 in Random class", "label": {"api": {"ints()": [[22, 27]], "doubles()": [[45, 53]]}}}, {"text": "Use a HashSet", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "I would advice to learn searching in http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html (for example) you can find there all available methods", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[37, 101]]}}}, {"text": "Create a PreparedStatement and make a Batch-Update", "label": {"api": {"PreparedStatement": [[9, 25]]}}}, {"text": "Timeouts are enabled by invoking ServerSocket.setSoTimeout(int)", "label": {"api": {"ServerSocket.setSoTimeout(int)": [[33, 62]]}}}, {"text": "Use Collections.max and provide a custom Comparator", "label": {"api": {"Collections.max": [[4, 18]], "Comparator": [[41, 50]]}}}, {"text": "Then if you really want to find the position of this object in the list you can use indexOf", "label": {"api": {"indexOf": [[84, 90]]}}}, {"text": "How can I get a JTree to only listen to its TreeModel while it is actually visible to the user or at least to have it unregister itself as soon as the corresponding JFrame is disposed", "label": {"api": {"JTree": [[16, 20]], "TreeModel": [[44, 52]], "JFrame": [[165, 170]]}}}, {"text": "As far as I can see the only case a JTree unregisters itself from its model is if you pass it a new model (using setModel(â€¦))", "label": {"api": {"JTree": [[36, 40]]}}}, {"text": "I implemented a TreeModel using a WatchService to have an always up to date model of a file system tree", "label": {"api": {"TreeModel": [[16, 24]]}}}, {"text": "So even if the JTree is not visible anymore it is still kept in memory by the model which still needs to get updates from the WatchService, although none of this is necessary any longer", "label": {"api": {"JTree": [[15, 19]]}}}, {"text": "I guess the best way would be to create a new class extending JTree that does the registering to and unregistering from the model", "label": {"api": {"JTree": [[62, 66]]}}}, {"text": "\\s is a regular expression that stands for any of the following", "label": {"api": {"regular expression": [[8, 25]]}}}, {"text": "First alternative is to use a Thread.setDefaultUncaughtExceptionHandler", "label": {"api": {"Thread.setDefaultUncaughtExceptionHandler": [[30, 70]]}}}, {"text": "you can use CountDownLatch(since java 1.5) here, tt is a synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "Since you're creating a new Scanner object using the new File(fileName), this constructor of Scanner throws a FileNotFoundException which needs to be handled", "label": {"api": {"Scanner": [[28, 34], [93, 99]]}}}, {"text": "I advice you move this code to a method inside the class and handle the FileNotFoundException either by having a throws clause or a try-catch around the code creating a new Scanner using a File object", "label": {"api": {"Scanner": [[173, 179]]}}}, {"text": "As per Java Documentation, InputStream", "label": {"api": {"InputStream": [[27, 37]]}}}, {"text": "Consider using a Vector or an ArrayList instead", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "Try to use Set instead of List", "label": {"api": {"Set": [[11, 13]]}}}, {"text": "Set wont allow duplicate values", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "For example, use an explicit ThreadPoolExecutor constructor, passing it the CallerRunsPolicy as Rejection Policy", "label": {"api": {"CallerRunsPolicy": [[76, 91]]}}}, {"text": "The getNodeValue method in the DOM is defined to always return null for element nodes (see the table at the top of the JavaDoc page for org.w3c.dom.Node for details)", "label": {"api": {"the JavaDoc page for org.w3c.dom.Node": [[115, 151]]}}}, {"text": "1) You can use InputVerifier like next", "label": {"api": {"InputVerifier": [[15, 27]]}}}, {"text": "Use getField instead of getDeclaredField", "label": {"api": {"getField": [[4, 11]]}}}, {"text": "Use the String.split() function to split the line at commas , into an array of Strings", "label": {"api": {"String.split()": [[8, 21]]}}}, {"text": "If this is a fixed format, you can use String#indexOf to get the index of \"DB2.QUERY_CT=\", then (since you know the length of DB2.QUERY_CT=, you can know where the number begins and extract it", "label": {"api": {"String#indexOf": [[39, 52]]}}}, {"text": "All in all simply use ConcurrentHashMap as map implementation in concurrent environement", "label": {"api": {"ConcurrentHashMap": [[22, 38]]}}}, {"text": "Use the @XmlTransient annotation", "label": {"api": {"@XmlTransient annotation": [[8, 31]]}}}, {"text": "Consider using a DelayQueue", "label": {"api": {"DelayQueue": [[17, 26]]}}}, {"text": "You need X as the specifier for the UTC offset as it's in ISO-8601 format, as per the SimpleDateFormat documentation", "label": {"api": {"SimpleDateFormat documentation": [[86, 115]]}}}, {"text": "The bean inherits from a superclass that could implement Formattable (http://docs.oracle.com/javase/7/docs/api/java/util/Formattable.html) but I just don't seem to understand how to make this work", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Formattable.html": [[70, 136]]}}}, {"text": "If you use a java ThreadPoolExecutor you can provide your own task queue to be used internally by it, you should not interact with the queue directly", "label": {"api": {"ThreadPoolExecutor": [[18, 35]]}}}, {"text": "You can use a PriorityBlockingQueue constructed with a custom Comparator that returns which task goes first", "label": {"api": {"PriorityBlockingQueue": [[14, 34]], "Comparator": [[62, 71]]}}}, {"text": "As in Tomcat and Weblogic, you can find some more interesting information", "label": {"api": {"Weblogic": [[17, 24]]}}}, {"text": "Java comes with a serialization mechanism (Serializable) which does not require much work from your side", "label": {"api": {"Serializable": [[43, 54]]}}}, {"text": "If you have a ListCellRenderer, simply invoke getListCellRendererComponent() with the appropriate values, and then invoke setBounds(x, y, w, h) and paint(g) on the returned component (which is all normal cases is the renderer itself) to paint it as it would be in a list", "label": {"api": {"getListCellRendererComponent()": [[46, 75]]}}}, {"text": "To catch when there is a String entered (blank text counts too), use NumberFormatException", "label": {"api": {"NumberFormatException": [[69, 89]], "Exception": [[81, 89]]}}}, {"text": "To catch any error, use Exception", "label": {"api": {"Exception": [[24, 32]]}}}, {"text": "To answer your question on how you can do it, you could get the entrySet from your map and then just put into the new map by using getValue as key and getKey as value", "label": {"api": {"entrySet": [[64, 71]], "getValue": [[131, 138]], "getKey": [[151, 156]]}}}, {"text": "But remember that keys in a Map are unique, which means if you have one value with two different key in your original map, only the second key (in iteration order) will be kep as value in the new map", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "Calendar javadocs for MONTH", "label": {"api": {"Calendar javadocs for MONTH": [[0, 26]]}}}, {"text": "The JavaDoc for String.compareTo says", "label": {"api": {"JavaDoc for String.compareTo": [[4, 31]]}}}, {"text": "Just implement a MouseListener and use mouseExited() and mouseEntered() to keep track", "label": {"api": {"mouseExited()": [[39, 51]], "mouseEntered()": [[57, 70]]}}}, {"text": "As of Java 1.5 you can use Character.digit to get the numeric value of the corresponding digit", "label": {"api": {"Character.digit": [[27, 41]]}}}, {"text": "You could try to use CopyOnWriteArrayList or CopyOnWriteArraySet in your case", "label": {"api": {"CopyOnWriteArrayList": [[21, 40]], "CopyOnWriteArraySet": [[45, 63]]}}}, {"text": "Your arrays have 100 elements, so lots of Zeros get printed, use Arrays.copyOf to create smaller arrays", "label": {"api": {"Arrays.copyOf": [[65, 77]]}}}, {"text": "You can do this with Files.lines", "label": {"api": {"Files.lines": [[21, 31]]}}}, {"text": "Note that it uses the UTF-8 charset to read the file, if that's not what you want you can pass your charset as the second argument to Files.lines", "label": {"api": {"Files.lines": [[134, 144]]}}}, {"text": "You have two options, you should use PreparedStatement and bind your parameter(s)", "label": {"api": {"PreparedStatement": [[37, 53]]}}}, {"text": "You can use Arrays.sort and provide a custom comparator", "label": {"api": {"Arrays.sort": [[12, 22]]}}}, {"text": "See the doc of the writeMethod, readMethod and of the Serializable interface", "label": {"api": {"Serializable": [[54, 65]]}}}, {"text": "There is no (realistic) way to put this in a loop, but you can circumvent the recursion using a Dequeue approach (in the form of a stack)", "label": {"api": {"Dequeue": [[96, 102]]}}}, {"text": "Then put that copy in a Dequeue and terminate the function", "label": {"api": {"Dequeue": [[24, 30]]}}}, {"text": "you can easily put the code part above in the run() method of a Runnable and have multiple threads wait on a ConcurrentLinkedDeque", "label": {"api": {"ConcurrentLinkedDeque": [[109, 129]]}}}, {"text": "If you don't have to use regular expressions, it is always preferred to use String.replace() instead of String.replaceAll(), since you get rid of all the regular expression overhead", "label": {"api": {"String.replace()": [[76, 91]]}}}, {"text": "Use LinkedHashSet instead of HashSet", "label": {"api": {"LinkedHashSet": [[4, 16]]}}}, {"text": "LinkedHashSet will maintain the insertion order", "label": {"api": {"LinkedHashSet": [[0, 12]]}}}, {"text": "You can use LinkedHashSet, which preserves insertion order", "label": {"api": {"LinkedHashSet": [[12, 24]]}}}, {"text": "If you are using Swing, SwingWorker is the way to do it", "label": {"api": {"SwingWorker": [[24, 34]]}}}, {"text": "So by using the SwingWorker, you don't have to worry about the internals of handling UI events in the EDT and the time consuming tasks in another thread", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "Use LinkedHashMap instead of HashSet", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "LinkedHashMap will maintain the insertion order", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "If you want to retain an order in a Map, your usual choice would be a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[70, 82]]}}}, {"text": "Arrays.sort(char[]) uses natural ordering, so you'll get Bs then Rs then Ws", "label": {"api": {"Arrays.sort(char[])": [[0, 18]], "natural ordering": [[25, 40]]}}}, {"text": "If you want an other sort order you have to implement your own Comparator and use Arrays.sort(T[], Comparator)", "label": {"api": {"Arrays.sort(T[], Comparator)": [[82, 109]]}}}, {"text": "If you use DecimalFormat http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html you can set up the display to look however you like but it does not rigidly enforce what the user types", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html": [[25, 93]]}}}, {"text": "This is a job for String#matches(String) and a suiting regular expression", "label": {"api": {"String#matches(String)": [[18, 39]]}}}, {"text": "Also if you need to get result from your Runnables, try to use Callable instead of Runnable", "label": {"api": {"Callable": [[63, 70]]}}}, {"text": "With that when you submit Callable you get Future instance from which you can get result", "label": {"api": {"Callable": [[26, 33]], "Future": [[43, 48]]}}}, {"text": "Read about Executors, Callable and Future", "label": {"api": {"Callable": [[22, 29]], "Future": [[35, 40]]}}}, {"text": "They suggest BitSet as solution for large sets of booleans, but in your case byte solves the problem better, because you won't have a large set of booleans, you will have a large set of 8 booleans objects", "label": {"api": {"BitSet": [[13, 18]]}}}, {"text": "Two of the exceptions thrown by commit() are rollback exceptions that indicate that the transaction was rolled back", "label": {"api": {"commit()": [[32, 39]]}}}, {"text": "The rollback() method doesn't throw any of those except SystemException", "label": {"api": {"rollback()": [[4, 13]]}}}, {"text": "\"The SystemException is thrown by the transaction manager to indicate that it has encountered an unexpected error condition that prevents future transaction services from proceeding.\" (src) So you can't rollback after a SystemException", "label": {"api": {"src": [[185, 187]]}}}, {"text": "To retain them, use the two-arg overload of split that takes a limit parameter", "label": {"api": {"two-arg overload of split": [[24, 48]]}}}, {"text": "Using an ArrayList", "label": {"api": {"ArrayList": [[9, 17]]}}}, {"text": "But just to clarify, a ThreadPoolExecutor accepts Runnable objects exactly like a Thread", "label": {"api": {"ThreadPoolExecutor": [[23, 40]]}}}, {"text": "As you can see in documentation of stack, pop gets and removes data", "label": {"api": {"documentation of stack": [[18, 39]]}}}, {"text": "You can use the String.trim() method to remove leading and trailing spaces", "label": {"api": {"String.trim()": [[16, 28]]}}}, {"text": "Take advantage of the APIs", "label": {"api": {"the APIs": [[18, 25]]}}}, {"text": "You have to use RandomAccessFile and use seek to get to the top", "label": {"api": {"RandomAccessFile": [[16, 31]], "seek": [[41, 44]]}}}, {"text": "You should check mark method of BufferedReader", "label": {"api": {"mark": [[17, 20]]}}}, {"text": "If this is an important operation, you're better off using a SortedMap, for instance TreeMap, which keeps its elements in sorted order, and then you can simply call firstKey() to find the lowest key", "label": {"api": {"firstKey()": [[165, 174]]}}}, {"text": "Capital \"D\" is day of year; lowercase \"d\" is day of month (SimpleDateFormat javadocs)", "label": {"api": {"SimpleDateFormat javadocs": [[59, 83]]}}}, {"text": "From the Oracle documentation on the org.w3c.dom package", "label": {"api": {"Oracle documentation": [[9, 28]]}}}, {"text": "I think you need to read more from your Process, and you should use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[70, 83]]}}}, {"text": "Timer.schedule(TimerTask, long), after the specified delay", "label": {"api": {"Timer.schedule(TimerTask, long)": [[0, 30]]}}}, {"text": "either Timer.schedule(TimerTask, long, long) or Timer.scheduleAtFixedRate(TimerTask, long, long)", "label": {"api": {"Timer.schedule(TimerTask, long, long)": [[7, 43]], "Timer.scheduleAtFixedRate(TimerTask, long, long)": [[48, 95]]}}}, {"text": "You can use Set.add(...) return value for this", "label": {"api": {"Set.add(...)": [[12, 23]]}}}, {"text": "Please refer to the SimpleDateFormat API for more info", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "Here's the 1.7 options list, if you prefer", "label": {"api": {"1.7 options list": [[11, 26]]}}}, {"text": "I can read this directly into Java Time objects by using the getTime() method from the ResultSet class", "label": {"api": {"Time objects": [[35, 46]], "ResultSet": [[87, 95]]}}}, {"text": "I have read everything I could find (this, this and many others) but none of the responses actually use Time objects", "label": {"api": {"Time objects": [[104, 115]]}}}, {"text": "You are using the Scanner.next method which only returns the next word in the string", "label": {"api": {"Scanner.next": [[18, 29]]}}}, {"text": "You can use Scanner.nextLine() to get the entire input string, instead of only 1 word", "label": {"api": {"Scanner.next": [[12, 23]], "Scanner.nextLine()": [[12, 29]]}}}, {"text": "You may want to see the API to see all the other fun things you can do with BigDecimal", "label": {"api": {"API": [[24, 26]]}}}, {"text": "If you want to create the whole path, see File#mkdirs", "label": {"api": {"File#mkdirs": [[42, 52]]}}}, {"text": "I ended up using Java's built in Color class", "label": {"api": {"Color class": [[33, 43]]}}}, {"text": "You can use SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "As @camickr has suggested below, you can also make use of event.getValueIsAdjusting() method", "label": {"api": {"event.getValueIsAdjusting()": [[58, 84]]}}}, {"text": "I would use a Java 7 PathMatcher with a glob pattern (or a regex pattern if the sophistication is needed) and use it in a FileVistor", "label": {"api": {"PathMatcher": [[21, 31]], "FileVistor": [[122, 131]]}}}, {"text": "Then just walk the file tree via Files.walkFileTree()", "label": {"api": {"Files.walkFileTree()": [[33, 52]]}}}, {"text": "All basic data type classes in java implement Comparable interface", "label": {"api": {"Comparable interface": [[46, 65]]}}}, {"text": "This is generally a bad idea and can even throw a ConcurrentModificationException under some circumstances", "label": {"api": {"throw a ConcurrentModificationException": [[42, 80]]}}}, {"text": "That is the MBeanServer", "label": {"api": {"MBeanServer": [[12, 22]]}}}, {"text": "You can explore the other types at this link", "label": {"api": {"at this link": [[32, 43]]}}}, {"text": "You don't call setColor(), so the rectangle is drawn with the default colour", "label": {"api": {"setColor()": [[15, 24]]}}}, {"text": "Approximately 5 seconds (plus or minus some unspecified and likely non-deterministic jitter) per the Timer documentation because (at the start) N = 5 and your period = 1000 so 5000 milliseconds", "label": {"api": {"Timer": [[101, 105]]}}}, {"text": "Tune your reads with setFetchSize() and your writes by using batching", "label": {"api": {"setFetchSize()": [[21, 34]]}}}, {"text": "Use Thread.yield(), and second the client.getSocket().getInputStream().available() method tells you exactly how many byte(s) you can read without blocking", "label": {"api": {"Thread.yield()": [[4, 17]]}}}, {"text": "You might be able to get away with using an ArrayList instead, if you just care about plain simple storage of multiple objects of the same type", "label": {"api": {"ArrayList": [[44, 52]]}}}, {"text": "However, in order to use a HashMap, you need to keep in mind that a Hash / Map is a collection of Key-Value pairs", "label": {"api": {"HashMap": [[27, 33]]}}}, {"text": "Please check the class ArrayList<E> documentation page", "label": {"api": {"class ArrayList<E> documentation": [[17, 48]]}}}, {"text": "The key is LinkedHashMap, part of standard Java SDK, which is a Set (i.e", "label": {"api": {"LinkedHashMap": [[11, 23]]}}}, {"text": "This approach is exactly what eis commented, with LinkedHashMap used as the \"structure that doesn't allow duplicates\"", "label": {"api": {"LinkedHashMap": [[50, 62]]}}}, {"text": "Modeling closely to Java AWT's Rectangle2D class, I have my Rectangle POJO", "label": {"api": {"Rectangle2D": [[31, 41]]}}}, {"text": "So this is definitely a bug in my algorithm, but I copied it straight from Rectangle2D#intersect, and don't see where I've gone wrong", "label": {"api": {"Rectangle2D": [[75, 85]]}}}, {"text": "And you should take a look at http://docs.oracle.com/javase/7/docs/api/java/io/File.html, specifically at the get*() methods that involve the filename", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/File.html": [[30, 87]]}}}, {"text": "I read somewhere that Instrumentation might be useful (Instrumentation)", "label": {"api": {"Instrumentation": [[22, 36], [55, 69]]}}}, {"text": "Check the ArrayList class documentation for other function", "label": {"api": {"ArrayList class": [[10, 24]]}}}, {"text": "When you get an Object from the ArrayList, you get.", "label": {"api": {"get": [[9, 11], [47, 49]]}}}, {"text": "I'm not sure if this will work, but looking at the JButton docs, there is a setFont(Font font) method you can call", "label": {"api": {"JButton": [[51, 57]], "setFont(Font font)": [[76, 93]], "Font": [[79, 82], [84, 87]]}}}, {"text": "You can try passing it a Font created with the font size you'd like using the Font(String name, int style, int size) constructor", "label": {"api": {"Font": [[25, 28], [78, 81]]}}}, {"text": "Create ArrayList of Integer and add result, return that array list", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "See ProcessBuilder javadoc for more info", "label": {"api": {"ProcessBuilder javadoc": [[4, 25]]}}}, {"text": "I think using a hashmap with an List is what you're specifically asking for", "label": {"api": {"List": [[32, 35]]}}}, {"text": "However, a look at this question shows this would not be quite as easy as this, as you must instantiate each List for all your key's (that question deals specifically with multidimensional hashmaps, but the premise is the same)", "label": {"api": {"List": [[109, 112]]}}}, {"text": "If you can't use the List inside either, I suppose you could put another hashmap inside, but I don't see that having much real use for this unless it's just an arbitrary requirement", "label": {"api": {"List": [[21, 24]]}}}, {"text": "You should save the return value of nextInt properly and use it for comparison", "label": {"api": {"nextInt": [[36, 42]]}}}, {"text": "You can use substring and lastIndexOf as shown below", "label": {"api": {"substring": [[12, 20]], "lastIndexOf": [[26, 36]]}}}, {"text": "You do have finalizers, but they're not guaranteed to run", "label": {"api": {"finalizers": [[12, 21]]}}}, {"text": "Further discussion about why finalizers may not run in this thread", "label": {"api": {"finalizers": [[29, 38]]}}}, {"text": "Not exactly a hook, but you can use a WeakReference to be notified that an object has become eligible to be garbage collected", "label": {"api": {"WeakReference": [[38, 50]]}}}, {"text": "You are binding UpAction and DownAction to KeyStroke.getKeyStroke(keyCode, 0), which according to the javadoc is a \"key pressed\" event", "label": {"api": {"according to the javadoc": [[85, 108]]}}}, {"text": "You can create a separate key release binding with, for example, KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0, true)", "label": {"api": {"KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0, true)": [[65, 111]]}}}, {"text": "Convert your Joda-Time DateTime object to a java.util.Date", "label": {"api": {"java.util.Date": [[44, 57]]}}}, {"text": "Joda-Time knows how to convert to java.util.Date", "label": {"api": {"java.util.Date": [[34, 47]]}}}, {"text": "By the way, the java.sql.Date class is simply a very thin subclass of java.util.Date", "label": {"api": {"java.util.Date": [[70, 83]], "java.sql.Date": [[16, 28]]}}}, {"text": "These classes supplant the mess that is java.util.Date/Calendar", "label": {"api": {"java.util.Date": [[40, 53]]}}}, {"text": "We can add an HyperlinkListener to that", "label": {"api": {"HyperlinkListener": [[14, 30]]}}}, {"text": "The documentation of Instrumentation.setNativeMethodPrefix explains the details", "label": {"api": {"documentation of Instrumentation.setNativeMethodPrefix": [[4, 57]]}}}, {"text": "Use setHorizontalAlignment() method of JLabel like next", "label": {"api": {"setHorizontalAlignment()": [[4, 27]]}}}, {"text": "I have a 2 JFormattedTextFields that input the same information in different forms", "label": {"api": {"JFormattedTextField": [[11, 29]]}}}, {"text": "I have implemented something like this before using PropertyChangeListeners, however I have encountered a strange error this time", "label": {"api": {"PropertyChangeListener": [[52, 73]]}}}, {"text": "When my JFrame opens the PropertyChangeListener event is fired for no apparent reason", "label": {"api": {"PropertyChangeListener": [[25, 46]], "JFrame": [[8, 13]]}}}, {"text": "The value of getNewValue() on the PropertyChangeEvent is null", "label": {"api": {"getNewValue()": [[13, 25]], "PropertyChangeEvent": [[34, 52]]}}}, {"text": "Then later in my JFrame constructor", "label": {"api": {"JFrame": [[17, 22]]}}}, {"text": "As you can see I do not set the value in code and the event is called (and generates a NullPointerException) before I get a chance to type anything in", "label": {"api": {"NullPointerException": [[87, 106]]}}}, {"text": "CharSequence is an interface that \"bundles\" most of the character based implementations like StringBuilder, StringBuffer, CharBuffer, String and in Avro Utf8", "label": {"api": {"CharSequence is an interface that \"bundles\"": [[0, 42]]}}}, {"text": "Have a look at using exec this Executes the specified string command in a separate process", "label": {"api": {"exec": [[21, 24]]}}}, {"text": "On the server side, implemented with Servlets, you simply make your class extend HttpServlet and implement the various doXxx() methods", "label": {"api": {"HttpServlet": [[81, 91]], "doXxx()": [[119, 125]]}}}, {"text": "When you set the root logger level to FINE that is setting the effective level for all child loggers too", "label": {"api": {"effective level": [[63, 77]]}}}, {"text": "The most efficient way to do this would be to use System.arrayCopy(), which is much faster and more efficient than copying manually using a loop", "label": {"api": {"System.arrayCopy()": [[50, 67]]}}}, {"text": "Do not reallocate the table component, instead use setModel() to refresh data", "label": {"api": {"setModel()": [[51, 60]]}}}, {"text": "I don't have a definitive answer to the question, by if I look at the java class generated for a tag file by jetty, it is a SimpleTag, as it extends SimpleTagSupport", "label": {"api": {"SimpleTagSupport": [[149, 164]]}}}, {"text": "You can use Collections.sort and provide a custom Comparator where you compare the first element of each list, i.e the name", "label": {"api": {"Collections.sort": [[12, 27]], "Comparator": [[50, 59]]}}}, {"text": "Arrays are objects too, but they don't override Object's toString() method, which is responsible for the \"crazy output\"", "label": {"api": {"Object's toString() method": [[48, 73]]}}}, {"text": "The documentation at http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#close() indicates that when you do so, it also closes the underlying stream", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#close()": [[21, 91]]}}}, {"text": "Yes, these are available through their wrapper's TYPE fields", "label": {"api": {"TYPE": [[49, 52]]}}}, {"text": "By default, the SAX and DOM parsers are not namespace-aware, you need to explicitly call setNamespace() on the factory", "label": {"api": {"setNamespace()": [[89, 102]]}}}, {"text": "As a rule of thumb always use a language construct, when there is one, in this case the Comparator", "label": {"api": {"Comparator": [[88, 97]]}}}, {"text": "Seeing @Elliott Frisch's answer I think the best thing for you is to implement Comparable in your object", "label": {"api": {"Comparable": [[79, 88]]}}}, {"text": "Collections.sort(List list) is way faster, and if you look at the source you would see why", "label": {"api": {"Collections.sort(List list)": [[0, 26]]}}}, {"text": "Java can do this with the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "In that case, each parent can spawn one thread per child and then use a semaphore to wait for all of them to finish", "label": {"api": {"semaphore": [[72, 80]]}}}, {"text": "Cancel them, or call shutdownNow", "label": {"api": {"shutdownNow": [[21, 31]]}}}, {"text": "Implementing the Comparable interface only makes sense for classes who really have a natural ordering", "label": {"api": {"Comparable": [[17, 26]]}}}, {"text": "Take a look at TreeSet, which is such a search tree", "label": {"api": {"TreeSet": [[15, 21]]}}}, {"text": "The FileHandler doesn't support generating file names by date and time from the LogManager", "label": {"api": {"FileHandler": [[4, 14]], "LogManager": [[80, 89]], "Handler": [[8, 14]]}}}, {"text": "If you want to generate a file name on startup you can subclass the FileHandler and create a static method to generate your file name using a SimpleDateFormat", "label": {"api": {"FileHandler": [[68, 78]], "SimpleDateFormat": [[142, 157]], "Handler": [[72, 78]]}}}, {"text": "The LogManager supports a 'config' option that will also allow you to install custom code to setup and install a FileHandler", "label": {"api": {"FileHandler": [[113, 123]], "LogManager": [[4, 13]], "Handler": [[117, 123]]}}}, {"text": "If you want to generate a file name per each LogRecord you have to create a custom Handler that will create and close a FileHandler on each publish", "label": {"api": {"FileHandler": [[120, 130]], "Handler": [[83, 89], [124, 130]]}}}, {"text": "If you put '\\\\' in a pattern it will be treated as a backslash, just like you expected", "label": {"api": {"pattern": [[21, 27]]}}}, {"text": "You can use java.util.Arrays as below", "label": {"api": {"java.util.Arrays": [[12, 27]]}}}, {"text": "If you are running two threads within the same JVM process, you could use a BlockingQueue in order to transfer some sort of file-transfer-finished token from the producer to the consumer such as for example the file's name once a file is fully written and its stream closed", "label": {"api": {"BlockingQueue": [[76, 88]]}}}, {"text": "Use the Clipboard and ClipboardContent, e.g", "label": {"api": {"Clipboard": [[8, 16], [22, 30]], "ClipboardContent": [[22, 37]]}}}, {"text": "Use String.split() in regards to explode", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "Use NavigableMap.pollLastEntry -removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty", "label": {"api": {"NavigableMap.pollLastEntry": [[4, 29]]}}}, {"text": "If long-term accuracy of scheduling is what you are after, then you should use the Timer#scheduleAtFixedRate method", "label": {"api": {"Timer#scheduleAtFixedRate": [[83, 107]]}}}, {"text": "I would suggest that you take a look at Strings's startsWith() and endsWith() methods", "label": {"api": {"Strings": [[40, 46]], "startsWith()": [[50, 61]], "endsWith()": [[67, 76]]}}}, {"text": "As The Guy with The Hat says, there are enough functions for strings such as startsWith and endsWith to achieve your goals", "label": {"api": {"startsWith": [[77, 86]], "endsWith": [[92, 99]]}}}, {"text": "You can use indexOf and lastIndexOf to find the positions of <s- and -e> in the string and use substring to extract the proper substring without any \"noise\"", "label": {"api": {"indexOf": [[12, 18]], "lastIndexOf": [[24, 34]], "substring": [[95, 103], [127, 135]]}}}, {"text": "Alternatively, you can possibly rely on response.isCommitted() (see doc) as a committed response would typically be closed, however this isn't definite - it could be closed but not committed", "label": {"api": {"see doc": [[64, 70]]}}}, {"text": "Note that getComponent() \"Returns the originator of the event.\" In general, your program should not rely on anomalous, platform-specific results", "label": {"api": {"getComponent()": [[10, 23]]}}}, {"text": "Also, you might want to consider using setFetchSize()", "label": {"api": {"setFetchSize()": [[39, 52]]}}}, {"text": "It will print the class of the TableColumn returned by JTable.getColumn() method, not the column class of the table model", "label": {"api": {"TableColumn": [[31, 41]], "JTable.getColumn()": [[55, 72]]}}}, {"text": "Based on a quick bit of testing, I achieved the desired results by calling the setComparator method on the TableRowSorter instance", "label": {"api": {"setComparator": [[79, 91]]}}}, {"text": "A similar problem exists in Object, with the equals(Object) and hashCode() methods", "label": {"api": {"Object": [[28, 33], [52, 57]]}}}, {"text": "However, if your case is more like the one in Object, where they dont' need to be overridden, but just satisfy a very specific contract, then clear documentation on what that contract is will work better, allowing developers to satisfy the contract the way they determine is best", "label": {"api": {"Object": [[46, 51]]}}}, {"text": "Have you tried http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html#getInputStream()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html#getInputStream()": [[15, 94]]}}}, {"text": "This is the ResultSet documentation, for more information on how it works and what you can do with it", "label": {"api": {"ResultSet": [[12, 20]]}}}, {"text": "For splitting up the String I would make use of the method toCharArray()", "label": {"api": {"toCharArray()": [[59, 71]]}}}, {"text": "Really its simple you override another method paintComponents() but you need paintComponent()", "label": {"api": {"paintComponents()": [[46, 62]], "paintComponent()": [[77, 92]]}}}, {"text": "You might want to take a look at Java Arrays API", "label": {"api": {"Java Arrays API": [[33, 47]]}}}, {"text": "Scanner has a constructor taking a File as argument", "label": {"api": {"a constructor taking a File as argument": [[12, 50]]}}}, {"text": "You can open an InputStream for a class path resource using Class.getResourceAsStream() or ClassLoader.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[60, 86]], "ClassLoader.getResourceAsStream()": [[91, 123]]}}}, {"text": "I am using http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html to process different tasks in my app", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html": [[11, 104]]}}}, {"text": "One can scale the images with Graphics.drawImage(x, y, w, h, null)", "label": {"api": {"Graphics.drawImage(x, y, w, h, null)": [[30, 65]]}}}, {"text": "From this (http://docs.oracle.com/javase/7/docs/api/constant-values.html#java.awt.event.KeyEvent.VK_E) we see that the ASCII binding for VK_E is 69", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/constant-values.html#java.awt.event.KeyEvent.VK_E": [[11, 100]]}}}, {"text": "When you need to append to a string in a loop, use StringBuilder", "label": {"api": {"StringBuilder": [[51, 63]]}}}, {"text": "It is common to use a MessageDigest to accomplish this, by applying a one way cryptographic hash function to the user's password (e.g", "label": {"api": {"MessageDigest": [[22, 34]]}}}, {"text": "You can use Rectangle method intersects()", "label": {"api": {"intersects()": [[29, 40]]}}}, {"text": "The trick is to only suppress ClientAbortException while allowing every other IOException to be handled as errors or logged, without introducing a compile/runtime dependency on your container API", "label": {"api": {"IOException": [[78, 88]]}}}, {"text": "Checking for null and using Java's Pattern class is another solution", "label": {"api": {"Pattern": [[35, 41]]}}}, {"text": "You can only write instances which implement the Serializable interface, otherwise you will get a rather self-explaining NotSerializableException", "label": {"api": {"Serializable interface": [[49, 70]]}}}, {"text": "The InputStream class does indeed not implement the Serializable interface", "label": {"api": {"Serializable interface": [[52, 73]], "InputStream class": [[4, 20]]}}}, {"text": "If you want items in the sorted order, you can use TreeSet from which you can retrieve the first element using TreeSet#first()", "label": {"api": {"TreeSet": [[51, 57], [111, 117]], "TreeSet#first()": [[111, 125]]}}}, {"text": "If you need to have predictable ordering, you need to use the LinkedHashSet implementation", "label": {"api": {"LinkedHashSet": [[62, 74]]}}}, {"text": "When you iterate over a LinkedHashSet, you will get the elements in the order you inserted", "label": {"api": {"LinkedHashSet": [[24, 36]]}}}, {"text": "You still need to use an iterator, because having a get method in LinkedHashSet would need you to use the concrete class everywhere", "label": {"api": {"LinkedHashSet": [[66, 78]]}}}, {"text": "From the Oracle docs", "label": {"api": {"Oracle docs": [[9, 19]]}}}, {"text": "You can use any desired number of Threads that can each take on parts of the workload; you can also schedule batches of smaller tasks to run on a fixed number of threads with a ThreadPoolExecutor, which can be provided with any number of tasks that will then be executed whenever possible by a specific number of threads", "label": {"api": {"Thread": [[34, 39], [177, 182]], "ThreadPoolExecutor": [[177, 194]]}}}, {"text": "If you actually need to schedule / delay these tasks, you can also use some other variant of ExecutorService, such as a ScheduledThreadPoolExecutor, which can execute and even re-execute various commands at pre-determined delays with a limited pool of threads", "label": {"api": {"Thread": [[129, 134]], "ThreadPoolExecutor": [[129, 146]], "ExecutorService": [[93, 107]], "ScheduledThreadPoolExecutor": [[120, 146]]}}}, {"text": "Notice the use of StringBuilder, much more faster and consuming less memory than a classical string concatenation", "label": {"api": {"StringBuilder": [[18, 30]]}}}, {"text": "For that purpose you can use FocusListener for example", "label": {"api": {"FocusListener": [[29, 41]]}}}, {"text": "Have a look at the BitSet class, it's a much more convenient way of setting bit flags", "label": {"api": {"BitSet": [[19, 24]]}}}, {"text": "I'd suggest you use BitSet, as it makes your code much more readable, and it can support many more flags than a simple bit mask", "label": {"api": {"BitSet": [[20, 25]]}}}, {"text": "You can use a listener ServletContextListener", "label": {"api": {"ServletContextListener": [[23, 44]]}}}, {"text": "A Map is an object that maps keys to values.Use HashMap Here is the example of hashmap", "label": {"api": {"HashMap": [[48, 54]]}}}, {"text": "However, if you are using org.springframework.http just for the http status, why don't you use native Java Status", "label": {"api": {"Status": [[107, 112]]}}}, {"text": "Usually the choice is between String and StringBuilder, not StringWriter", "label": {"api": {"String": [[30, 35], [41, 46], [60, 65]], "StringBuilder": [[41, 53]], "StringWriter": [[60, 71]]}}}, {"text": "StringWriter is a character output stream and I suppose is not what you need", "label": {"api": {"String": [[0, 5]], "StringWriter": [[0, 11]]}}}, {"text": "String is an immutable type, so once created its value can't be modified", "label": {"api": {"String": [[0, 5]]}}}, {"text": "StringBuffer is more useful when you need to do many manipulations on the characters sequence", "label": {"api": {"String": [[0, 5]]}}}, {"text": "So if you need, for example, to concatenate a large amount of strings, then I'll go for StringBuffer", "label": {"api": {"String": [[88, 93]]}}}, {"text": "You are looking for the retainAll method to find entries in all lists", "label": {"api": {"retainAll": [[24, 32]]}}}, {"text": "Increasing the underlying network buffer size with a call to setReceiveBufferSize will give you some margin and greatly improve the behavior", "label": {"api": {"setReceiveBufferSize": [[61, 80]]}}}, {"text": "The join method doesn't affect the order of execution of any currently executing Threads", "label": {"api": {"join method": [[4, 14]]}}}, {"text": "You need to URL-encode each parameter", "label": {"api": {"URL-encode": [[12, 21]]}}}, {"text": "Alternatively, you may be able to pass the entire original query string", "label": {"api": {"query string": [[59, 70]]}}}, {"text": "If you're using Java 7, the clearest way to achieve this is to use Paths and Files as follows", "label": {"api": {"Paths": [[67, 71]], "Files": [[77, 81]]}}}, {"text": "According to the Javadoc for RuntimePermission, the createClassLoader permission is a risky one to grant", "label": {"api": {"the Javadoc for RuntimePermission": [[13, 45]]}}}, {"text": "Apparently you have extended the the class Unmarshaller#Listener which has only the methods afterUnmarshal  and beforeUnmarshal which explains why only those two are called", "label": {"api": {"Unmarshaller#Listener": [[43, 63]]}}}, {"text": "In order to Listen to marshaling events you need to have another Listener class extending Marshaller#Listener which in its turn has the methods you need and which you have to override", "label": {"api": {"Marshaller#Listener": [[90, 108]]}}}, {"text": "Having done that in your class you should have got errors saying that the class Unmarshaller#Listener does not have any methods beforeMarshal or afterMarshal", "label": {"api": {"Unmarshaller#Listener": [[80, 100]]}}}, {"text": "After an object is garbage collected, JVM calls its finalize method", "label": {"api": {"finalize": [[52, 59]]}}}, {"text": "Because of my background, I had always assumed in languages like Java when I call compile for Pattern it produced a DFA or Transducer in the background", "label": {"api": {"Pattern": [[94, 100]]}}}, {"text": "As a result, I had always assumed no matter how ugly my regex, no matter how long my regex, Pattern.matches or similar methods would run in linear time", "label": {"api": {"Pattern": [[92, 98]]}}}, {"text": "java.util.LinkedList<E> is already a doubly-linked list", "label": {"api": {"java.util.LinkedList<E>": [[0, 22]]}}}, {"text": "You can make your Student class implement the Comparable interface and then use the PriorityQueue", "label": {"api": {"Comparable": [[46, 55]], "PriorityQueue": [[84, 96]]}}}, {"text": "I'd like to check if a Path (introduced in Java 7) ends with a  certain extension", "label": {"api": {"Path": [[23, 26]]}}}, {"text": "So how can I check the file extension of a Path", "label": {"api": {"Path": [[43, 46]]}}}, {"text": "Java NIO's PathMatcher provides FileSystem.getPathMatcher(String syntaxAndPattern)", "label": {"api": {"PathMatcher": [[11, 21], [46, 56]], "FileSystem.getPathMatcher(String syntaxAndPattern)": [[32, 81]]}}}, {"text": "The checkedList method will ensure that  your list will receive only instances of the class of instance variable", "label": {"api": {"checkedList": [[4, 14]]}}}, {"text": "here, the nextsetBit would give you the next turned on bit at or after a specified index", "label": {"api": {"nextsetBit": [[10, 19]]}}}, {"text": "The best way to do this is a servlet filter", "label": {"api": {"servlet filter": [[29, 42]]}}}, {"text": "Or alternatively, use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[22, 39]]}}}, {"text": "You could use System.arraycopy to achieve the same result..", "label": {"api": {"System.arraycopy": [[14, 29]]}}}, {"text": "First, I would add a class level field of type Random", "label": {"api": {"Random": [[47, 52]]}}}, {"text": "setText does just that, sets the current text value to what ever you specify", "label": {"api": {"setText": [[0, 6]]}}}, {"text": "Instead, you could try using append, which will append the text you supply to the end of the JTextArea's Document, for example..", "label": {"api": {"append": [[29, 34], [48, 53]]}}}, {"text": "In such situations, you can get the the integer part of the decimal number using split and parse", "label": {"api": {"split": [[81, 85]]}}}, {"text": "Each key in a HashMap must be unique", "label": {"api": {"HashMap": [[14, 20]]}}}, {"text": "When \"adding a duplicate key\" the old value (for the same key, as keys must be unique) is simply replaced; see HashMap.put", "label": {"api": {"HashMap": [[111, 117]], "HashMap.put": [[111, 121]]}}}]