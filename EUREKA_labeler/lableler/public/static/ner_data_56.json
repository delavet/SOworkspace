[{"text": "Alternatively, you may look at interfaces like javax.swing.SwingConstants, which are used to share constants for a certain functionality among implementations", "label": {"api": {"javax.swing.SwingConstants": [[47, 72]]}}}, {"text": "Use LinkedHashSet instead if you need to preserve the order", "label": {"api": {"LinkedHashSet": [[4, 16]]}}}, {"text": "However LinkedHashSet maintains an additional linked list so needs more resources", "label": {"api": {"LinkedHashSet": [[8, 20]]}}}, {"text": "A LinkedHashSet maintains insertion order of items by constructing links between the elements as they are inserted", "label": {"api": {"LinkedHashSet": [[2, 14]]}}}, {"text": "The AudioSystem class has an helper method to do this, AudioSystem.write", "label": {"api": {"AudioSystem.write": [[55, 71]]}}}, {"text": "With mp3AudioType being the right AudioFileFormat.Type for mp3; maybe just AudioFileFormat.Type(\"MP3\", \"mp3\") would work", "label": {"api": {"AudioFileFormat.Type": [[34, 53], [75, 94]]}}}, {"text": "In the java doc it says for setMouseTransparent that is affects all children as well as the parent", "label": {"api": {"setMouseTransparent": [[28, 46]]}}}, {"text": "If in those steps you find you need to perform the tryAndLookup(), store a Future for the pending result in a separate list of pending lookups before leaving the synchronized block", "label": {"api": {"Future": [[75, 80]]}}}, {"text": "Threads that find they need the same result will find the Future and can get() its result outside the synchronized block", "label": {"api": {"Future": [[58, 63]]}}}, {"text": "For copying an array use System.arraycopy  (see http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy%28java.lang.Object,%20int,%20java.lang.Object,%20int,%20int%29)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy%28java.lang.Object,%20int,%20java.lang.Object,%20int,%20int%29": [[48, 182]]}}}, {"text": "You've misunderstood the usage of list.subList", "label": {"api": {"list.subList": [[34, 45]]}}}, {"text": "the file has to be created before accessing it with FileInputStream", "label": {"api": {"FileInputStream": [[52, 66]]}}}, {"text": "But it would be cleaner to check it's existence because in that case FileNotFoundException is actually a container for multiple exceptions (see doc)", "label": {"api": {"see doc": [[140, 146]]}}}, {"text": "You can get the resources in your classpath (even when sealed in the JAR) by using the ClassLoader#getResource() and ClassLoader#getResourceAsStream() methods", "label": {"api": {"ClassLoader#getResource()": [[87, 111]], "ClassLoader#getResourceAsStream()": [[117, 149]]}}}, {"text": "One way to do this is use the Collections.sort() method which..", "label": {"api": {"Collections.sort()": [[30, 47]]}}}, {"text": "All elements in the list must implement the Comparable interface", "label": {"api": {"Comparable": [[44, 53]]}}}, {"text": "The Comparable interface defines only one method which..", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "Do this lengthy operation in a separate thread, using a SwingWorker for example", "label": {"api": {"SwingWorker": [[56, 66]]}}}, {"text": "If you look at the JavaDoc of getField(), you see the problem", "label": {"api": {"JavaDoc of getField()": [[19, 39]]}}}, {"text": "From the JavaDoc ofgetDeclaredField()", "label": {"api": {"JavaDoc ofgetDeclaredField()": [[9, 36]]}}}, {"text": "Use FileChannel for your IO operations", "label": {"api": {"FileChannel": [[4, 14]]}}}, {"text": "For example, using Reader#skip", "label": {"api": {"Reader#skip": [[19, 29]]}}}, {"text": "And from the JavaDocs for mod", "label": {"api": {"the JavaDocs for mod": [[9, 28]]}}}, {"text": "This code relies on an implementation detail that was not documented before Java 7, and now is (in the documentation of the join() method), but with the following words", "label": {"api": {"documentation of the join() method": [[103, 136]]}}}, {"text": "If the file does not exist and cannot be created,FileOutputStream will raise a FileNotFoundException (yes, this seems weird, but see the javadoc)", "label": {"api": {"see the javadoc": [[129, 143]]}}}, {"text": "It is documented since Java 7, in the documentation of the join() method", "label": {"api": {"documentation of the join() method": [[38, 71]]}}}, {"text": "ArrayList has a get method to get element from it", "label": {"api": {"get method": [[16, 25]]}}}, {"text": "The type of the ternary expression depends on the types of its operands, but one of the operands (Collections.emptyList()) has an undetermined type parameter", "label": {"api": {"Collections.emptyList()": [[98, 120]]}}}, {"text": "The solution to your problem is to refactor your code to use java.lang.ProcessBuilder instead", "label": {"api": {"java.lang.ProcessBuilder": [[61, 84]]}}}, {"text": "You could use an IdentityHashMap instead", "label": {"api": {"IdentityHashMap": [[17, 31]]}}}, {"text": "java.security.MessageDigest is not generally part of J2ME, so it's not directly available", "label": {"api": {"java.security.MessageDigest": [[0, 26]]}}}, {"text": "This is because it implements the Deque interface", "label": {"api": {"Deque interface": [[34, 48]]}}}, {"text": "The javadoc for Queue states", "label": {"api": {"javadoc for Queue": [[4, 20]]}}}, {"text": "The preferred way to create processes in recent versions of Java is to use the ProcessBuilder class, which makes this very simple", "label": {"api": {"ProcessBuilder": [[79, 92]]}}}, {"text": "But if you do want to/need to use Runtime.exec for whatever reason, there are overloaded versions of that method that allow the arguments to be specified explicitly", "label": {"api": {"overloaded versions of that method": [[78, 111]]}}}, {"text": "If you explicitly want the entire file in memory, you can also wrap your input in a DataInputStream and use readFully(byte[]) after using File.length() to figure out the size of the file", "label": {"api": {"readFully(byte[])": [[108, 124]]}}}, {"text": "I think, the easiest you can do, is to use Scanner class to read file and then write with writer", "label": {"api": {"Scanner class": [[43, 55]]}}}, {"text": "I try to use a ForkJoinPool  to parallelize my CPU intensive calculations", "label": {"api": {"ForkJoinPool": [[15, 26]]}}}, {"text": "My understanding of a ForkJoinPool is, that it continues to work as long as any task is available to be executed", "label": {"api": {"ForkJoinPool": [[22, 33]]}}}, {"text": "My observation is very similar to those of ForkJoinPool seems to waste a thread", "label": {"api": {"ForkJoinPool": [[43, 54]]}}}, {"text": "After debugging a lot into ForkJoinPool I have a guess", "label": {"api": {"ForkJoinPool": [[27, 38]]}}}, {"text": "ForkJoinPool provides an asyncMode, but this is a global parameter and can not be used for individual submissions", "label": {"api": {"ForkJoinPool": [[0, 11]], "asyncMode": [[25, 33]]}}}, {"text": "You should use PrintWriter to write text files, ObjectOutputStream writes binary data", "label": {"api": {"PrintWriter": [[15, 25]]}}}, {"text": "JDBC statements can return the generated keys", "label": {"api": {"can return the generated keys": [[16, 44]]}}}, {"text": "SO_TIMEOUT (which is set by socket.setSoTimeout) only affects socket.getInputStream().read()", "label": {"api": {"socket.setSoTimeout": [[28, 46]]}}}, {"text": "To specify connect timeout, specify a second parameter to socket.connect", "label": {"api": {"specify a second parameter to socket.connect": [[28, 71]]}}}, {"text": "Try calling setPrototypeDisplayValue on the combobox", "label": {"api": {"setPrototypeDisplayValue": [[12, 35]]}}}, {"text": "The Pair class can be compared to the Map.Entry of a HashMap", "label": {"api": {"Map.Entry": [[38, 46]]}}}, {"text": "A KeyStroke can be used for the SPACE key which can be mapped to an Action to cycle through a JButton array containing the red, yellow and green buttons and invoke doClick in order", "label": {"api": {"doClick": [[164, 170]]}}}, {"text": "You can use setContextMenu() on Tab to do this", "label": {"api": {"setContextMenu()": [[12, 27]], "ContextMenu": [[15, 25]]}}}, {"text": "The ContextMenu javadoc page has information on creating the menu - it's very similar to a standard JavaFX menu (just do contextMenu.getItems().addAll(item1, item2);, etc", "label": {"api": {"ContextMenu": [[4, 14]]}}}, {"text": "You may have a look to WeakHashMap", "label": {"api": {"WeakHashMap": [[23, 33]]}}}, {"text": "I am wondering what's the purpose of the link SkipLists present in this javadoc link", "label": {"api": {"link": [[41, 44], [80, 83]]}}}, {"text": "Once opened the link ctrl +f and type SkipLists then click on the link, I am curious to know on a scale from 0 to 10 how much the link relates to the argument", "label": {"api": {"link": [[16, 19], [66, 69], [130, 133]]}}}, {"text": "From the ReentrantReadWriteLock class javadoc", "label": {"api": {"ReentrantReadWriteLock class javadoc": [[9, 44]]}}}, {"text": "I suspect you're looking for CharsetEncoder.canEncode(CharSequence)", "label": {"api": {"CharsetEncoder.canEncode(CharSequence)": [[29, 66]]}}}, {"text": "As an alternative to Jon Skeet's suggestion, you can also use CharsetEncoder class to do the encoding directly (with the encode method), but first call the onMalformedInput and onUnmappableCharacter methods to specify what the encoder should do when it encounters bad input", "label": {"api": {"CharsetEncoder": [[62, 75]], "encode": [[121, 126], [227, 232]], "onMalformedInput": [[156, 171]], "onUnmappableCharacter": [[177, 197]]}}}, {"text": "That way most of the time you're just doing a simple encode call, but if anything goes wrong you'll get an exception", "label": {"api": {"encode": [[53, 58]]}}}, {"text": "With the method java.io.DataInputStream.readLong() it's possible to read data 8 bytes per 8 bytes", "label": {"api": {"java.io.DataInputStream.readLong()": [[16, 49]]}}}, {"text": "Pass a Callable to the constructor instead of passing a Runnable, and you won't have to catch the exception anymore", "label": {"api": {"Pass a Callable": [[0, 14]]}}}, {"text": "Yes, you should be able to use a QueueBrowser for this", "label": {"api": {"QueueBrowser": [[33, 44]]}}}, {"text": "A client uses a QueueBrowser object to look at messages on a queue without removing them", "label": {"api": {"QueueBrowser": [[16, 27]]}}}, {"text": "submit returns a Future", "label": {"api": {"submit": [[0, 5]]}}}, {"text": "You can cancel the Future", "label": {"api": {"cancel": [[8, 13]]}}}, {"text": "You may have to keep a list of all the futures though after you submit each Runnable", "label": {"api": {"submit": [[64, 69]]}}}, {"text": "You can have one more Runnable for cleanup that iterates this list, looking for things that have errored and if any have, then it cancel's everyone", "label": {"api": {"cancel": [[130, 135]]}}}, {"text": "You can just use Collections.sort and provide a different Comparator for each case", "label": {"api": {"Collections.sort": [[17, 32]]}}}, {"text": "The String contains method will work here", "label": {"api": {"contains": [[11, 18]]}}}, {"text": "From the ThreadMXBean documentation", "label": {"api": {"ThreadMXBean documentation": [[9, 34]]}}}, {"text": "The documentation for OperatingSystemMXBean may also be useful", "label": {"api": {"documentation for OperatingSystemMXBean": [[4, 42]]}}}, {"text": "And its documentation says what you should do here", "label": {"api": {"its documentation": [[4, 20]]}}}, {"text": "As discussed in the comments, use a JComponent for graphics since you are using Swing", "label": {"api": {"JComponent": [[36, 45]]}}}, {"text": "check out the documentation for encodings are available", "label": {"api": {"check out the documentation": [[0, 26]]}}}, {"text": "SocketFactory has a couple of createSocket methods that provide a mechanism to specify the local interface", "label": {"api": {"has a couple of createSocket methods": [[14, 49]]}}}, {"text": "Use a ThreadPoolExecutor .Tune it's parameters like number of active threads and others to suit your environment and system", "label": {"api": {"ThreadPoolExecutor": [[6, 23]]}}}, {"text": "So if you've got tasks that take longer, they should be coded via classes that implement the runnable interface", "label": {"api": {"the runnable interface": [[89, 110]]}}}, {"text": "This may happen because of your internal Locale specification", "label": {"api": {"Locale": [[41, 46]]}}}, {"text": "the Javadoc of java.lang.Math.pow(double a, double b) states", "label": {"api": {"java.lang.Math.pow(double a, double b)": [[15, 52]]}}}, {"text": "As dd is for \"Day in month\"", "label": {"api": {"Day in month": [[14, 25]]}}}, {"text": "The implementation most used is the ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[36, 57]]}}}, {"text": "To avoid explicitly coding the iteration could use Collections.frequency() which", "label": {"api": {"Collections.frequency()": [[51, 73]]}}}, {"text": "SwingWorker is intended for this", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "Data acquisition can take place asynchronously in doInBackground(), while process() safely updates the TableModel on the event dispatch thread via publish()", "label": {"api": {"publish()": [[147, 155]]}}}, {"text": "In particular, see the section entitled Sample Usage and this tutorial", "label": {"api": {"Sample Usage": [[40, 51]]}}}, {"text": "One option is to use a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[23, 42]]}}}, {"text": "You probably just want to extend the JButton and override the .paint(Graphics g) method (extending JComponent is semantically incorrect and may cause trouble with other frameworks since this is a button)", "label": {"api": {"JButton": [[37, 43]], ".paint(Graphics g)": [[62, 79]]}}}, {"text": "You'll probably want to implement java.awt.event.MouseListener for your button so that you can have different effects for your button when the user hovers over it or clicks on it", "label": {"api": {"java.awt.event.MouseListener": [[34, 61]]}}}, {"text": "From another answer, you'll want to override contains(int x, int y) so that the clickable area reflects the actual shape of your button", "label": {"api": {"contains(int x, int y)": [[45, 66]]}}}, {"text": "I am search for the documentation which specifies what happens if I call getInt on a JDBC result set for a column containing a value which does not fit into an integer", "label": {"api": {"getInt": [[73, 78]]}}}, {"text": "The documentation for getInt does not specify this", "label": {"api": {"getInt": [[22, 27]]}}}, {"text": "It would also help to know your default locale.) You can set the locale that the scanner should use by calling Scanner.useLocale(Locale locale)", "label": {"api": {"Scanner.useLocale(Locale locale)": [[111, 142]]}}}, {"text": "See the discussion on \"Localized Numbers\" in the Scanner docs", "label": {"api": {"Scanner docs": [[49, 60]]}}}, {"text": "Try using a ConcurrentHashMap or ConcurrentSkipListMap instead", "label": {"api": {"ConcurrentHashMap": [[12, 28]], "ConcurrentSkipListMap": [[33, 53]]}}}, {"text": "As it it mentioned in specification of Connection interface", "label": {"api": {"Connection": [[39, 48]]}}}, {"text": "To check completion you can use future.isDone(), this needs to be constantly checked", "label": {"api": {"future.isDone()": [[32, 46]]}}}, {"text": "But if you use future.get(), this method will wait until finished and then return the result", "label": {"api": {"future.get()": [[15, 26]]}}}, {"text": "A JavaFX ImageView has a property called viewport which defines what part of the image is visible", "label": {"api": {"ImageView": [[9, 17]], "viewport": [[41, 48]]}}}, {"text": "you can simply use c.newInstance() to fill your internal array (if your MyInterface implementations all have public no-arguments constructors)", "label": {"api": {"c.newInstance()": [[19, 33]]}}}, {"text": "One way to achieve this, is by using SwingUtilities.invokeLater(), so it might be a good idea to replace new TTT(); with this", "label": {"api": {"SwingUtilities.invokeLater()": [[37, 64]]}}}, {"text": "You can try taking a look at http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html": [[29, 98]]}}}, {"text": "Java regex reference", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "Point inherits the public clone() method from Point2D", "label": {"api": {"Point": [[0, 4], [46, 50]], "Point2D": [[46, 52]]}}}, {"text": "You can use read() from BufferedReader which reads one char at a time", "label": {"api": {"read()": [[12, 17]], "BufferedReader": [[24, 37]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "Within doInBackground(), use publish(V..", "label": {"api": {"doInBackground()": [[7, 22]]}}}, {"text": "chunks) to send data to process(List<V> chunks)", "label": {"api": {"process(List<V> chunks)": [[24, 46]]}}}, {"text": "See java.awt.Container.add() for more information", "label": {"api": {"java.awt.Container.add()": [[4, 27]]}}}, {"text": "String(byte[] bytes, Charset charset))  â€”is a good one", "label": {"api": {"String(byte[] bytes, Charset charset)": [[0, 36]]}}}, {"text": "Can't you change the locale if it's available for the language you want", "label": {"api": {"locale": [[21, 26]]}}}, {"text": "Instead of looping until an EOFException is thrown, you could take a much cleaner approach, and use available()", "label": {"api": {"available()": [[100, 110]]}}}, {"text": "A ResultSet that is TYPE_SCROLL_INSENSITIVE is not meant to detect updates to the underlying database (that is what the insensitive means here)", "label": {"api": {"TYPE_SCROLL_INSENSITIVE": [[20, 42]]}}}, {"text": "If you want the ResultSet to detect changes, then you should use TYPE_SCROLL_SENSITIVE", "label": {"api": {"TYPE_SCROLL_SENSITIVE": [[65, 85]]}}}, {"text": "However as the changes usually occur in a different transaction, I believe most databases are unable to offer TYPE_SCROLL_SENSITIVE, and if they can then they probably only allow you to see changes to the data of the selected rows, but not detect additional (or removed) rows", "label": {"api": {"TYPE_SCROLL_SENSITIVE": [[110, 130]]}}}, {"text": "If you try to use TYPE_SCROLL_SENSITIVE, you might want to check if your database actually supports that type (eg using DatabaseMetaData.supportsResultSetType(int))", "label": {"api": {"TYPE_SCROLL_SENSITIVE": [[18, 38]], "DatabaseMetaData.supportsResultSetType(int)": [[120, 162]]}}}, {"text": "You might also want to check DatabaseMetaData.ownInsertsAreVisible(int) and related methods for your specific database and driver", "label": {"api": {"DatabaseMetaData.ownInsertsAreVisible(int)": [[29, 70]]}}}, {"text": "addAll does not append corresponding elements of Collections rather it appends them to the end of the Collection", "label": {"api": {"addAll": [[0, 5]]}}}, {"text": "As arrays are fixed in size, you can use System#arrayCopy to create a new array large enough to accommodate entries from corresponding array elements", "label": {"api": {"System#arrayCopy": [[41, 56]]}}}, {"text": "I'd take a look at DelayQueue", "label": {"api": {"DelayQueue": [[19, 28]]}}}, {"text": "I'd have one thread pull objects from the DelayQueue continuously and hand them off to a cached thread pool to execute them as soon as possible, rather than use a Timer", "label": {"api": {"DelayQueue": [[42, 51]]}}}, {"text": "DelayQueue will block until the waiting period for the next item has expired", "label": {"api": {"DelayQueue": [[0, 9]]}}}, {"text": "In case you need to deal with other attributes, have a look also at the API documentation for the HTML.Attribute class", "label": {"api": {"HTML.Attribute class": [[98, 117]]}}}, {"text": "Using CipherOutPutStream (http://docs.oracle.com/javase/6/docs/api/javax/crypto/CipherOutputStream.html) to write the objects into the ObjectOutputStream might be an easy and good approach here", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/crypto/CipherOutputStream.html": [[26, 102]]}}}, {"text": "javax.crypto.SealedObject is definitely the answer", "label": {"api": {"javax.crypto.SealedObject": [[0, 24]]}}}, {"text": "Try using CountDownLatch#await(long, TimeUnit) instead..", "label": {"api": {"CountDownLatch#await(long, TimeUnit)": [[10, 45]]}}}, {"text": "This is another example of how to use readAttributes() method  of the class BasicFileAttributes class", "label": {"api": {"BasicFileAttributes": [[76, 94]]}}}, {"text": "You are initializing ConversationUser.current to new ThreadLocal<ConversationUser>() without extending it anonymously to override initialValue(), like you do for ThreadContext.threadLocal", "label": {"api": {"ThreadLocal": [[53, 63]]}}}, {"text": "See the ThreadLocal javadocs for more information and a helpful example", "label": {"api": {"ThreadLocal": [[8, 18]]}}}, {"text": "Class.getResource() returns a URL, and File has no constructor with a URL as an argument", "label": {"api": {"Class.getResource()": [[0, 18]]}}}, {"text": "This is documented in the description for the Thread.join() method (not the best place, probably)", "label": {"api": {"Thread.join()": [[46, 58]]}}}, {"text": "Sounds like you want the Observer/Observable pattern", "label": {"api": {"Observer": [[25, 32]], "Observable": [[34, 43]]}}}, {"text": "Since newValue is actually a Date object, you could very likely just get whatever date field you are interested as an int directly from the Date object or more appropriately use a Calendar", "label": {"api": {"Date": [[29, 32], [140, 143]], "Calendar": [[180, 187]]}}}, {"text": "As the javadoc says", "label": {"api": {"javadoc says": [[7, 18]]}}}, {"text": "You can use StringBuilder to build a String containing your XML", "label": {"api": {"StringBuilder": [[12, 24]]}}}, {"text": "The simplest implementation of which is PropertyResourceBundle", "label": {"api": {"PropertyResourceBundle": [[40, 61]]}}}, {"text": "Further information can be found in the JavaFX 2 documentation", "label": {"api": {"JavaFX 2 documentation": [[40, 61]]}}}, {"text": "I have a Task that should return a list of SomeObject from a database", "label": {"api": {"Task": [[9, 12]]}}}, {"text": "Then you can use the javadoc from the API", "label": {"api": {"API": [[38, 40]]}}}, {"text": "In the left lower corner there is a complete list of classes in the API", "label": {"api": {"API": [[68, 70]]}}}, {"text": "Look up the substring method in the string class", "label": {"api": {"substring": [[12, 20]]}}}, {"text": "For ascending and descending, you might use reverseOrder to get a different Comparator", "label": {"api": {"reverseOrder": [[44, 55]]}}}, {"text": "Note you might want to check if the field isAssaignableFrom Comparable before comparing the fields", "label": {"api": {"isAssaignableFrom": [[42, 58]]}}}, {"text": "To achieve sorting on your list have your BeanInterface classes implement the Comparable interface and override the compareTo method to specify how the objects should be sorted", "label": {"api": {"Comparable": [[78, 87]]}}}, {"text": "You can use Java's HttpURLConnection to check for an error when connecting to the first url", "label": {"api": {"HttpURLConnection": [[19, 35]]}}}, {"text": "Check the ORACLE documentation for more", "label": {"api": {"ORACLE documentation": [[10, 29]]}}}, {"text": "Alternatively, calling asSubclass(SomeClass.class) will do this for you", "label": {"api": {"asSubclass(SomeClass.class)": [[23, 49]]}}}, {"text": "getElementsByTagName doesn't return a single element - it returns multiple elements", "label": {"api": {"getElementsByTagName": [[0, 19]]}}}, {"text": "I would attempt to use PropertyEditor instances and map them to model elements", "label": {"api": {"PropertyEditor": [[23, 36]]}}}, {"text": "You'd only pay the initial cost of getting the components relationships/dependencies in a nice model as well as registering the revelant PropertyEditors for visual editing", "label": {"api": {"PropertyEditor": [[137, 150]]}}}, {"text": "You just need to call HttpServletResponse#setHeader(\"Content-type, \"application/json\") to set appropriate content-type", "label": {"api": {"HttpServletResponse#setHeader(\"Content-type, \"application/json\")": [[22, 85]]}}}, {"text": "In case of multiple threads, you could use an AtomicInteger", "label": {"api": {"AtomicInteger": [[46, 58]]}}}, {"text": "In this case, make sure that first you increment the AtomicInteger with incrementAndGet(1) and after you create the ID", "label": {"api": {"AtomicInteger": [[53, 65]], "incrementAndGet(1)": [[72, 89]]}}}, {"text": "Use isReachable() instead", "label": {"api": {"isReachable()": [[4, 16]]}}}, {"text": "getTextContent() will only \"return the text content of this node and its descendants\" i.e", "label": {"api": {"getTextContent()": [[0, 15]]}}}, {"text": "If you want to do numeric comparison then convert to an integer using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[70, 85]]}}}, {"text": "Call textArea.setCaretColor(Color.WHITE); method", "label": {"api": {"textArea.setCaretColor(Color.WHITE);": [[5, 40]]}}}, {"text": "The trim() function removes both the trailing and leading space, however, if I only want to remove the trailing space of a string, how can I do it", "label": {"api": {"trim()": [[4, 9]]}}}, {"text": "As of JDK11 you can use stripTrailing", "label": {"api": {"stripTrailing": [[24, 36]]}}}, {"text": "If you want the object to stick around for a while until there is actual memory pressure, try SoftReference instead", "label": {"api": {"SoftReference": [[94, 106]]}}}, {"text": "You should use System.arraycopy", "label": {"api": {"System.arraycopy": [[15, 30]]}}}, {"text": "One problem is that you are using degrees while the math functions such as cos etc..", "label": {"api": {"cos": [[75, 77]]}}}, {"text": "You have to use ServletOutputStream and its write() method to write bytes to the response", "label": {"api": {"ServletOutputStream": [[16, 34]], "write()": [[44, 50]]}}}, {"text": "There are many ways, use substring function http://docs.oracle.com/javase/6/docs/api/java/lang/String.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[44, 105]]}}}, {"text": "You can use String class indexOf() method", "label": {"api": {"indexOf()": [[25, 33]]}}}, {"text": "One would have to alter the program, for instance a Thread has a set(Default)UncaughtExceptionHandler", "label": {"api": {"set(Default)UncaughtExceptionHandler": [[65, 100]]}}}, {"text": "Just use Double.compareTo(Double) method in your sort method", "label": {"api": {"Double.compareTo(Double)": [[9, 32]]}}}, {"text": "You can just use Double.compare() for that", "label": {"api": {"Double.compare()": [[17, 32]]}}}, {"text": "A Enum in Java is a list of known and immutable elements", "label": {"api": {"Enum": [[2, 5]]}}}, {"text": "Therefor it should be possible to implement the EnumMap as a perfect hash", "label": {"api": {"Enum": [[48, 51]], "EnumMap": [[48, 54]]}}}, {"text": "Enum.ordinal method is used for getting ordinal value of a given Enumeration constant", "label": {"api": {"Enum.ordinal": [[0, 11]]}}}, {"text": "It must be compiled first, for example using the Java Compiler API", "label": {"api": {"Java Compiler API": [[49, 65]]}}}, {"text": "You could use a Map with the ID as key, this way you will have one collection and you can add both in populate(employeeList) in one iteration", "label": {"api": {"Map": [[16, 18]]}}}, {"text": "Java has the notion of format strings, bearing a strong resemblance to format strings in other languages", "label": {"api": {"format strings": [[23, 36], [71, 84]]}}}, {"text": "It is used in JDK methods like String#format() for output conversion", "label": {"api": {"String#format()": [[31, 45]]}}}, {"text": "There is not a pure scanf replacement in standard Java, but you could use a java.util.Scanner for the same problems you would use scanf to solve", "label": {"api": {"java.util.Scanner": [[76, 92]]}}}, {"text": "Here's the code using findAll", "label": {"api": {"findAll": [[22, 28]]}}}, {"text": "You can use Calendar class", "label": {"api": {"Calendar": [[12, 19]]}}}, {"text": "Java now has a pretty good built-in date library, java.time bundled with Java 8", "label": {"api": {"java.time": [[50, 58]]}}}, {"text": "The thing is I don't see any getters with the possibility to indicate default values, like the java.util.Properties getters", "label": {"api": {"java.util.Properties getters": [[95, 122]]}}}, {"text": "Yes, in Java you can use the String#split(String regex) method in order to split the value of a String object", "label": {"api": {"String#split(String regex)": [[29, 54]]}}}, {"text": "It is explained in the javadoc of Process", "label": {"api": {"javadoc of Process": [[23, 40]]}}}, {"text": "See the documentation for ArrayList#remove(int), as in the following syntax", "label": {"api": {"the documentation for ArrayList#remove(int)": [[4, 46]]}}}, {"text": "The equivalent Java classes are `Timer and TimerTask", "label": {"api": {"Timer": [[33, 37], [43, 47]], "TimerTask": [[43, 51]]}}}, {"text": "If you want to be able to cancel, then use the TimerTask as a variable", "label": {"api": {"Timer": [[47, 51]], "TimerTask": [[47, 55]]}}}, {"text": "The TimerTask class has the method cancel", "label": {"api": {"Timer": [[4, 8]], "TimerTask": [[4, 12]]}}}, {"text": "You may want to have a look at ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[31, 57]]}}}, {"text": "It is an implementation of ScheduledExecutorService, which has the ability to schedule periodically", "label": {"api": {"ScheduledExecutorService": [[27, 50]]}}}, {"text": "I am guessing you forgot to call the Repaint of the JPanel whose paintComponent you are overriding everytime you update the object", "label": {"api": {"Repaint": [[37, 43]]}}}, {"text": "java.util.Stack.iterator() iterates the wrong way", "label": {"api": {"Stack": [[10, 14]]}}}, {"text": "Java's built-in Stack iterator methods are inherited from other classes, so they don't behave as you'd expect", "label": {"api": {"Stack": [[16, 20]]}}}, {"text": "There is no way to extend the System.out.println, but you can set a PrintStream to the System.out by the method System.setOut, or you can create a wrapper class like the example below to do something before the print", "label": {"api": {"System.setOut": [[112, 124]]}}}, {"text": "You could use Arrays.fill", "label": {"api": {"Arrays.fill": [[14, 24]]}}}, {"text": "You could use a JMX client (like VisualVM) and then call getVMOption(String name), see HotSpotDiagnosticMXBean", "label": {"api": {"HotSpotDiagnosticMXBean": [[87, 109]]}}}, {"text": "It attempts to use reflection to access the package-protected Flag helper class (available since Java 6), and falls back to HotSpotDiagnosticMXBean.getDiagnosticOptions() if that doesn't work", "label": {"api": {"HotSpotDiagnosticMXBean.getDiagnosticOptions()": [[124, 169]]}}}, {"text": "If you want to send a HTTPS request, you cound use HttpsURLConnection", "label": {"api": {"HttpsURLConnection": [[51, 68]]}}}, {"text": "Use Arrays.copyOf() or System.arraycopy() to clone an array in Java", "label": {"api": {"Arrays.copyOf()": [[4, 18]], "System.arraycopy()": [[23, 40]]}}}, {"text": "Your requirement will be fulfilled if you use an ArrayList in Java to store values and then use Collections.shuffle() and pick up its first element", "label": {"api": {"ArrayList": [[49, 57]], "Collections.shuffle()": [[96, 116]]}}}, {"text": "If you want to avoid duplicate elements in the Collection , then you can use Set", "label": {"api": {"Set": [[77, 79]]}}}, {"text": "To pick a random element from it , create an ArrayList from Set like , new ArrayList<E>(set); , shuffle it and pick the list's first element", "label": {"api": {"ArrayList": [[45, 53], [75, 83]], "Set": [[60, 62]]}}}, {"text": "I would suggest you keep an EnumMap of error codes in your enum that you build in a static block", "label": {"api": {"EnumMap": [[28, 34]]}}}, {"text": "The java EnumMap is also very nifty, it is a Map that is optimised for enum keys", "label": {"api": {"EnumMap": [[9, 15]]}}}, {"text": "You need to use an EventListener so your program can detect when the button has been pressed and check for the text in the textArea", "label": {"api": {"EventListener": [[19, 31]]}}}, {"text": "Generally, you cannot send a POST request using sendRedirect() method", "label": {"api": {"sendRedirect()": [[48, 61]]}}}, {"text": "You can use RequestDispatcher to forward() requests with parameters within the same web application, same context", "label": {"api": {"RequestDispatcher": [[12, 28]], "forward()": [[33, 41]]}}}, {"text": "Arrays in Java are not of a seperate type", "label": {"api": {"Array": [[0, 4]]}}}, {"text": "The class Array is merely a collection of static methods to work with arrays and you cannot make instances of it", "label": {"api": {"Array": [[10, 14]]}}}, {"text": "As pointed out in other answers you can use the isArray method from Class to determine whether the object is an array", "label": {"api": {"Array": [[50, 54]]}}}, {"text": "NullPointerException is one example", "label": {"api": {"NullPointerException": [[0, 19]]}}}, {"text": "If you want decent random numbers, you should simply use SecureRandom instead of Random ..", "label": {"api": {"SecureRandom": [[57, 68]]}}}, {"text": "If it does not exist then you use a ReentrantLock to synchronize", "label": {"api": {"ReentrantLock": [[36, 48]]}}}, {"text": "So you do a trylock and only one of your threads succeeds", "label": {"api": {"trylock": [[12, 18]]}}}, {"text": "One idea might be to use a PriorityBlockingQueue and define a quality value for each input, which is then sort by quality automatically inside the list", "label": {"api": {"PriorityBlockingQueue": [[27, 47]]}}}, {"text": "On the other hand, you can use MaxMind IP GeoLocation database and use some business logic to detect the IP addres using a Servlet-Filter and method ServletRequest#getRemoteAddr()", "label": {"api": {"ServletRequest#getRemoteAddr()": [[149, 178]]}}}, {"text": "You can just use the iterator to remove the item by calling Iterator#remove", "label": {"api": {"Iterator#remove": [[60, 74]]}}}, {"text": "Swing Timer has a constructor Timer(int , java.awt.event.ActionListener)", "label": {"api": {"Timer(int , java.awt.event.ActionListener)": [[30, 71]]}}}, {"text": "You could change the color with by setting a Font color", "label": {"api": {"Font": [[45, 48]]}}}, {"text": "I found a lot of examples about the SecureRandom class that look like this", "label": {"api": {"SecureRandom": [[36, 47]], "Random": [[42, 47]]}}}, {"text": "However, both SecureRandom() and SecureRandom.getInstance(String) have this part in their documentation", "label": {"api": {"SecureRandom": [[14, 25], [33, 44]], "SecureRandom()": [[14, 27]], "SecureRandom.getInstance(String)": [[33, 64]], "Random": [[20, 25], [39, 44]]}}}, {"text": "The returned SecureRandom object has not been seeded", "label": {"api": {"SecureRandom": [[13, 24]], "Random": [[19, 24]]}}}, {"text": "If setSeed is not called, the first call to nextBytes will force the SecureRandom object to seed itself", "label": {"api": {"SecureRandom": [[69, 80]], "Random": [[75, 80]], "nextBytes": [[44, 52]], "next": [[44, 47]]}}}, {"text": "So, the Random object is never seeded at creation time in the above examples", "label": {"api": {"Random": [[8, 13]]}}}, {"text": "The documentation of nextInt() (from the Random class documentation, it's not overridden in SecureRandom) states", "label": {"api": {"SecureRandom": [[92, 103]], "Random": [[41, 46], [98, 103]], "nextInt()": [[21, 29]], "next": [[21, 24]]}}}, {"text": "The method nextInt is implemented by class Random as if by", "label": {"api": {"Random": [[43, 48]], "next": [[11, 14]]}}}, {"text": "So, there is no call to a nextBytes method, neither the documentation for the next method in SecureRandom says anything about seeding", "label": {"api": {"SecureRandom": [[93, 104]], "Random": [[99, 104]], "nextBytes": [[26, 34]], "next": [[26, 29], [78, 81]]}}}, {"text": "are the above Random objects seeded for sure", "label": {"api": {"Random": [[14, 19]]}}}, {"text": "As correctly pointed out in a comment, looking at the source code it seems like next calls nextBytes, therefore initializing the seed, however this is not mentioned in the documentation", "label": {"api": {"nextBytes": [[91, 99]], "next": [[80, 83], [91, 94]]}}}, {"text": "See ProgressMonitorInputStream & How to Use Progress Bars", "label": {"api": {"ProgressMonitorInputStream": [[4, 29]]}}}, {"text": "I think you're going to have to handle the quotes after you get the token back because in the Scanner#next(String) method, the regex is used to test the next token, not to determine the next token", "label": {"api": {"the Scanner#next(String) method": [[90, 120]]}}}, {"text": "Swing is easily doublebuffered via setDoubleBuffered(true) if that is all you wanted to achieve", "label": {"api": {"easily": [[9, 14]]}}}, {"text": "You have no control over the repaint, the OS calls it whenever it deems necessary unless you call setIgnoreRepaint on the JFrame", "label": {"api": {"setIgnoreRepaint": [[98, 113]]}}}, {"text": "In order to close the Main_Menu, you can just call its dispose method", "label": {"api": {"dispose": [[55, 61]]}}}, {"text": "The Media constructor takes a URI, not a file path specifier", "label": {"api": {"Media constructor": [[4, 20]]}}}, {"text": "The supplied URI must conform to RFC-2396 as required by java.net.URI", "label": {"api": {"java.net.URI": [[57, 68]]}}}, {"text": "To construct a URI for a file, call file.toURI() instead of your current call to file.getPath()", "label": {"api": {"file.toURI()": [[36, 47]]}}}, {"text": "Store them in an ArrayList", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "But println displays it like that because it's defined to do so (see the Javadocs)", "label": {"api": {"the Javadocs": [[69, 80]]}}}, {"text": "JComponent has a method named scrollRectToVisible which is designed to do this", "label": {"api": {"scrollRectToVisible": [[30, 48]]}}}, {"text": "To compare strings, you use equals", "label": {"api": {"equals": [[28, 33]]}}}, {"text": "The reason my example above returns true is that both strings are initialized pointing to literals, and String literals in Java are intern'd by default, so that literals with the same characters are mapped to the same object", "label": {"api": {"intern'd": [[132, 139]]}}}, {"text": "the .equals()/.hashCode() contract", "label": {"api": {".equals()": [[4, 12]], ".hashCode()": [[14, 24]]}}}, {"text": "But keys in a HashMap, which you use, rely heavily on .equals() and .hashCode()", "label": {"api": {".equals()": [[54, 62]], ".hashCode()": [[68, 78]]}}}, {"text": "This will normally be caused by the test framework calling shutdownNow on the ExecutorService that's running the test", "label": {"api": {"shutdownNow": [[59, 69]]}}}, {"text": "The best way to improve your code is to delete all of your classes and use TimeUnit instead", "label": {"api": {"TimeUnit": [[75, 82]]}}}, {"text": "TimeUnit has all this functionality (and more) and comes with the JDK", "label": {"api": {"TimeUnit": [[0, 7]]}}}, {"text": "Use LinkedHashMap instead of HashMap", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "Use getRGB() function and compare the images pixel by pixel", "label": {"api": {"getRGB()": [[4, 11]]}}}, {"text": "From Servlet API, request.getSession() creates a new session if there is no existing session", "label": {"api": {"Servlet API": [[5, 15]]}}}, {"text": "Use java.lang.String.split(String regex, int limit)", "label": {"api": {"java.lang.String.split(String regex, int limit)": [[4, 50]]}}}, {"text": "Every possible short value is <= 32767, because 32767 is the biggest number that a short can hold", "label": {"api": {"the biggest number that a short can hold": [[57, 96]]}}}, {"text": "But you can easily combine regex with any programmatic replacement that you can write in Java using Matcher.appendReplacement()", "label": {"api": {"Matcher.appendReplacement()": [[100, 126]]}}}, {"text": "To me it sounds like you want to parse date strings in different formats and maybe convert them to a Date object as in DateFormat.parse(String)", "label": {"api": {"DateFormat.parse(String)": [[119, 142]]}}}, {"text": "Read specific API  before asking here and here is the essential part of API", "label": {"api": {"specific API": [[5, 16]]}}}, {"text": "To define encoding for read data use InputStreamReader(InputStream, Charset) constructor", "label": {"api": {"InputStreamReader(InputStream, Charset)": [[37, 75]]}}}, {"text": "The DefaultTableModel constructor takes Vectors, not Lists", "label": {"api": {"DefaultTableModel": [[4, 20]], "Vector": [[40, 45]]}}}, {"text": "You can use boolean removeAll(Collection<?> c) method", "label": {"api": {"boolean removeAll(Collection<?> c)": [[12, 45]]}}}, {"text": "Java provides the ThreadLocal<T> class to declare variables that are not shared between threads", "label": {"api": {"ThreadLocal<T>": [[18, 31]]}}}, {"text": "Integer.parseInt(String) needs a String argument, you are passing void", "label": {"api": {"Integer.parseInt(String)": [[0, 23]]}}}, {"text": "showMessageDialog() returns a void", "label": {"api": {"showMessageDialog()": [[0, 18]]}}}, {"text": "This is all documented in the javadoc for Object", "label": {"api": {"the javadoc for Object": [[26, 47]]}}}, {"text": "If you think you need to override equals(), then you need to override hashCode() and vice versa", "label": {"api": {"hashCode()": [[70, 79]]}}}, {"text": "The general contract of hashCode() is", "label": {"api": {"hashCode()": [[24, 33]]}}}, {"text": "Override the equals() and hashCode() method in your Policy class", "label": {"api": {"equals()": [[13, 20]], "hashCode()": [[26, 35]]}}}, {"text": "Implement Comparable and override the compareTo() method if you need to order the objects", "label": {"api": {"Comparable": [[10, 19]], "compareTo()": [[38, 48]]}}}, {"text": "I would use String.split", "label": {"api": {"String.split": [[12, 23]]}}}, {"text": "You could use Random class to do that (too)", "label": {"api": {"Random": [[14, 19]]}}}, {"text": "Your MessageSentTimestampComparer doesn't implement Comparator", "label": {"api": {"Comparator": [[52, 61]]}}}, {"text": "You could use String.compareTo() to do that", "label": {"api": {"String.compareTo()": [[14, 31]]}}}, {"text": "If you had changed this to String[], you can use String#compareTo method to discern if one string is \"less than\" another", "label": {"api": {"String#compareTo": [[49, 64]]}}}, {"text": "See javadoc for Class object to see all info you can get", "label": {"api": {"Class object": [[16, 27]]}}}, {"text": "At this link you can see Oracle's documentation for class Random", "label": {"api": {"link": [[8, 11]]}}}, {"text": "From the Math.sin Javadocs", "label": {"api": {"Math.sin": [[9, 16]]}}}, {"text": "From the docs for DAY_OF_WEEK_IN_MONTH", "label": {"api": {"DAY_OF_WEEK_IN_MONTH": [[18, 37]]}}}, {"text": "DAY_OF_MONTH 1 through 7 always correspond to DAY_OF_WEEK_IN_MONTH 1; 8 through 14 correspond to DAY_OF_WEEK_IN_MONTH 2, and so on", "label": {"api": {"DAY_OF_WEEK_IN_MONTH": [[46, 65], [97, 116]]}}}, {"text": "JInternalFrame might be what you are looking for", "label": {"api": {"JInternalFrame": [[0, 13]]}}}, {"text": "You can easily do this with Collections.sort", "label": {"api": {"Collections.sort": [[28, 43]]}}}, {"text": "See if the String's default compareTo method works for you", "label": {"api": {"compareTo": [[28, 36]]}}}, {"text": "I use MappedByteBuffers to achieve thread safety between readers and writers of a file via volatile variables (writer updates position and readers read the writer's position) (this is a file upload system, the the incoming file is a stream, if that matters)", "label": {"api": {"MappedByteBuffers": [[6, 22]]}}}, {"text": "To access the clipboard, you can use the awt datatransfer classes", "label": {"api": {"awt datatransfer classes": [[41, 64]]}}}, {"text": "By using the st.pop() it will remove and return the last item of the stack", "label": {"api": {"st.pop()": [[13, 20]]}}}, {"text": "If you dont want it to get removed you can use one ordered Collection like ArrayList and access the item by list.get or using an Iterator", "label": {"api": {"ArrayList": [[75, 83]], "list.get": [[108, 115]], "Iterator": [[129, 136]]}}}, {"text": "If you need to use a simple array of primitives (and not a wrapper class), you can use a couple of methods in the java.util.Arrays and java.lang.System classes to help", "label": {"api": {"java.util.Arrays": [[114, 129]], "java.lang.System": [[135, 150]]}}}, {"text": "You can use FileOutputStream#write(byte[] b)", "label": {"api": {"FileOutputStream#write(byte[] b)": [[12, 43]]}}}, {"text": "Use List for this requirement", "label": {"api": {"List": [[4, 7]]}}}, {"text": "You can use a ArrayList<ArrayList> in place of 2-dim array", "label": {"api": {"List": [[19, 22], [29, 32]], "ArrayList": [[14, 22], [24, 32]]}}}, {"text": "ArrayList is Resizable-array implementation of the List interface", "label": {"api": {"List": [[5, 8], [51, 54]], "ArrayList": [[0, 8]]}}}, {"text": "I think the perfect bet of your requirement is   ArrayList", "label": {"api": {"ArrayList": [[49, 57]]}}}, {"text": "For many components in one space, use a CardLayout as see in this short example", "label": {"api": {"CardLayout": [[40, 49]]}}}, {"text": "In Java 7+, you can use Objects#equals", "label": {"api": {"Objects#equals": [[24, 37]]}}}, {"text": "Then you start your client program, which connects immediatley to the server (new MyClient()) and blocks waiting for the user input from console", "label": {"api": {"immediatley": [[51, 61]]}}}, {"text": "But after creating a new thread to process the client request, your server closes the sSocket, and then tries to accept on that same closed socket, hence the exception", "label": {"api": {"accept": [[113, 118]]}}}, {"text": "In your saveTeam if validation fails you can call FacesContext#renderResponse() on your current FacesContext instance to skip all the subsequent phases and go to render response phase", "label": {"api": {"FacesContext#renderResponse()": [[50, 78]]}}}, {"text": "The documentation says that getDefaultScreenDevice throws HeadlessException - if isHeadless() returns true", "label": {"api": {"getDefaultScreenDevice": [[28, 49]]}}}, {"text": "If you want to get random ints from a defined list of integers then put the Integers inside a List and then shuffle it with Collections.shuffle method", "label": {"api": {"Collections.shuffle": [[124, 142]]}}}, {"text": "If you store the numbers as int you could write the numbers to a memory mapped file (java.nio) IntBuffer", "label": {"api": {"Buffer": [[98, 103]]}}}, {"text": "This is also well documented in the Javadoc", "label": {"api": {"well documented": [[13, 27]]}}}, {"text": "Compare next() and nextLine() - nextLine() is expecting a line separator to terminate on which I presume your input doesn't have", "label": {"api": {"next()": [[8, 13]], "nextLine()": [[19, 28], [32, 41]]}}}, {"text": "The second argument of split indicates the maximum number of pieces the string should be split into, in your case you only need 3", "label": {"api": {"split": [[23, 27], [89, 93]]}}}, {"text": "This will be faster than using the single-argument version of split, which will continue splitting on the delimiter unnecessarily", "label": {"api": {"split": [[62, 66], [89, 93]]}}}, {"text": "For String or any object-equality test in Java, you should almost always be using equals", "label": {"api": {"equals": [[82, 87]]}}}, {"text": "What you're interested in doing is comparing the contents of the String instance, and equals will do that for you", "label": {"api": {"equals": [[86, 91]]}}}, {"text": "You can use String.format() (if you're familiar with C/C++, this one is similar to printf())", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "If you output string is long, then you can also use StringBuilder along with the String.format()", "label": {"api": {"String.format()": [[81, 95]], "StringBuilder": [[52, 64]]}}}, {"text": "One simple way is to use String.split() function which returns an array of strings given an input string and delimiters described as an regular expression", "label": {"api": {"String.split()": [[25, 38]]}}}, {"text": "If you don't really care about what elements inside the input string and just simply remove new line symbols, then you can use String.replaceAll()", "label": {"api": {"String.replaceAll()": [[127, 145]]}}}, {"text": "Take a look at using Random", "label": {"api": {"Random": [[21, 26]]}}}, {"text": "InputStream.read(byte[], int, int) will read up to spx_data_length bytes, but may very well read less", "label": {"api": {"InputStream.read(byte[], int, int)": [[0, 33]]}}}, {"text": "You should either loop until the read returns -1, or use something like DataInputStream.readFully(byte[], int, int)", "label": {"api": {"DataInputStream.readFully(byte[], int, int)": [[72, 114]]}}}, {"text": "Everything inherits from Object, so the toString on Object will be called if you have not defined one", "label": {"api": {"toString": [[40, 47]]}}}, {"text": "You're not explicitly calling toString(), but implicitly you are", "label": {"api": {"toString()": [[30, 39]]}}}, {"text": "System is a class, with a static field out, of type PrintStream", "label": {"api": {"System": [[0, 5]], "out": [[39, 41]], "PrintStream": [[52, 62]]}}}, {"text": "So you're calling the println(Object) method of a PrintStream", "label": {"api": {"PrintStream": [[50, 60]], "println(Object)": [[22, 36]]}}}, {"text": "As we see, it's calling the String.valueOf(Object) method", "label": {"api": {"String.valueOf(Object)": [[28, 49]]}}}, {"text": "And here you see, that toString() is called", "label": {"api": {"toString()": [[23, 32]]}}}, {"text": "The best you can do with standard JDK libraries is Collections.unmodifiableMap()", "label": {"api": {"Collections.unmodifiableMap()": [[51, 79]]}}}, {"text": "As pointed out, a long might not be big enough to hold the sum, so the problem might need BigInteger instead", "label": {"api": {"BigInteger": [[90, 99]]}}}, {"text": "You should use GZIPInputStream to read the icecache file that is in the linked zip file", "label": {"api": {"GZIPInputStream": [[15, 29]]}}}, {"text": "There is a class called Class that represents the class of an object", "label": {"api": {"Class": [[24, 28]]}}}, {"text": "One way to get a class object is to use the Object method getClass()", "label": {"api": {"Class": [[61, 65]]}}}, {"text": "But if you want to refer to a Class by name of its class, you use a class literal", "label": {"api": {"Class": [[30, 34]]}}}, {"text": "Assuming you are using just plain servlets, you can use servlet filters, or a servlet to handle all invalid paths of your application, and then use the method request.getRequestURI() to find out the path entered by user", "label": {"api": {"request.getRequestURI()": [[159, 181]]}}}, {"text": "Be careful, forName requires a fully-qualified class name (e.g", "label": {"api": {"forName": [[12, 18]]}}}, {"text": "Then call newInstance on the class object", "label": {"api": {"newInstance": [[10, 20]]}}}, {"text": "It will never throw a NullPointerException if foo is null", "label": {"api": {"NullPointerException": [[22, 41]]}}}, {"text": "First, you can split a String into a String[] by using String#split", "label": {"api": {"String#split": [[55, 66]]}}}, {"text": "I've implemented the hashCode() and equals() methods of it to handle exactly those 2 fields, in order to put instances of the class into a set", "label": {"api": {"hashCode": [[21, 28]], "equals": [[36, 41]]}}}, {"text": "You can get that effect by using a TreeSet when providing a custom Comparator that only inspects the fields you're interested in", "label": {"api": {"TreeSet": [[35, 41]], "Comparator": [[67, 76]]}}}, {"text": "Note, however, that strictly speaking such a TreeSet no longer is a \"correct\" Set because it effectively ignores the equal() method of your objects", "label": {"api": {"TreeSet": [[45, 51]]}}}, {"text": "(See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal", "label": {"api": {"TreeSet": [[171, 177]], "Comparator": [[19, 28]]}}}, {"text": "You can supply the ArrayList.toArray() method with an existing array to define what type of array you want to get out of it", "label": {"api": {"with an existing array": [[46, 67]]}}}, {"text": "string have getBytes() method", "label": {"api": {"getBytes()": [[12, 21]]}}}, {"text": "You can use NetworkInterface for  this (http://docs.oracle.com/javase/6/docs/api/java/net/NetworkInterface.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/net/NetworkInterface.html": [[40, 110]]}}}, {"text": "You need to use DecimalFormat to format it as per your need", "label": {"api": {"DecimalFormat": [[16, 28]]}}}, {"text": "You can use a DocumentFilter, it is effective in your case", "label": {"api": {"DocumentFilter": [[14, 27]]}}}, {"text": "The script also prints the binary (bits) representation of the int, and, using a much more efficient transformation, Integer.reverseBytes(int), does the same thing", "label": {"api": {"Integer.reverseBytes(int)": [[117, 141]]}}}, {"text": "You need to use a Filter to do anything closer to what you intend to do", "label": {"api": {"Filter": [[18, 23]]}}}, {"text": "You can implement HttpSessionListener to listen to the session invalidation event", "label": {"api": {"HttpSessionListener": [[18, 36]]}}}, {"text": "I'm trying to convert Log4j Level to JUL Level, and would like to use some out-of-the-box utility class", "label": {"api": {"Level": [[28, 32], [41, 45]]}}}, {"text": "I've found UtilLoggingLevel, but can't figure out how to use it for this particular case", "label": {"api": {"Level": [[22, 26]]}}}, {"text": "You're setting HOUR when you should be setting HOUR_OF_DAY", "label": {"api": {"HOUR": [[15, 18], [47, 50]], "HOUR_OF_DAY": [[47, 57]]}}}, {"text": "HOUR modifies the value as seen in \"10 AM\" or \"10 PM\"", "label": {"api": {"HOUR": [[0, 3]]}}}, {"text": "HOUR_OF_DAY is the hour as specified in the 24 hour clock", "label": {"api": {"HOUR": [[0, 3]], "HOUR_OF_DAY": [[0, 10]]}}}, {"text": "See the javadoc for Files", "label": {"api": {"the javadoc for Files": [[4, 24]]}}}, {"text": "List and ArrayList and Arrays were introduced in V1.2 (http://docs.oracle.com/javase/6/ocs/api/java/util/List.html )", "label": {"api": {"http://docs.oracle.com/javase/6/ocs/api/java/util/List.html": [[55, 113]]}}}, {"text": "Just use String.split()", "label": {"api": {"String.split()": [[9, 22]]}}}, {"text": "Use the getResponseBody() method to obtain an OutputStream", "label": {"api": {"getResponseBody()": [[8, 24]]}}}, {"text": "At the moment I am trying to figure out whether targeting java.awt.Graphics2D will be forward compatible", "label": {"api": {"java.awt.Graphics2D": [[58, 76]]}}}, {"text": "Is there interoperability between java.awt.Graphics2D and javafx.scene.canvas.GraphicsContext", "label": {"api": {"java.awt.Graphics2D": [[34, 52]], "javafx.scene.canvas.GraphicsContext": [[58, 92]]}}}, {"text": "I know how to do it with JButton by adding a mouse listener on the glasspane and then use this method getDeepestComponentAt()  from SwingUtilities", "label": {"api": {"getDeepestComponentAt() ": [[102, 125]]}}}, {"text": "The alternative is to use the specification of invokeAll which guarantees to return the futures in the same order as the tasks that were submitted", "label": {"api": {"which guarantees to return the futures in the same order as the tasks that were submitted": [[57, 145]]}}}, {"text": "Then you can turn it to an int using Integer#parseInt", "label": {"api": {"Integer#parseInt": [[37, 52]]}}}, {"text": "See StringBuilder and Character for additional information", "label": {"api": {"StringBuilder": [[4, 16]], "Character": [[22, 30]]}}}, {"text": "Try creating a compound border with your line border and an empty border", "label": {"api": {"compound border": [[15, 29]]}}}, {"text": "String#indexOf(String, int) behaves the same way", "label": {"api": {"String#indexOf(String, int)": [[0, 26]]}}}, {"text": "Anyway, as the DataOutputStream documentation states, doing writeBytes on a String will just discard its high eight bits", "label": {"api": {"DataOutputStream": [[15, 30]]}}}, {"text": "Instead of using an Array, use a List", "label": {"api": {"List": [[33, 36]]}}}, {"text": "That way you can use List.add() and you don't need to worry about how many elements are going to be in that list", "label": {"api": {"List": [[21, 24]]}}}, {"text": "Elements in a list can be access similar to an array by using List.get(index) to get the objects or a more generic for( element", "label": {"api": {"List": [[62, 65]]}}}, {"text": "List ) {}", "label": {"api": {"List": [[0, 3]]}}}, {"text": "if you do not need access to the specific methods of ConcurrentMap", "label": {"api": {"ConcurrentMap": [[53, 65]]}}}, {"text": "System.nanoTime() is more accurate than System.currentTimeMillis()", "label": {"api": {"System.nanoTime()": [[0, 16]], "System.currentTimeMillis()": [[40, 65]]}}}, {"text": "By default this returns System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[24, 49]]}}}, {"text": "Properties.store() escapes certain characters", "label": {"api": {"Properties.store()": [[0, 17]]}}}, {"text": "Once you read them back with Properties.load(), they are unescaped so that you will get the original value", "label": {"api": {"Properties.load()": [[29, 45]]}}}, {"text": "As said in the JavaDoc, you have to \"release\" the key after pressing it", "label": {"api": {"in the JavaDoc": [[8, 21]]}}}, {"text": "For example, with Map.get(), a null return indicates either that the key is present and its value is null, or that the key is absent", "label": {"api": {"Map.get()": [[18, 26]]}}}, {"text": "You can encode the parameters using URLEncoder.encode(String)", "label": {"api": {"URLEncoder.encode(String)": [[36, 60]]}}}, {"text": "Create a ThreadLocal object of type Locale like ThreadLocal<Locale> will have thread-local Locale object , which can be used to get an instance of the Calendar object using Calendar#getInstance(Locale)", "label": {"api": {"Calendar#getInstance(Locale)": [[173, 200]]}}}, {"text": "As it says in the Error javadoc, you probably don't want to catch such things - but then again your situation may seem to warrant it if you know what you're going to do with caught Errors", "label": {"api": {"Error javadoc": [[18, 30]]}}}, {"text": "You got a ClassCastException; that means you have some problem in your XML", "label": {"api": {"ClassCastException": [[10, 27]]}}}, {"text": "You can use the BigDecimal class , toPlainString() method", "label": {"api": {"BigDecimal": [[16, 25]], "toPlainString()": [[35, 49]]}}}, {"text": "Returns a string representation of this BigDecimal without an exponent field", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "Use an updatable resultset and named columns", "label": {"api": {"resultset": [[17, 25]]}}}, {"text": "Have a look at the Javadoc for Files", "label": {"api": {"Javadoc for Files": [[19, 35]]}}}, {"text": "The reason why I say that is because Java 7 (within the java.nio.* package) provides new File I/O APIs that are much more versatile than previous Java versions", "label": {"api": {"package": [[67, 73]]}}}, {"text": "You can use the getRemoteSocketAdress() method from the Socket class", "label": {"api": {"getRemoteSocketAdress()": [[16, 38]]}}}, {"text": "Do NOT use regexes for this when Java has URI", "label": {"api": {"URI": [[42, 44]]}}}, {"text": "I would use the existing URL class and the getPath() method to get the section following the host/port/protocol", "label": {"api": {"URL": [[25, 27]], "getPath()": [[43, 51]]}}}, {"text": "I'd certainly start with an existing class designed to break apart URL components and then work from there", "label": {"api": {"URL": [[67, 69]]}}}, {"text": "If you use a regexp you're likely to run into and have to cater for lots of edge cases that the URL class already handles", "label": {"api": {"URL": [[96, 98]]}}}, {"text": "You can use File.separator for that or /", "label": {"api": {"File.separator": [[12, 25]]}}}, {"text": "In Java 7 , you can make use of the Paths class", "label": {"api": {"Paths": [[36, 40]]}}}, {"text": "AbstractTableModel supports listeners that the table registers itself on it to react to the content changes", "label": {"api": {"AbstractTableModel": [[0, 17]]}}}, {"text": "However AbstractTableModel it is not aware when the underlying data actually become different - this is already fully in your code", "label": {"api": {"AbstractTableModel": [[8, 25]]}}}, {"text": "The EntityManager's merge and persist will return a managed entity", "label": {"api": {"merge": [[20, 24]], "persist": [[30, 36]]}}}, {"text": "Use the Class object to access Field objects with the getFields() method", "label": {"api": {"getFields()": [[54, 64]]}}}, {"text": "If they aren't, then use getDeclaredFields(), which accesses all Fields that are directly declared on the class, public or not", "label": {"api": {"getDeclaredFields()": [[25, 43]]}}}, {"text": "Because you're putting zero in height in our first code, see the interface of drawRect", "label": {"api": {"drawRect": [[78, 85]]}}}, {"text": "or even better, use the Arrays.copyOfRange() utility method to do the work for you", "label": {"api": {"Arrays.copyOfRange()": [[24, 43]]}}}, {"text": "Your original version with the (?s) should work perfectly fine, since Java supports match flags", "label": {"api": {"supports match flags": [[75, 94]]}}}, {"text": "More generally, see the javadoc for Formatter", "label": {"api": {"Formatter": [[36, 44]]}}}, {"text": "This is possible because the interface involved in this process, From<Z,X>, extends Path<X>, therefore classStudentMapping is a Path<Student>", "label": {"api": {"From<Z,X>": [[65, 73]]}}}, {"text": "you should learn about DateFormat from here link1 and link2, you will realize that your code should be like that (year should be written in small letters)", "label": {"api": {"link2": [[54, 58]]}}}, {"text": "To create an array, you can use java.lang.reflect.Array and its newInstance method", "label": {"api": {"java.lang.reflect.Array": [[32, 54]], "newInstance": [[64, 74]]}}}, {"text": "I'm using javax.imageio.ImageIO to save a BufferedImage as a jpeg file", "label": {"api": {"javax.imageio.ImageIO": [[10, 30]]}}}, {"text": "ImageWriter.setOutput should be passed an ImageOutputStream", "label": {"api": {"ImageOutputStream": [[42, 58]]}}}, {"text": "Use of a general Object other than an ImageOutputStream is intended for writers that interact directly with an output device or imaging protocol", "label": {"api": {"ImageOutputStream": [[38, 54]]}}}, {"text": "The set of legal classes is advertised by the writer's service provider's getOutputTypes method; most writers will return a single-element array containing only ImageOutputStream.class to indicate that they accept only an ImageOutputStream", "label": {"api": {"ImageOutputStream": [[161, 177], [222, 238]]}}}, {"text": "FileImageOutputStream - an implementation of ImageOutputStream that writes its output directly to a File or RandomAccessFile", "label": {"api": {"ImageOutputStream": [[4, 20], [45, 61]], "FileImageOutputStream": [[0, 20]]}}}, {"text": "MemoryCacheImageOutputStream - an implementation of ImageOutputStream that writes its output to a regular OutputStream", "label": {"api": {"ImageOutputStream": [[11, 27], [52, 68]], "MemoryCacheImageOutputStream": [[0, 27]]}}}, {"text": "The easiest way is to use the method CriteriaBuilder#nullLiteral() which does exactly that", "label": {"api": {"CriteriaBuilder#nullLiteral()": [[37, 65]]}}}, {"text": "No, putting an element to a volatile HashMap will not create a happens-before relationship, not even with a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[108, 124]]}}}, {"text": "Actually ConcurrentHashMap does not hold lock for read operations (e.g", "label": {"api": {"ConcurrentHashMap": [[9, 25]]}}}, {"text": "See ConcurrentHashMap Javadoc", "label": {"api": {"ConcurrentHashMap": [[4, 20]]}}}, {"text": "Yes, it is worth to keep the ConcurrentHashMap, because the map reads and writes will happen at the same time", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "I know that I am passing invalid parameters and will likely be causing a NPE within the method but that is not what is happening, instead the test is failing", "label": {"api": {"NPE": [[73, 75]]}}}, {"text": "I am using boolean and not Boolean", "label": {"api": {"Boolean": [[27, 33]]}}}, {"text": "System.getenv() will return a Map", "label": {"api": {"System.getenv()": [[0, 14]]}}}, {"text": "Grepcode lists these call sites, namely including IdentityHashMap amongst others", "label": {"api": {"IdentityHashMap": [[50, 64]]}}}, {"text": "Executor is an interface and not a class, unless Javadoc is mistaken or I misread your post", "label": {"api": {"Executor": [[0, 7]]}}}, {"text": "Instead, the timer thread should be periodically passing a task to invokeLater()", "label": {"api": {"invokeLater()": [[67, 79]]}}}, {"text": "Making your dialog via an appropriate constructor or by using setModal(true) will block input to other windows of your program and halt execution in the caller until the dialog is closed", "label": {"api": {"constructor": [[38, 48]], "setModal(true)": [[62, 75]]}}}, {"text": "Both String and Double (the object form of double) have a compareTo() method that returns an int", "label": {"api": {"String": [[5, 10]], "Double": [[16, 21]]}}}, {"text": "You can use Container#getComponents() for this case", "label": {"api": {"Container#getComponents()": [[12, 36]]}}}, {"text": "The javadoc for Lock says", "label": {"api": {"javadoc for Lock": [[4, 19]]}}}, {"text": "If you wanted to be safer (and probably more correct in this case) you could also use an AtomicInteger which is specifically designed for threadsafe counters", "label": {"api": {"AtomicInteger": [[89, 101]]}}}, {"text": "While I hate to sound obvious, is there any reason you're not using this constructor", "label": {"api": {"this constructor": [[68, 83]]}}}, {"text": "I'd rather not use the BigDecimal classes or equivalent, as the code is already slow enough ;) (unless they don't impact speed too much, of course)", "label": {"api": {"BigDecimal": [[23, 32]]}}}, {"text": "When there is a variable involved, the concatenation is translated into StringBuilder#append chain", "label": {"api": {"StringBuilder#append": [[72, 91]]}}}, {"text": "You can create a thread that will be responsible of changing the int value, then in order to perform a periodic task, you can use ScheduledExecutorService#scheduleAtFixedRate", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate": [[130, 173]]}}}, {"text": "That layout might be achieved using a GroupLayout with two vertical groups and two horizontal groups", "label": {"api": {"GroupLayout": [[38, 48]]}}}, {"text": "Please refer to the official FXML reference for further details as there are some exceptions to the above advice depending on the type of value you are trying to set and may require some additional code to get it working", "label": {"api": {"FXML reference": [[29, 42]]}}}, {"text": "Use deleteOnExit() on the created file to achieve that", "label": {"api": {"deleteOnExit()": [[4, 17]]}}}, {"text": "In such a situation the temporary files should be deleted by the application, as soon as they are not needed anymore (see delete() or Files helper class in JDK7)", "label": {"api": {"delete()": [[122, 129]], "Files helper class": [[134, 151]]}}}, {"text": "To ensure interoperability have a look at the new Path abstraction for file names in Java7", "label": {"api": {"Path": [[50, 53]]}}}, {"text": "More can be read on the buffered reader here", "label": {"api": {"buffered reader here": [[24, 43]]}}}, {"text": "Java Calendar is lenient by default", "label": {"api": {"Calendar": [[5, 12]]}}}, {"text": "You can use a Map instead, where the key will be employee name \"Peter\" and value will be the Employee object", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "A better approach would be to use some unique ID as key for the Map like an employeeID", "label": {"api": {"Map": [[64, 66]]}}}, {"text": "And use SimpleDateFormat with correct format string", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "You can try to force the JVM to call finalize() by calling System.runFinalization()", "label": {"api": {"System.runFinalization()": [[59, 82]]}}}, {"text": "Use the split() method from the String class, passing an appropriate regular expression as parameter", "label": {"api": {"split()": [[8, 14]]}}}, {"text": "If you need a modifiable list, pass it to ArrayList's copy constructor", "label": {"api": {"ArrayList's copy constructor": [[42, 69]]}}}, {"text": "You are getting an IllegalArgumentException because you are passing tfData.getText() (a string) as the constructor for data (which is a Date)", "label": {"api": {"Date": [[136, 139]]}}}, {"text": "The constructors for the class Date are", "label": {"api": {"Date": [[31, 34]]}}}, {"text": "Appariently the String returned from tfData.getText() is not in a valid format for the Date(String s) (deprecated) constructor", "label": {"api": {"Date": [[87, 90]]}}}, {"text": "EDIT Since the result of the computation is a( reference to a)n object, I suggest the use of an AtomicReference", "label": {"api": {"AtomicReference": [[96, 110]]}}}, {"text": "My advice is to use a Timer", "label": {"api": {"Timer": [[22, 26]]}}}, {"text": "So I wrote my own Decoder that implements Decoder.Binary<Date>", "label": {"api": {"Decoder.Binary<Date>": [[42, 61]]}}}, {"text": "Since Java 1.5 there are more abstract levels of synchronization and wait-notify mechanisms, so you could check java's concurrent library", "label": {"api": {"library": [[130, 136]]}}}, {"text": "You need a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[11, 24]]}}}, {"text": "See the java.util.regex package docs for more details", "label": {"api": {"java.util.regex package docs": [[8, 35]]}}}, {"text": "You should use BigDecimal class for pecision", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "Use BigDecimal.valueOf(value) to convert the double to BigDecimal", "label": {"api": {"BigDecimal": [[4, 13], [55, 64]], "BigDecimal.valueOf(value)": [[4, 28]]}}}, {"text": "Translates a double into a BigDecimal, using the double's canonical string representation provided by the Double.toString(double) method", "label": {"api": {"BigDecimal": [[27, 36]]}}}, {"text": "You have to use the JarFile class and get the Manifest using getManifest() method", "label": {"api": {"JarFile": [[20, 26]], "getManifest()": [[61, 73]]}}}, {"text": "However it is suggested that you use ArrayList instead", "label": {"api": {"ArrayList": [[37, 45]]}}}, {"text": "From the ActionEvent, you can get the action command", "label": {"api": {"ActionEvent": [[9, 19]], "action command": [[38, 51]]}}}, {"text": "So, just set an action command to each button to identify them", "label": {"api": {"action command": [[16, 29]], "set an action command": [[9, 29]]}}}, {"text": "Use the result of RemoteServer.getClientHost()", "label": {"api": {"RemoteServer.getClientHost()": [[18, 45]]}}}, {"text": "Instead of trying to make your custom queue work (I doubt that your plan with the boolean flag is possible), save the time and work and use one of the BlockingQueues or ConcurrentLinkedQueue provided in the JDK", "label": {"api": {"BlockingQueues": [[151, 164]], "ConcurrentLinkedQueue": [[169, 189]]}}}, {"text": "At the end you need to call close", "label": {"api": {"close": [[28, 32]]}}}, {"text": "Call getMetadata() on the ResultSest, then call getColumnType on the metadata object", "label": {"api": {"getColumnType": [[48, 60]]}}}, {"text": "The returned value is from java.sql.Types", "label": {"api": {"java.sql.Types": [[27, 40]]}}}, {"text": "You can use java.util.Random.nextGaussian() to produce these", "label": {"api": {"java.util.Random.nextGaussian()": [[12, 42]]}}}, {"text": "Throwable.getLocalizedMessage() might work, assuming that the library you're using provides localized exception messages", "label": {"api": {"Throwable.getLocalizedMessage()": [[0, 30]]}}}, {"text": "It is called an \"Adapter\" and is pretty frequent in the JDK (see MouseMotionListener and MouseMotionAdapter for example)", "label": {"api": {"MouseMotionListener": [[65, 83]], "MouseMotionAdapter": [[89, 106]]}}}, {"text": "While it is surely possible to do your way, it is much simpler and easier to use JSplitPane to achieve I think the comparable goal", "label": {"api": {"JSplitPane": [[81, 90]]}}}, {"text": "JSplitPane also has the setDividerLocation methods (one absolute, one proportional) if you need to resize the two components programmatically", "label": {"api": {"JSplitPane": [[0, 9]], "setDividerLocation": [[24, 41]]}}}, {"text": "For instance, if you rely upon File#listFiles() you may have your mock return a fixed list of Files, however, the order they are returned in is not  guaranteed - a fact you may only discover when you run your code on a different platform", "label": {"api": {"File#listFiles()": [[31, 46]]}}}, {"text": "You could use the Java Compiler API present since JDK6, to compile a the snippet of code into a class that implements Predicate and load it on the fly, but it won't be pretty", "label": {"api": {"Java Compiler API": [[18, 34]]}}}, {"text": "One option would be using FileLock to control to prevent more than one instance of your app/jvm to operate the same time", "label": {"api": {"FileLock": [[26, 33]]}}}, {"text": "here is a simple example showing how to work with FileLock", "label": {"api": {"FileLock": [[50, 57]]}}}, {"text": "The .intValue() method is defined in class Number, which Long extends", "label": {"api": {"Number": [[43, 48]]}}}, {"text": "This is especially useful if the method requires a lot of documentation, like for example the Properties.load() methods", "label": {"api": {"Properties.load()": [[94, 110]]}}}, {"text": "You can use the Calendar class in Java , use its set() method to add/subtract the required number of days from the Calendar.DATE field", "label": {"api": {"Calendar": [[16, 23], [115, 122]], "set()": [[49, 53]], "Calendar.DATE": [[115, 127]]}}}, {"text": "To subtract n days from today , Use c.get(Calendar.DATE)-n", "label": {"api": {"Calendar": [[42, 49]], "Calendar.DATE": [[42, 54]]}}}, {"text": "It would be easier if you passed the enum type as well - that would enable you to use the Enum#valueOf static method", "label": {"api": {"Enum#valueOf static method": [[90, 115]]}}}, {"text": "To change other font properties (and see limitations) refer to JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[63, 88]]}}}, {"text": "StringBuilder does have a constructor accepting a String as an argument, and does have a .charAt() method (which it it must implement since it implements CharSequence)", "label": {"api": {"StringBuilder": [[0, 12]], "constructor accepting a String as an argument": [[26, 70]], "a .charAt() method": [[87, 104]]}}}, {"text": "this is a mishap from the part of your IDE, which did not import the correct StringBuilder", "label": {"api": {"StringBuilder": [[77, 89]]}}}, {"text": "You can achieve this using setBorderPainted() and setContentAreaFilled() methods", "label": {"api": {"setBorderPainted()": [[27, 44]], "setContentAreaFilled()": [[50, 71]]}}}, {"text": "I have read the javadoc of this class again and again, but still cannot figure out the difference", "label": {"api": {"the javadoc of this class": [[12, 36]]}}}, {"text": "Apart from the obvious difference that .propertyNames() returns an Enumeration and .stringPropertyNames() returns a Set, as far as I can see, both methods return the same content", "label": {"api": {".propertyNames()": [[39, 54]], ".stringPropertyNames()": [[83, 104]]}}}, {"text": "Take a look at File.listFiles(FileFilter filter), this returns only the files that conform to the specified filter", "label": {"api": {"File.listFiles(FileFilter filter)": [[15, 47]]}}}, {"text": "To append to the file , use the constructor File(filename,append)", "label": {"api": {"File(filename,append)": [[44, 64]]}}}, {"text": "Again, most likely, java.util.Random nextInt(8) will be good enough for you", "label": {"api": {"java.util.Random nextInt(8)": [[20, 46]]}}}, {"text": "Java provides SecureRandom which is more appropriate for cryptographic-strength random number generation", "label": {"api": {"SecureRandom": [[14, 25]]}}}, {"text": "To use this to generate a number between 0 and N, you can use the same algorithm presented in the Random.nextInt(int) documentation but with SecureRandom instead", "label": {"api": {"SecureRandom": [[141, 152]], "Random.nextInt(int) documentation": [[98, 130]]}}}, {"text": "By default, JDK parsers are not namespace aware", "label": {"api": {"By default": [[0, 9]]}}}, {"text": "Because Collection.contains(Object) has Object as its parameter", "label": {"api": {"Collection.contains(Object)": [[8, 34]]}}}, {"text": "Read everything as bytes from the buffered input stream, and convert string sections into String's using constructor that accepts the byte array", "label": {"api": {"constructor that accepts the byte array": [[105, 143]]}}}, {"text": "Depending on how the data are actually encoded, you may need to use \"UTF-8\" or something else as the name of the charset", "label": {"api": {"charset": [[113, 119]]}}}, {"text": "You can not compare String with the operators <, >, instead you need to use compareTo", "label": {"api": {"compareTo": [[76, 84]]}}}, {"text": "See also the ScriptEngine", "label": {"api": {"ScriptEngine": [[13, 24]]}}}, {"text": "Try passing false as the parameter to the getSession(boolean)", "label": {"api": {"getSession(boolean)": [[42, 60]]}}}, {"text": "You need to use Iterator", "label": {"api": {"Iterator": [[16, 23]]}}}, {"text": "Take a look at Executors", "label": {"api": {"Executors": [[15, 23]]}}}, {"text": "java.lang.Object class is superclass of all classes", "label": {"api": {"java.lang.Object": [[0, 15]]}}}, {"text": "Class Object is the root of the class hierarchy", "label": {"api": {"Object": [[6, 11]]}}}, {"text": "Every class has Object as a superclass", "label": {"api": {"Object": [[16, 21]]}}}, {"text": "Easiest way is to insert a call to robot.delay() before robot.createScreenCapture()", "label": {"api": {"robot.delay()": [[35, 47]], "robot.createScreenCapture()": [[56, 82]]}}}, {"text": "See java doc at http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html": [[16, 82]]}}}, {"text": "Just construct a JOptionPane dialog", "label": {"api": {"JOptionPane": [[17, 27]]}}}, {"text": "Use the class BigDecimal", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "To create a BigDecimal from a literal which is too precise to be represented by a double, use the string constructor", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "Therefor the BigDecimal class has various methods to perform basic arithmetics while retaining precision", "label": {"api": {"BigDecimal": [[13, 22]]}}}, {"text": "When your code is performance-critical, I recommend the question \"What to do with Java BigDecimal performance?\" as further reading", "label": {"api": {"BigDecimal": [[87, 96]]}}}, {"text": "The best bet here is Map.Cause List doesn't carry the key value pairs", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "Using Map only you can  get the value by key when ever you need..other wise(list) you need to bare more lines of code", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "No, it's correct - it's a method with a return type of java.lang.Void", "label": {"api": {"java.lang.Void": [[55, 68]]}}}, {"text": "One way of doing that would be to use Java 6/7's FutureTask class", "label": {"api": {"FutureTask": [[49, 58]]}}}, {"text": "Use a Single Thread Executor and then enqueue the long running task into it", "label": {"api": {"Single Thread Executor": [[6, 27]]}}}, {"text": "If you're looking for just the property overrides and JVM arguments, you can use RuntimeMXBean", "label": {"api": {"RuntimeMXBean": [[81, 93]]}}}, {"text": "What you want to do is update your display with a call to SwingUtilities.invokeLater (link)", "label": {"api": {"link": [[86, 89]]}}}, {"text": "I think you just need to escape your input before using it", "label": {"api": {"escape": [[25, 30]]}}}, {"text": "Pattern.quote(String) to avoid unexpected errors like this as user input may contain special regex symbols", "label": {"api": {"Pattern.quote(String)": [[0, 20]]}}}, {"text": "It also uses System.identityHashCode, which has a chance of collisions that is known upfront to the designers of IdentityHashMap, and is known to be very small", "label": {"api": {"System.identityHashCode": [[13, 35]]}}}, {"text": "Hash values in Java are provided by objects through the implementation of public int hashCode() which is declared in Object class and it is implemented for all the basic data types", "label": {"api": {"public int hashCode()": [[74, 94]]}}}, {"text": "implementing that method requires also to have public boolean equals(Object o) implemented in a consistent manner", "label": {"api": {"public boolean equals(Object o)": [[47, 77]]}}}, {"text": "the .equals()/.hashCode() contract", "label": {"api": {"the .equals()/.hashCode() contract": [[0, 33]]}}}, {"text": "the Set contract stipulates that a Set should not contain duplicate elements; however, the strategy of a Set implementation is left..", "label": {"api": {"Set": [[4, 6], [35, 37], [105, 107]]}}}, {"text": "You will notice, if you look at the javadoc of Map, that its keys can be retrieved by a method called .keySet()", "label": {"api": {"Set": [[106, 108]]}}}, {"text": "Therefore, Map and Set are very closely related in this regard", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "If we take the case of a HashSet (and, ultimately, HashMap), it relies on .equals() and .hashCode()", "label": {"api": {"Set": [[29, 31]], "HashSet": [[25, 31]]}}}, {"text": "In contrast, a TreeSet (and TreeMap) relies on the natural ordering of elements (see Comparable)", "label": {"api": {"Set": [[19, 21]], "TreeSet": [[15, 21]], "Comparable": [[85, 94]]}}}, {"text": "Note that, internally, a HashSet is a HashMap..", "label": {"api": {"Set": [[29, 31]], "HashSet": [[25, 31]]}}}, {"text": "They could be, but it's typically very difficult to maintain the symmetric and transitive properties of equality in that case", "label": {"api": {"the symmetric and transitive properties of equality": [[61, 111]]}}}, {"text": "when you override .equals(), you absolutely MUST override .hashCode() as well, and obey the defined contract", "label": {"api": {"defined contract": [[92, 107]]}}}, {"text": "What about the Modifier.toString() method", "label": {"api": {"Modifier.toString()": [[15, 33]]}}}, {"text": "In java API javax.swing.SwingUtilities is the interface which contains only constants but no method declaration", "label": {"api": {"javax.swing.SwingUtilities": [[12, 37]]}}}, {"text": "the toArray method that takes no arguments returns an Object[] which can't be cast to a String[]", "label": {"api": {"toArray method that takes no arguments": [[4, 41]]}}}, {"text": "The other version returns a typed array", "label": {"api": {"other version": [[4, 16]]}}}, {"text": "You can use the constructor for Random that doesn't take a parameter", "label": {"api": {"Random": [[32, 37]]}}}, {"text": "Generally you would only seed Random yourself when you want a repeatable sequence of random data (they are determinstic)", "label": {"api": {"Random": [[30, 35]]}}}, {"text": "Random numbers in Java are pseudo-random", "label": {"api": {"Random": [[0, 5]]}}}, {"text": "You should have a look at the java.net.URL class and its getPath() and getQuery() methods", "label": {"api": {"java.net.URL": [[30, 41]]}}}, {"text": "On your @DiscriminatorColumn annotation, you need to specify the discriminatorType", "label": {"api": {"discriminatorType": [[65, 81]]}}}, {"text": "Use JPanel with GridLayout as the cell renderer", "label": {"api": {"GridLayout": [[16, 25]]}}}, {"text": "Derive from AbstractCellEditor, overriding getCellEditorValue (return the value composed from the panel) and getTableCellEditorComponent (return the panel itself after setting the fields to the current value)", "label": {"api": {"AbstractCellEditor": [[12, 29]]}}}, {"text": "clone() will not always return a deep-clone of an Object (especially for complex Object, whose fields reference other mutable Objects etc)", "label": {"api": {"clone()": [[0, 6]]}}}, {"text": "Primitive data-types and Strings are immutable, so there is no need for clone()ing when getting/setting fields of these types", "label": {"api": {"clone()": [[72, 78]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "You will probably want to use a Executors.newSingleThreadScheduledExecutor()", "label": {"api": {"Executors.newSingleThreadScheduledExecutor()": [[32, 75]]}}}, {"text": "The JDK has all it takes to do so, there is no reason not to use it", "label": {"api": {"all it takes to do so": [[12, 32]]}}}, {"text": "Instead of using synchronized, you might want to take a look at ReentrantLock, especially its methods getOwner() and isHeldByCurrentThread()", "label": {"api": {"ReentrantLock": [[64, 76]]}}}, {"text": "To test if the current thread holds the monitor, Thread.holdsLock exists", "label": {"api": {"Thread.holdsLock": [[49, 64]]}}}, {"text": "To test in general, which thread (or thread ID) holds the lock, it's possible to do this with java.lang.management classes (thanks @amicngh)", "label": {"api": {"java.lang.management": [[94, 113]]}}}, {"text": "But if you only want to test the current thread, Thread.holdsLock works great", "label": {"api": {"Thread.holdsLock": [[49, 64]]}}}, {"text": "Otherwise, implementations of java.util.concurrent.locks.Lock may provide more information and flexibility than ordinary Java monitors (thanks @user1252434)", "label": {"api": {"java.util.concurrent.locks.Lock": [[30, 60]]}}}, {"text": "Use a PreparedStatement and set the values using its setXXX() methods", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "You can use MouseInfo to get the mouse's location", "label": {"api": {"MouseInfo": [[12, 20]]}}}, {"text": "What I understood is you need to reverse the order , so multiply the result of compareTo() with -1", "label": {"api": {"compareTo()": [[79, 89]]}}}, {"text": "To sort based on dates , you have to  convert the String to Date in the Comparator which you are already doing using f.parse(firstString) and use Date's compareTo()", "label": {"api": {"compareTo()": [[153, 163]]}}}, {"text": "This is because Properties extends Hashtable<Object, Object> (which, in turn, implements Map<Object, Object>)", "label": {"api": {"Properties extends Hashtable<Object, Object>": [[16, 59]]}}}, {"text": "You either want to look at Java's Calendar or JodaTime, given you're looking at rules over dates, I'd recommend Joda", "label": {"api": {"Java's Calendar": [[27, 41]]}}}, {"text": "You can use the getColumns method of the DatabaseMetaData class, to fetch the datatype of the column", "label": {"api": {"getColumns": [[16, 25]]}}}, {"text": "You can use String.split", "label": {"api": {"String.split": [[12, 23]]}}}, {"text": "I'm not quite sure what you are asking but I think what you are looking for is InputStreamReader (link) which is used to convert a stream of bytes into characters", "label": {"api": {"link": [[98, 101]]}}}, {"text": "If that is the case, use Object.getClass", "label": {"api": {"Object.getClass": [[25, 39]]}}}, {"text": "You could try converting the hashes into BigIntegers instead", "label": {"api": {"BigIntegers": [[41, 51]]}}}, {"text": "It uses a BlockingQueue to communicate between threads; the FileTask adds lines to the queue, and the CPUTask reads them and processes them", "label": {"api": {"BlockingQueue": [[10, 22]]}}}, {"text": "You are multiplying ints together, and overflow occurs because the maximum integer is 2^31 - 1", "label": {"api": {"the maximum integer is 2^31 - 1": [[63, 93]]}}}, {"text": "Instead of doing array() from the ShortBuffer, you could simply use a bulk get() into an existing array", "label": {"api": {"get()": [[75, 79]]}}}, {"text": "The try with resources syntax is for assigning objects that implement autocloseable such as streams and database connections so that they can be correctly cleaned up in the event of an exception", "label": {"api": {"autocloseable": [[70, 82]]}}}, {"text": "AutoCloseable http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html are closed before catching any of inner exception", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html": [[14, 82]]}}}, {"text": "You can use Pattern.quote(\"$money\")", "label": {"api": {"Pattern.quote(\"$money\")": [[12, 34]]}}}, {"text": "Beware, this has O(n) complexity â€“ having a ListIterator that points at the middle would make insertion O(1), so you might want to use that for performance", "label": {"api": {"ListIterator": [[44, 55]]}}}, {"text": "Some of the classes in Java API are final, for example java.lang.System", "label": {"api": {"java.lang.System": [[55, 70]]}}}, {"text": "String#toLowerCase is your answer to the problem", "label": {"api": {"String#toLowerCase": [[0, 17]]}}}, {"text": "You can use the iteratorâ€™s remove method to achieve this", "label": {"api": {"remove": [[27, 32]]}}}, {"text": "Finally, for more complex layouts you might want to check out GridBadLayout", "label": {"api": {"GridBadLayout": [[62, 74]]}}}, {"text": "Since icon is one of the properties listed, you can use your icon when you create the Action or in a call to putValue()", "label": {"api": {"properties": [[25, 34]]}}}, {"text": "You can use a Scanner", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "This is OK for learning purpose , but you should ideally override the no-arg init() in your Servlet lest you do something which makes the Servlet lifecycle go haywire", "label": {"api": {"init()": [[77, 82]]}}}, {"text": "You can use the ServerSocket(int port, int backlog, InetAddress address) constructor to create a server socket bound to a particular IP address (3rd parameter)", "label": {"api": {"ServerSocket(int port, int backlog, InetAddress address)": [[16, 71]]}}}, {"text": "Move this logic into a Filter that checks the authentication and redirects if needed", "label": {"api": {"Filter": [[23, 28]]}}}, {"text": "Your bean can implement the interface SessionSynchronization", "label": {"api": {"SessionSynchronization": [[38, 59]]}}}, {"text": "This question discusses differences between the two; it seems to be unreliable to use SessionSynchronization for SLSB", "label": {"api": {"SessionSynchronization": [[86, 107]]}}}, {"text": "Calendar.getTime returns a date and Date.getTime() returns a long", "label": {"api": {"Calendar.getTime": [[0, 15]], "Date.getTime()": [[36, 49]]}}}, {"text": "You're using ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[13, 30]]}}}, {"text": "You can read the data again with ObjectInputStream", "label": {"api": {"ObjectInputStream": [[33, 49]]}}}, {"text": "You can use ExecutorCompletionService - it allows you to get Futures in the order they are completed", "label": {"api": {"ExecutorCompletionService": [[12, 36]]}}}, {"text": "See URLClassLoader(URL[], ClassLoader)", "label": {"api": {"URLClassLoader(URL[], ClassLoader)": [[4, 37]]}}}, {"text": "Is anybody aware of any real life use of the class AtomicLongFieldUpdate", "label": {"api": {"AtomicLongFieldUpdate": [[51, 71]]}}}, {"text": "The equivalent of USE mydb is Connection.setCatalog(\"mydb\"), calling this method makes sure the driver is in a consistent state", "label": {"api": {"Connection.setCatalog(\"mydb\")": [[30, 58]]}}}, {"text": "Similarly, you shouldn't use SHOW TABLES to get information on tables, use DatabaseMetaData.getTables() instead", "label": {"api": {"DatabaseMetaData.getTables()": [[75, 102]]}}}, {"text": "If you are dealing with huge numbers , you can use the BigInteger class for integers and BigDecimal for numbers with decimal digits", "label": {"api": {"BigInteger": [[55, 64]], "BigDecimal": [[89, 98]]}}}, {"text": "Comparable and Comparator", "label": {"api": {"Comparable": [[0, 9]], "Comparator": [[15, 24]]}}}, {"text": "Comparable is for comparaing this with another object while Comparator is used for comparing two other objects", "label": {"api": {"Comparable": [[0, 9]], "Comparator": [[60, 69]]}}}, {"text": "So request.getServerName() is the closest we got to you need", "label": {"api": {"request.getServerName()": [[3, 25]]}}}, {"text": "I'd recommend that you use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[29, 52]]}}}, {"text": "You can obtain one using, for instance, Executors.newScheduledThreadPool()", "label": {"api": {"Executors.newScheduledThreadPool()": [[40, 73]]}}}, {"text": "You might be able to eliminate the lock on lock_map by replacing your HashMap with a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[85, 101]]}}}, {"text": "Strings are interned when you call the intern() method", "label": {"api": {"intern()": [[39, 46]]}}}, {"text": "The intern() method interns a copy, which it returns", "label": {"api": {"intern()": [[4, 11]]}}}, {"text": "Although the docs are not immediately obvious (you have to click links until you get to ReadableByteChannel.read()), reads into a buffer changes the buffer's position", "label": {"api": {"ReadableByteChannel.read()": [[88, 113]]}}}, {"text": "Java 7 onward we have JDK 7 Objects#equals()", "label": {"api": {"Objects#equals()": [[28, 43]]}}}, {"text": "Use the proper FileWriter constructor that takes a boolean on whether to append", "label": {"api": {"FileWriter constructor that takes a boolean on whether to append": [[15, 78]]}}}, {"text": "The inputMismatchException means that the Scanner (input) received something not of int which is expected from nextInt", "label": {"api": {"inputMismatchException": [[4, 25]]}}}, {"text": "The Scanner.next() method only reads a word", "label": {"api": {"Scanner.next()": [[4, 17]]}}}, {"text": "You should use Scanner.nextLine() method so that you can read the whole sentence", "label": {"api": {"Scanner.nextLine()": [[15, 32]]}}}, {"text": "String.toCharArray() method gives you a char[]", "label": {"api": {"String.toCharArray()": [[0, 19]]}}}, {"text": "Use split method", "label": {"api": {"split": [[4, 8]]}}}, {"text": "you may use the functions split() to achieve this", "label": {"api": {"split()": [[26, 32]]}}}, {"text": "Check the Timer javadoc that also redirects to the Java tutorial about Timers", "label": {"api": {"Timer javadoc": [[10, 22]]}}}, {"text": "The javadoc writes", "label": {"api": {"writes": [[12, 17]]}}}, {"text": "String#equals() checks the character equality of string, == checks memory reference", "label": {"api": {"String#equals()": [[0, 14]]}}}, {"text": "However, you can easily acquire the exact values at runtime using Container#getInsets()", "label": {"api": {"Container#getInsets()": [[66, 86]]}}}, {"text": "If it is even bigger than that, you have to use a BigInteger", "label": {"api": {"BigInteger": [[50, 59]]}}}, {"text": "BigInteger has .shiftLeft() and .shiftRight() methods (the equivalents of Java's << and >>> -- note the triple > -- on integer primitive types)", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "Note that these operations will return a new BigInteger", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "Such a method, destroy, was planned but not implemented", "label": {"api": {"was planned but not implemented": [[24, 54]]}}}, {"text": "You could use BlockingQueues", "label": {"api": {"BlockingQueues": [[14, 27]]}}}, {"text": "You can use the BigDecimal#add() method", "label": {"api": {"BigDecimal#add()": [[16, 31]]}}}, {"text": "A TreeMap<String, Integer> should work for your purposes; it implements the SortedMap<K, V> interface", "label": {"api": {"TreeMap<String, Integer>": [[2, 25]], "SortedMap<K, V>": [[76, 90]], "Map": [[6, 8], [82, 84]]}}}, {"text": "New code should generally prefer Map and HashMap for general-purpose key-value data structures", "label": {"api": {"Map": [[33, 35], [45, 47]], "HashMap": [[41, 47]]}}}, {"text": "In short, I need to replicate the functionality of this Maven plugin which generates the necessary files for a ServiceLoader-enabled service", "label": {"api": {"ServiceLoader": [[111, 123]]}}}, {"text": "Note that it uses little-endian encoding so you could first wrap the structure in a ByteBuffer setting the order to little-endian", "label": {"api": {"setting the order": [[95, 111]]}}}, {"text": "split for splitting the original input at the comma", "label": {"api": {"split": [[0, 4], [10, 14]]}}}, {"text": "parseInt for converting a String -> int", "label": {"api": {"parseInt": [[0, 7]]}}}, {"text": "The valueOf function of Integer is an option but then you have to convert String -> Integer -> int", "label": {"api": {"valueOf": [[4, 10]]}}}, {"text": "You should use trim to eliminate white-spaces", "label": {"api": {"trim": [[15, 18]]}}}, {"text": "Furthermore, you should catch the NumberFormatException thrown by parseInt", "label": {"api": {"parseInt": [[66, 73]], "NumberFormatException": [[34, 54]]}}}, {"text": "Look at some of the geometry types in java.awt package, like the x and y fields of Point", "label": {"api": {"Point": [[83, 87]]}}}, {"text": "Attribute ordering is not a feature of DOM Level 3 which the Java type implements", "label": {"api": {"the Java type implements": [[57, 80]]}}}, {"text": "You can use java.util.Arrays.binarySearch for that", "label": {"api": {"java.util.Arrays.binarySearch": [[12, 40]]}}}, {"text": "BTW, why don't you use String#equals", "label": {"api": {"String#equals": [[23, 35]]}}}, {"text": "I would take a look at the Document, specifically, the Document#insertString method", "label": {"api": {"Document": [[27, 34], [55, 62]], "Document#insertString": [[55, 75]]}}}, {"text": "Just use Thread#sleep", "label": {"api": {"Thread#sleep": [[9, 20]]}}}, {"text": "The Java documentation on Random says", "label": {"api": {"Random": [[26, 31]]}}}, {"text": "If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers", "label": {"api": {"Random": [[20, 25]]}}}, {"text": "In order to guarantee this property, particular algorithms are specified for the class Random", "label": {"api": {"Random": [[87, 92]]}}}, {"text": "Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code", "label": {"api": {"Random": [[74, 79]]}}}, {"text": "However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods", "label": {"api": {"Random": [[29, 34]]}}}, {"text": "SimpleDateFormat, in the Date and Time Patterns and Examples section", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "You may be looking for Class.isAssignableFrom(), which tells you whether one class is a superclass of another", "label": {"api": {"Class.isAssignableFrom()": [[23, 46]]}}}, {"text": "You need to use the appropriate FileWriter constructor with true as the second argument", "label": {"api": {"appropriate FileWriter constructor": [[20, 53]]}}}, {"text": "As this key varies my platform, the Toolkit class includes a getMenuShortcutKeyMask() that \"Determines which modifier key is the appropriate accelerator key for menu shortcuts.\" There's a complete example here", "label": {"api": {"Toolkit": [[36, 42]], "getMenuShortcutKeyMask()": [[61, 84]]}}}, {"text": "With a List, you can do List.remove(int index), which returns the element removed", "label": {"api": {"List.remove(int index)": [[24, 45]]}}}, {"text": "Java has the @Override annotation that you can put on methods so the compiler will tell you if your method does not in fact override", "label": {"api": {"@Override": [[13, 21]]}}}, {"text": "To do what you want, you should use Character.getNumericValue() method", "label": {"api": {"Character.getNumericValue()": [[36, 62]]}}}, {"text": "In Java there is java.util.timer along with java.util.timertask", "label": {"api": {"java.util.timer": [[17, 31], [44, 58]], "java.util.timertask": [[44, 62]]}}}, {"text": "From the API docs", "label": {"api": {"API docs": [[9, 16]]}}}, {"text": "Seems best suited to a CardLayout with a single control to select between cards (e.g", "label": {"api": {"CardLayout": [[23, 32]]}}}, {"text": "All annotations of the package have a corresponding List annotation", "label": {"api": {"All annotations of the package": [[0, 29]]}}}, {"text": "This is because the Queue interface requires implementing classes to have a function remove and the Deque interface requires implementing classes to have a removeFirst function, and the ArrayDeque implements a Deque (Double ended queue), which is an entended version of the Queue interface", "label": {"api": {"Queue interface": [[20, 34], [274, 288]], "Deque interface": [[100, 114]]}}}, {"text": "You can use UUID", "label": {"api": {"UUID": [[12, 15]]}}}, {"text": "Since UUID is 128 bit number, you will have to convert it to BigInteger", "label": {"api": {"UUID": [[6, 9]]}}}, {"text": "If you need to pre-check if the object has not already been locked by some other thread, this should be possible with Thread.holdsLock method", "label": {"api": {"Thread.holdsLock": [[118, 133]]}}}, {"text": "If this is not enough, look into the advanced lock classes", "label": {"api": {"advanced lock classes": [[37, 57]]}}}, {"text": "I know both the IdentityHashSet (via Collections#newSetFromMap(Map))and the LinkedHashSet", "label": {"api": {"IdentityHashSet": [[16, 30]], "Collections#newSetFromMap(Map)": [[37, 66]], "LinkedHashSet": [[76, 88]]}}}, {"text": "However, what I need is a combination of the two, a LinkedIdentityHashSet", "label": {"api": {"IdentityHashSet": [[58, 72]]}}}, {"text": "HashSet and HashMap rely on the contract for equals() and hashCode described in the javadoc for java.lang.Object", "label": {"api": {"java.lang.Object": [[96, 111]]}}}, {"text": "Don't use parseInt when you want a byte; instead try Byte.parseByte", "label": {"api": {"Byte.parseByte": [[53, 66]]}}}, {"text": "You should use a DecimalFormat which specifies the appropriate number of decimal places", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "You might want to look into the DecimalFormat class, it can be used to format a doubles like this", "label": {"api": {"DecimalFormat": [[32, 44]]}}}, {"text": "The println method of PrintStream (of which out is an instance) takes a single argument", "label": {"api": {"println": [[4, 10]]}}}, {"text": "Perhaps you were you thinking of printf instead", "label": {"api": {"printf": [[33, 38]]}}}, {"text": "There is already an implementation of BST in java - TreeMap", "label": {"api": {"TreeMap": [[52, 58]]}}}, {"text": "The BST can be anything - in my code example I used Java's TreeMap class", "label": {"api": {"TreeMap": [[59, 65]]}}}, {"text": "From the Cipher docs it says to go to the reference guide here, but it still isn't clear to me", "label": {"api": {"Cipher docs": [[9, 19]]}}}, {"text": "Just construct a new ArrayList wrapping the keyset of the request parameter map", "label": {"api": {"construct": [[5, 13]], "request parameter map": [[58, 78]]}}}, {"text": "See the Javadoc of @Inject and the Spring reference on @Inject support", "label": {"api": {"Javadoc of @Inject": [[8, 25]]}}}, {"text": "If this does yield the same result for two files which compared different before, then metadata is in fact the source of your problem, and you can either use some command line approach like this, or update your code to read the image and compute the hash from the raw uncompressed data", "label": {"api": {"read the image": [[219, 232]]}}}, {"text": "Have you considered a HashTable", "label": {"api": {"HashTable": [[22, 30]]}}}, {"text": "Have a look at Arrays.toString", "label": {"api": {"Arrays.toString": [[15, 29]]}}}, {"text": "In your case, you will want to call Arrays.toString on each element of dps, printing / storing the results", "label": {"api": {"Arrays.toString": [[36, 50]]}}}, {"text": "According to that, you can use the Process Builder , which is used to create operating system processes", "label": {"api": {"Process Builder": [[35, 49]]}}}, {"text": "java.lang.ClassLoader is an object that is responsible for loading classes", "label": {"api": {"java.lang.ClassLoader": [[0, 20]]}}}, {"text": "Every Class object contains a reference to the ClassLoader that defined it and can fetch it with getClassLoader() method", "label": {"api": {"getClassLoader()": [[97, 112]]}}}, {"text": "ClassLoader's getResource method finds the resource with the given name", "label": {"api": {"getResource": [[14, 24]]}}}, {"text": "the GC is allowed to clear an object whenever there are no more strong references pointing to it", "label": {"api": {"strong references": [[64, 80]]}}}, {"text": "It might not clear the object right away, it might take some time, but unless you manage to acquire new strong references to it (yes, there are ways", "label": {"api": {"strong references": [[104, 120]]}}}, {"text": "see SoftReference and WeakReference for example), it will eventually be cleared, and certainly before it throws an OutOfMemoryError", "label": {"api": {"SoftReference": [[4, 16]], "WeakReference": [[22, 34]], "OutOfMemoryError": [[115, 130]]}}}, {"text": "Take a look at the String.replace(char,char) docs and you will see that it replaces EVERY instance of the oldChar with the newChar", "label": {"api": {"String.replace(char,char)": [[19, 43]]}}}, {"text": "To get a char[] from a String, simply call the String.toCharArray() method on the secret word", "label": {"api": {"String.toCharArray()": [[47, 66]]}}}, {"text": "It means that it the compiler cannot resolve createTempFile to a type so it cannot instantiate File#createTempFile as it is a static method", "label": {"api": {"File#createTempFile": [[95, 113]]}}}, {"text": "If you don't need to have a title placing a border around things is even easier - just set the the css border parameters on a region (e.g", "label": {"api": {"css border parameters on a region": [[99, 131]]}}}, {"text": "map.get(key) will retrieve either the value at this key location, or null if it doesn't exist", "label": {"api": {"map.get(key)": [[0, 11]]}}}, {"text": "One solution, using a Map and an enum for months", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "IOException is a checked exception", "label": {"api": {"IOException": [[0, 10]]}}}, {"text": "Its simple :) and SimpleDateFormat can help you out", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "The packages java.util.concurrent, java.util.concurrent.atomic and java.util.concurrent.locks provide all kinds of high-level tools for synchronizing and working in a concurrent environment", "label": {"api": {"java.util.concurrent": [[13, 32], [35, 54], [67, 86]], "java.util.concurrent.atomic": [[35, 61]], "java.util.concurrent.locks": [[67, 92]]}}}, {"text": "Well, use getDeclaredField(name) of a class, and if its not there, try looking at its super class and so on", "label": {"api": {"getDeclaredField(name)": [[10, 31]]}}}, {"text": "What does the word alive refer to in Oracles documentation", "label": {"api": {"alive": [[19, 23]]}}}, {"text": "You can also check the Thread.getState() and interesting information about Thread States suggested by @Marou Maroun", "label": {"api": {"Thread.getState()": [[23, 39]]}}}, {"text": "In case you want to have proper control on when it will be invoked, use the ScheduledExecutorService, specifically the schedule() method which gives you more precise execution schedule", "label": {"api": {"ScheduledExecutorService": [[76, 99]], "schedule()": [[119, 128]]}}}, {"text": "This is a simplified example; you may also want to read more about ProcessBuilder", "label": {"api": {"ProcessBuilder": [[67, 80]]}}}, {"text": "Use String.split() method", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "String#replaceAll() method will create a new string", "label": {"api": {"String#replaceAll()": [[0, 18]]}}}, {"text": "Simply use String#replace() method", "label": {"api": {"String#replace()": [[11, 26]]}}}, {"text": "I suggest you construct a Set from arrayA and then call removeAll on it using the second array", "label": {"api": {"Set": [[26, 28]]}}}, {"text": "See the javadoc for Object#equals(Object) and this StackOverflow  question for more discussison and reasoning", "label": {"api": {"javadoc for Object#equals(Object)": [[8, 40]]}}}, {"text": "To get want you want, write your Comparator<String> and compare the Strings base on the prefix, then use the TreeMap(Comparator) constructor to construct the map", "label": {"api": {"Comparator<String>": [[33, 50]], "TreeMap(Comparator)": [[109, 127]]}}}, {"text": "Set is what you are looking for", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "The most common is the HashSet (fast contains() operation but the order is not guaranteed), TreeSet (this is actually implementation of SortedSet, the instances stored in TreeSet should implement Comparable) and the last commonly used is the LinkedHashSet", "label": {"api": {"Set": [[27, 29], [96, 98], [142, 144], [175, 177], [252, 254]], "TreeSet": [[92, 98], [171, 177]], "SortedSet": [[136, 144]], "LinkedHashSet": [[242, 254]]}}}, {"text": "The order of LinkedHashSet is derived from the time elements were added into the container", "label": {"api": {"Set": [[23, 25]], "LinkedHashSet": [[13, 25]]}}}, {"text": "You're looking for a Set<String>, more specifically a TreeSet<String>", "label": {"api": {"Set<String>": [[21, 31], [58, 68]], "TreeSet<String>": [[54, 68]]}}}, {"text": "You can use Set and the equivalent to what you propose is TreeSet", "label": {"api": {"Set": [[12, 14], [62, 64]], "TreeSet": [[58, 64]]}}}, {"text": "However I think HashSet will do better job for the task you describe", "label": {"api": {"Set": [[20, 22]], "HashSet": [[16, 22]]}}}, {"text": "ClassFileTransformer seems to be my best bet but it still does not do what i want to do", "label": {"api": {"ClassFileTransformer": [[0, 19]]}}}, {"text": "For Object comparison use Object#equals() method", "label": {"api": {"Object#equals()": [[26, 40]]}}}, {"text": "Comparing with \"C\" will save you from NPE", "label": {"api": {"NPE": [[38, 40]]}}}, {"text": "Another point you might need, use BigDecimal instead of double while calculation", "label": {"api": {"BigDecimal": [[34, 43]]}}}, {"text": "I browsed the Text javadoc and css reference without results", "label": {"api": {"Text javadoc": [[14, 25]], "css reference": [[31, 43]]}}}, {"text": "It is possible to do this effect by displaying and svg in a WebView", "label": {"api": {"WebView": [[60, 66]]}}}, {"text": "The WebView is a too heavy component for drawing a text with this effect", "label": {"api": {"WebView": [[4, 10]]}}}, {"text": "BufferedReader will, as you have speculated, read the contents of the stream into memory", "label": {"api": {"BufferedReader": [[0, 13]]}}}, {"text": "I had some trouble finding a credible reference but I have seen several mentions of the default buffer size on BufferedReader being 8192 bytes (8kb)", "label": {"api": {"BufferedReader": [[111, 124]]}}}, {"text": "If you think you need to reserve a larger buffer than this, the BufferedReader constructor is overloaded with a second parameter allowing you to specify the size of the buffer in bytes", "label": {"api": {"BufferedReader": [[64, 77]]}}}, {"text": "will initialize your BufferedReader with a buffer of size bytes", "label": {"api": {"BufferedReader": [[21, 34]]}}}, {"text": "By calling the toByteArray method (see ByteArrayOutputStream#toByteArray) of your byte array stream, you may then get the pretended result, which is the whole contents of the file with the appropriate array size", "label": {"api": {"ByteArrayOutputStream#toByteArray": [[39, 71]]}}}, {"text": "And quoting from InputStream#read", "label": {"api": {"InputStream#read": [[17, 32]]}}}, {"text": "Well, unless you're willing to create a temporary subList just for using an enhanced for loop, which is fine, because sublists are views of the original list and don't create a new list object", "label": {"api": {"subList": [[50, 56]]}}}, {"text": "You could iterate through the sublist, as below", "label": {"api": {"sublist": [[30, 36]]}}}, {"text": "Take a look at the java.awt.dnd Drag & Drop package to start", "label": {"api": {"java.awt.dnd": [[19, 30]]}}}, {"text": "You can add a LineListener to the clip and re-enable the button when the LineEvent.Type Stop fires", "label": {"api": {"LineListener": [[14, 25]], "LineEvent.Type Stop": [[73, 91]]}}}, {"text": "You're getting a NullPointerException thrown from Double.parseDouble(String s) which happens if s is null", "label": {"api": {"happens": [[85, 91]]}}}, {"text": "SwingWorker is a common way to publish() interim results; examples are seen in the API and Concurrency in Swing", "label": {"api": {"API": [[83, 85]]}}}, {"text": "You can also use animation mechanism with Timeline", "label": {"api": {"Timeline": [[42, 49]]}}}, {"text": "Since the String in java is a final class which you cannot have a class extend from it, you need to use composition", "label": {"api": {"String": [[10, 15]]}}}, {"text": "You can test the first two yourself with contains", "label": {"api": {"contains": [[41, 48]]}}}, {"text": "Also be careful with interned Strings, the last test isNotConsideredIdenticalVariable needs a trick to stop compiler optimization (namely automatic interning)", "label": {"api": {"interned Strings": [[21, 36]]}}}, {"text": "Why not use two Lists tangled together", "label": {"api": {"Lists": [[16, 20]]}}}, {"text": "Also, consider using a Map with entries mapped to Lists", "label": {"api": {"Lists": [[50, 54]], "Map": [[23, 25]]}}}, {"text": "Use SimpleDateFormat.parse() to convert a String to a Date", "label": {"api": {"SimpleDateFormat.parse()": [[4, 27]]}}}, {"text": "Use SimpleDateFormat.format() to convert a Date to a String", "label": {"api": {"SimpleDateFormat.format()": [[4, 28]]}}}, {"text": "format() does not take String parameters", "label": {"api": {"format()": [[0, 7]]}}}, {"text": "When I try to send any action from ScheduledExecutorService using LocalBroadcastManager it seems that real action hasn't been sent(or hasn't been delivered)", "label": {"api": {"ScheduledExecutorService": [[35, 58]]}}}, {"text": "If I use Timer and TimerTask for the same purpose I used ScheduledExecutorService and ScheduledFuture - it works", "label": {"api": {"Timer": [[9, 13], [19, 23]], "TimerTask": [[19, 27]], "ScheduledExecutorService": [[57, 80]], "ScheduledFuture": [[86, 100]]}}}, {"text": "Keep it simple, split is enough", "label": {"api": {"split": [[16, 20]]}}}, {"text": "Use the other constructor for Scanner that specifies a character set", "label": {"api": {"other constructor": [[8, 24]]}}}, {"text": "Using other constructors results in the default character set being used which typically cannot correctly read unicode characters", "label": {"api": {"other constructor": [[6, 22]]}}}, {"text": "I have an third-party RPC-API that provides an interface similar to that of java.sql.ResultSet (for reading values) and java.sql.PreparedStatement (for writing values)", "label": {"api": {"java.sql.ResultSet": [[76, 93]], "java.sql.PreparedStatement": [[120, 145]]}}}, {"text": "You can create a string-array with String.split(\"de.test.class.mho.\")", "label": {"api": {"String.split(\"de.test.class.mho.\")": [[35, 68]]}}}, {"text": "Please consider using ArrayList instead of a raw array", "label": {"api": {"ArrayList": [[22, 30]]}}}, {"text": "Use URL.openStream to open the stream and Java NIO (New I/O) to read efficiently", "label": {"api": {"URL.openStream": [[4, 17]]}}}, {"text": "The @Value annotation type has the @Retention(value=RUNTIME) annotation, which means that the information is available at runtime (i.e", "label": {"api": {"@Retention(value=RUNTIME)": [[35, 59]]}}}, {"text": "Does Simple have an equivalent annotation type of javax.xml.bind.annotation.XmlAnyElement or XmlAnyAttribute", "label": {"api": {"javax.xml.bind.annotation.XmlAnyElement": [[50, 88]], "XmlAnyAttribute": [[93, 107]]}}}, {"text": "You can implement a Comparator and override its compare() as per your need", "label": {"api": {"Comparator": [[20, 29]], "compare()": [[48, 56]]}}}, {"text": "The logic inside the compare() need not use equals() or hashCode() at all", "label": {"api": {"compare()": [[21, 29]]}}}, {"text": "If you want to print trailing zeroes, but not all of them, you will need a DecimalFormat", "label": {"api": {"DecimalFormat": [[75, 87]]}}}, {"text": "You can use SortedSet", "label": {"api": {"SortedSet": [[12, 20]]}}}, {"text": "This can be done with the java.io.File class", "label": {"api": {"java.io.File": [[26, 37]]}}}, {"text": "Use the existing timeout methods, setConnectTimeout(int) and setReadTimeout(int)", "label": {"api": {"setConnectTimeout(int)": [[34, 55]], "setReadTimeout(int)": [[61, 79]]}}}, {"text": "Take a look at the group() method on Matcher, you can do something like this", "label": {"api": {"group()": [[19, 25]]}}}, {"text": "Also, take a look at Scanner, a utility class that makes reading input from the user easier", "label": {"api": {"Scanner": [[21, 27]]}}}, {"text": "You can use System.getProperty", "label": {"api": {"System.getProperty": [[12, 29]]}}}, {"text": "Loop over the Set<String> (which is Iterable) that is returned by the stringPropertyNames() method", "label": {"api": {"stringPropertyNames()": [[70, 90]]}}}, {"text": "When processing each property name, use getProperty to get the property value", "label": {"api": {"getProperty": [[40, 50]]}}}, {"text": "In the standard JRE, you make HTTP requests using a URLConnection", "label": {"api": {"URLConnection": [[52, 64]]}}}, {"text": "If you know you're making an HTTP request using URL#openConnection(), you can cast the result of that method to an http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html", "label": {"api": {"URLConnection": [[169, 181]], "URL#openConnection()": [[48, 67]]}}}, {"text": "That getRequestMethod() method that will give you the type of the HTTP request method", "label": {"api": {"getRequestMethod()": [[5, 22]]}}}, {"text": "The java.util.concurrent package contains various helpful classes around concurrency (for thread pools, producer/consumer queues etc) but really it's the language support in C# 5 that ties everything together..", "label": {"api": {"java.util.concurrent": [[4, 23]]}}}, {"text": "You can implement a Comparator, override its compare() method and use Arrays.sort()", "label": {"api": {"Comparator": [[20, 29]], "compare()": [[45, 53]], "Arrays.sort()": [[70, 82]]}}}, {"text": "In case you use a List<strVal> use Collections.sort()", "label": {"api": {"Collections.sort()": [[35, 52]]}}}, {"text": "If you think that the comparison of the class objects can be done only by its val property and that property defines the natural ordering of the objects then your class can implement Comparable", "label": {"api": {"Comparable": [[183, 192]]}}}, {"text": "You should use the sort method defined in the Arrays utility class", "label": {"api": {"Arrays utility class": [[46, 65]]}}}, {"text": "In order to sort according to your key you should either make your class implement Comparable or provide a Comparator", "label": {"api": {"Comparable": [[83, 92]], "Comparator": [[107, 116]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#nextBoolean() says that nextBoolean() takes no parameters, yet you are giving it one", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#nextBoolean()": [[0, 75]]}}}, {"text": "You can use SequenceInputSteam to assist in the deserialization of an object from multiple files", "label": {"api": {"SequenceInputSteam": [[12, 29]]}}}, {"text": "You can simply construct a new one", "label": {"api": {"construct": [[15, 23]]}}}, {"text": "According to the official javadoc, putAll \"will replace any mappings that this map had for any of the keys currently in the specified map.\", so you are now losing your previous objects contained in dataz", "label": {"api": {"official javadoc": [[17, 32]]}}}, {"text": "You can handle the case where the class it not in the classpath by catching the ClassNotFoundException", "label": {"api": {"ClassNotFoundException": [[80, 101]]}}}, {"text": "If you know (or set) the session timeout on the server, you can set a corresponding timer on the client, to go off 2mins prior to the actual session expiry", "label": {"api": {"the session timeout": [[21, 39]]}}}, {"text": "You can check that the locale is one of the available locales", "label": {"api": {"the available locales": [[40, 60]]}}}, {"text": "If you happen to use such a converter more than often for UISelectOne/UISelectMany components (<h:selectOneMenu> and friends), you may find OmniFaces SelectItemsConverter much more useful", "label": {"api": {"UISelectOne": [[58, 68]], "UISelectMany": [[70, 81]]}}}, {"text": "The data may repesent changes by firing PropertyChangeEvent's", "label": {"api": {"PropertyChangeEvent's": [[40, 60]]}}}, {"text": "a) From this example it looks like you can just get the webEngine from the WebView instance and load the URL", "label": {"api": {"WebView": [[75, 81]]}}}, {"text": "b) There seems to be history support built-in", "label": {"api": {"history support built-in": [[21, 44]]}}}, {"text": "For tabs, you'll likely need to have a TabPane (each tab with its one WebView component)", "label": {"api": {"TabPane": [[39, 45]], "WebView": [[70, 76]]}}}, {"text": "AppletPanel.runLoader() calls setStub()", "label": {"api": {"setStub()": [[30, 38]]}}}, {"text": "For List, Use the Collections.unmodifiableList() to return a List which is not modifiable outside (i.e., you can still modify the List inside your SomeClass)", "label": {"api": {"Collections.unmodifiableList()": [[18, 47]]}}}, {"text": "You could implement the Observer pattern", "label": {"api": {"Observer": [[24, 31]]}}}, {"text": "Observable and Observer", "label": {"api": {"Observable": [[0, 9]], "Observer": [[15, 22]]}}}, {"text": "Create one blocking queue for every threads and inject them into your Singleton", "label": {"api": {"blocking queue": [[11, 24]]}}}, {"text": "You can use an additional concurrent queue to feed the singleton without blocking it", "label": {"api": {"concurrent queue": [[26, 41]]}}}, {"text": "You can check http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html this for official documentation", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html": [[14, 80]]}}}, {"text": "The SimpleDateFormat javadoc page has all the date format symbols", "label": {"api": {"SimpleDateFormat javadoc page": [[4, 32]]}}}, {"text": "InternalError is tempting, but as an Error my understanding is that it should only be use to indicate problems in the JVM itself, not application logic errors", "label": {"api": {"InternalError": [[0, 12]]}}}, {"text": "Seems like you want to overrides the Object.equals method", "label": {"api": {"Object.equals": [[37, 49]]}}}, {"text": "If you want to override Object.equals, you must have exactly one argument whose type is an Object", "label": {"api": {"Object.equals": [[24, 36]]}}}, {"text": "So, it is not quite the same as Java's .compareTo() which does a lexicographical comparison by default, using Unicode code points, as you say", "label": {"api": {"Java's .compareTo()": [[32, 50]]}}}, {"text": "On the opposite, if you want to do locale-dependent string comparison in Java, you need to use a Collator", "label": {"api": {"Collator": [[97, 104]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "You could put all the keys and values in a SortedSet, for example a TreeSet, which has the first() and last() methods to retrieve the lowest / highest item", "label": {"api": {"a SortedSet": [[41, 51]]}}}, {"text": "For any object you should use Field#get(Object) method", "label": {"api": {"Field#get(Object)": [[30, 46]]}}}, {"text": "If a 3rd party library throws exceptions or converts them, you can attach UncaughtExceptionHandler to a thread", "label": {"api": {"UncaughtExceptionHandler": [[74, 97]]}}}, {"text": "With reference to Java Timer Class or ScheduledExecutorService interface ,Can I set a scheduler(or timer) inside run method (or TimerTask) of the executor thread(other scheduler)", "label": {"api": {"ScheduledExecutorService interface": [[38, 71]]}}}, {"text": "%s in place of {}) you can use String.format method for that", "label": {"api": {"String.format": [[31, 43]]}}}, {"text": "See String.format method", "label": {"api": {"String.format": [[4, 16]]}}}, {"text": "In Java there is the Executor interface for handling tasks", "label": {"api": {"Executor": [[21, 28]]}}}, {"text": "It does exactly what you want when using Executors.newSingleThreadExecutor()", "label": {"api": {"Executor": [[41, 48], [66, 73]], "Executors.newSingleThreadExecutor()": [[41, 75]]}}}, {"text": "Use String.length() to get the length of a String", "label": {"api": {"String.length()": [[4, 18]]}}}, {"text": "As the explanation of week year I guess that parsing the week year of 2013 (due to the wrong pattern 2013 -> YYYY ) is somehow setting the whole date to the first week year of the 2013, that is Monday 31/12/2012", "label": {"api": {"explanation of week year": [[7, 30]]}}}, {"text": "See Desktop.open(File) for details beyond", "label": {"api": {"Desktop.open(File)": [[4, 21]]}}}, {"text": "Have a look at the Pattern class to see the predefined character classes", "label": {"api": {"Pattern": [[19, 25]]}}}, {"text": "I would suggest you don't use String.replaceAll to start with", "label": {"api": {"String.replace": [[30, 43]]}}}, {"text": "Use String.replace instead", "label": {"api": {"String.replace": [[4, 17]]}}}, {"text": "Collections.sort does not work on Sets, only on Lists", "label": {"api": {"Collections.sort": [[0, 15]]}}}, {"text": "The Javadocs for read(byte[] b) state", "label": {"api": {"Javadocs for read(byte[] b)": [[4, 30]]}}}, {"text": "ImageIcon has a constructor that takes a URL", "label": {"api": {"constructor": [[16, 26]]}}}, {"text": "Look at the JarURLConnection class too", "label": {"api": {"JarURLConnection": [[12, 27]]}}}, {"text": "I think f is a Method rather than a Field", "label": {"api": {"Method": [[15, 20]]}}}, {"text": "If you are not sure initially about the array size use ArrayList Instead", "label": {"api": {"ArrayList": [[55, 63]]}}}, {"text": "You should use some type of List instead, such as an ArrayList", "label": {"api": {"List": [[28, 31], [58, 61]], "ArrayList": [[53, 61]]}}}, {"text": "One solution is to use Arrays.copyOf() which will take care of the copy for you", "label": {"api": {"Arrays.copyOf()": [[23, 37]]}}}, {"text": "next() reads a single word1, use nextLine() to read the entire line", "label": {"api": {"next()": [[0, 5]], "nextLine()": [[33, 42]]}}}, {"text": "1 Specifically, next() \"Finds and returns the next complete token from this scanner", "label": {"api": {"next()": [[16, 21]]}}}, {"text": "You can change this delimiter via useDelimiter", "label": {"api": {"useDelimiter": [[34, 45]]}}}, {"text": "You can use the Java Pattern class to match your input explicitly with the regex (in string format)", "label": {"api": {"Pattern": [[21, 27]]}}}, {"text": "In that case, String#indexOf() with String#substring() can be used for a simpler approach", "label": {"api": {"String#indexOf()": [[14, 29]], "String#substring()": [[36, 53]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "See BufferedReader for more info", "label": {"api": {"BufferedReader": [[4, 17]]}}}, {"text": "I just read through the API documentation of the java.util.concurrent package", "label": {"api": {"API documentation of the java.util.concurrent": [[24, 68]]}}}, {"text": "You can sort your pc_list using the Collections.sort utility method a custom Comparator", "label": {"api": {"Collections.sort": [[36, 51]], "Comparator": [[77, 86]]}}}, {"text": "Use String#equals like that", "label": {"api": {"String#equals": [[4, 16]]}}}, {"text": "I'd suggest a combination of a ScheduledExecutorService and a ForkJoinPool", "label": {"api": {"ScheduledExecutorService": [[31, 54]], "ForkJoinPool": [[62, 73]]}}}, {"text": "Looking at the SQLException javadocs, there seems to be an overlap between getCause and getNextException", "label": {"api": {"SQLException javadocs": [[15, 35]]}}}, {"text": "You could make the cast safer using the Class.cast method though", "label": {"api": {"Class.cast": [[40, 49]]}}}, {"text": "Here it is", "label": {"api": {"Here it is": [[0, 9]]}}}, {"text": "Although providing an implementation is indeed mandatory, it is OK to throw an exception to indicate that the method is not implemented", "label": {"api": {"throw an exception to indicate that the method is not implemented": [[70, 134]]}}}, {"text": "Create a Calendar object, instead of Date, and use add", "label": {"api": {"Calendar": [[9, 16]]}}}, {"text": "How to load external Facelets via a ResourceResolver is discussed here and here", "label": {"api": {"ResourceResolver": [[36, 51]]}}}, {"text": "I'd probably try to use an UncaughtExceptionHandler", "label": {"api": {"UncaughtExceptionHandler": [[27, 50]]}}}, {"text": "Note that, ServletContext.getRealPath() return the real OS path corresponding to the given virtual path", "label": {"api": {"ServletContext.getRealPath()": [[11, 38]]}}}, {"text": "Since HashSet overrides Object.equals1, you'll see the HashSet implementation of equals used when you invoke the virtual method on an object that has a runtime type of HashSet (remember dynamic dispatch depends on the runtime type of the receiving object, not the compile-time type)", "label": {"api": {"HashSet overrides Object.equals": [[6, 36]]}}}, {"text": "We know that HashSet overrides Object.equals because the documentation says that HashSet derives from AbstractSet and the documentation for AbstractSet.equals  says", "label": {"api": {"HashSet overrides Object.equals": [[13, 43]], "AbstractSet.equals ": [[140, 158]]}}}, {"text": "It's because split expects a regular expression, and | has a special meaning when used inside a regex", "label": {"api": {"split expects a regular expression": [[13, 46]]}}}, {"text": "Use SwingWorker to publish() your rows in the background and update the TableModel in your implementation of process()", "label": {"api": {"publish()": [[19, 27]]}}}, {"text": "Just place your image called Icon.png in the resources folder and call the above method with itself as parameter inside a class extending a class from the Window family such as JFrame or JDialog", "label": {"api": {"Window": [[155, 160]]}}}, {"text": "Using an email regex will be a better idea, use pattern Matcher with the following regex(you may correct regex in case any flaws found)", "label": {"api": {"Matcher": [[56, 62]]}}}, {"text": "I'm not a Java developer, but you should look at using Pattern.split", "label": {"api": {"Pattern.split": [[55, 67]]}}}, {"text": "When you call Method.invoke with this signature", "label": {"api": {"Method.invoke": [[14, 26]]}}}, {"text": "By component, a Java AWT Component is meant", "label": {"api": {"Java AWT Component": [[16, 33]]}}}, {"text": "Use Dimension.setSize(double,double) instead", "label": {"api": {"Dimension.setSize(double,double)": [[4, 35]]}}}, {"text": "You just need to enable Multiline mode of matching using (?m) embedded flag or Pattern.MULTILINE mode in your regex", "label": {"api": {"Pattern.MULTILINE": [[79, 95]]}}}, {"text": "If that is your exact code, then try actionPerformed instead of actionperformed (note the capital P in Performed)", "label": {"api": {"actionPerformed": [[37, 51]]}}}, {"text": "The compiler seems the be complaining, that you fail to provide an implementation of the method actionPerformed (declared in ActionListener, of which you create an instance by virtue of anonymous inner classes) due to this typo", "label": {"api": {"actionPerformed": [[96, 110]]}}}, {"text": "The SwingWorker Javadoc page has everything you need to start using it, including example code", "label": {"api": {"SwingWorker Javadoc page": [[4, 27]]}}}, {"text": "With Java 7, you could annotate the method with @SafeVarargs, which basically promises the compiler that generic arrays are okay (meaning it's no longer on the caller to suppress the warning)", "label": {"api": {"@SafeVarargs": [[48, 59]]}}}, {"text": "I normally use @PrePersist and @PreUpdate for stuff like this", "label": {"api": {"@PreUpdate": [[31, 40]]}}}, {"text": "It looks like Rule has a direct reference to Strategy so you can put the @PreUpdate method there", "label": {"api": {"@PreUpdate": [[73, 82]]}}}, {"text": "Alternatively, you can tell your relationship to cascade updates to Strategy and put the @PreUpdate in Strategy instead (this way you can still change modifiedDate if Strategy is updated independently)", "label": {"api": {"@PreUpdate": [[89, 98]], "cascade": [[49, 55]]}}}, {"text": "Note that, String#charAt method takes an index, and returns the character at that index", "label": {"api": {"String#charAt": [[11, 23]]}}}, {"text": "You need to use String#indexOf which gives the first index of the passed sequence, or character", "label": {"api": {"String#indexOf": [[16, 29]]}}}, {"text": "You can use JComponent#setForeground(Color) - But not on JTextArea", "label": {"api": {"JComponent#setForeground(Color)": [[12, 42]]}}}, {"text": "Instead, use a JEditorPane or JTextPane", "label": {"api": {"JEditorPane": [[15, 25]], "JTextPane": [[30, 38]]}}}, {"text": "You can change the background of the JTextArea using JTextArea#setBackground (If that what you mean)", "label": {"api": {"JTextArea#setBackground": [[53, 75]]}}}, {"text": "Obligatory regex solution using String.replaceAll", "label": {"api": {"String.replaceAll": [[32, 48]]}}}, {"text": "Why not use java.util.Calendar's methods get(int field) and set(int field, int value)", "label": {"api": {"java.util.Calendar": [[12, 29]], "get(int field)": [[41, 54]], "set(int field, int value)": [[60, 84]]}}}, {"text": "For starters, JDBC 4.0 drivers are auto-loaded using the ServiceLoader API", "label": {"api": {"ServiceLoader": [[57, 69]]}}}, {"text": "In that case, the JDBC driver JAR file has got to be placed in Tomcat's own /lib folder in order to properly utilize the JDBC driver auto-loading by the ServiceLoader mechanism", "label": {"api": {"ServiceLoader": [[153, 165]]}}}, {"text": "The writeUTF function writes the length of the string before its characters", "label": {"api": {"writeUTF": [[4, 11]]}}}, {"text": "You need Map#get(Object) method", "label": {"api": {"Map#get(Object)": [[9, 23]]}}}, {"text": "Object.wait() and Object.notify() (with their overloads / variants)", "label": {"api": {"Object.wait()": [[0, 12]], "Object.notify()": [[18, 32]]}}}, {"text": "You can also make use of the new Condition mechanism introduced in java.util.concurrent", "label": {"api": {"Condition": [[33, 41]]}}}, {"text": "A List will let use use Collections.shuffle(List) to simplify shuffling your cards", "label": {"api": {"Collections.shuffle(List)": [[24, 48]]}}}, {"text": "You can make use of the MenuListener which should provide you information about the state of the menu", "label": {"api": {"MenuListener": [[24, 35]]}}}, {"text": "You dont need to add 'transparent circles', just use the properties getX() and getY() of the MouseEvent to identify the position it was clicked in the image and then play the relative sound to it", "label": {"api": {"getX()": [[68, 73]], "getY()": [[79, 84]]}}}, {"text": "See the constructor JButton(Icon)", "label": {"api": {"JButton(Icon)": [[20, 32]]}}}, {"text": "You may use one of the implementation of ScheduledExecutorService if you are Ok to move logic which you want to execute repeatedly inside a thread", "label": {"api": {"ScheduledExecutorService": [[41, 64]]}}}, {"text": "No, You cann't set or freeze System.currentTimeMills()", "label": {"api": {"System.currentTimeMills()": [[29, 53]]}}}, {"text": "But if your requirement is something like that so in that case you can set time in variable and used when ever you want.but System.currentTimeMills() will always returns you the current time value in milliseconds", "label": {"api": {"System.currentTimeMills()": [[124, 148]]}}}, {"text": "Java recognises posix expressions (see javadoc), but the syntax is a little different", "label": {"api": {"see javadoc": [[35, 45]]}}}, {"text": "This is because Calendar.MONTH is 0-based (Calendar.JANUARY = 0, and so on)", "label": {"api": {"Calendar.MONTH is 0-based": [[16, 40]]}}}, {"text": "The output of the process can be found by using getInputStream on the returned Process from the exec call", "label": {"api": {"getInputStream": [[48, 61]]}}}, {"text": "Java regex reference", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "Java 8 introduces Map.merge(K, V, BiFunction), which makes this easy if not particularly concise", "label": {"api": {"Map.merge(K, V, BiFunction)": [[18, 44]]}}}, {"text": "I believe because it extends Rectangle2D which is used in Graphics2D, and it says", "label": {"api": {"Rectangle2D": [[29, 39]], "Graphics2D": [[58, 67]]}}}, {"text": "If you read the Javadoc for Rectangle#getX()", "label": {"api": {"Rectangle#getX()": [[28, 43]]}}}, {"text": "public abstract double getX() in class RectangularShape", "label": {"api": {"public abstract double getX()": [[0, 28]]}}}, {"text": "Use Field#get(Object obj) to get the value", "label": {"api": {"Field#get(Object obj)": [[4, 24]]}}}, {"text": "I recommend that you switch to a cache, or barring that, that you switch to a ConcurrentMap with SoftReferences - the GC is eager about collecting weak references and so they're not really appropriate for a cache, whereas it delays the collection of soft references while still not allowing them to cause an OutOfMemoryError", "label": {"api": {"SoftReferences": [[97, 110]]}}}, {"text": "beep issues a request to the underlying operating system to emit an audio beep", "label": {"api": {"beep": [[0, 3], [74, 77]]}}}, {"text": "Check the API of PropertyValueFactory and the tutorial of Table View to go deep on this", "label": {"api": {"API of PropertyValueFactory": [[10, 36]]}}}, {"text": "You're modifying the existing List", "label": {"api": {"List": [[30, 33]]}}}, {"text": "List allows duplication, it won't prevent you to add Objects with the same value twice", "label": {"api": {"List": [[0, 3]]}}}, {"text": "Set doesn't allow duplication", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "Using javax, you could extract the data via xpath queries with something like this", "label": {"api": {"javax": [[6, 10]]}}}, {"text": "In Java 7 there's Files#getOwner, otherwise the only way is, as vRallev said, with a Process", "label": {"api": {"Files#getOwner": [[18, 31]]}}}, {"text": "I believe a CountDownLatch will do what you want", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "The nextInt() call will leave the input in the buffer if it does not match the int pattern", "label": {"api": {"nextInt()": [[4, 12]]}}}, {"text": "Compare String using equals() method", "label": {"api": {"equals()": [[21, 28]]}}}, {"text": "You can find all of the classes that implement Queue by looking on its javadoc page", "label": {"api": {"Queue": [[47, 51]]}}}, {"text": "Of those classes, only ArrayBlockingQueue, LinkedBlockingDeque, and LinkedBlockingQueue can be bounded, but all three are in java.util.concurrent", "label": {"api": {"Queue": [[36, 40], [82, 86]], "ArrayBlockingQueue": [[23, 40]], "LinkedBlockingDeque": [[43, 61]], "LinkedBlockingQueue": [[68, 86]]}}}, {"text": "You will have to implement your own method of keeping the number of elements in your Queue below a maximum", "label": {"api": {"Queue": [[85, 89]]}}}, {"text": "Try javax.swing.BorderFactory.createMatteBorder() on the enclosing panel; use a non-zero value for the right side", "label": {"api": {"javax.swing.BorderFactory.createMatteBorder()": [[4, 48]]}}}, {"text": "You should not catch ConcurrentModificationException", "label": {"api": {"You should not catch ConcurrentModificationException": [[0, 51]]}}}, {"text": "You can use String#toCharArray() method", "label": {"api": {"String#toCharArray()": [[12, 31]]}}}, {"text": "Have you tried the toCharArray() method from the String class", "label": {"api": {"toCharArray()": [[19, 31]]}}}, {"text": "As the class DatabaseConnection doesn't override the default implementation of toString() (by Object class), you see the class name with its hashcode", "label": {"api": {"Object class": [[94, 105]]}}}, {"text": "month is 0 based, so what you get is alright", "label": {"api": {"month": [[0, 4]]}}}, {"text": "private String first_name; is not an EJB, but you are marking it with the @EJB annotation", "label": {"api": {"@EJB": [[74, 77]]}}}, {"text": "a method of ArrayList", "label": {"api": {"method ": [[2, 8]]}}}, {"text": "Here is how the method works", "label": {"api": {"method ": [[16, 22]]}}}, {"text": "An ArithmeticException is a RuntimeException", "label": {"api": {"ArithmeticException": [[3, 21]]}}}, {"text": "You spelled the method wrong Connection#prepareStatement(String sql) throws SQLException", "label": {"api": {"Connection#prepareStatement(String sql) throws SQLException": [[29, 87]]}}}, {"text": "Use the next method on the ResultSet, which will return false on the first call if there are no rows", "label": {"api": {"next": [[8, 11]]}}}, {"text": "HttpURLConnection's javadoc says", "label": {"api": {"HttpURLConnection": [[0, 16]]}}}, {"text": "Each HttpURLConnection instance is used to make a single request but the underlying network connection to the HTTP server may be transparently shared by other instances", "label": {"api": {"HttpURLConnection": [[5, 21]]}}}, {"text": "You need to write your own Comparator to achieve this", "label": {"api": {"Comparator": [[27, 36]]}}}, {"text": "Study this article about Java Object Sorting Example (Comparable And Comparator)", "label": {"api": {"Comparator": [[69, 78]]}}}, {"text": "You can use Java UUID to generate a unique requestId", "label": {"api": {"Java UUID": [[12, 20]]}}}, {"text": "AtomicBoolean, in fact, all of the atomic classes, use compare-and-swap to guarantee atomicitiy", "label": {"api": {"AtomicBoolean": [[0, 12]], "atomic classes": [[35, 48]]}}}, {"text": "Use CountDownLatch, I'll copy here their usage example for better syntax highlighting (", "label": {"api": {"CountDownLatch": [[4, 17]]}}}, {"text": "Just use  Arrays#sort() after you added whatever value to the array", "label": {"api": {"Arrays#sort()": [[10, 22]]}}}, {"text": "have you read the documentation of the wait-notify functions", "label": {"api": {"wait": [[39, 42]], "notify": [[44, 49]]}}}, {"text": "anyway, for the best way to achieve a wait-notify mechanism, use something like this (based on this website)", "label": {"api": {"wait": [[38, 41]], "notify": [[43, 48]]}}}, {"text": "You can use the cancel() method from your ScheduledFuture object", "label": {"api": {"cancel()": [[16, 23]], "ScheduledFuture": [[42, 56]]}}}, {"text": "If you want your currently running task to stop, you need to code your run method so it is sensitive to interrupts and pass true to the cancel() method to request an interrupt", "label": {"api": {"cancel()": [[136, 143]]}}}, {"text": "If a number can be of virtually any length, use BigInteger", "label": {"api": {"BigInteger": [[48, 57]]}}}, {"text": "BigInteger provides a divide method", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "Whichever approach you use, you may also want to consider the java.util.concurrent.ConcurrentHashMap implementation as the concrete type for the mapOfConstants variable since this will avoid headaches later", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[62, 99]]}}}, {"text": "Logarithmic growth may be aided by the use of a java.util.WeakHashMap or, failing that, the judicious use of weak references", "label": {"api": {"java.util.WeakHashMap": [[48, 68]], "weak references": [[109, 123]]}}}, {"text": "You can use Thread.getState() and use the corresponding states", "label": {"api": {"Thread.getState()": [[12, 28]], "states": [[56, 61]]}}}, {"text": "You can check it with isAlive.", "label": {"api": {"isAlive": [[22, 28]]}}}, {"text": "isAlive tests if this thread is alive", "label": {"api": {"isAlive": [[0, 6]]}}}, {"text": "Thread.isAlive() can determine if a thread is running", "label": {"api": {"Thread.isAlive()": [[0, 15]]}}}, {"text": "Thread#getState(); can return the exact state of a thread", "label": {"api": {"Thread#getState()": [[0, 16]]}}}, {"text": "JTable is not a spreadsheet, but setCellSelectionEnabled() should allow you to proceed", "label": {"api": {"setCellSelectionEnabled()": [[33, 57]]}}}, {"text": "Process documentation offers getErrorStream() and getOutputStream() methods", "label": {"api": {"Process": [[0, 6]]}}}, {"text": "Not exactly what you asked for, but File.createTempFile might do the trick", "label": {"api": {"File.createTempFile": [[36, 54]]}}}, {"text": "You can implement the finalize method to call close; this way you can be sure that the resource is closed at least when the object is garbage collected, even though you can't know when (or if) that happens", "label": {"api": {"finalize": [[22, 29]]}}}, {"text": "You can use Java 7's WatchService to accomplish this for you", "label": {"api": {"WatchService": [[21, 32]]}}}, {"text": "The serialization methods readObject and writeObjectwill be called by the Java contract and allow me to implement a custom serialization", "label": {"api": {"by the Java contract": [[67, 86]]}}}, {"text": "the 1-argument version of Collections.sort expects a list of Comparables", "label": {"api": {"Collections.sort": [[26, 41]]}}}, {"text": "Java 8 introduces the Instant.ofEpochSecond utility method for creating an Instant from a Unix timestamp, this can then be converted into a ZonedDateTime and finally formatted, e.g.", "label": {"api": {"Instant.ofEpochSecond": [[22, 42]], "Instant": [[22, 28], [75, 81]], "ZonedDateTime": [[140, 152]]}}}, {"text": "The specs are a little vague, but the Thread Javadoc offers the following", "label": {"api": {"Thread Javadoc": [[38, 51]]}}}, {"text": "You can use ExecutorService.invokeAll", "label": {"api": {"ExecutorService.invokeAll": [[12, 36]]}}}, {"text": "But given that you are having a URL, you can use java.net.URL.getFile()", "label": {"api": {"java.net.URL.getFile()": [[49, 70]]}}}, {"text": "Implement the only method of the Iterable interface, iterator()", "label": {"api": {"iterator()": [[53, 62]]}}}, {"text": "You will need to return an instance of Iterator in this method", "label": {"api": {"Iterator": [[39, 46]]}}}, {"text": "Typically this is done by creating an inner class that implements Iterator, and implementing iterator by creating an instance of that inner class and returning it", "label": {"api": {"Iterator": [[66, 73]]}}}, {"text": "You can look at the javadoc here", "label": {"api": {"javadoc here": [[20, 31]]}}}, {"text": "Look at LinkedList, for example", "label": {"api": {"LinkedList": [[8, 17]]}}}, {"text": "You can always use SwingUtilities to help you", "label": {"api": {"SwingUtilities": [[19, 32]]}}}, {"text": "If the component is not yet held by a window, then this will return null as per the SwingUtilities API", "label": {"api": {"SwingUtilities": [[84, 97]], "SwingUtilities API": [[84, 101]]}}}, {"text": "Read the documentation for ready() carefully", "label": {"api": {"ready()": [[27, 33]]}}}, {"text": "See the Rectangle online Java documentation for more detail", "label": {"api": {"Rectangle online Java documentation": [[8, 42]]}}}, {"text": "Date.getTime() returns a long", "label": {"api": {"Date.getTime()": [[0, 13]]}}}, {"text": "Here is a better way to write strings using OutputStreamWriter", "label": {"api": {"OutputStreamWriter": [[44, 61]]}}}, {"text": "Thread class has 'uncaught exception handler' - see http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler%28java.lang.Thread.UncaughtExceptionHandler%29", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler%28java.lang.Thread.UncaughtExceptionHandler%29": [[52, 188]]}}}, {"text": "If the objects inside the ArrayList has the equal methods properly overridden and defined you can use the contains method", "label": {"api": {"contains": [[106, 113]]}}}, {"text": "HashSet for example", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "There is a provision to implement the SingleThreadModel ,it is deprecated, it is not only bad but ridiculous to do so", "label": {"api": {"SingleThreadModel": [[38, 54]]}}}, {"text": "Better to implement a ServletRequestListener and put the logic there", "label": {"api": {"ServletRequestListener": [[22, 43]]}}}, {"text": "You can also use a ThreadLocal variable if you want to create only 1 instance per thread", "label": {"api": {"ThreadLocal": [[19, 29]]}}}, {"text": "You can use Executors.newScheduledThreadPool(1) to achieve this", "label": {"api": {"Executors.newScheduledThreadPool(1)": [[12, 46]]}}}, {"text": "As API says, ATOMIC_MOVE is not supported for copy(), but for move() only", "label": {"api": {"says": [[7, 10]]}}}, {"text": "On the other hand, you can create so-called \"hard links\" using Files.createLink()", "label": {"api": {"Files.createLink()": [[63, 80]]}}}, {"text": "Use equals() to compare the contents of the String", "label": {"api": {"equals()": [[4, 11]]}}}, {"text": "P.S.:- Invoked equals() on the String literal to avoid any NPE due to null day", "label": {"api": {"equals()": [[15, 22]]}}}, {"text": "If data flow goes via OSGi services registered by the other bundles, you can create a java.lang.reflect.Proxy object for every service and register these objects as OSGi services (with the same OBJECTCLASS and properties as original ones) with maximal SERVICE_RANKING", "label": {"api": {"java.lang.reflect.Proxy": [[86, 108]]}}}, {"text": "Check out the rather complicated regular expression that is listed in the documentation for Double.valueOf", "label": {"api": {"Double.valueOf": [[92, 105]]}}}, {"text": "So,  you multiply -1 with a value between 0.0 and 1.0 (1.0 is not included) (according to the java docs of Math.random())", "label": {"api": {"Math.random()": [[107, 119]]}}}, {"text": "But, instead of doing that, you can use the isEmpty() check directly on your list; this way, you don't have to constantly monitor the list's size", "label": {"api": {"isEmpty()": [[44, 52]]}}}, {"text": "This is a much better solution than the existing SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[49, 64]]}}}, {"text": "Just write to a ByteArrayOutputStream instead - you can then create a ByteArrayInputStream to read from the same byte array, and then pass that to ImageIO.read(InputStream)", "label": {"api": {"ImageIO.read(InputStream)": [[147, 171]]}}}, {"text": "Java regex reference", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "For Sets (and other non-indexable collections) you will need to use their Iterators as returned by the iterator() method of Collection", "label": {"api": {"Iterator": [[74, 81]], "iterator()": [[103, 112]]}}}, {"text": "You can do the same for Maps, using the Iterator of their entrySet()s", "label": {"api": {"Iterator": [[40, 47]], "entrySet()": [[58, 67]]}}}, {"text": "You should probably use disconnect(true) instead, and then reconnect to the card", "label": {"api": {"disconnect(true)": [[24, 39]]}}}, {"text": "Consider using StringBuilder instead of String if you will do lots of concatenation on String", "label": {"api": {"StringBuilder": [[15, 27]]}}}, {"text": "This uses the new java.util.stream package and lambda expressions", "label": {"api": {"java.util.stream": [[18, 33]]}}}, {"text": "What is the C# equivalent to Java's Throwable", "label": {"api": {"Throwable": [[36, 44]]}}}, {"text": "In Java, the root of the exception class hierarchy is called Throwable, not Exception", "label": {"api": {"Throwable": [[61, 69]]}}}, {"text": "The Throwable base class has two derived classes", "label": {"api": {"Throwable": [[4, 12]]}}}, {"text": "So the Throwable base class includes problems that a reasonable program should not try to catch", "label": {"api": {"Throwable": [[7, 15]]}}}, {"text": "The best way is to use ArrayList or another implementation of List", "label": {"api": {"ArrayList": [[23, 31]], "List": [[28, 31], [62, 65]]}}}, {"text": "You need to call ResultSet.next() each time the user clicks on the \"Next\" button", "label": {"api": {"ResultSet.next()": [[17, 32]]}}}, {"text": "Just use ArrayList#toString()", "label": {"api": {"ArrayList#toString()": [[9, 28]]}}}, {"text": "You would want to call get and pass in the reference, casting the return to a String", "label": {"api": {"get": [[23, 25]]}}}, {"text": "You can use get as follows", "label": {"api": {"get": [[12, 14]]}}}, {"text": "Logging level set and handlers configured", "label": {"api": {"level": [[8, 12]]}}}, {"text": "Notice that the level I set up is FINE which would ensure that most of what you log is not ignored by any handler since FINE is one of the lowest levels", "label": {"api": {"level": [[16, 20], [146, 150]]}}}, {"text": "By default loggers are configured to handle only SEVERE level logs, which usually ignores the rest, SEVERE being the highest level", "label": {"api": {"level": [[56, 60], [125, 129]]}}}, {"text": "Next you need to ensure that the level you use to log is included withing the LEVEL you setup on the XML module file", "label": {"api": {"level": [[33, 37]]}}}, {"text": "...the level must be set to FINE or any other level below for this messages you appear in your log, if you choose any level above FINE, all those messages will be ignored", "label": {"api": {"level": [[7, 11], [46, 50], [118, 122]]}}}, {"text": "You can get the item from the list by the index number", "label": {"api": {"get": [[8, 10]]}}}, {"text": "Float.parseFloat() is the problem  as it returns a new float", "label": {"api": {"Float.parseFloat()": [[0, 17]]}}}, {"text": "You can use java.lang.BigDecimal", "label": {"api": {"java.lang.BigDecimal": [[12, 31]]}}}, {"text": "In Java, String#matches only returns true if the whole string matches the regex", "label": {"api": {"String#matches": [[9, 22]]}}}, {"text": "I think String#contains is better for your case since you are not really want to match a regex but a substring", "label": {"api": {"String#contains": [[8, 22]]}}}, {"text": "The getResourceAsStream-method returns null whenever running the executable jar in a directory which ends with a exclamation mark", "label": {"api": {"getResourceAsStream": [[4, 22]]}}}, {"text": "Two ways, you could try the Java Scanner class to look for a specific string (e.g Longitude) assuming the existence of this word in the document implies the element exists", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "Since the document is a string and assuming you don't need to parse it for other reasons, I would use the StAX API", "label": {"api": {"StAX API": [[106, 113]]}}}, {"text": "Also , do properly close all the connections which you have opened in the finally block", "label": {"api": {"close": [[19, 23]]}}}, {"text": "Did you try using getEnclosingClass()", "label": {"api": {"getEnclosingClass()": [[18, 36]]}}}, {"text": "The method isMemberClass() will test if the method is a member (and not an anonymous or local class) and the second condition will verify that your member class is not static", "label": {"api": {"isMemberClass()": [[11, 25]]}}}, {"text": "Vector.get(0) should work", "label": {"api": {"Vector.get(0)": [[0, 12]]}}}, {"text": "To compare String , use equals() method", "label": {"api": {"equals()": [[24, 31]]}}}, {"text": "Use the String.equals(otherString) function to compare strings, not the == operator", "label": {"api": {"String.equals(otherString)": [[8, 33]]}}}, {"text": "You should remove an element from a List using an Iterator", "label": {"api": {"Iterator": [[50, 57]]}}}, {"text": "This should give you some hints, why you should use an Iterator", "label": {"api": {"Iterator": [[55, 62]]}}}, {"text": "You can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "if for some reason you need that information on your own, you can use Thread.getStackTrace() and inspect the second StackTraceElement on it", "label": {"api": {"Thread.getStackTrace()": [[70, 91]], "StackTraceElement": [[116, 132]]}}}, {"text": "You could try using java.text.NumberFormat and a pattern that displays every number with a fixed width.", "label": {"api": {"java.text.NumberFormat": [[20, 41]]}}}, {"text": "the compiler will insist that I catch a MalformedURLException", "label": {"api": {"MalformedURLException": [[40, 60]]}}}, {"text": "If the desired Locale is not your default Locale, you can specify it explicitly from among the Supported Locales", "label": {"api": {"Locale": [[15, 20], [42, 47], [105, 110]]}}}, {"text": "Does it fetch the rows immediately after query execution (after the client application invokes PreparedStatement.executeQuery()) or after the client application first invokes ResultSet.next() to retrieve a row from the result set", "label": {"api": {"PreparedStatement.executeQuery()": [[95, 126]], "ResultSet.next()": [[175, 190]]}}}, {"text": "According to the javadoc for InflaterInputStream, for its single-arg constructor (with just an InputStream), the input stream is initialized with a default decompressor and buffer size", "label": {"api": {"InflaterInputStream": [[29, 47]]}}}, {"text": "Same thing for the DeflaterOutputStream", "label": {"api": {"DeflaterOutputStream": [[19, 38]]}}}, {"text": "The only difference in handling is that on closing the InflaterInputStream the 'default' Inflater gets closed (using end()), which doesn't happen if an instance of Inflater is passed to one of the other constructors", "label": {"api": {"end()": [[117, 121]]}}}, {"text": "You can transform a DOMSource to a DOMResult, see http://docs.oracle.com/javase/6/docs/api/javax/xml/transform/dom/DOMResult.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/xml/transform/dom/DOMResult.html": [[50, 128]]}}}, {"text": "It looks like your Java doesn't support UTF-8, which is really strange, because every Java should support it according to the documentation of the Charset class", "label": {"api": {"documentation of the Charset class": [[126, 159]]}}}, {"text": "It makes the class initializer run - which in the case of JDBC drivers used to be the way that the driver would register itself with DriverManager", "label": {"api": {"DriverManager": [[133, 145]]}}}, {"text": "In the Java7 API reference(Java API 7) there's a function list() of File class that has the signature", "label": {"api": {"Java API 7": [[27, 36]]}}}, {"text": "Here's a simple solution using Java's format strings (using positional arguments)", "label": {"api": {"Java's format strings": [[31, 51]]}}}, {"text": "You can use Class.isAssignableFrom", "label": {"api": {"Class.isAssignableFrom": [[12, 33]]}}}, {"text": "ClassLoader#getResource() is able to locate files relative to the \"root\" of the classpath", "label": {"api": {"ClassLoader#getResource()": [[0, 24]]}}}]