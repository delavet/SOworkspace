[{"text":"Collect the result with Stream.collect into a new list using Collectors.toList()","label":{"api":{"Stream.collect":[[24,37]],"Collectors.toList()":[[61,79]]}}},{"text":"Adding Thread.yield() to the outer loop in t mitigates the problem, as shown below","label":{"api":{"Thread.yield()":[[7,20]]}}},{"text":"Except for the artificial nature of the example, a hint like Thread.yield() would not ordinarily be required","label":{"api":{"Thread.yield()":[[61,74]]}}},{"text":"I do not believe that Thread.yield() should need to be called in this case at all, despite the artificial nature of the test case, however","label":{"api":{"Thread.yield()":[[22,35]]}}},{"text":"Note that the GUI updates promptly in the example below, even without Thread.yield()","label":{"api":{"Thread.yield()":[[70,83]]}}},{"text":"I am trying to analyze a thread dump which seems to indicate that there are numerous threads that are waiting on java.util.concurrent.Semaphore permits, i.e., the threads are waiting on Semaphore.acquire()","label":{"api":{"java.util.concurrent.Semaphore":[[113,142]],"Semaphore.acquire()":[[186,204]]}}},{"text":"This I was able to imply because the threads are in WAITING (parking) state, and from what I've understood, Semaphore's do not use LOCK monitors, but use LockSupport.park() instead, waiting on another thread to unpark it","label":{"api":{"Semaphore":[[108,116]],"LOCK monitors":[[131,143]],"LockSupport.park()":[[154,171]]}}},{"text":"Integer iOb = new Integer(88); is not auto-boxing, Integer takes an int parameter in one of its constructor overloads (see API)","label":{"api":{"Integer":[[51,57]]}}},{"text":"If you bind your server socket to an unspecified host address, the socket will be bind to all available interfaces (see InetSocketAddress)","label":{"api":{"InetSocketAddress":[[120,136]]}}},{"text":"For example, using a properties file, or command line arguments","label":{"api":{}}},{"text":"Java internationalization of strings can be done through the ResourceBundle class","label":{"api":{"ResourceBundle":[[61,74]]}}},{"text":"Since you are using an embeddableID, you can also use the @MapsId annotation so that the EmbeddedID's shipToId attribute gets set by JPA with the value from the referenced entity","label":{"api":{"@MapsId":[[58,64]],"JPA":[[133,135]]}}},{"text":"The JoinColumn defines the field and the @MapsId forces it to override any column definition on the shipToId attribute","label":{"api":{"JoinColumn":[[4,13]],"@MapsId":[[41,47]]}}},{"text":"Implement a ServletContextListener and register it in the web.xml or via annotation","label":{"api":{"ServletContextListener":[[12,33]]}}},{"text":"But from what I can see, the Comparable interface does not require that compareTo() be \"consistent with equals()\" (though it is strongly recommended)","label":{"api":{"Comparable":[[29,38]],"compareTo()":[[72,82]],"equals()":[[104,111]]}}},{"text":"From the Comparable documentation","label":{"api":{"Comparable":[[9,18]]}}},{"text":"@Nicol Bolas makes a good point - there is a function Files.readAllBytes(Path path), if you use it instead of re-implementing the functionality you will be less prone to little bugs like this","label":{"api":{"Files.readAllBytes(Path path)":[[54,82]]}}},{"text":"So, you want every user just once, so a Set is the better choice","label":{"api":{"Set":[[40,42]]}}},{"text":"For this you may have a look at Oracle's Stream-documentation","label":{"api":{"Stream":[[41,46]]}}},{"text":"JDBC Type -1 is LONGVARCHAR, and is the type that is supposed to be returned by your query","label":{"api":{"LONGVARCHAR":[[16,26]]}}},{"text":"No mapping for LONGVARCHAR in Hibernate 3.2","label":{"api":{"LONGVARCHAR":[[15,25]]}}},{"text":"Here .stream.collect(Collectors.joining()) part is Java 8 Stream way to join a sequence of Strings into one","label":{"api":{".stream.collect(Collectors.joining())":[[5,41]]}}},{"text":"You can get it by calling TreeSet.iterator()","label":{"api":{"TreeSet.iterator()":[[26,43]]}}},{"text":"I am using CompletableFuture.runAsync() to asynchronously initialise a few fields in an object","label":{"api":{"CompletableFuture.runAsync()":[[11,38]]}}},{"text":"You may use toCollection(Supplier)","label":{"api":{"toCollection(Supplier)":[[12,33]]}}},{"text":"The documentation for ResourceBundle indicates that the call to getBundle(String) retrieves the bundle from the default location within the classloader","label":{"api":{"ResourceBundle":[[22,35]],"getBundle(String)":[[64,80]]}}},{"text":"Read a String, instead of an int","label":{"api":{"String":[[7,12]],"int":[[29,31]]}}},{"text":"You can start with Instant.ofEpochMilli(long)","label":{"api":{"Instant.ofEpochMilli(long)":[[19,44]]}}},{"text":"In Java, methods that throw checked exceptions (Exception or its subtypes - IOException, InterruptedException, etc) must declare throws statement","label":{"api":{"Exception":[[48,56]],"IOException":[[76,86]],"InterruptedException":[[89,108]]}}},{"text":"What could potentially go wrong if only RuntimeException were allowed to be catched in this scenario","label":{"api":{"RuntimeException":[[40,55]]}}},{"text":"But if you care about starting them at the same time (almost) you can use CyclicBarrier (taken from here)","label":{"api":{"CyclicBarrier":[[74,86]]}}},{"text":"As for the compareTo method - normally you implement the Comparable interface","label":{"api":{"compareTo":[[11,19]],"Comparable":[[57,66]]}}},{"text":"What repaint Component.repaint does (emphasis mine)","label":{"api":{"Component.repaint":[[13,29]]}}},{"text":"Have a look at Collections.shuffle()","label":{"api":{"Collections.shuffle()":[[15,35]]}}},{"text":"Stream.iterate returns 'an infinite sequential ordered Stream'","label":{"api":{"Stream.iterate":[[0,13]]}}},{"text":"According to the description of the  Stream package","label":{"api":{"Stream":[[37,42]]}}},{"text":"The real cause is that ordered parallel .distinct() is the full barrier operation as described in documentation","label":{"api":{"parallel .distinct()":[[31,50]]}}},{"text":"The @Column annotation should still work for this collection of strings","label":{"api":{"@Column":[[4,10]]}}},{"text":"If you really need specific (and changing) usernames/passwords depending on application logic, then you can use DataSource.getConnection(String username, String password)","label":{"api":{"DataSource.getConnection(String username, String password)":[[112,169]]}}},{"text":"To get a human readable format using Arrays use","label":{"api":{"Arrays":[[37,42]]}}},{"text":"Use the the Socket.setKeepAlive() or apply the heart beat mechanism","label":{"api":{"Socket.setKeepAlive()":[[12,32]]}}},{"text":"For most you can just use the String.valueOf() method","label":{"api":{"String.valueOf()":[[30,45]]}}},{"text":"You can use Character.isLowerCase() and Character.isUpperCase() to check an individual char","label":{"api":{"Character.isLowerCase()":[[12,34]],"Character.isUpperCase()":[[40,62]]}}},{"text":"Read the javadoc of Matcher.group(int group)","label":{"api":{"Matcher.group(int group)":[[20,43]]}}},{"text":"See Formatter for details","label":{"api":{"Formatter":[[4,12]]}}},{"text":"Printing single character is support - see https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#print(char) , so no reason for compiler error","label":{"api":{}}},{"text":"How about Files.readAllLines()","label":{"api":{"Files.readAllLines()":[[10,29]]}}},{"text":"There is no difference in function betweenaddElement() and add(), except that add() returns a boolean","label":{"api":{"addElement()":[[42,53]],"add()":[[59,63],[78,82]]}}},{"text":"From the JavaDoc for addElement()","label":{"api":{"addElement()":[[21,32]]}}},{"text":"This method is identical in functionality to the add(E) method (which is part of the List interface)","label":{"api":{"add(E)":[[49,54]],"List":[[85,88]]}}},{"text":"You can't traverse through the list using Iterator and modify the list with List-level add/remove methods at the same time","label":{"api":{"Iterator":[[42,49]],"add":[[87,89]],"remove":[[91,96]]}}},{"text":"To add an element in such situations you can use ListIterator and its method add","label":{"api":{"ListIterator":[[49,60]],"add":[[77,79]]}}},{"text":"I am using a Service in this example because it is a reusable Worker","label":{"api":{"Service":[[13,19]],"reusable Worker":[[53,67]]}}},{"text":"I would recommend you look into ThreadPoolExecutor when dealing with large number of threads","label":{"api":{"ThreadPoolExecutor":[[32,49]]}}},{"text":"So, People use @Deprecated annotation for APIs that have been deprecated","label":{"api":{"@Deprecated":[[15,25]]}}},{"text":"When you use thenRunAsync(Runnable), tasks will be executed using a thread pool (there are other possibilites - see API docs)","label":{"api":{"thenRunAsync(Runnable)":[[13,34]]}}},{"text":"See the Color constructor documentation for details","label":{"api":{"Color":[[8,12]]}}},{"text":"When the response is received in the callback, and I've done my processing, I decrement a CountDownLatch","label":{"api":{"CountDownLatch":[[90,103]]}}},{"text":"I await the CountDownLatch, \"blocking\" the current thread until the CountDownLatch reaches 0","label":{"api":{"CountDownLatch":[[12,25],[68,81]]}}},{"text":"we create a pattern that captures every character but only find the first one and print it (the dotall mode is enabled to handle the case where the first character is a line separator)","label":{"api":{"dotall mode":[[96,106]]}}},{"text":"s.charAt(0) uses CharSequence API, not String, so formally it is correct answer","label":{"api":{"s.charAt(0)":[[0,10]],"CharSequence":[[17,28]],"String":[[39,44]]}}},{"text":"Another option is to use a method accepting CharSequence as argument, e","label":{"api":{"CharSequence":[[44,55]]}}},{"text":"Starting from here, get the type parameters that are declared on the method with the getTypeParameters method, which returns a TypeVariable<Method>[]","label":{"api":{"getTypeParameters":[[85,101]],"TypeVariable<Method>[]":[[127,148]]}}},{"text":"The TypeVariable interface has a method to retrieve the name T, getName, and a method to retrieve the bounds, getBounds","label":{"api":{"TypeVariable":[[4,15]],"getName":[[64,70]],"getBounds":[[110,118]]}}},{"text":"I am using Java's javax.imageio.ImageIO to read contents from my FlashAir 32Gb (2nd gen) and to write them to my local hard drive","label":{"api":{"javax.imageio.ImageIO":[[18,38]]}}},{"text":"It's decoding the images, and then re-encoding them at the default JPEG compression rate (which, judging by the JPEGImageWriteParam documentation, is 0.75)","label":{"api":{"JPEGImageWriteParam":[[112,130]]}}},{"text":"I would suggest using an InputStreamReader to read the file then wrap in a buffered reader as shown in the example","label":{"api":{"InputStreamReader":[[25,41]]}}},{"text":"You can only call the XMLStreamReader.getElementText() method on elements which contain text-only content","label":{"api":{"XMLStreamReader.getElementText()":[[22,53]]}}},{"text":"The Javadoc for XMLStreamReader.getElementText() contains detailed pseudocode which shows how the method computes the String that it returns and under what conditions it will throw an XMLStreamException","label":{"api":{"XMLStreamReader.getElementText()":[[16,47]],"XMLStreamException":[[184,201]]}}},{"text":"I tried to generify Future by replacing it with Future<Runnable> but it created a compile error instead since submit() returns a Future<?>","label":{"api":{"Future":[[20,25],[129,134]],"Future<Runnable>":[[48,63]],"submit()":[[110,117]]}}},{"text":"Then after threadPool.shutdown() invoke threadPool.awaitTermination() -- to block until all tasks complete","label":{"api":{"threadPool.shutdown()":[[11,31]],"threadPool.awaitTermination()":[[40,68]]}}},{"text":"The idea is to have a MappedByteBuffer backed by a \"file\" on tmpfs filesystem","label":{"api":{"MappedByteBuffer":[[22,37]]}}},{"text":"The performance of such MappedByteBuffer will be the same as for other Direct ByteBuffers, but it will persist the JVM restart, i.e","label":{"api":{"MappedByteBuffer":[[24,39]],"Direct ByteBuffers":[[71,88]]}}},{"text":"To create the correctly typed array, you need to use the reflection method Array.newInstance()","label":{"api":{"Array.newInstance()":[[75,93]]}}},{"text":"Consider using Iterator for search and removal","label":{"api":{"Iterator":[[15,22]]}}},{"text":"Invoke recover on your Session","label":{"api":{"recover":[[7,13]],"Session":[[23,29]]}}},{"text":"You can use an ImageView and setPickOnBounds for that","label":{"api":{"ImageView":[[15,23]],"setPickOnBounds":[[29,43]]}}},{"text":"The model has a getElementAt(int) method","label":{"api":{"getElementAt(int)":[[16,32]]}}},{"text":"From the docs for the add method","label":{"api":{"add":[[22,24]]}}},{"text":"Unless it is a specific requirement to use Vector, DON'T, and if it is, tell teacher to update assignment to something newer than 1998","label":{"api":{"Vector":[[43,48]]}}},{"text":"Vector was replaced by ArrayList back in Java 1.2 in 1998, and javadoc says","label":{"api":{"Vector":[[0,5]],"ArrayList":[[23,31]]}}},{"text":"Unlike the new collection implementations, Vector is synchronized","label":{"api":{"collection":[[15,24]],"Vector":[[43,48]]}}},{"text":"If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector","label":{"api":{"ArrayList":[[72,80]],"Vector":[[94,99]]}}},{"text":"If synchronization is needed, I'd recommend using Collections.synchronizedList() around an ArrayList over the use of Vector, which means that Vector should never be used, unless with an old API that requires it","label":{"api":{"Collections.synchronizedList()":[[50,79]],"ArrayList":[[91,99]],"Vector":[[117,122],[142,147]]}}},{"text":"The above code will only perform well on List objects with direct access by index, such as ArrayList, but will perform badly on lists like LinkedList","label":{"api":{"List":[[41,44]],"ArrayList":[[91,99]],"LinkedList":[[139,148]]}}},{"text":"Run the server in the context of a class that implements the cancel() method of Future<V>","label":{"api":{"cancel()":[[61,68]],"Future<V>":[[80,88]]}}},{"text":"SwingWorker<T,V> is such a RunnableFuture<V>; a complete example is seen here","label":{"api":{"SwingWorker<T,V>":[[0,15]],"RunnableFuture<V>":[[27,43]]}}},{"text":"But you could install a HttpSessionListener to get notified when sessions are created and destroyed and keep track of them in an own collection","label":{"api":{"HttpSessionListener":[[24,42]]}}},{"text":"Alternatively you could install a HttpSessionAttributeListener to get notified when attributes are added and removed from sessions","label":{"api":{"HttpSessionAttributeListener":[[34,61]]}}},{"text":"Note that the Ellipse2D boundary includes the upper-left corner's x and y coordinates, as well as width and height","label":{"api":{"Ellipse2D":[[14,22]]}}},{"text":"If the result of getSupportsWindowDecorations() is true for a given LookAndFeel, you can invoke setWindowDecorationStyle() on the JRootPane","label":{"api":{"getSupportsWindowDecorations()":[[17,46]],"LookAndFeel":[[68,78]],"setWindowDecorationStyle()":[[96,121]],"JRootPane":[[130,138]]}}},{"text":"Of course, if you were actually willing to write something like this in a real application, you would want to use String.replace(target, replacement) like this","label":{"api":{"String.replace(target, replacement)":[[114,148]]}}},{"text":"The problem with File.listFiles is that it does not list recursively","label":{"api":{"File.listFiles":[[17,30]]}}},{"text":"If I understand your requirement correctly, have a look at the LocalDate.parse() methods","label":{"api":{"LocalDate.parse()":[[63,79]]}}},{"text":"Use replaceAll with an according regular expression with capturing groups and use $1 and $2 in the replacement to reuse the strings in the captured groups","label":{"api":{"replaceAll":[[4,13]]}}},{"text":"The java.time framework built into Java 8 and later parses two-digit year strings as being in the 2000s","label":{"api":{"java.time":[[4,12]]}}},{"text":"From the java.time.DateTimeFormatter class documentation","label":{"api":{"java.time.DateTimeFormatter":[[9,35]]}}},{"text":"get Waits if necessary for the computation to complete, and then retrieves its result","label":{"api":{"get":[[0,2]]}}},{"text":"Use isDone to check that you can call get without waiting","label":{"api":{"isDone":[[4,9]],"get":[[38,40]]}}},{"text":"SwingWorker's processmethod has different arguments and a different return type","label":{"api":{"SwingWorker":[[0,10]],"processmethod":[[14,26]]}}},{"text":"Instead of looping forever on the isAlive() check, create a CountDownLatch when you start the thread, count it down when the thread finishes, and simply await() it in cancel","label":{"api":{"isAlive()":[[34,42]],"CountDownLatch":[[60,73]],"await()":[[153,159]]}}},{"text":"This will incidentally also solve the first problem at the same time without any need for volatile, because in addition to its scheduling coordination a CountDownLatch guarantees that any thread that awaited on it will see the results of everything done in any thread that counted it down","label":{"api":{"CountDownLatch":[[153,166]]}}},{"text":"Replace the Thread t with a CountDownLatch","label":{"api":{"Thread":[[12,17]],"CountDownLatch":[[28,41]]}}},{"text":"In start, initialize the CountDownLatch with a count of 1","label":{"api":{"CountDownLatch":[[25,38]]}}},{"text":"In start, after initializing the CountDownLatch, get an ExecutorService by calling Executors.newSingleThreadExecutor(), and then submit the renameAllFiles call to it","label":{"api":{"CountDownLatch":[[33,46]],"ExecutorService":[[56,70]],"Executors.newSingleThreadExecutor()":[[83,117]],"renameAllFiles":[[140,153]]}}},{"text":"Integer.toHexString(int) is available","label":{"api":{"Integer.toHexString(int)":[[0,23]]}}},{"text":"As is BigInteger.toString(int radix)","label":{"api":{"BigInteger.toString(int radix)":[[6,35]]}}},{"text":"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html It'll do all the shifting for you","label":{"api":{}}},{"text":"You need to call ResultSet.wasNull() to test whether the last column read had a value of SQL NULL","label":{"api":{"ResultSet.wasNull()":[[17,35]]}}},{"text":"Hibernate uses the JPA @Index annotation which doesn't support function-based indexes","label":{"api":{"@Index":[[23,28]]}}},{"text":"As of Java 7, the default locale comes in two categories","label":{"api":{"locale":[[26,31]]}}},{"text":"The garbage collector traverses existing references and within the objects found this way, it will find meta information (i.e","label":{"api":{"garbage collector":[[4,20]]}}},{"text":"a pointer to class specific information) needed to understand how much memory belongs to the object and how to interpret the contained data (to traverse the sub-references, if any)","label":{"api":{}}},{"text":"Once all references to an object are gone, there is no information left about the former existence of this object","label":{"api":{}}},{"text":"When you search memory that is considered to be unused, you may find reminiscences of old objects, but without references to their starting points, itâ€™s impossible to say whether the bit pattern that looks like an object really is a dead object or just a coincidence","label":{"api":{}}},{"text":"Similarly, soft, weak and phantom references encapsulate a reference to the object in question","label":{"api":{}}},{"text":"You can obtain that with anyMatch","label":{"api":{"anyMatch":[[25,32]]}}},{"text":"HashMap (and, in fact, all classes implementing Map) only stores one value per key","label":{"api":{"HashMap":[[0,6]],"Map":[[48,50]]}}},{"text":"Quoting the Javadoc of Map","label":{"api":{"Map":[[23,25]]}}},{"text":"a Collection like a List or Set, so your map type might be Map<String, List<String>>","label":{"api":{"Collection":[[2,11]],"List":[[20,23]],"Set":[[28,30]],"Map<String, List<String>>":[[59,83]]}}},{"text":"You can override the public boolean equals(Object o) method of Object class in Address as","label":{"api":{"equals(Object o)":[[36,51]],"Object":[[63,68]]}}},{"text":"then you can use List.contains(Object o) method of List to verify that element(Address obj) is present or not in the list","label":{"api":{"List.contains(Object o)":[[17,39]],"element(Address obj)":[[71,90]]}}},{"text":"In Java 8, you can use forEach to iterate over the entries of the hashmap and retrieve both key and value in each iteration","label":{"api":{"forEach":[[23,29]]}}},{"text":"The int constructor parameter is an initial capacity, not the number of elements present initially","label":{"api":{}}},{"text":"PriorityBlockingQueue.size() returns the number of elements present in the collection; PriorityBlockingQueue.remainingCapacity() returns the available capacity","label":{"api":{"PriorityBlockingQueue.size()":[[0,27]],"PriorityBlockingQueue.remainingCapacity()":[[87,127]]}}},{"text":"This is perfectly well explained in this javadoc","label":{"api":{}}},{"text":"Consider use of a concurrent hashmap and the method Map.computeIfAbsent() which takes a function to call to compute a default value if key is absent from the map","label":{"api":{"concurrent hashmap":[[18,35]],"Map.computeIfAbsent()":[[52,72]]}}},{"text":"Have a look at MappedByteBuffer and ByteBuffer","label":{"api":{"MappedByteBuffer":[[15,30]],"ByteBuffer":[[36,45]]}}},{"text":"For this, you can calculate the duration between instant and toCheck with Duration.between","label":{"api":{"instant":[[49,55]],"toCheck":[[61,67]],"Duration.between":[[74,89]]}}},{"text":"Since nextChar does not exist, I will offer you to consider trying the following","label":{"api":{"nextChar":[[6,13]]}}},{"text":"I guess you already have the answer you seek but just for the sake of answering, you can try using result-set-metadata by using a select * from table and then checking the column names against your query (you'd have to parse the query string I guess...)","label":{"api":{"result-set-metadata":[[99,117]]}}},{"text":"Math.round is underspecified, and I believe its behavior has actually changed in the past -- see http://bugs.java.com/view_bug.do?bug_id=6430675 -- but generally speaking it behaves like RoundingMode.HALF_UP, which has an extensive table of its differences from RoundingMode.CEILING or RoundingMode.FLOOR","label":{"api":{"Math.round":[[0,9]],"RoundingMode.HALF_UP":[[187,206]],"RoundingMode.CEILING":[[262,281]],"RoundingMode.FLOOR":[[286,303]]}}},{"text":"If you define a no-parameter initialize() method in your Controller and don't implement the Initializable interface, then the FXML loader will still automatically invoke the initialize method","label":{"api":{"initialize()":[[29,40]],"Initializable":[[92,104]],"FXML loader":[[126,136]],"initialize":[[174,183]]}}},{"text":"If instead, you define a parameterized public void initialize(URL url, ResourceBundle rb) method in your Controller, then the FXML loader will not automatically invoke the initialize method unless your controller also implements the Initializable interface","label":{"api":{"initialize(URL url, ResourceBundle rb)":[[51,88]],"FXML loader":[[126,136]],"Initializable":[[233,245]]}}},{"text":"As the code in the question was using a parameterized initialize method and not also implementing Initializable, the initialization was not occurring","label":{"api":{"Initializable":[[98,110]]}}},{"text":"In this framework, you would start off by getting an ExecutorService from one of the static factory methods in Executors, replace both new Thread and t.start() with a call to submit(), and then either coordinate between threads with a CountDownLatch or other provided synchronizer class or (as in your simple case) call get() on the Future that submit() returns","label":{"api":{"ExecutorService":[[53,67]],"Executors":[[111,119]],"Thread":[[139,144]],"t.start()":[[150,158]],"submit()":[[175,182],[345,352]],"CountDownLatch":[[235,248]],"get()":[[320,324]],"Future":[[333,338]]}}},{"text":"The HTML document is in the WebEngine's document property, but it's loaded in the background, so you must wait for it to load","label":{"api":{"WebEngine":[[28,36]]}}},{"text":"The document object is a regular XML document, so if the button has an id attribute, you can easily retrieve it","label":{"api":{"document":[[4,11]],"button":[[57,62]]}}},{"text":"Finally, you can add a DOM event listener to the button, as described in the WebEngine documentation","label":{"api":{"DOM event listener":[[23,40]],"button":[[49,54]],"WebEngine":[[77,85]]}}},{"text":"You can use Timeline which is probably more suitable for this","label":{"api":{"Timeline":[[12,19]]}}},{"text":"Alternatively, you may try to have the delay of the KeyFrame as zero, and use the Timeline's targetFrameRate, but I personally never tried it","label":{"api":{"KeyFrame":[[52,59]],"Timeline":[[82,89]],"targetFrameRate":[[93,107]]}}},{"text":"Like 1 but automatically by the data structure itself, use CopyOnWriteArrayList and return it (wrapped in unmodifiable)","label":{"api":{"CopyOnWriteArrayList":[[59,78]]}}},{"text":"Depending on the properties of the data structure you need you could go for a non RandomAccess list like ConcurrentLinkedQueue or ConcurrentLinkedDeque, both allow iterating etc over the data structure without any extra synchronization","label":{"api":{"RandomAccess list":[[82,98]],"ConcurrentLinkedQueue":[[105,125]],"ConcurrentLinkedDeque":[[130,150]]}}},{"text":"See javadoc of Pattern","label":{"api":{"Pattern":[[15,21]]}}},{"text":"Note that the replaceAll() method shown in comments is also using a regular expression","label":{"api":{"replaceAll()":[[14,25]]}}},{"text":"Given a Map mapping a String to a List, is there a way to use Java Streams to return a Boolean where TRUE means one or more list had elements","label":{"api":{"Map":[[8,10]],"String":[[22,27]],"List":[[34,37]],"Streams":[[67,73]],"Boolean":[[87,93]]}}},{"text":"No need to examine all the Map values (all the Lists)","label":{"api":{"Map":[[27,29]],"List":[[47,50]]}}},{"text":"Use the anyMatch method that finds if any element of the stream matches a Predicate","label":{"api":{"anyMatch":[[8,15]],"Predicate":[[74,82]]}}},{"text":"Go through the string and call Character.isLetter(char) for each char to test if it is a letter character","label":{"api":{"Character.isLetter(char)":[[31,54]]}}},{"text":"Use System.nanoTime() if you want the highest precission","label":{"api":{"System.nanoTime()":[[4,20]]}}},{"text":"It sounds like something as simple as java.util.Timer could do the job","label":{"api":{"java.util.Timer":[[38,52]]}}},{"text":"From java documentation link","label":{"api":{}}},{"text":"Have a look at this link to understand about various API related to memory","label":{"api":{}}},{"text":"If you have a PreparedStatement you should be able to do something like this","label":{"api":{"PreparedStatement":[[14,30]]}}},{"text":"Specifically, depending on the implementation of a collection this could throw ConcurrentModificationException","label":{"api":{"collection":[[51,60]],"ConcurrentModificationException":[[79,109]]}}},{"text":"java.util.TimerTask has only thread to run task","label":{"api":{"java.util.TimerTask":[[0,18]]}}},{"text":"You can replace it with java.util.concurrent.ScheduledExecutorService, it could launch more thread to run task..","label":{"api":{"java.util.concurrent.ScheduledExecutorService":[[24,68]]}}},{"text":"In the first case (ArrayList::new) you are using the constructor which takes an initial capacity argument, in the second case you are not","label":{"api":{"ArrayList::new":[[19,32]]}}},{"text":"Here are the two constructors' current implementations","label":{"api":{}}},{"text":"https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.util.Calendar.YEAR It's a different way of doing enumerations, with static final integers","label":{"api":{}}},{"text":"Note that if you really want an OffsetDateTime, you can use ZonedDateTime.toOffsetDateTime() to convert a ZonedDateTime into an OffsetDateTime","label":{"api":{"OffsetDateTime":[[32,45],[128,141]],"ZonedDateTime.toOffsetDateTime()":[[60,91]],"ZonedDateTime":[[106,118]]}}},{"text":"And you could use equals() instead of == to compare two strings","label":{"api":{"equals()":[[18,25]]}}},{"text":"In this case, use Map","label":{"api":{"Map":[[18,20]]}}},{"text":"You can choose a file with a FileChooser or choose a directory with a DirectoryChooser","label":{"api":{"FileChooser":[[29,39]],"DirectoryChooser":[[70,85]]}}},{"text":"Whenever I check RandomAccessFile.length, will get I the accurate length","label":{"api":{"RandomAccessFile.length":[[17,39]]}}},{"text":"From the documentation for the getBounds2D() method of Path2D.Float","label":{"api":{"getBounds2D()":[[31,43]],"Path2D.Float":[[55,66]]}}},{"text":"This is actually just a copy of the general contract of Shape.getBounds2D()","label":{"api":{"Shape.getBounds2D()":[[56,74]]}}},{"text":"FileSystems is an utility class/factory that is only used to get instances of FileSystem","label":{"api":{"FileSystems":[[0,10]],"FileSystem":[[78,87]]}}},{"text":"Refer to the class documentation for the methods in the FileSystems class","label":{"api":{"FileSystems":[[56,66]]}}},{"text":"Basically, you will never use FileSystems except when you want to get an instance of FileSystem","label":{"api":{"FileSystems":[[30,40]],"FileSystem":[[85,94]]}}},{"text":"For all other use cases, yo uwould only want to use FileSystem","label":{"api":{"FileSystem":[[52,61]]}}},{"text":"The java.util.logging logging framework uses shutdown hooks to make sure the flush() method is called on its handlers","label":{"api":{"java.util.logging":[[4,20]],"flush()":[[77,83]]}}},{"text":"The handlers provided with the java api do implement this","label":{"api":{}}},{"text":"You can use the JarFile class like this","label":{"api":{"JarFile":[[16,22]]}}},{"text":"Similarly to Map.Entry","label":{"api":{"Map.Entry":[[13,21]]}}},{"text":"You are not using correctly the Period class here","label":{"api":{"Period":[[32,37]]}}},{"text":"The period between those two dates, as defined by the Period class is \"1 month\"","label":{"api":{"Period":[[54,59]]}}},{"text":"If you print the period, you will have \"P1M\", which is the pattern to say that","label":{"api":{}}},{"text":"As such, getDays(), which return the amount of days in the period, will return 0","label":{"api":{"getDays()":[[9,17]]}}},{"text":"You can convince yourself of that by printing the result of getMonths, it would return 1","label":{"api":{"getMonths":[[60,68]]}}},{"text":"In Java Time, there is an enum Month for all the months, and the method length(leapYear) return the length of this month, i.e","label":{"api":{"Time":[[8,11]],"Month":[[31,35]],"length(leapYear)":[[72,87]]}}},{"text":"To check for the current year, we can call Year.now() and return if it's a leap year or not with isLeap()","label":{"api":{"Year.now()":[[43,52]],"isLeap()":[[97,104]]}}},{"text":"Therefore, we will parse each String into a YearMonth object using a custom DateTimeFormatter","label":{"api":{"YearMonth":[[44,52]],"DateTimeFormatter":[[76,92]]}}},{"text":"Once they are parsed, we can get the period between those two temporal objects with Period.between","label":{"api":{"Period.between":[[84,97]]}}},{"text":"This method takes a LocalDate as parameter so we need to add a day to each YearMonth","label":{"api":{"LocalDate":[[20,28]],"YearMonth":[[75,83]]}}},{"text":"Finally, getYears() return the amount of years in this period and getMonths() returns the amount of month","label":{"api":{"getYears()":[[9,18]],"getMonths()":[[66,76]]}}},{"text":"If you're using java 8 you should take a look at its new Base64 class","label":{"api":{"Base64":[[57,62]]}}},{"text":"It will provide you with a Base64.Encoder whose encodeToString(byte[] src) method accepts a byte array and return a base64 encoded String","label":{"api":{"Base64.Encoder":[[27,40]],"encodeToString(byte[] src)":[[48,73]]}}},{"text":"Using a stringjoiner directly isn't effective when you have all your information already self contained in a streamable list, because you can stream directly and create a string with Collectors.joining","label":{"api":{"stringjoiner":[[8,19]],"Collectors.joining":[[183,200]]}}},{"text":"The above code uses .stream() to loop over the List then .map() them to strings, then finally collects them using Collectors.joining","label":{"api":{".stream()":[[20,28]],".map()":[[57,62]],"Collectors.joining":[[114,131]]}}},{"text":"Yuri Schimke also suggested another method, you can also use DecimalFormat to format the numbers","label":{"api":{"DecimalFormat":[[61,73]]}}},{"text":"I think the problem here is that you think a PropertyChangeListener will listen to setText() - It doesn't","label":{"api":{"PropertyChangeListener":[[45,66]],"setText()":[[83,91]]}}},{"text":"In the documentation of the propertyChange method it states","label":{"api":{"propertyChange":[[28,41]]}}},{"text":"Furthermore in the setText method's documentation","label":{"api":{"setText":[[19,25]]}}},{"text":"You can use if you want the TrayIcon.displayMessage","label":{"api":{"TrayIcon.displayMessage":[[28,50]]}}},{"text":"For large content, instead of a JLabel, you can use a JEditorPane which has support for HTML content","label":{"api":{"JLabel":[[32,37]],"JEditorPane":[[54,64]]}}},{"text":"You can use \\p{Punct}, which is one of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~, along with \\s which is a whitespace [ \\t\\n\\x0B\\f\\r]","label":{"api":{}}},{"text":"That method is documented to return the contents of the line, not including any line-termination characters","label":{"api":{}}},{"text":"A system-dependent line separator is used by the Files.write() method you're calling, as documented in its sibling","label":{"api":{"Files.write()":[[49,61]]}}},{"text":"You can also get this system-dependent line separator with System.lineSeparator()","label":{"api":{"System.lineSeparator()":[[59,80]]}}},{"text":"I was looking at the Executor interface","label":{"api":{"Executor":[[21,28]]}}},{"text":"My question is, how can I implement this Thread Pool Executor to be accessible from all the requests received and act as a queue for all the threads","label":{"api":{"Thread Pool Executor":[[41,60]]}}},{"text":"I was looking also at the Tomcat Executor, which I believe is used by Tomcat itself to manage its thread","label":{"api":{"Executor":[[33,40]]}}},{"text":"Also please look at the documentation for Files.readAllLines and note that this function is not intended for reading in large files","label":{"api":{"Files.readAllLines":[[42,59]]}}},{"text":"Use Scanner or BufferedReader instead on large files","label":{"api":{"Scanner":[[4,10]],"BufferedReader":[[15,28]]}}},{"text":"There is a much easier solution, using the built-in Collections.shuffle","label":{"api":{"Collections.shuffle":[[52,70]]}}},{"text":"getByteRgbInstance() returns a pixel format in which there are three bytes per pixel","label":{"api":{"getByteRgbInstance()":[[0,19]]}}},{"text":"The last argument to the setPixels method is the difference in offset in the array from the beginning of one row to the beginning of the next row","label":{"api":{"setPixels":[[25,33]]}}},{"text":"Ideally, you would use something like a TreeSet","label":{"api":{"TreeSet":[[40,46]]}}},{"text":"As you can surmise from the Process docs, the process object is created when you create a child process from your code","label":{"api":{"Process":[[28,34]]}}},{"text":"If you look at the documentation for ArrayList, you'll see that the methods that deal with size (adding, creating, determining size, etc) all return an int","label":{"api":{"ArrayList":[[37,45]]}}},{"text":"The guava library has it's own Supplier which does not extend Java 8 Supplier","label":{"api":{"Supplier":[[31,38],[69,76]]}}},{"text":"Also guava provides a cache for suppliers - Suppliers#memoize","label":{"api":{"Suppliers#memoize":[[44,60]]}}},{"text":"Is there something similar, but for Java 8 Suppliers","label":{"api":{"Suppliers":[[43,51]]}}},{"text":"As per my understanding from the JavaDoc for the ProcessBuilder, it just spawns a separate process and continues with its execution","label":{"api":{"ProcessBuilder":[[49,62]]}}},{"text":"assert throws an AssertionError if the assertion is false","label":{"api":{"AssertionError":[[17,30]]}}},{"text":"You can execute command line statements from Java using a ProcessBuilder","label":{"api":{"ProcessBuilder":[[58,71]]}}},{"text":"Forget about your KeyListener , since PaintWindow will receive no key event , not being a java.awt.Component","label":{"api":{"KeyListener":[[18,28]],"PaintWindow":[[38,48]],"java.awt.Component":[[90,107]]}}},{"text":"If you have no idea what can be null, or want to check everything for null, the only way is to chain calls to Optional.map","label":{"api":{"Optional.map":[[110,121]]}}},{"text":"The final call to orElse(0) allows to return the default value 0 if any mapper returned null","label":{"api":{"orElse(0)":[[18,26]]}}},{"text":"Use a JDK AtomicReference as your bean, rather than creating a dedicated class just for storage","label":{"api":{"AtomicReference":[[10,24]]}}},{"text":"Invoke the set method to store a value","label":{"api":{"set":[[11,13]]}}},{"text":"Invoke the get to recover the value","label":{"api":{"get":[[11,13]]}}},{"text":"Obviously you won't get rid of the steps in the route to store/fetch the value, but you can scrap away your custom class","label":{"api":{}}},{"text":"The getRow doesn't work, because it \"Retrieves the current row number.\"","label":{"api":{"getRow":[[4,9]]}}},{"text":"The canonicalization docs do not indicate why the CN of the server certificate is being canonicalized to this hex form","label":{"api":{"canonicalization":[[4,19]]}}},{"text":"If you read the documentation for String.replaceAll, the return value of String.replaceAll is a result String","label":{"api":{"String.replaceAll":[[34,50],[73,89]]}}},{"text":"I can only search them by ID, which is not sufficient, as they can be added and removed by the user","label":{"api":{}}}]