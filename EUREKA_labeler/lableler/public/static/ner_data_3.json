[{"text": "The documentation of PriorityQueue makes it clear", "label": {"api": {"PriorityQueue": [[21, 33]]}}}, {"text": "You should pass a Comparator<String[]> instance to the appropriate constructor of PriorityQueue that will be used for comparison, as String[] can't be compared on natural ordering", "label": {"api": {"PriorityQueue": [[82, 94]], "appropriate constructor": [[55, 77]]}}}, {"text": "From PriorityQueue javadocs", "label": {"api": {"PriorityQueue javadocs": [[5, 26]]}}}, {"text": "Supply your own Comparator<String[]> using the PriorityQueue constructor that takes a Comparator", "label": {"api": {"the PriorityQueue constructor that takes a Comparator": [[43, 95]]}}}, {"text": "The PriorityQueue contains elements that are \"ordered according to their natural ordering, or by a Comparator provided at queue construction time.\" Although Sting objects have a natural ordering, arrays of string do not", "label": {"api": {"PriorityQueue": [[4, 16]]}}}, {"text": "Looking at JOptionPane.showInputDialog() javadoc, this method returns a String", "label": {"api": {"JOptionPane.showInputDialog()": [[11, 39]]}}}, {"text": "If you think the data set is too large, try to implement your own cell model, deriving from AbstractTableModel instead", "label": {"api": {"AbstractTableModel": [[92, 109]]}}}, {"text": "Given the class object, it can call getEnumConstants() to find out the number of existing values for this enum", "label": {"api": {"getEnumConstants()": [[36, 53]]}}}, {"text": "You'll find a full list in the Oracle documentation", "label": {"api": {"Oracle documentation": [[31, 50]]}}}, {"text": "Try using System.arraycopy to resize your array each time you need to add to it", "label": {"api": {"System.arraycopy": [[10, 25]]}}}, {"text": "For arrays, length is a member variable, not a method, but in String, length() is an actual method", "label": {"api": {"String, length() is an actual method": [[62, 97]]}}}, {"text": "Check also the Observable class or other variations of the model-view paradigm", "label": {"api": {"Observable": [[15, 24]]}}}, {"text": "Use one of the BlockingQueues, which are thread safe, use lock-free algorithms and have blocking AND non-blocking methods", "label": {"api": {"BlockingQueues": [[15, 28]]}}}, {"text": "What you can do is split the string on the commas, convert each token into an integer and put these values inside a collection", "label": {"api": {"split the string on the commas": [[19, 48]], "convert each token into an integer": [[51, 84]]}}}, {"text": "Note that if you use TreeSet,  because of TreeSet is sorted you have to implement Comparable", "label": {"api": {"Comparable": [[82, 91]]}}}, {"text": "When you implement Comparable you will get what you expected", "label": {"api": {"Comparable": [[19, 28]]}}}, {"text": "Given the nature of the view, I would recommend abandoning images altogether and instead implement the rendering in an Icon", "label": {"api": {"Icon": [[119, 122]]}}}, {"text": "nextLine() advances the scanner past the newline, which means that it captures the entire line", "label": {"api": {"nextLine() advances the scanner": [[0, 30]]}}}, {"text": "You can use System.exit(code) to finish the program", "label": {"api": {"System.exit(code)": [[12, 28]]}}}, {"text": "The nextDouble method returns a random double value between 0.0 inclusive, and 1.0 exclusive", "label": {"api": {"nextDouble method": [[4, 20]]}}}, {"text": "You could also use regular expressions or a class like Formatter to parse the input and handle it", "label": {"api": {"Formatter": [[55, 63]]}}}, {"text": "Look into Comparable and Comparator", "label": {"api": {"Comparable": [[10, 19]], "Comparator": [[25, 34]]}}}, {"text": "It's documented in the documentation of join() (which is the method you should use, instead of wait())", "label": {"api": {"documentation of join()": [[23, 45]]}}}, {"text": "Method getName in java.lang.Class returns also package, so it is not useful in this case", "label": {"api": {"getName": [[7, 13]]}}}, {"text": "Better ḿethod for this case is getSimpleName()", "label": {"api": {"getSimpleName()": [[31, 45]]}}}, {"text": "BTW, why do you want to write your own method, instead of using ArrayList#indexOf(Object) method", "label": {"api": {"ArrayList#indexOf(Object)": [[64, 88]]}}}, {"text": "Object#finalize() is a protected method", "label": {"api": {"Object#finalize()": [[0, 16]]}}}, {"text": "I have a small program that uses the JavaFX MediaPlayer to play a wav file", "label": {"api": {"JavaFX MediaPlayer": [[37, 54]]}}}, {"text": "The variable newVal is listed as type \"Duration\", and the Duration class has methods like toMinutes() and toSeconds(), but I can't apply them to newVal, and I don't understand why", "label": {"api": {"Duration class": [[58, 71]]}}}, {"text": "You can round to the nearest whole integer via Math.round(double)", "label": {"api": {"Math.round(double)": [[47, 64]]}}}, {"text": "Each platform specifies physical fonts to use for the defined logical Font families", "label": {"api": {"Font": [[70, 73]]}}}, {"text": "You can find the details on the Object type documentation", "label": {"api": {"Object type": [[32, 42]]}}}, {"text": "Just use SimpleDateFormat (click the link to see all format patterns)", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "Java's List type does not specify an implementation, only an interface", "label": {"api": {"List": [[7, 10]]}}}, {"text": "The ArrayList type is a List implemented with a dynamic array; the Linkedlist is exactly what the name says", "label": {"api": {"List": [[9, 12], [24, 27]], "ArrayList": [[4, 12]], "Linkedlist": [[67, 76]]}}}, {"text": "You should use Math.pow instead", "label": {"api": {"Math.pow": [[15, 22]]}}}, {"text": "Additionally, you should use BigDecimal when working with currencies, for a number of reasons you will find explained here on SO", "label": {"api": {"BigDecimal": [[29, 38]]}}}, {"text": "You don't show code so no one can fix that for you; anyway, there are classical idioms when dealing with Sockets, or indeed any class which implements Closeable (which Socket does)", "label": {"api": {"which Socket does": [[162, 178]]}}}, {"text": "You can use a DecimalFormat", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "See also ProgressMonitorInputStream, since this is monitoring a download", "label": {"api": {"ProgressMonitorInputStream": [[9, 34]]}}}, {"text": "I think the solution is to use a SpinnerListModel (http://docs.oracle.com/javase/7/docs/api/javax/swing/SpinnerListModel.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/SpinnerListModel.html": [[51, 124]]}}}, {"text": "By the way, as a suggestion, if your item classes have equals() and hashCode() properly implemented, consider a LinkedHashSet (which will preserve insertion order but will not allow duplicates)", "label": {"api": {"LinkedHashSet": [[112, 124]], "Set": [[122, 124]]}}}, {"text": "There are other Set implementations that may be useful too  (e.g", "label": {"api": {"Set": [[16, 18]]}}}, {"text": "TreeSet if your items implement Comparable), depending on your ordering/sorting requirements", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "A Condition is bound to a lock and Condition.await() will effectively unlock, check and wait, and then relock the lock", "label": {"api": {"Condition.await()": [[35, 51]]}}}, {"text": "Use equalsIgnoreCase() if names are case-insensitive", "label": {"api": {"equalsIgnoreCase()": [[4, 21]]}}}, {"text": "Use trim() first if leading/trailing whitespace is an issue", "label": {"api": {"trim()": [[4, 9]]}}}, {"text": "Refer to Enum's .ordinal() to understand why", "label": {"api": {"Enum's .ordinal()": [[9, 25]]}}}, {"text": "In Java 8 or later, the Comparator.naturalOrder() method gives you the same thing, so you don't need to write the class above", "label": {"api": {"Comparator.naturalOrder()": [[24, 48]]}}}, {"text": "toString() is a method declared for each Object and returns a String representation of the class", "label": {"api": {"toString()": [[0, 9]]}}}, {"text": "Using AbstractList, you get a sort of View on your cards list inside the Deck", "label": {"api": {"AbstractList": [[6, 17]]}}}, {"text": "Use a pattern that forces the format to two decimal places", "label": {"api": {"pattern": [[6, 12]]}}}, {"text": "The Java LinkedList implements interface Deque that provides method descendingIterator", "label": {"api": {"Deque": [[41, 45]], "descendingIterator": [[68, 85]]}}}, {"text": "A more complex example is the use of java.sql.Driver in java.sql.DriverManager (in general, factory-type designs make heavy use of this concept) -- an SQL driver implementation may not make implementation classes public (e.g", "label": {"api": {"java.sql.DriverManager": [[56, 77]]}}}, {"text": "Creating a Timer class seems excessive for the use that you propose, not to mention that there is already a Timer class built into Java", "label": {"api": {"Timer": [[11, 15], [108, 112]]}}}, {"text": "If the value is a String, you can use the substring method", "label": {"api": {"substring": [[42, 50]]}}}, {"text": "If it's a float or double, you can divide by 10 and cast to an int or you can use Math.floor() to drop the fractional part after dividing by 10", "label": {"api": {"Math.floor()": [[82, 93]]}}}, {"text": "Take a look at ReadableByteChannel.read() javadoc for example - the method declares only IOException in its throws clause, but describes a lot of more specific subclasses of that exception in its javadoc", "label": {"api": {"ReadableByteChannel.read()": [[15, 40]]}}}, {"text": "You need to use Collections#sort", "label": {"api": {"Collections#sort": [[16, 31]]}}}, {"text": "You can use pack() method that is implemented in Window class which is the sub-class of Container class", "label": {"api": {"pack()": [[12, 17]], "Window": [[49, 54]], "Container": [[88, 96]]}}}, {"text": "You will need to grant it the \"getNetworkInformation\" permission", "label": {"api": {"\"getNetworkInformation\" permission": [[30, 63]]}}}, {"text": "According to javadoc, Scanner by default use localized symbols; read the section Localized numbers", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "Use the iterator() function described here to get hold of an iterator on the HashSet and then get the elements from that", "label": {"api": {"described here": [[28, 41]]}}}, {"text": "See Class#forName() for more details on this", "label": {"api": {"Class#forName()": [[4, 18]]}}}, {"text": "It seems like ArrayDeque fits all your requirements", "label": {"api": {"ArrayDeque": [[14, 23]]}}}, {"text": "Most ArrayDeque operations run in amortized constant time", "label": {"api": {"ArrayDeque": [[5, 14]]}}}, {"text": "You can also achieve the same result with String.format()", "label": {"api": {"String.format()": [[42, 56]]}}}, {"text": "It can be used for basic and simple code, but if you really want to dive into threading, you should not use it, but use the concurrent package and it's classes and features instead", "label": {"api": {"concurrent package": [[124, 141]]}}}, {"text": "Use a TreeSet which will sort the elements inside it", "label": {"api": {"TreeSet": [[6, 12]]}}}, {"text": "Note that your Computer class won't need to implement equals nor hashCode to be used inside a TreeSet", "label": {"api": {"TreeSet": [[94, 100]]}}}, {"text": "This is how standard defines the sendRedirect()", "label": {"api": {"sendRedirect()": [[33, 46]]}}}, {"text": "Yes, that's what ArrayList#remove (and List#remove generally) is for", "label": {"api": {"ArrayList#remove": [[17, 32]]}}}, {"text": "I see that there are a ton of generic data structures provided in Java", "label": {"api": {"generic data structures provided in Java": [[30, 69]]}}}, {"text": "One thread will take care to read every line of the file and insert it into a BlockingQueue in order to be processed", "label": {"api": {"BlockingQueue": [[78, 90]], "take": [[16, 19]]}}}, {"text": "Another thread(s) will take the elements from this queue and process them", "label": {"api": {"take": [[23, 26]]}}}, {"text": "To implement this multi thread work, it would be better using ExecutorService interface and passing Runnable instances, each should implement each task", "label": {"api": {"ExecutorService": [[62, 76]]}}}, {"text": "It uses System.arraycopy, with which you could take a similar approach to what you are doing, and have", "label": {"api": {"System.arraycopy": [[8, 23]]}}}, {"text": "The StringBuilder class does not override hashCode, so it inherits the hashCode method from Object", "label": {"api": {"The StringBuilder class does not override hashCode": [[0, 49]], "the hashCode method from Object": [[67, 97]]}}}, {"text": "Reading the constructor details of ImageIcon it says that it starts the loading of the URL, but doesn't block", "label": {"api": {"constructor details of ImageIcon": [[12, 43]]}}}, {"text": "You can check for when the image is done loading by imageIcon.getImageLoadStatus() method", "label": {"api": {"imageIcon.getImageLoadStatus()": [[52, 81]]}}}, {"text": "Add an ActionListener to your JButton enter like so", "label": {"api": {"ActionListener": [[7, 20]]}}}, {"text": "See Object.wait() for example", "label": {"api": {"Object.wait()": [[4, 16]]}}}, {"text": "It's just because next returns only the first word (or also called the first 'token')", "label": {"api": {"next": [[18, 21]]}}}, {"text": "To read the entire line, use nextLine", "label": {"api": {"next": [[29, 32]]}}}, {"text": "The other thing you can do is go ahead and use next all the way (instead of a split) because Scanner already searches for tokens using whitespace by default", "label": {"api": {"next": [[47, 50]]}}}, {"text": "It seems that the proper way to deal with such tasks (declare already implemented interface) is to either use dynamic proxies (as suggested in this SO post) or 3rd-party tools (such as javassist or CGLIB as pointed out here)", "label": {"api": {"dynamic proxies": [[110, 124]]}}}, {"text": "You can probably do this with the java.awt.Robot class", "label": {"api": {"java.awt.Robot": [[34, 47]]}}}, {"text": "The Object parameter of Field#getInt must be an instance of class A", "label": {"api": {"Field#getInt": [[24, 35]]}}}, {"text": "The interface javax.websocket.MessageHandler.Whole should be what you are looking for", "label": {"api": {"javax.websocket.MessageHandler.Whole": [[14, 49]]}}}, {"text": "You can simply use a HashSet Which accepts unique records, and returns false when the record(key) already exists", "label": {"api": {"HashSet": [[21, 27]]}}}, {"text": "Here is the source code of the equals method in Integer (value here is an int primitive)", "label": {"api": {"equals": [[31, 36]]}}}, {"text": "And here is the source code of the equals method in Long (value here is a long primitive)", "label": {"api": {"equals": [[35, 40]]}}}, {"text": "From the source, the equals method firstly checks if the passed-in obj is an instance of the corresponding class", "label": {"api": {"equals": [[21, 26]]}}}, {"text": "If it isn't, equals skips the check on the primitive value and returns false", "label": {"api": {"equals": [[13, 18]]}}}, {"text": "Have you checked the PriorityQueue API to see what it expects", "label": {"api": {"PriorityQueue API": [[21, 37]]}}}, {"text": "Nowhere in the PriorityQueue API is there mention of Priorizable", "label": {"api": {"PriorityQueue API": [[15, 31]]}}}, {"text": "System.out.println() simply calls toString() on your object to transform it to a String", "label": {"api": {"toString()": [[34, 43]]}}}, {"text": "Since you haven't overridden toString() in Employee, the default Object.toString() method is called, which displays the type of the object (Employee) frollowed by its hashCode()", "label": {"api": {"toString()": [[29, 38], [72, 81]]}}}, {"text": "I took a look at its API at http://docs.oracle.com/javaee/6/api/javax/ws/rs/Produces.html but I didn't find my answer", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/ws/rs/Produces.html": [[28, 88]]}}}, {"text": "You must use fast I/O, i.e., BufferedReader and BufferedWriter classes instead of Scanner (take a look at this blog post)", "label": {"api": {"BufferedReader": [[29, 42]], "BufferedWriter": [[48, 61]], "Scanner": [[82, 88]]}}}, {"text": "Additional to @SURESH ATTA, you can use Map to define your data structure, the key would be save as index and value would be your integers", "label": {"api": {"Map": [[40, 42]]}}}, {"text": "Use substring method of String class", "label": {"api": {"substring": [[4, 12]], "String": [[24, 29]]}}}, {"text": "String#split takes a regular expression as parameter", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "You could also use the method Pattern#quote to simplify the task", "label": {"api": {"Pattern#quote": [[30, 42]]}}}, {"text": "The documentation for the String split function says that the input string is treated as a regular expression (with a link explaining how that works)", "label": {"api": {"documentation for the String split function": [[4, 46]], "regular expression": [[91, 108]]}}}, {"text": "As Germann points out, '*' is a special character in regular expressions", "label": {"api": {"regular expression": [[53, 70]]}}}, {"text": "An ExecutorService has just the method for that", "label": {"api": {"just the method for that": [[23, 46]]}}}, {"text": "if you use Java 7, use the new Files API", "label": {"api": {"Files": [[31, 35]]}}}, {"text": "Is java.util.logging.FileHandler in Java 8 broken?, JavaLogger randomly writes to a second file and FileLock", "label": {"api": {"FileLock": [[100, 107]]}}}, {"text": "using an ImageProcessor or, if necessary, a BufferedImage)", "label": {"api": {"BufferedImage": [[44, 56]]}}}, {"text": "You can load an existing class via Class.forName; your class could also have a static initializer static { /* your init code */ } so that it could be run while loading the class", "label": {"api": {"Class.forName": [[35, 47]]}}}, {"text": "You might want to try an XPath query for the attributes something like /trkseg/trkpt/@lat to get all the latitudes", "label": {"api": {"XPath": [[25, 29]]}}}, {"text": "Have you tried looking at @AssociationOverride", "label": {"api": {"@AssociationOverride": [[26, 45]]}}}, {"text": "The AynchronousSocketChannel and AsynchronousServerSocketChannel come into their own when using the methods that take a CompletionHandler", "label": {"api": {"AynchronousSocketChannel": [[4, 27]], "AsynchronousServerSocketChannel": [[33, 63]], "CompletionHandler": [[120, 136]]}}}, {"text": "Where ConnectionHander is an implementation of CompletionHandler that deals with client connections", "label": {"api": {"CompletionHandler": [[47, 63]]}}}, {"text": "The thread that makes the accept call can then continue doing other work and the NIO API will deal with scheduling the callback to the CompletionHandler when a client connection is made (I believe this is an OS level interupt)", "label": {"api": {"CompletionHandler": [[135, 151]], "accept": [[26, 31]]}}}, {"text": "If you just wish to wait for both threads to complete you should use the Thread join method, which is specifically designed for this", "label": {"api": {"join": [[80, 83]]}}}, {"text": "The center of the oval is relative to the starting top left corner of the oval that you supply in the first two parameters", "label": {"api": {"first two parameters": [[102, 121]]}}}, {"text": "drawOval accepts the top-left position and the width and height, not the centre position and the width and height", "label": {"api": {"drawOval": [[0, 7]]}}}, {"text": "You can use the nio2 Files.newDirectoryStream method with an additional pattern matcher to only list files which match the pattern", "label": {"api": {"Files.newDirectoryStream": [[21, 44]]}}}, {"text": "There is, of course, java.awt.Rectangle, which may help you on your quest", "label": {"api": {"java.awt.Rectangle": [[21, 38]]}}}, {"text": "According to the documentation, Java throws a java.lang.StackOverflowError error under the following circumstance", "label": {"api": {"java.lang.StackOverflowError": [[46, 73]]}}}, {"text": "But instead of all this if, I would use a DateFormatSymbols object", "label": {"api": {"DateFormatSymbols": [[42, 58]]}}}, {"text": "They are parameters, not attributes, use ServletRequest#getParameter instead", "label": {"api": {"ServletRequest#getParameter": [[41, 67]]}}}, {"text": "Just build it using charAt()", "label": {"api": {"charAt()": [[20, 27]]}}}, {"text": "Why are Java HashMap not like EnumMaps or other special hashtable collections that do not require a hash (because the hash is pre-calculated)", "label": {"api": {"EnumMap": [[30, 36]]}}}, {"text": "If you want a faster HashMap (ie fast hash) then certain assumptions need to be made about the data your storing in the Map (like EnumMap)", "label": {"api": {"EnumMap": [[130, 136]]}}}, {"text": "Change your String.format parameters", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "For the ImageIcon, it's because you have the arguments in the wrong order", "label": {"api": {"the arguments in the wrong order": [[41, 72]]}}}, {"text": "The doc says the path is converted to URL and to use forward slashes", "label": {"api": {"The doc": [[0, 6]]}}}, {"text": "The doc says the image is loaded in the background", "label": {"api": {"The doc": [[0, 6]]}}}, {"text": "StyledDocument contains various methods to set styles", "label": {"api": {"StyledDocument": [[0, 13]]}}}, {"text": "StyledDocument has a removeStyle method that removes the named style", "label": {"api": {"StyledDocument": [[0, 13]]}}}, {"text": "The constant Integer.MAX_VALUE is the maximum possible int, 2147483647", "label": {"api": {"Integer.MAX_VALUE is the maximum possible int, 2147483647": [[13, 69]]}}}, {"text": "Parse a long with Long.parseLong, which can handle larger numbers (or reduce the number of digits in ab and/or abc)", "label": {"api": {"Long.parseLong": [[18, 31]]}}}, {"text": "The constant Long.MAX_VALUE is the maximum possible long, 9223372036854775807L, which is 19 digits", "label": {"api": {"Long.MAX_VALUE is the maximum possible long, 9223372036854775807L": [[13, 77]]}}}, {"text": "You get this guarantee with any List, including ArrayList", "label": {"api": {"List": [[32, 35], [53, 56]], "ArrayList": [[48, 56]]}}}, {"text": "I recommend an ArrayList as it is generally a good idea to use specific implementations in GWT to reduce serialization code", "label": {"api": {"List": [[20, 23]], "ArrayList": [[15, 23]]}}}, {"text": "LinkList is another option, and there is a good comparison when to use it instead of ArrayList", "label": {"api": {"List": [[4, 7], [90, 93]], "ArrayList": [[85, 93]]}}}, {"text": "When to use LinkedList over ArrayList", "label": {"api": {"List": [[18, 21], [33, 36]], "ArrayList": [[28, 36]]}}}, {"text": "The reason mine works and yours doesn't is because the first parameter of substring is where to start", "label": {"api": {"substring": [[74, 82]]}}}, {"text": "So better choice is to use one of the queues found in the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[58, 77]]}}}, {"text": "You have to use BigDecimal instead of double", "label": {"api": {"BigDecimal": [[16, 25]]}}}, {"text": "Unfortunately, StrictMath doesn't support BigDecimal, so you will have to use another library, or your own implementation of sin/cos/tan", "label": {"api": {"BigDecimal": [[42, 51]]}}}, {"text": "you've reached the end of the underlying stream", "label": {"api": {"you've reached the end of the underlying stream": [[0, 46]]}}}, {"text": "Set<>.equals is defined in exactly the way that you want it to be", "label": {"api": {"Set<>.equals": [[0, 11]]}}}, {"text": "I know this question is 3 years old, but with the java.time classes built into Java 8 and later, this problem can now be resolved with an elegant short code, without Joda-Time", "label": {"api": {"java.time": [[50, 58]]}}}, {"text": "The WeekFields object can also be defined from a Locale by calling WeekFields.of( Locale )", "label": {"api": {"WeekFields": [[4, 13], [67, 76]], "Locale": [[49, 54], [82, 87]], "WeekFields.of( Locale )": [[67, 89]]}}}, {"text": "JPA offers @OrderColumn for that purpose", "label": {"api": {"@OrderColumn": [[11, 22]]}}}, {"text": "You can read more about AWT Threads, which states that ..", "label": {"api": {"AWT Threads": [[24, 34]]}}}, {"text": "Sounds like you're looking for a Map", "label": {"api": {"Map": [[33, 35]]}}}, {"text": "EDIT - With this particular input/output, since you don't have a delimiter, Scanner may not be the way to go here, but if you've got a delimiter between commands, it would be a great option, so I'll keep the answer here in the hopes it might help someone in the future", "label": {"api": {"Scanner": [[76, 82]]}}}, {"text": "I'd look at the Scanner class if I were you", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "The Scanner can wrap your input stream, and then scan based on a regex or delimter to grab chunks of input", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "It's writing it to the output stream of the URLConnection - which is basically used for the body of an HTTP request (assuming it's an HTTP URL, of course)", "label": {"api": {"URLConnection": [[44, 56]]}}}, {"text": "You can let Java quote sepcial characters using Pattern.quote", "label": {"api": {"Pattern.quote": [[48, 60]]}}}, {"text": "What about String.indexof(String) (which is faster)", "label": {"api": {"String.indexof(String)": [[11, 32]]}}}, {"text": "The Map JavaDoc says", "label": {"api": {"Map JavaDoc": [[4, 14]]}}}, {"text": "According to the HashMap API", "label": {"api": {"HashMap API": [[17, 27]]}}}, {"text": "And the Hashtable API", "label": {"api": {"Hashtable API": [[8, 20]]}}}, {"text": "Use isInstance (http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#isInstance%28java.lang.Object%29)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#isInstance%28java.lang.Object%29": [[16, 109]]}}}, {"text": "Provider your Scanner with a delimiter (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html#useDelimiter(java.lang.String)) so it will get rid of the commas by itself", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html#useDelimiter(java.lang.String)": [[40, 137]]}}}, {"text": "I think what you are looking for is the entrySet() method of Map", "label": {"api": {"entrySet()": [[40, 49]]}}}, {"text": "keySet returns a parameterized Set<K> which you can use here, as do all of the Collections methods that return another kind of Collection", "label": {"api": {"keySet": [[0, 5]]}}}, {"text": "Create a custom class which implements Iterator and return the custom Iterator from your CLL.iterator method", "label": {"api": {"Iterator": [[39, 46], [70, 77]]}}}, {"text": "See LinkedList#ListItr for inspiration - but only conside the Iterator methods (next, hasNext, remove) for this exercise", "label": {"api": {"Iterator": [[62, 69]]}}}, {"text": "In addition, the CLL class should conform to Iterable, which means it has an iterator method to obtain an Iterator", "label": {"api": {"Iterator": [[106, 113]], "Iterable": [[45, 52]]}}}, {"text": "You can also use String.equalsIgnoreCase() if names are case-insensitive, possibly using trim() first if leading/trailing whitespace is an issue, too", "label": {"api": {"String.equalsIgnoreCase()": [[17, 41]], "trim()": [[89, 94]]}}}, {"text": "Use java.sql.Timestamp class which holds date and time for sql fields, and CallableStatement#setTimestamp", "label": {"api": {"java.sql.Timestamp": [[4, 21]], "CallableStatement#setTimestamp": [[75, 104]]}}}, {"text": "You can use NumberFormat with Locale#US", "label": {"api": {"NumberFormat": [[12, 23]], "Locale#US": [[30, 38]]}}}, {"text": "Use ClassLoader.getResources(String name) and write code to filter out URLs that are not in the same package as the class", "label": {"api": {"ClassLoader.getResources(String name)": [[4, 40]]}}}, {"text": "Alternatively you might just use a normal ArrayList and roll out your own solution using ReentrantReadWriteLock This should work OK in case you have more reads than writes", "label": {"api": {"ReentrantReadWriteLock": [[89, 110]]}}}, {"text": "The simple way is to have a number of threads each of which creates a ServerSocket, binds to a port, and then calls accept on it", "label": {"api": {"ServerSocket": [[70, 81]]}}}, {"text": "If you're just interested in the current time since Jan 1 1970 UTC in milliseconds, use System.currentTimeMillis()see javadoc", "label": {"api": {"see javadoc": [[114, 124]]}}}, {"text": "You could use Collections.sort() and then specify the Comparator where ascending or descending", "label": {"api": {"Collections.sort()": [[14, 31]]}}}, {"text": "Use String.IndexOf() to find the first occurence of the char", "label": {"api": {"String.IndexOf()": [[4, 19]]}}}, {"text": "Call String.Substring() from your new beginning index to line.length", "label": {"api": {"String.Substring()": [[5, 22]]}}}, {"text": "Problem is that matches method checks if entire input String can be matched by regex, not if it contains substring that can be matched by regex", "label": {"api": {"matches": [[16, 22]]}}}, {"text": "Maybe use find() method from Matcher class instead", "label": {"api": {"find()": [[10, 15]]}}}, {"text": "If you really need to use matches then you can just add .* at start and end of your regex so parts beside required one could also be consumed by regex", "label": {"api": {"matches": [[26, 32]]}}}, {"text": "Convert the string to lower case characters using the String.toLowerCase() method", "label": {"api": {"String.toLowerCase()": [[54, 73]]}}}, {"text": "If you dont want to mess with bit arithmetics you could simply use standard Java API Integer.signum", "label": {"api": {"Integer.signum": [[85, 98]]}}}, {"text": "You should also take a look at printf (an example) to print out tables", "label": {"api": {"printf": [[31, 36]]}}}, {"text": "ResourceBundle allows to retrieve textual data for a key, returning a result based on a specified locale", "label": {"api": {"ResourceBundle": [[0, 13]]}}}, {"text": "You might also look into the Java compiler API or into tools like Spoon which you could apply in your build process", "label": {"api": {"Java compiler API": [[29, 45]]}}}, {"text": "The variable timestampsList is an ArrayList of String's, all respecting the pattern used by the SimpleDateFormat object", "label": {"api": {"ArrayList": [[34, 42]], "SimpleDateFormat": [[96, 111]]}}}, {"text": "The problem with the given code is that I can't generate the value of the sum of the timestamps, by using the same SimpleDateFormat what I get is an hour in the pattern informed in a future date", "label": {"api": {"SimpleDateFormat": [[115, 130]]}}}, {"text": "What will happen if I copy the a piece of my audio data to the buffer by System.arraycopy() and the remaining Audio data is smaller than 65536", "label": {"api": {"System.arraycopy()": [[73, 90]]}}}, {"text": "That forces a few core Java APIs to accept many different types of primitive arrays, such as Arrays.sort, which has overloads for many different types of primitive arrays", "label": {"api": {"Arrays.sort": [[93, 103]]}}}, {"text": "BlockingQueue.take() will block until an element is available", "label": {"api": {"BlockingQueue.take()": [[0, 19]]}}}, {"text": "Another approach could be to use the overload of poll that takes a timeout value instead of take(), and have the logic be that BigFileProcessor breaks it's loop if it can't read anything from the queue for more than N seconds, etc", "label": {"api": {"the overload of poll that takes a timeout value": [[33, 79]]}}}, {"text": "See JToolBar.addSeparator() which", "label": {"api": {"JToolBar.addSeparator()": [[4, 26]]}}}, {"text": "Or JToolBar.addSeparator(Dimension) which", "label": {"api": {"JToolBar.addSeparator(Dimension)": [[3, 34]]}}}, {"text": "The JDK's Proxy class contains static methods to do just that", "label": {"api": {"Proxy": [[10, 14]]}}}, {"text": "Second, because equals is required to be symmetric", "label": {"api": {"equals is required to be symmetric": [[16, 49]]}}}, {"text": "Instead of adding these into a fixed array add them into a java list", "label": {"api": {"list": [[64, 67]]}}}, {"text": "Once you have filled the list up use listClass.size() to retrieve the size of the list", "label": {"api": {"list": [[25, 28], [37, 40], [82, 85]]}}}, {"text": "The MediaItem@3c4568f8 output is the result of Object's toString() method", "label": {"api": {"Object's toString() method": [[47, 72]]}}}, {"text": "You have to use (for instance) String.valueOf(), ie", "label": {"api": {"String.valueOf()": [[31, 46]]}}}, {"text": "You can tell this if add returns false; then you don't have to check the rest of the array", "label": {"api": {"add": [[21, 23]]}}}, {"text": "The reason is that Math.ceil returns a double", "label": {"api": {"Math.ceil returns a double": [[19, 44]]}}}, {"text": "The Process class gives you an exit value Process.exitValue() this will typically be 0 for success and non-zero for failure/error", "label": {"api": {"Process.exitValue()": [[42, 60]]}}}, {"text": "Switch to using a Scanner so you can can call nextLine() to read an entire line of input at once, and you can extract the first character of the String to see if it's 'y' or 'Y'", "label": {"api": {"Scanner so you can can call nextLine()": [[18, 55]]}}}, {"text": "You should have a look at the selectedItemProperty which always points to the last selected item", "label": {"api": {"selectedItemProperty": [[30, 49]]}}}, {"text": "If you want to store the integer value in a String, use String.valueOf", "label": {"api": {"String.valueOf": [[56, 69]]}}}, {"text": "See for example this or the javadocs for more information", "label": {"api": {"the javadocs": [[24, 35]]}}}, {"text": "From the Lock doc", "label": {"api": {"Lock doc": [[9, 16]]}}}, {"text": "The PostgreSQL JDBC driver provides a org.postgresql.util.HStoreConverter utility class with to/from String and byte[] conversion", "label": {"api": {"Converter": [[64, 72]], "Convert": [[64, 70]]}}}, {"text": "You can use it to implement your own JPA 2.1 Converter", "label": {"api": {"Converter": [[45, 53]], "Convert": [[45, 51]]}}}, {"text": "Then, use it with the JPA Convert annotation in your entity", "label": {"api": {"Convert": [[26, 32]]}}}, {"text": "However, using the Converter to map to a generic Map<> has earlier been blocked by the Hibernate bug HHH-8804, but that has been fixed in Hibernate 5.0.0 and 4.3.11", "label": {"api": {"Converter": [[19, 27]], "Convert": [[19, 25]]}}}, {"text": "Parse the page's URL", "label": {"api": {"URL": [[17, 19]]}}}, {"text": "If the tag was protocol-relative, use the protocol from the parsed page URL, then append the content of the attribute", "label": {"api": {"URL": [[72, 74]]}}}, {"text": "If it's relative, strip the query string and fragment IF from the original URL, and \"append\" the relative portion", "label": {"api": {"URL": [[75, 77]]}}}, {"text": "Be aware that a relative URL can look like /foo, foo, foo/bar, or ./../../bar/../foo, so you might want to resolve path traversals before printing", "label": {"api": {"URL": [[25, 27]]}}}, {"text": "Take a look at URL and the Commons URL Builder", "label": {"api": {"URL": [[15, 17], [35, 37]]}}}, {"text": "You're calling toString() on an array - arrays don't override toString(), so you end up with the implementation from Object", "label": {"api": {"implementation from Object": [[97, 122]]}}}, {"text": "scan.close(); also closes System.in so that no more data can be read from the stream", "label": {"api": {"System.in": [[26, 34]]}}}, {"text": "So when you start reading from scan1, System.in will no longer return any data", "label": {"api": {"System.in": [[38, 46]]}}}, {"text": "Look at the docs of Scanner#close() for more info", "label": {"api": {"Scanner#close()": [[20, 34]]}}}, {"text": "And if you look at the docs of System.in, you can see that it does implement the Closeable interface", "label": {"api": {"System.in": [[31, 39]]}}}, {"text": "Thus the InputStream#close() is called and that closes the InputStream leaving you without a input stream to read data from", "label": {"api": {"InputStream#close()": [[9, 27]]}}}, {"text": "I'm writing some code that calls Field.set and Field.get many many thousands of times", "label": {"api": {"Field.set": [[33, 41]]}}}, {"text": "I want to see if I can improve performance using MethodHandle in Java 7", "label": {"api": {"MethodHandle": [[49, 60]]}}}, {"text": "However, this doesn't seem to perform better than the Field.set call using reflection", "label": {"api": {"Field.set": [[54, 62]]}}}, {"text": "I read that using invokeExact could be faster but when I tried using that I got a java.lang.invoke.WrongMethodTypeException", "label": {"api": {"invokeExact": [[18, 28]], "java.lang.invoke.WrongMethodTypeException": [[82, 122]]}}}, {"text": "Has anyone successfully been able to optimize repeated calls to Field.set or Field.get", "label": {"api": {"Field.set": [[64, 72]]}}}, {"text": "Serializable is a marker interface", "label": {"api": {"Serializable": [[0, 11]]}}}, {"text": "If a class A implements Serializable and the other class B & C extend  A, then are they both get serialize even if there's no method to implement", "label": {"api": {"Serializable": [[24, 35]]}}}, {"text": "Arrays.copyOf will work for you", "label": {"api": {"Arrays.copyOf": [[0, 12]]}}}, {"text": "In particular, try using List<String>, instead of String[]", "label": {"api": {"List": [[25, 28]]}}}, {"text": "As you can see in the javadoc, System.lineSeparator() doesn't exists in java < 7", "label": {"api": {"in the javadoc": [[15, 28]]}}}, {"text": "On Windows the JDK is 7 which has System.lineSeparator() method defined", "label": {"api": {"System.lineSeparator(": [[34, 54]], "System": [[34, 39]]}}}, {"text": "The same method does not exist in the previous JDK verions  (check System class in Java 6) which is running on your Linux box", "label": {"api": {"System": [[67, 72]]}}}, {"text": "For the backward compatible code use System.getProperty(\"line.separator\")", "label": {"api": {"System": [[37, 42]]}}}, {"text": "You have to parse it into an enum first", "label": {"api": {"parse it into an enum": [[12, 32]]}}}, {"text": "I don't understand your problem very well, but if you want to take a part of a String, the substring method should do the job", "label": {"api": {"substring": [[91, 99]]}}}, {"text": "You should either use a switch or a Map to associate your string identifiers with your actual objects", "label": {"api": {"Map": [[36, 38]]}}}, {"text": "Use setDateFormatOverride() on the axis with a suitable DateFormat", "label": {"api": {"DateFormat": [[7, 16], [56, 65]]}}}, {"text": "The isLast method only determines if you're on the last row, not the last column", "label": {"api": {"isLast": [[4, 9]]}}}, {"text": "The way to determine the number of columns is to get the ResultSetMetaData object from the ResultSet and get the number of columns from it, using the getMetaData() method on the ResultSet and the getColumnCount() method on the ResultSetMetaData", "label": {"api": {"getMetaData() method": [[150, 169]], "getColumnCount() method": [[196, 218]]}}}, {"text": "Use the Java Observer/Observable pattern", "label": {"api": {"Observer": [[13, 20]], "Observable": [[22, 31]]}}}, {"text": "StarTest implements the Observer interface", "label": {"api": {"Observer": [[24, 31]]}}}, {"text": "You connect Observer and Observable as follows", "label": {"api": {"Observer": [[12, 19]], "Observable": [[25, 34]]}}}, {"text": "You can use String's charAt method to get the first character and the Character toUpperCase method to convert it to upper case", "label": {"api": {"charAt": [[21, 26]], "toUpperCase": [[80, 90]]}}}, {"text": "Then use the substring method to get everything after the first character", "label": {"api": {"substring": [[13, 21]]}}}, {"text": "You may want to use a Map to map each product with its cost", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "I think the problem is that you never take the selected file", "label": {"api": {"take the selected file": [[38, 59]]}}}, {"text": "You can use Matcher.group (int groupNum)", "label": {"api": {"Matcher.group (int groupNum)": [[12, 39]]}}}, {"text": "You need to get the parent of the file you pass which is the directory you may want to create using File#getParentFile()", "label": {"api": {"File#getParentFile()": [[100, 119]]}}}, {"text": "This method returns a File object of witch you have to call File#mkdirs()", "label": {"api": {"File#mkdirs()": [[60, 72]]}}}, {"text": "If you want the first call to next()/previous() to return the last element you could use listIterator(int index) and pass it list.size() -1 if you want to iterate forward or list.size() if you want to iterate backward", "label": {"api": {"listIterator(int index)": [[89, 111]]}}}, {"text": "GroupLayout was incorporated into the JSE in Java 6", "label": {"api": {"GroupLayout": [[0, 10]]}}}, {"text": "But if you want something more complex, based on LC_COLLATE, you will have to use a Collator and maybe define your own RuleBasedCollator", "label": {"api": {"Collator": [[84, 91], [128, 135]], "RuleBasedCollator": [[119, 135]]}}}, {"text": "Look through the methods of JList in the docs", "label": {"api": {"methods of JList": [[17, 32]]}}}, {"text": "Your compression program uses zlib (see JDK documentation), so you need to use a C++ zlib library to decompress its output", "label": {"api": {"JDK documentation": [[40, 56]]}}}, {"text": "Use a prepared statement instead", "label": {"api": {"prepared statement": [[6, 23]]}}}, {"text": "If you want your fight number to be alpha numeric then int is not the correct data type, you should use String and for validating that you could use the String method matches in conjunction with a regular expression", "label": {"api": {"matches": [[167, 173]]}}}, {"text": "Then you'll use Matcher.find() to find each occurrence", "label": {"api": {"Matcher.find()": [[16, 29]]}}}, {"text": "I don't think there's a right (or intended) way to do this since all of this is under a layer of abstraction in the form of the ClassLoader", "label": {"api": {"ClassLoader": [[128, 138]]}}}, {"text": "If you know the location of the jar file, you could just treat it as a zip file and open it with the ZipFile class, but this would be a major hack", "label": {"api": {"ZipFile": [[101, 107]]}}}, {"text": "You probably should be using JComponent which is has setToolTipText", "label": {"api": {"setToolTipText": [[53, 66]]}}}, {"text": "split takes a regular expression as parameter", "label": {"api": {"split": [[0, 4]]}}}, {"text": "Another solution would be to use Pattern.quote", "label": {"api": {"Pattern.quote": [[33, 45]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/package-list, and save that file to the folder you specified", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/package-list": [[0, 52]]}}}, {"text": "You should implement your own Comparator to define such an ordering", "label": {"api": {"Comparator": [[30, 39]]}}}, {"text": "Instead use the appropriate date setter method in the PreparedStatement class", "label": {"api": {"PreparedStatement": [[54, 70]]}}}, {"text": "The FileOutputStream will - by default (or, whenever not created for appending) - truncate the output file", "label": {"api": {"not created for appending": [[53, 77]]}}}, {"text": "Also, in this case equalsIgnoreCase may be helpful for you", "label": {"api": {"equalsIgnoreCase": [[19, 34]]}}}, {"text": "Because you are using Scanner on a file, Scanner can actually tell you this information with hasNextDouble", "label": {"api": {"hasNextDouble": [[93, 105]]}}}, {"text": "To get the input of user you can use Scanner", "label": {"api": {"Scanner": [[37, 43]]}}}, {"text": "You can use Scanner to read int, float, double, String..", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "To avoid this, the java.time API has a clear rule", "label": {"api": {"clear rule": [[39, 48]]}}}, {"text": "I think you should use Arrays.copyOfRange() to create a copy of your array", "label": {"api": {"Arrays.copyOfRange()": [[23, 42]]}}}, {"text": "As far as the -1, that is answered by the JavaDoc of indexOf", "label": {"api": {"JavaDoc of indexOf": [[42, 59]]}}}, {"text": "You need to invoke a method such as Scanner#nextLine() to read input and then compare the read value to \"me\" or \"Me\"", "label": {"api": {"Scanner#nextLine()": [[36, 53]]}}}, {"text": "You might want to use String#equalsIgnoreCase for case-insensitive matching too", "label": {"api": {"String#equalsIgnoreCase": [[22, 44]]}}}, {"text": "On strings, you can use substring() to get the string parts", "label": {"api": {"substring()": [[24, 34]]}}}, {"text": "Then you can use a CharsetDecoder to try and map the bytes read into one or more encodings", "label": {"api": {"CharsetDecoder": [[19, 32]]}}}, {"text": "That's done using the Integer.parseInt() method", "label": {"api": {"Integer.parseInt()": [[22, 39]]}}}, {"text": "Of course, if one of the text fields contains text that doesn't represent an integer, you'll get an exception, as documented in the Integer.parseInt() javadoc", "label": {"api": {"Integer.parseInt()": [[132, 149]]}}}, {"text": "What you want to do is load the resource from within the archive, which you can do using the java.lang.Class.getResourceAsStream(String) function", "label": {"api": {"java.lang.Class.getResourceAsStream(String)": [[93, 135]]}}}, {"text": "You might want to read oracle's documentation on regular expressions for more information", "label": {"api": {"oracle's documentation": [[23, 44]]}}}, {"text": "I have little experience with it, but if you look at the docs for TimeZone you should be able to come up with an algortithm o print out all timezones installed on your system", "label": {"api": {"TimeZone": [[66, 73]]}}}, {"text": "You should use JFileChooser if you want to let the users choose where to save the file", "label": {"api": {"JFileChooser": [[15, 26]]}}}, {"text": "As discussed in this question, you can create your own subclass of EventQueue which inspects events, and create a place in the code where you can set your break point and only catch certain kinds of events", "label": {"api": {"EventQueue": [[67, 76]]}}}, {"text": "Then your best bet is to use a JTextField inside of a JFrame", "label": {"api": {"JTextField": [[31, 40]], "JFrame": [[54, 59]]}}}, {"text": "Another solution would be to use Scanner with delimiter \",\" and pair returned parts", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "You can use the overloaded Integer.parseInt(String s, int radix) method for such a conversion", "label": {"api": {"Integer.parseInt(String s, int radix)": [[27, 63]]}}}, {"text": "Just parse it into an int with Integer.parseInt(String s, int radix)", "label": {"api": {"Integer.parseInt(String s, int radix)": [[31, 67]]}}}, {"text": "I think you actually want Byte.parseByte(String, int) which allows you to specify the radix", "label": {"api": {"Byte.parseByte(String, int)": [[26, 52]]}}}, {"text": "Worth mentioning String#toLowerCase", "label": {"api": {"String#toLowerCase": [[17, 34]]}}}, {"text": "Or simply use String#equalsIgnoreCase", "label": {"api": {"String#equalsIgnoreCase": [[14, 36]]}}}, {"text": "what would fit into a long), you could use a BitSet", "label": {"api": {"BitSet": [[45, 50]]}}}, {"text": "Use the Path API to specify the path to your file - I'd suggest using a call to String.format instead of all that concatenation, too", "label": {"api": {"Path": [[8, 11]]}}}, {"text": "From @Column annotation documentation i verified nullable attribute has true as default value", "label": {"api": {"@Column": [[5, 11]]}}}, {"text": "For efficiency, I would simply use a StringBuilder", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "You're calling the parameterless getDisplayName() method whose documentation includes", "label": {"api": {"getDisplayName()": [[33, 48]]}}}, {"text": "Your code will give you a list of 'hashes' (it's not actually the hash code) because that's what the default implementation of toString does", "label": {"api": {"toString": [[127, 134]]}}}, {"text": "The basic layout of your code should be something like this (I've removed some fields to keep the length down and used Apache commons-lang to help with the equals, hashCode and toString methods)", "label": {"api": {"toString": [[177, 184]]}}}, {"text": "java.util.UUID is a class in Java, which means a reference to this type can have the value null", "label": {"api": {"java.util.UUID": [[0, 13]]}}}, {"text": "The java regex Pattern class provides this", "label": {"api": {"Pattern class ": [[15, 28]]}}}, {"text": "In your case I would suggest you override JTable.prepareRenderer() method instead to set rows background color independently of the renderer type (JLabel, JCheckBox, or even custom renderers)", "label": {"api": {"JTable.prepareRenderer()": [[42, 65]]}}}, {"text": "Yes - for Java 7 use a WatchService", "label": {"api": {"WatchService": [[23, 34]]}}}, {"text": "In addition to writeChars(), which would work, there is a writeUTF8() method that will work as well", "label": {"api": {"writeUTF8()": [[58, 68]]}}}, {"text": "You can use printf()", "label": {"api": {"printf()": [[12, 19]]}}}, {"text": "A ServletContextListener is meant for exactly this type of thing", "label": {"api": {"ServletContextListener": [[2, 23]]}}}, {"text": "Every thread has a handler for uncaught exceptions—exceptions that terminate the thread", "label": {"api": {"handler": [[19, 25]]}}}, {"text": "The default exception handler invokes printStackTrace() on the Throwable that terminates the thread, unless the error is an instance of ThreadDeath", "label": {"api": {"handler": [[22, 28]], "printStackTrace()": [[38, 54]]}}}, {"text": "You can change this behavior on a particular thread by setting a custom handler, for a group of threads by extending ThreadGroup, or for all threads by installing a default handler", "label": {"api": {"handler": [[72, 78], [173, 179]], "setting a custom handler,": [[55, 79]], "extending ThreadGroup,": [[107, 128]], "installing": [[152, 161]]}}}, {"text": "I searched around and didn't really find much, save for MappedByteBuffer, but I'm not sure how, or if it's even possible, to create a File from that class", "label": {"api": {"MappedByteBuffer": [[56, 71]]}}}, {"text": "Use ResourceBundle and *.properties files for each language", "label": {"api": {"ResourceBundle": [[4, 17]]}}}, {"text": "You can use a Scanner and use the useDelimiter(String regex) method to do this", "label": {"api": {"Scanner": [[14, 20]], "useDelimiter(String regex)": [[34, 59]]}}}, {"text": "You could perhaps have your classes inherit from java.io.Closeable and/or AutoCloseable, but other than advertising the need to clean up your resources, you mostly have to rely on the developers using your code to do the right thing", "label": {"api": {"java.io.Closeable": [[49, 65]], "AutoCloseable": [[74, 86]]}}}, {"text": "To test for NaN, you must Double's isNaN method", "label": {"api": {"Double's isNaN method": [[26, 46]]}}}, {"text": "Read the documentation on the number format supported by parseDouble", "label": {"api": {"number format": [[30, 42]]}}}, {"text": "I have read the docs  for PropertyChange support and EventListenerList", "label": {"api": {"PropertyChange support": [[26, 47]], "EventListenerList": [[53, 69]]}}}, {"text": "Is it only in case of GUI applications, that EventListenerList becomes handy?", "label": {"api": {"EventListenerList": [[45, 61]]}}}, {"text": "\"Java Integer class,\" and the official docs will show you the chain of inheritance up from java.lang.Integer -> java.lang.Number -> java.lang.Object", "label": {"api": {"the official docs": [[26, 42]]}}}, {"text": "Yes, Socket and ServerSocket use TCP/IP", "label": {"api": {"Socket": [[5, 10], [22, 27]], "ServerSocket": [[16, 27]]}}}, {"text": "The package overview for the java.net package is explicit about this, but it's easy to overlook", "label": {"api": {"package overview": [[4, 19]]}}}, {"text": "UDP is handled by the DatagramSocket class", "label": {"api": {"Socket": [[30, 35]], "DatagramSocket": [[22, 35]]}}}, {"text": "Implement flow control in your buttons (or in whatever code you're using to determine the behavior here) and just use CardLayout.show() to show the appropriate card", "label": {"api": {"CardLayout.show()": [[118, 134]]}}}, {"text": "Use the Class class's getDeclaredMethods() method", "label": {"api": {"Class class's getDeclaredMethods() method": [[8, 48]]}}}, {"text": "PrintWriter truncates existing files to 0 bytes on opening", "label": {"api": {"PrintWriter truncates existing files to 0 bytes on opening": [[0, 57]]}}}, {"text": "Oracle Java documentation says", "label": {"api": {"Oracle Java documentation": [[0, 24]]}}}, {"text": "sql types on database server, so which is used to store value, and can get access using index in java calling stored procedures and functions context", "label": {"api": {"sql types": [[0, 8]]}}}, {"text": "Use the Collections.sort(List, Comparator) method", "label": {"api": {"Collections.sort(List, Comparator)": [[8, 41]]}}}, {"text": "There's cardinality(), which returns the number of bits that are set", "label": {"api": {"cardinality()": [[8, 20]]}}}, {"text": "There's also length(), which returns 1 + the index of the highest bit set", "label": {"api": {"length()": [[13, 20]]}}}, {"text": "And there's size(), which returns the capacity, in bits, of the set", "label": {"api": {"size()": [[12, 17]]}}}, {"text": "Of those three length() - 1 is the closest thing to the \"last bit set by you\", but note that it is the index of the highest set bit, not the index of the most recently set bit (which is not possible using only BitSet)", "label": {"api": {"length()": [[15, 22]]}}}, {"text": "You also mentioned \"number of elements added to it\", for which cardinality() is the closest match (as long as you don't consider setting a bit to 0 to be semantically equivalent to \"adding a 0 to the set\")", "label": {"api": {"cardinality()": [[63, 75]]}}}, {"text": "You can use a Scanner to read the String URL by URL, and filter the URLs you want", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "Alternatively, if you don't want to use a Scanner, you can also split() the String", "label": {"api": {"Scanner": [[42, 48]]}}}, {"text": "You need to use the indexOfReturns the index within this string of the first occurrence of the specified character, starting the search at the specified index.", "label": {"api": {"indexOf": [[20, 26]]}}}, {"text": "lastIndexOf Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index", "label": {"api": {"lastIndexOf": [[0, 10]]}}}, {"text": "Use BigDecimal instead", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "You can just use the indexOf method", "label": {"api": {"indexOf": [[21, 27]]}}}, {"text": "Look at the String class documentation and try to find a method to change the string value to all uppercase", "label": {"api": {"String class documentation": [[12, 37]]}}}, {"text": "You can use String#lastIndexOf and simply do", "label": {"api": {"String#lastIndexOf": [[12, 29]]}}}, {"text": "stop(), as documented, is deprecated and should never be used", "label": {"api": {"as documented": [[8, 20]]}}}, {"text": "And a Thread can be started only once (as documented as well)", "label": {"api": {"as documented": [[39, 51]], "as documented as well": [[39, 59]]}}}, {"text": "Queue is one of the multiple interfaces implemented by LinkedList class", "label": {"api": {"Queue": [[0, 4]], "LinkedList": [[55, 64]]}}}, {"text": "See documentation for File.listFiles", "label": {"api": {"documentation for File.listFiles": [[4, 35]]}}}, {"text": "If you want only files, not folders, use the isFile() method", "label": {"api": {"isFile() method": [[45, 59]]}}}, {"text": "You can also give a file filter to the listFiles method, and then create a filter that lets through files and one filter that lets through folders", "label": {"api": {"give a file filter to the listFiles method": [[13, 54]]}}}, {"text": "That's why a valid benchmark would try to test both implementation against all the new operations and stipulations provided by the List interface", "label": {"api": {"all the new operations and stipulations provided by the List interface": [[75, 144]]}}}, {"text": "Compute the delay between now and your target date, and call schedule() with this delay as argument", "label": {"api": {"schedule()": [[61, 70]]}}}, {"text": "The class java.util.Timer has exactly what you need", "label": {"api": {"java.util.Timer": [[10, 24]]}}}, {"text": "The String#equals(Object) method first checks if the passed argument is an instance of String or not", "label": {"api": {"String#equals(Object)": [[4, 24]]}}}, {"text": "Read about ObjectOutputStream and ObjectInputStream and try your best", "label": {"api": {"ObjectOutputStream": [[11, 28]], "ObjectInputStream": [[34, 50]]}}}, {"text": "Once you've worked out your requirements, I suggest you express them as a regular expression - and then check whether the text matches the regular expression", "label": {"api": {"regular expression": [[74, 91], [139, 156]]}}}, {"text": "(You could also change the case consistently at the same time, for example.) As noted in comments, JFormattedTextField is probably a good match - see the tutorial to get started", "label": {"api": {"JFormattedTextField": [[99, 117]]}}}, {"text": "What use is Java 6 interface MultivaluedMap", "label": {"api": {"MultivaluedMap": [[29, 42]]}}}, {"text": "Create a process and execute a shell script with that process then get the OutputSTream from that process through which you can enter the values", "label": {"api": {"process": [[9, 15], [54, 60], [98, 104]]}}}, {"text": "You could pass a BytesMessage", "label": {"api": {"BytesMessage": [[17, 28]]}}}, {"text": "I have a custom JComponent placed in a JFrame (Well placed in a JPanel on a JFrame)", "label": {"api": {"JComponent": [[16, 25]], "JFrame": [[39, 44], [76, 81]], "JPanel": [[64, 69]]}}}, {"text": "I have used setDefaultCloseOperation() to set my JFrame to  DISPOSE_ON_CLOSE", "label": {"api": {"JFrame": [[49, 54]], "setDefaultCloseOperation()": [[12, 37]], "DISPOSE_ON_CLOSE": [[60, 75]]}}}, {"text": "My custom component has a Timer that continues to run after the frame has been closed", "label": {"api": {"Timer": [[26, 30]]}}}, {"text": "I know I could add a WindowListener to the JFrame and then make a call to the custom component to stop, but I would prefer to have my component be completely encapsulated", "label": {"api": {"JFrame": [[43, 48]], "WindowListener": [[21, 34]]}}}, {"text": "Is there any event I can use to detect when the parent JFrame has been closed from within my JComponent", "label": {"api": {"JComponent": [[93, 102]], "JFrame": [[55, 60]]}}}, {"text": "In general, you can use the wasNull() method to check if the last \"get\" method represented a null", "label": {"api": {"the wasNull() method": [[24, 43]]}}}, {"text": "One outrageous hack would be to write a custom java.io.InputStream extension which just removes the DTD reference before the parser sees it", "label": {"api": {"java.io.InputStream": [[47, 65]]}}}, {"text": "I have a JComboBox that is intended to be used to select a Font", "label": {"api": {"JComboBox": [[9, 17]], "Font": [[59, 62]]}}}, {"text": "To allow for a preview of the font when the user is making a selection I have written a custom ListCellRenderer", "label": {"api": {"ListCellRenderer": [[95, 110]]}}}, {"text": "In using this however I noticed a drastic performance hit when initializing my JComboBox with this ListCellRenderer", "label": {"api": {"JComboBox": [[79, 87]], "ListCellRenderer": [[99, 114]]}}}, {"text": "Upon further investigation I discovered that my ListCellRenderer was being called for many fonts when I set the default value for my item with setSelectedItem()", "label": {"api": {"ListCellRenderer": [[48, 63]], "setSelectedItem()": [[143, 159]]}}}, {"text": "For now I have changed my code to set the ListCellRenderer last but I would like to know why is this happening", "label": {"api": {"ListCellRenderer": [[42, 57]]}}}, {"text": "Even if my item were on the screen (which it is not yet) the ListCellRenderer does not render the selected item as it is shown idly in the JComboBox", "label": {"api": {"JComboBox": [[139, 147]], "ListCellRenderer": [[61, 76]]}}}, {"text": "You want the stringPropertyNames() method of your Properties object", "label": {"api": {"stringPropertyNames()": [[13, 33]]}}}, {"text": "In addition to strictfp, there's also StrictMath which requires that the results be predictable for transcendental and other functions", "label": {"api": {"StrictMath": [[38, 47]]}}}, {"text": "Basically I want something akin to the Java ServiceLoader for logback config", "label": {"api": {"Java ServiceLoader": [[39, 56]]}}}, {"text": "Apparently Log4j2 (the new log4j) does exactly what I want and is very similar to the Java ServiceLoader", "label": {"api": {"Java ServiceLoader": [[86, 103]]}}}, {"text": "You can request secure processing by setting FEATURE_SECURE_PROCESSING; whether this prohibits external entities is up to the provider of the DocumentBuilderFactory, but it's a likely candidate", "label": {"api": {"FEATURE_SECURE_PROCESSING;": [[45, 70]]}}}, {"text": "Integer.parseInt() will help you with that", "label": {"api": {"Integer.parseInt()": [[0, 17]]}}}, {"text": "I believe that BlockingQueue offers you the solution you need (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html": [[63, 142]]}}}, {"text": "The only means of dynamic binding that Java offers is via reflection (tutorial, also java.lang.Class documentation), e.g.", "label": {"api": {"java.lang.Class documentation": [[85, 113]]}}}, {"text": "There's a static function, doubleToLongBits(), to perform the type conversion", "label": {"api": {"doubleToLongBits()": [[27, 44]]}}}, {"text": "If you can change from int[] to Integer[], then you can use overloaded version of Arrays.sort(), and pass a Comparator returned by Collections.reverseOrder() as second argument", "label": {"api": {"Arrays.sort()": [[82, 94]], "Collections.reverseOrder()": [[131, 156]]}}}, {"text": "While iterating a Collection, element removal should be done only by means of Iterator.remove", "label": {"api": {"Iterator.remove": [[78, 92]]}}}, {"text": "Note that Iterator.remove is the only safe way to modify a collection during iteration; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress", "label": {"api": {"Iterator.remove": [[10, 24]]}}}, {"text": "You need to use the overloaded String#split(regex, limit) method which takes in the limit parameter", "label": {"api": {"String#split(regex, limit)": [[31, 56]]}}}, {"text": "And also note that, String#split(regex, limit) internally calls the Pattern#split(regex, limit)", "label": {"api": {"String#split(regex, limit)": [[20, 45]]}}}, {"text": "java.util.Date and java.sql.Date are different", "label": {"api": {"java.util.Date": [[0, 13]], "java.sql.Date": [[19, 31]]}}}, {"text": "Database accepts only java.sql.Date", "label": {"api": {"java.sql.Date": [[22, 34]]}}}, {"text": "For that, you need to convert java.util.Date into java.sql.Date", "label": {"api": {"java.util.Date": [[30, 43]], "java.sql.Date": [[50, 62]]}}}, {"text": "You read the file line by line and split each line at the commas", "label": {"api": {"split": [[35, 39]]}}}, {"text": "A nice way to do this is to utilize a Set", "label": {"api": {"Set": [[38, 40]]}}}, {"text": "You should use appropriate layout manager, BorderLayout in this case", "label": {"api": {"BorderLayout": [[43, 54]]}}}, {"text": "You should synchronize this new thread with the EDT by using SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[61, 88]]}}}, {"text": "Or even better you can do repetitive tasks using a Swing Timer which is a convenience class to handle all this concurrency stuff", "label": {"api": {"Swing Timer": [[51, 61]]}}}, {"text": "Take a look to How to Use Swing Timers tutorial for a better explanation", "label": {"api": {"Swing Timer": [[26, 36]]}}}, {"text": "A multi-item variant of the setPrototypeDisplayValue method is what I actually need, but it doesn't exist", "label": {"api": {"setPrototypeDisplayValue": [[28, 51]]}}}, {"text": "Assuming your class handling the JDBC has a method that returns a Connection, you can write a test for the connection not being null and isValid to submit queries and execute them", "label": {"api": {"isValid": [[137, 143]]}}}, {"text": "Isn't Query.executeUpdate() supposed to return the number of entities updated or deleted", "label": {"api": {"Query.executeUpdate()": [[6, 26]]}}}, {"text": "I would replace the List<Thread> threads by an ExecutorService, its awaitTermination method would be particularly handy", "label": {"api": {"ExecutorService": [[47, 61]], "awaitTermination": [[68, 83]]}}}, {"text": "Unlike Sleep, awaitTermination(10, TimeUnit.SECONDS) will return immediately if all tasks are done", "label": {"api": {"awaitTermination": [[14, 29]]}}}, {"text": "Since println takes Object the compiler doesn't need to insert a cast, and the code simply erases to", "label": {"api": {"println": [[6, 12]]}}}, {"text": "That's because the println(String) overload is used, so the code erases to", "label": {"api": {"println": [[19, 25]], "println(String)": [[19, 33]]}}}, {"text": "Because Thread.interrupted(), as documented, doesn't throw InterruptedException at all", "label": {"api": {"as documented": [[30, 42]]}}}, {"text": "Files.move is not equivalent to the mv command", "label": {"api": {"Files.move": [[0, 9]]}}}, {"text": "I have a JPanel inside of a JScrollPane which is nested inside some other containers", "label": {"api": {"JPanel": [[9, 14]], "JScrollPane": [[28, 38]]}}}, {"text": "My JPanel uses a modified FlowLayout from SO user jxd in this question", "label": {"api": {"JPanel": [[3, 8]]}}}, {"text": "JPanel (ModifiedFlowLayout) > JScrollPane > JPanel (GridBagLayout) > JTabbedPane > JPanel (GridBagLayout) > JSplitPane > JPanel (BorderLayout) > JFrame", "label": {"api": {"JPanel": [[0, 5], [44, 49], [83, 88], [121, 126]], "JScrollPane": [[30, 40]]}}}, {"text": "The problem is that when I call pack() on my JFrame the JScrollPane/JPanel expands horizontally to fill the entire remaining screen space (across multiple monitors)", "label": {"api": {"JPanel": [[68, 73]], "JScrollPane": [[56, 66]], "pack()": [[32, 37]]}}}, {"text": "The space used is more than is needed to display all of the components in the JPanel", "label": {"api": {"JPanel": [[78, 83]]}}}, {"text": "I tried using setMaximumSize() on my JPanel but it seems to be ignored in this scenario", "label": {"api": {"JPanel": [[37, 42]], "setMaximumSize()": [[14, 29]]}}}, {"text": "Just sort the ArrayList", "label": {"api": {"sort": [[5, 8]]}}}, {"text": "This is the basic idea, implemented using List", "label": {"api": {"List": [[42, 45]]}}}, {"text": "Take a look at the tutorial about Java Collections to understand how List and ArrayList work", "label": {"api": {"List": [[69, 72], [83, 86]]}}}, {"text": "I recomment you to use ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[23, 46]]}}}, {"text": "Well that would be a valid nested class, but it wouldn't implement Map.Entry, so it couldn't be used for the Map methods which require Map.Entry, such as entrySet()", "label": {"api": {"entrySet()": [[154, 163]]}}}, {"text": "The DisplayShelf is a Cover Flow style implementation of PerspectiveTransform animations, so its not exactly the same as a full image flip", "label": {"api": {"PerspectiveTransform": [[57, 76]]}}}, {"text": "Read the JavaDocs for more info on how to accomplish your goals in a system-independent way", "label": {"api": {"Read the JavaDocs": [[0, 16]]}}}, {"text": "Assuming this is your MediaControl, then it is already a Parent subclass, so you don't need to place it in a parent Group", "label": {"api": {"Parent": [[57, 62]], "Group": [[116, 120]]}}}, {"text": "It uses a class called TwoIntsForCompare, which implements Comparable", "label": {"api": {"Comparable": [[59, 68]]}}}, {"text": "After putting each sub-array into this object, they are inserted into a TreeMap with does the sorting automatically, by using TwoIntsForCompares compareTo function", "label": {"api": {"TreeMap": [[72, 78]]}}}, {"text": "Also you can consider using ArrayList instead of array, you can get the same performance and you don't need to care about the index at all in this case", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "Just use add method", "label": {"api": {"add": [[9, 11]]}}}, {"text": "This is the intent of ProcessBuilder.redirectError/redirectOutput which were introduced in Java 7", "label": {"api": {"ProcessBuilder.redirectError": [[22, 49]], "redirectOutput": [[51, 64]]}}}, {"text": "Using Redirect.INHERIT will make the child process share stderr/stdout with the Java process", "label": {"api": {"Redirect.INHERIT": [[6, 21]]}}}, {"text": "In the GridBagLayout API, I found three methods", "label": {"api": {"GridBagLayout API": [[7, 23]]}}}, {"text": "Call, JFrame#pack, it will pack the frame based on the needs of the frame decorations and the preferred size of the frames content", "label": {"api": {"JFrame#pack": [[6, 16]]}}}, {"text": "The Math.log method uses base e, the natural log, not the common log, base 10", "label": {"api": {"Math.log method": [[4, 18]]}}}, {"text": "Use the Math.log10 method for the common log (base 10)", "label": {"api": {"Math.log10 method": [[8, 24]]}}}, {"text": "Have a look at http://docs.oracle.com/javase/7/docs/api/java/util/List.html to learn more about lists", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/List.html": [[15, 74]]}}}, {"text": "Provide an alert handler to a WebEngine", "label": {"api": {"alert handler to a WebEngine": [[11, 38]]}}}, {"text": "The reflection type representing this kind of structure is called AnnotatedParameterizedType", "label": {"api": {"AnnotatedParameterizedType": [[66, 91]]}}}, {"text": "If you call map.get() and the key doesn't exist it'll return null (as described in the Map documentation)", "label": {"api": {"Map documentation": [[87, 103]]}}}, {"text": "You usually define one or more service classes/interfaces that define your REST operations via JAX-RS annotations, like this one", "label": {"api": {"JAX-RS annotations": [[95, 112]]}}}, {"text": "HTTP Sessions are accessible from the HTTP Request object via getSession() and getSession(boolean) as usual", "label": {"api": {"HTTP Sessions": [[0, 12]], "HTTP Request": [[38, 49]]}}}, {"text": "You can instantiate AbstractMap.SimpleEntry<K, V> class, which implements the Map.Entry interface", "label": {"api": {"AbstractMap.SimpleEntry<K, V>": [[20, 48]]}}}, {"text": "Oh, and there is also an AbstractMap.SimpleImmutableEntry if you need it", "label": {"api": {"AbstractMap.SimpleImmutableEntry": [[25, 56]]}}}, {"text": "So you'll want all the X and Y's be relative to each other, so use SwingUtilities.convertPoint", "label": {"api": {"SwingUtilities.convertPoint": [[67, 93]]}}}, {"text": "I have searched and have seen that java.util.Calendar can be used, and it is possible to clear the field values that go with the timestamp, such as MINUTE, SECOND etc", "label": {"api": {"java.util.Calendar": [[35, 52]], "MINUTE": [[148, 153]], "SECOND": [[156, 161]]}}}, {"text": "For example, Objects.requireNonNull()", "label": {"api": {"Objects.requireNonNull()": [[13, 36]]}}}, {"text": "Use ZipOutputStream with ZipEntry for each record", "label": {"api": {"ZipOutputStream": [[4, 18]], "ZipEntry": [[25, 32]]}}}, {"text": "You should be able to extract particular records (ZipEntry) when you want to without having to unzip the whole file", "label": {"api": {"ZipEntry": [[50, 57]]}}}, {"text": "Use Java's parseInt(String s, int radix)", "label": {"api": {"parseInt(String s, int radix)": [[11, 39]]}}}, {"text": "You can however insert all elements into a self-balancing binary search tree one by one, in any order", "label": {"api": {"self-balancing binary search tree": [[43, 75]]}}}, {"text": "I have a JScrollPane that contains a JPanel which then contains some custom components which are an extension of JPanel (they are all the same type)", "label": {"api": {"JScrollPane": [[9, 19]], "JPanel": [[37, 42], [113, 118]]}}}, {"text": "This JScrollPane is set invisible before the containing JFrame is shown", "label": {"api": {"JScrollPane": [[5, 15]], "JFrame": [[56, 61]]}}}, {"text": "When the user selects a JCheckBox I use setVisible() to show the scroll pane", "label": {"api": {"JCheckBox": [[24, 32]], "setVisible()": [[40, 51]]}}}, {"text": "The first time the pane is shown however there is a significant delay between when setVisible() is called and when the pane is painted", "label": {"api": {"setVisible()": [[83, 94]]}}}, {"text": "They are ComponentListeners but have empty implementations except for componentResized()", "label": {"api": {"ComponentListener": [[9, 25]], "componentResized()": [[70, 87]]}}}, {"text": "They also have a custom paintComponent() method, but a breakpoint inside that method shows the delay happens before the this is called so it is not a case of a slow painting", "label": {"api": {"paintComponent()": [[24, 39]]}}}, {"text": "Neither the JScrollPane or the JPanel have any other listeners", "label": {"api": {"JScrollPane": [[12, 22]], "JPanel": [[31, 36]]}}}, {"text": "What else happens between setVisible() and paintComponent()", "label": {"api": {"setVisible()": [[26, 37]], "paintComponent()": [[43, 58]]}}}, {"text": "After the initial display though setVisible() applies immediately as in the full program", "label": {"api": {"setVisible()": [[33, 44]]}}}, {"text": "Now the question is, what is happening during a resize that is causing setVisible() to take effect and how can I cause it to happen instantly", "label": {"api": {"setVisible()": [[71, 82]]}}}, {"text": "If you look at the code for Rectangle.toString(), which is called automatically by System.out.println, you will see that it prints out the parameters that make up the Rectangle object", "label": {"api": {"System": [[83, 88]], "out": [[90, 92], [131, 133]], "toString()": [[38, 47]]}}}, {"text": "You're not explicitly calling toString(), but impliclty you are", "label": {"api": {"toString()": [[30, 39]]}}}, {"text": "System is a class, with a static field out, of type PrintStream", "label": {"api": {"System": [[0, 5]], "out": [[39, 41]], "PrintStream": [[52, 62]]}}}, {"text": "So you're calling the println(Object) method of a PrintStream", "label": {"api": {"PrintStream": [[50, 60]], "println(Object)": [[22, 36]]}}}, {"text": "As we see, it's calling the String.valueOf(Object) method", "label": {"api": {"String.valueOf(Object)": [[28, 49]]}}}, {"text": "And here you see, that toString() is called", "label": {"api": {"toString()": [[23, 32]]}}}, {"text": "Hand off the work to be done outside of the request-response cycle to an ExecutorService", "label": {"api": {"ExecutorService": [[73, 87]]}}}, {"text": "Make sure that, since this is a webapp, you have a way to shut down the ExecutorService when the webapp is stopped - which will also give the ExecutorService a chance to finish any in-progress work before allowing the container to stop", "label": {"api": {"ExecutorService": [[72, 86], [142, 156]]}}}, {"text": "You can use a TreeSet instead", "label": {"api": {"TreeSet": [[14, 20]]}}}, {"text": "Add all your objects to the TreeSet, you will get a sorted Set", "label": {"api": {"TreeSet": [[28, 34]]}}}, {"text": "There are several drawImage methods, see the javadoc", "label": {"api": {"drawImage": [[18, 26]]}}}, {"text": "You probably want this drawImage", "label": {"api": {"drawImage": [[23, 31]]}}}, {"text": "If insertion order matters, then you should use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[50, 62]]}}}, {"text": "The date format is arbitrary as long as you can construct an appropriate SimpleDateFormat to represent it", "label": {"api": {"SimpleDateFormat": [[73, 88]]}}}, {"text": "After you have a Date, you can use Date.getTime() to retrieve the millisecond value", "label": {"api": {"Date.getTime()": [[35, 48]]}}}, {"text": "Then the matching SimpleDateFormat would be", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "A SimpleDateFormat provides a non-deprecated way to convert arbitrary strings to dates", "label": {"api": {"SimpleDateFormat": [[2, 17]]}}}, {"text": "This is not necessarily the case -- an accessor (even a get-accessor returning a value) may be impure, such as the get method of LinkedHashMap when in access-order mode (which moves the requested entry to last position in iteration order)", "label": {"api": {"LinkedHashMap": [[129, 141]]}}}, {"text": "replaceAll() returns the string with the changes made, it does not modify temp5", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "Fortunately, Java has the second of these signatures built in, as Integer.parseInt(String, int), so you don't need to do it yourself", "label": {"api": {"Integer.parseInt(String, int)": [[66, 94]]}}}, {"text": "You can use Node.getTextContent() to conveniently get all the text of a node (gets text of children as well)", "label": {"api": {"Node.getTextContent()": [[12, 32]]}}}, {"text": "String.length() can be used to determine, if the input has one letter", "label": {"api": {"String.length()": [[0, 14]]}}}, {"text": "To check if the read String is a letter you can use Character.isLetter(char)", "label": {"api": {"Character.isLetter(char)": [[52, 75]]}}}, {"text": "I think your mixing Java EE 7's JSONObject with GSON's JsonObject", "label": {"api": {"JSONObject": [[32, 41]]}}}, {"text": "AccessDeniedException is only thrown by the new file API; the old file API (which you use with this PrintWriter constructor) only knows how to throw FileNotFoundException even if the real filesystem-level problem is not \"the file does not exist\"", "label": {"api": {"AccessDeniedException": [[0, 20]]}}}, {"text": "More generally, the new file API defines FileSystemException (inheriting IOException), which all new, meaningful exceptions defined by the new API inherit", "label": {"api": {"FileSystemException": [[41, 59]]}}}, {"text": "If you want to set some arbitrary value to that field, use GregorianCalendar", "label": {"api": {"GregorianCalendar": [[59, 75]]}}}, {"text": "Since your application is using swing you should take a look at the SwingWorker class that is designed just for jobs like that", "label": {"api": {"SwingWorker": [[68, 78]]}}}, {"text": "in which you use Double.valueOf to convert the String to a double", "label": {"api": {"Double.valueOf": [[17, 30]]}}}, {"text": "Instead, consider adding a dynamically colored Border or Icon", "label": {"api": {"Border": [[47, 52]], "Icon": [[57, 60]]}}}, {"text": "You're calling toString() on an array - and arrays don't override Object.toString()", "label": {"api": {"Object.toString()": [[66, 82]]}}}, {"text": "So you get the behaviour from Object.toString()", "label": {"api": {"Object.toString()": [[30, 46]]}}}, {"text": "Call Arrays.toString(double[]) on the result instead and it will be fine", "label": {"api": {"Arrays.toString(double[])": [[5, 29]]}}}, {"text": "Take a look at how JPA does things for setting parameters", "label": {"api": {"JPA does things": [[19, 33]]}}}, {"text": "You also know that you already have dynamic arrays such as ArrayList<Computer> at your disposal", "label": {"api": {"ArrayList<Computer>": [[59, 77]]}}}, {"text": "When a scanner throws an InputMismatchException, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method", "label": {"api": {"InputMismatchException": [[25, 46]]}}}, {"text": "See Format String Syntax for more information on the format strings you can specify to PrintWriter.printf", "label": {"api": {"Format String Syntax": [[4, 23]], "PrintWriter.printf": [[87, 104]]}}}, {"text": "Look into Comparable and Comparator", "label": {"api": {"Comparable": [[10, 19]], "Comparator": [[25, 34]]}}}, {"text": "Say I define a class called MyClass What does MyClass.class hold", "label": {"api": {"Class": [[30, 34], [48, 52]]}}}, {"text": "(if so, what would it be for MyClass?) Something else", "label": {"api": {"Class": [[31, 35]]}}}, {"text": "It holds a reference to a Class object, which you can use for various things, most notable getting runtime information about the class for debugging and reflection", "label": {"api": {"Class": [[26, 30]]}}}, {"text": "It is also the same thing returned by the non-static method getClass()", "label": {"api": {"Class": [[63, 67]], "getClass()": [[60, 69]]}}}, {"text": "I am not completely familiar with Py4J, but you may be able to use the latter to access the Class of a given object instance", "label": {"api": {"Class": [[92, 96]]}}}, {"text": "Note that getClass() is a base method of java.lang.Object", "label": {"api": {"Class": [[13, 17]], "getClass()": [[10, 19]]}}}, {"text": "I suggest using Scanner.nextLine() for those string inputs instead", "label": {"api": {"Scanner.nextLine()": [[16, 33]]}}}, {"text": "Java ArrayList don't have addLast() method", "label": {"api": {"ArrayList": [[5, 13]], "addLast()": [[26, 34]]}}}, {"text": "Use add() method from ArrayList to add in a specified index or use LinkedList which has addLast() method", "label": {"api": {"ArrayList": [[22, 30]], "add()": [[4, 8]], "LinkedList": [[67, 76]], "addLast()": [[88, 96]]}}}, {"text": "Although you are calling methods dynamically and it seems like reflection, but as far as I see, you are calling accessors and nested accessors, which leads to use Java Introspection API", "label": {"api": {"Java Introspection": [[163, 180]]}}}, {"text": "Check out Properties", "label": {"api": {"Properties": [[10, 19]]}}}, {"text": "The Properties.load() method has the ability to load a \"key=value\" formatted file into a map of keys -> values", "label": {"api": {"Properties": [[4, 13]], "Properties.load()": [[4, 20]]}}}, {"text": "You can then access the data like theProperties.getProperty(\"path\")", "label": {"api": {"Properties": [[37, 46]]}}}, {"text": "split the String on all whitespace, which includes tabs", "label": {"api": {"split": [[0, 4]]}}}, {"text": "This task should be done in a separate thread, using for example a SwingWorker, which will notify its progress regularly in order to update the label text", "label": {"api": {"SwingWorker": [[67, 77]]}}}, {"text": "If the file does not exist, you will get a NoSuchFileException", "label": {"api": {"NoSuchFileException": [[43, 61]]}}}, {"text": "If you don't have access to it, you will get an AccessDeniedException", "label": {"api": {"AccessDeniedException": [[48, 68]]}}}, {"text": "You've got a NodeList", "label": {"api": {"NodeList": [[13, 20]]}}}, {"text": "you could use Date.getTime(), here's an example", "label": {"api": {"Date.getTime()": [[14, 27]]}}}, {"text": "To get the count sorted, just use a SortedMap by providing a Comparator (I have no prior experience on this, so you better look up the API yourself)", "label": {"api": {"SortedMap": [[36, 44]]}}}, {"text": "When you'll create a jar you won't have access to that file as a File object but as an URL from which you'll have to get the InputStream with openStream()", "label": {"api": {"URL": [[87, 89]], "openStream()": [[142, 153]]}}}, {"text": "Instead, use the Scanner(InputStream) with", "label": {"api": {"Scanner(InputStream)": [[17, 36]]}}}, {"text": "You can use the Timer class with it's schedule() method", "label": {"api": {"Timer class": [[16, 26]], "schedule()": [[38, 47]]}}}, {"text": "Have you looked at the docs for Pattern", "label": {"api": {"Pattern": [[32, 38]]}}}, {"text": "And if you're already on Java 7, then you can use Pattern.UNICODE_CHARACTER_CLASS flag, or embedded flag - (?U) with your given pattern", "label": {"api": {"Pattern.UNICODE_CHARACTER_CLASS": [[50, 80]]}}}, {"text": "The javadoc for Enum.compareTo() mentions it (emphasis mine)", "label": {"api": {"javadoc for Enum.compareTo()": [[4, 31]]}}}, {"text": "Check ProgressMonitor.isCanceled(), which indeed, the ProgressMonitorDemo does", "label": {"api": {"ProgressMonitor.isCanceled()": [[6, 33]]}}}, {"text": "The host OS owns the frame decorations, but you can Create Translucent and Shaped Windows and use Frame#setUndecorated(), as shown here", "label": {"api": {"Frame#setUndecorated()": [[98, 119]]}}}, {"text": "As per your question your have placed it in the same package as this class that's why you are getting FileNotFoundException", "label": {"api": {"File": [[102, 105]]}}}, {"text": "Let me explain you how new File(pathname) works", "label": {"api": {"File": [[27, 30]]}}}, {"text": "Javadoc about File says", "label": {"api": {"File": [[14, 17]]}}}, {"text": "According to this response, you should use ListIterator.add() instead of List.add due to the better performance", "label": {"api": {"ListIterator.add()": [[43, 60]]}}}, {"text": "BufferedWriter also inherits write(String) from Writer, which just takes a string", "label": {"api": {"write(String)": [[29, 41]], "BufferedWriter": [[0, 13]]}}}, {"text": "Check out the docs for BufferedWriter and at the bottom of the \"Method Summary\" section you'll see \"Methods inherited from...\"", "label": {"api": {"BufferedWriter": [[23, 36]]}}}, {"text": "Note that FileWriter also has a write(String), which you can use directly", "label": {"api": {"write(String)": [[32, 44]]}}}, {"text": "The BufferedWriter provides an extra layer of buffering, which is useful for improving performance in applications that write large amounts of data, but probably won't have much of an effect for your case", "label": {"api": {"BufferedWriter": [[4, 17]]}}}, {"text": "BufferedWriter does add newLine(), though, which might float your boat", "label": {"api": {"BufferedWriter": [[0, 13]]}}}, {"text": "Alternatively, you could use a PrintWriter, then you will have println()", "label": {"api": {"println()": [[63, 71]]}}}, {"text": "If you want it to be case-insensitive, and replace with the same case, you have to use the i flag", "label": {"api": {"i flag": [[91, 96]]}}}, {"text": "For the Thread constructor taking a Runnable, it says", "label": {"api": {"says": [[49, 52]]}}}, {"text": "In Java 8, there is a new method String.chars() which returns a stream of ints (IntStream) that represent the character codes", "label": {"api": {"String.chars()": [[33, 46]]}}}, {"text": "To retrieve element by index you can use ArrayList.get(int) method", "label": {"api": {"ArrayList.get(int)": [[41, 58]]}}}, {"text": "You should avoid inserting element in non sequential order, as it is much less efficient, but it can be done using ArrayList.add(index,element)", "label": {"api": {"ArrayList.add(index,element)": [[115, 142]]}}}, {"text": "Check http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html (and others) for a description on how to use them and what their use cases are", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html": [[6, 73]]}}}, {"text": "If your goal is to have matching output, you can use String.format() to print the values from code written in the Java programming language", "label": {"api": {"String.format()": [[53, 67]]}}}, {"text": "The full description of what it accepts is in Formatter; if you dig through it far enough you will find", "label": {"api": {"Formatter": [[46, 54]]}}}, {"text": "int List.size() does exist", "label": {"api": {"int List.size()": [[0, 14]]}}}, {"text": "You're not using println() so the boolean you passed to the constructor to enable autoflush doesn't apply as stated in the javadoc", "label": {"api": {"in the javadoc": [[116, 129]]}}}, {"text": "Assuming you are using a Scanner object scanner (wild guess since you're reading using a while loop), what you probably want to do is", "label": {"api": {"Scanner": [[25, 31]]}}}, {"text": "I would use the Pattern class to define a regular expression which matches your definition of a word", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "You can then create a Matcher for each line you read in from the file and call the find method to see if a two-or-longer sequence is found and, if so, use the group method to extract the matching sequence, and the end method to get the offset for the next find call", "label": {"api": {"Matcher": [[22, 28]]}}}, {"text": "You need to shutdown your executor service properly", "label": {"api": {"shutdown your executor service properly": [[12, 50]]}}}, {"text": "Some examples include a particular constructor of Scanner, or more formally, Scanner#<init>(File file)", "label": {"api": {"Scanner#<init>(File file)": [[77, 101]]}}}, {"text": "see the ArrayList.contains method for how to check if the item is in the list", "label": {"api": {"ArrayList.contains": [[8, 25]]}}}, {"text": "you can add items to the list with the add method", "label": {"api": {"add": [[8, 10], [39, 41]]}}}, {"text": "Right now your LinkedList isA Node and since Node has just single constructor that takes value, you have to call super(value)", "label": {"api": {"LinkedList": [[15, 24]]}}}, {"text": "Also you can use LinkedList from java.util package (don't reinvent the wheel here)", "label": {"api": {"LinkedList": [[17, 26]]}}}, {"text": "My hypothesis here is that you use a ResourceBundle", "label": {"api": {"ResourceBundle": [[37, 50]]}}}, {"text": "The \"funny\" thing is that this uses a method which is available in Properties (since 1.6) but which ResourceBundle doesn't use, nor does it provide a way to use it..", "label": {"api": {"ResourceBundle": [[100, 113]], "method which is available in Properties": [[38, 76]]}}}, {"text": "HashTable (are you sure you don't want a HashMap instead?) has a constructor overload that takes a loadfactor", "label": {"api": {"HashTable": [[0, 8]], "HashMap": [[41, 47]]}}}, {"text": "The documentation on a loadfactor", "label": {"api": {"The documentation on a loadfactor": [[0, 32]]}}}, {"text": "What you should take away from this is that you have no power over how much space is allocated by the HashTable", "label": {"api": {"HashTable": [[102, 110]]}}}, {"text": "For more details see the java api", "label": {"api": {"java api": [[25, 32]]}}}, {"text": "You can create the PriorityQueue and in the constructor put comparator code", "label": {"api": {"constructor": [[44, 54]]}}}, {"text": "Instead you may use Integer.compare(int,int)", "label": {"api": {"Integer.compare(int,int)": [[20, 43]]}}}, {"text": "As Radiodef helpfully points out in comments, it is documented at Double.valueOf()", "label": {"api": {"Double.valueOf()": [[66, 81]]}}}, {"text": "You can just turn the string into a char[] (array of characters) with the toCharArray() method", "label": {"api": {"toCharArray()": [[74, 86]]}}}, {"text": "To remove all items from a collection that are in another collection, use removeAll", "label": {"api": {"removeAll": [[74, 82]]}}}, {"text": "Either put DO SOME OTHER STUFF into callback, or declare a semaphore, and call semaphore.release in the callback and call semaphore.aquire where you want to wait", "label": {"api": {"semaphore": [[59, 67], [79, 87], [122, 130]]}}}, {"text": "The nextInt(n) method uses the modulo operator on a randomly generated integer between -2^31 and (2^31)-1, which is essentially what you will be doing in the end anyway, just with n = 2", "label": {"api": {"uses the modulo operator": [[22, 45]]}}}, {"text": "You can use the built in BytaArrayOutputStream to achieve that", "label": {"api": {"BytaArrayOutputStream": [[25, 45]]}}}, {"text": "You can use write(int b) and toByteArray() to realize add b to block_storage and process block_storage as a byte[]", "label": {"api": {"write(int b)": [[12, 23]], "toByteArray()": [[29, 41]]}}}, {"text": "As @marcman pointed out, the buffer can be reset()", "label": {"api": {"reset()": [[43, 49]]}}}, {"text": "I have used the LinearGradientPaint class to draw a rectangle dynamically filled with user-defined colors", "label": {"api": {"LinearGradientPaint class": [[16, 40]]}}}, {"text": "A FileAttribute is what its name says", "label": {"api": {"FileAttribute": [[2, 14]]}}}, {"text": "What attributes are defined depend on the FileSystem implementation", "label": {"api": {"FileSystem": [[42, 51]]}}}, {"text": "Paths.get() will return a Path from the default FileSystem", "label": {"api": {"FileSystem": [[48, 57]]}}}, {"text": "One can imagine however to write a FileSystem implementation for CVS for instance, where each file has a version; then you could define a CVSFileAttribute with a version, yes", "label": {"api": {"FileAttribute": [[141, 153]], "FileSystem": [[35, 44]]}}}, {"text": "I am testing with Java Character and I got amazing thing for me", "label": {"api": {"Java Character": [[18, 31]]}}}, {"text": "Obviously it's not automatically sorted but you can do that after adding a batch of items by running the Collections.sort() method which also accepts a Comparator, but this time your comparator can focus on the specific task of detailing the ordering now that you know the list is pre-filtered so you are not concerned with trying to filter items out", "label": {"api": {"Collections.sort()": [[105, 122]]}}}, {"text": "If you are using a bounded BlockingQueue by passing a capacity value in the constructor, then the producer will block when it attempts to call put() until the consumer removes an item by calling take()", "label": {"api": {"put()": [[143, 147]], "take()": [[195, 200]]}}}, {"text": "Using NumberFormat you can do something like this", "label": {"api": {"NumberFormat": [[6, 17]]}}}, {"text": "When using Locale.FRANCE, you tell Java that you write double numbers with , instead of .", "label": {"api": {"Locale.FRANCE": [[11, 23]]}}}, {"text": "You could use DecimalFormat like this", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "So DecimalFormatSymbols.getInstance() will get the default locale and its correct symbols", "label": {"api": {"DecimalFormat": [[3, 15]]}}}, {"text": "Read More about DecimalFormat", "label": {"api": {"DecimalFormat": [[16, 28]]}}}, {"text": "The contract of toString()", "label": {"api": {"contract": [[4, 11]]}}}, {"text": "The seed, in your code is the long passed as argument to the constructor", "label": {"api": {"constructor": [[61, 71]]}}}, {"text": "Use a PreparedStatement", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "You can use setName() to set an unique name and then traverse the component tree of the container recursively to get the component with a certain name (Get a Swing component by name)", "label": {"api": {"setName()": [[12, 20]]}}}, {"text": "While Swing components can have a name (http://docs.oracle.com/javase/7/docs/api/java/awt/Component.html#getName()) this is not an id; it is up to you to ensure consistency", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Component.html#getName()": [[40, 113]]}}}, {"text": "I am using java collections, lets say the List interface for example", "label": {"api": {"List": [[42, 45]]}}}, {"text": "The nearest common ancestor of A and B is the Object class", "label": {"api": {"Object": [[46, 51]]}}}, {"text": "In this case just use Set's (or any other Collection) built in size() method", "label": {"api": {"size()": [[63, 68]]}}}, {"text": "An iterator is an implementation of java.util.Iterator interface", "label": {"api": {"java.util.Iterator interface": [[36, 63]]}}}, {"text": "If you have done that, it should be clear to you that you must use the appropriate constructor and supply the appropriately configured separator/grouping chars, whereas in the pattern itself the dot and the comma have a special meaning", "label": {"api": {"the appropriate constructor": [[67, 93]]}}}, {"text": "And Thread.sleep() is static", "label": {"api": {"Thread.sleep() is static": [[4, 27]]}}}, {"text": "With Java 8 and later, use java.time.LocalDate class", "label": {"api": {"java.time.LocalDate": [[27, 45]]}}}, {"text": "From the documentation for Scanner", "label": {"api": {"Scanner": [[27, 33]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "From the documentation for next()", "label": {"api": {"next()": [[27, 32]]}}}, {"text": "You can use the Random(long seed) constructor for it", "label": {"api": {"Random(long seed)": [[16, 32]]}}}, {"text": "That JavaDoc for Class.getDeclaredConstructor is pretty clear", "label": {"api": {"Class.getDeclaredConstructor": [[17, 44]]}}}, {"text": "As defined in the API, the method setChanged is protected, and so available only to the class/subclasses", "label": {"api": {"in the API": [[11, 20]]}}}, {"text": "When you add a UI component in swing, you need to call the component's revalidate method for the changes to take effect", "label": {"api": {"revalidate": [[71, 80]]}}}, {"text": "Judging by the PlayerList.Entry mentioned in the for loop, PlayerList probably implements java.util.Map, which means to iterate around the entries it should be called like this", "label": {"api": {"java.util.Map": [[90, 102]]}}}, {"text": "Java 8 added a new java.time API for working with dates and times (JSR 310)", "label": {"api": {"java.time": [[19, 27]]}}}, {"text": "How can I obtain a LocalDateTime instance from the given string", "label": {"api": {"LocalDateTime": [[19, 31]]}}}, {"text": "After I finished working with the LocalDateTime object", "label": {"api": {"LocalDateTime": [[34, 46]]}}}, {"text": "How can I then convert the LocalDateTime instance back to a string with the same format as shown above", "label": {"api": {"LocalDateTime": [[27, 39]]}}}, {"text": "Finally, and perhaps requiring the biggest change of all, you don't have the method signature for equals() correct", "label": {"api": {"equals()": [[98, 105]]}}}, {"text": "Since primitive types (ints, longs, etc.) don't have any methods on them (including .equals(), you have to compare these fields using == rather than .equals(), as shown in the example above", "label": {"api": {"equals()": [[85, 92], [150, 157]]}}}, {"text": "This isn't the most complete solution (there's plenty of good information answering this question), and you should also override Object.hashCode() if you're modifying equals(), to keep them consistent", "label": {"api": {"equals()": [[167, 174]], "Object.hashCode()": [[129, 145]]}}}, {"text": "I would use a CountDownLatch instead of reimplementing the logic", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "The next() method will return a String that you can see if it's equals to \"C\" of \"F\"", "label": {"api": {"next() method": [[4, 16]]}}}, {"text": "For more information about how to correctly shutdown an ExecutorService, see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html, section 'Usage Examples'", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html": [[77, 158]]}}}, {"text": "To get better accuracy when measuring small amounts of time, you should use System.nanoTime()", "label": {"api": {"System.nanoTime()": [[76, 92]]}}}, {"text": "You have to get familiar with Arrays.Sort(...) where you can pass an comparator", "label": {"api": {"Arrays.Sort(...)": [[30, 45]]}}}, {"text": "Keep that link open at all times", "label": {"api": {"Keep that link open at all times": [[0, 31]]}}}, {"text": "The upper code block returns the lexicographical difference when the account names are equal, see String.compareTo(String), that is, they not always return -1, 0 or 1", "label": {"api": {"String.compareTo(String)": [[98, 121]]}}}, {"text": "When you are planning to also override the equals(Object) and hashCode() methods, keep in mind that it is strongly recommended, although not strictly required that x.compareTo(y) == 0 equals to x.equals(y), see Comparable<T>.compareTo(T object)", "label": {"api": {"Comparable<T>.compareTo(T object)": [[211, 243]]}}}, {"text": "As an example, ArrayList accepts a Collection in its copy constructor", "label": {"api": {"its copy constructor": [[49, 68]]}}}, {"text": "You can use the TYPE Class objects", "label": {"api": {"TYPE": [[16, 19]]}}}, {"text": "You can get all GET parameters from a UriInfo instance, if you get one injected using a parameter like @Context UriInfo uriInfo (see the getQueryParameters())", "label": {"api": {"getQueryParameters()": [[137, 156]]}}}, {"text": "It appears this is supported in Java 11, via new fields in the ExtendedSocketOptions class", "label": {"api": {"new fields in the ExtendedSocketOptions class": [[45, 89]]}}}, {"text": "See the javadoc for Files", "label": {"api": {"javadoc for Files": [[8, 24]]}}}, {"text": "I would propose to profit from ScheduledExecutorService.scheduleAtFixedRate method, that will call your implementation at fixed rate", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate": [[31, 74]]}}}, {"text": "It is normally used from a command prompt, but can be used through Java's ProcessBuilder", "label": {"api": {"ProcessBuilder": [[74, 87]]}}}, {"text": "What you want is .find()", "label": {"api": {".find()": [[17, 23]]}}}, {"text": "Regex matching is done using .find()", "label": {"api": {".find()": [[29, 35]]}}}, {"text": "I think of returning some proxy which is initialized with the original instance", "label": {"api": {"proxy": [[26, 30]]}}}, {"text": "On the first write access the proxy will continue using a copy", "label": {"api": {"proxy": [[30, 34]]}}}, {"text": "the annotation @ReturnCopyOnwriteReference which replaces transparently the returned object with the proxy", "label": {"api": {"proxy": [[101, 105]]}}}, {"text": "An API method which returns such a proxy needs only that annotation", "label": {"api": {"proxy": [[35, 39]]}}}, {"text": "If you're just looking for a COW collection use Java's CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[55, 74]]}}}, {"text": "Try to use StringBuffer instead of String, that is recomendable for this situations", "label": {"api": {"StringBuffer": [[11, 22]]}}}, {"text": "IllegalStateException seems entirely appropriate here", "label": {"api": {"IllegalStateException": [[0, 20]]}}}, {"text": "You can use the String.format as suggested by @Reimeus or you can use a MessageFormat", "label": {"api": {"MessageFormat": [[72, 84]]}}}, {"text": "Use PreparedStatement.setBoolean(int parameterIndex, boolean x) method", "label": {"api": {"PreparedStatement.setBoolean(int parameterIndex, boolean x)": [[4, 62]]}}}, {"text": "java.util.concurrent.RecursiveAction was only introduced in JDK7 (see the @since annotation in the Javadoc), so if you were to compile your code against an earlier version of the JDK (6 or below) then you would get an error message like this", "label": {"api": {"java.util.concurrent.RecursiveAction": [[0, 35]]}}}, {"text": "You can use the containsAll() method", "label": {"api": {"containsAll()": [[16, 28]]}}}, {"text": "The toString() you defined for it broke the general contract of the toString method; instead of providing a 'string that \"textually represents\" this object', you used it to provide formatting for a particular presentation of the data to the user (i.e", "label": {"api": {"'string that \"textually represents\" this object'": [[108, 155]]}}}, {"text": "It's a while until you'll be ready to do that, but at that point you want to look at the API docs for Pseudoclass and of course post back here if you need more help", "label": {"api": {"API docs for Pseudoclass": [[89, 112]]}}}, {"text": "You probably want the format method of the PrintWriter class - you don't need to explicitly format this into a String before you print it", "label": {"api": {"PrintWriter": [[43, 53]]}}}, {"text": "Check the Javadocs for PrintWriter and for Formatter to work out what format-string should be", "label": {"api": {"PrintWriter": [[23, 33]], "Formatter": [[43, 51]]}}}, {"text": "The FXML documentation has a brief section on scripting, and sure enough the following \"works\"", "label": {"api": {"brief section on scripting": [[29, 54]]}}}, {"text": "set replaces, add pushes everything after index back an index", "label": {"api": {"set": [[0, 2]], "add": [[14, 16]]}}}, {"text": "The processing environment provides you with a Filer that can be used to load (known) resources", "label": {"api": {"Filer": [[47, 51]]}}}, {"text": "If you need absolute paths to discover files or directories, you can use a JavaFileManager and a StandardLocation", "label": {"api": {"StandardLocation": [[97, 112]]}}}, {"text": "The Filer for example is only required to support CLASS_OUTPUT and SOURCE_OUTPUT", "label": {"api": {"Filer": [[4, 8]]}}}, {"text": "If you do that, you can get the source path by creating a temporary resource with the Filer at the SOURCE_OUTPUT location and get the source path relative from that file's location", "label": {"api": {"Filer": [[86, 90]]}}}, {"text": "But you could use Collections.sort support of Comparator to customise the way in which values are compared while they are been sorted and SimpleDateFormat to convert the value to a Date value which can then be compared directly...for example..", "label": {"api": {"Collections.sort": [[18, 33]], "Comparator": [[46, 55]], "SimpleDateFormat": [[138, 153]]}}}, {"text": "Bean Validation 1.1 introduced the ParameterNameProvider interface for providing names for method and constructor parameters when creating constraint violation objects", "label": {"api": {"ParameterNameProvider": [[35, 55]]}}}, {"text": "Hibernate Validator 5.2 introduced the ReflectionParameterNameProvider class, a ParameterNameProvider implementation that uses reflection to get the actual parameter names (to work properly, it requires the classes to be compiled with the -parameters compiler argument)", "label": {"api": {"ParameterNameProvider": [[49, 69], [80, 100]], "Validator": [[10, 18]]}}}, {"text": "Dropwizard extends it and add support to JAX-RS @XxxParam annotations with the JerseyParameterNameProvider that should work with other JAX-RS implementations too", "label": {"api": {"ParameterNameProvider": [[85, 105]]}}}, {"text": "Customization of the Validator used in validation of Jersey resource classes/methods can be done using ValidationConfig class and exposing it via ContextResolver<T> mechanism", "label": {"api": {"Validator": [[21, 29]], "ContextResolver<T>": [[146, 163]]}}}, {"text": "I have no idea why I can pass any type of value to the HashMap.containsKey() method", "label": {"api": {"HashMap.containsKey()": [[55, 75]], "containsKey()": [[63, 75]]}}}, {"text": "I assume this method is an instance method (correct me if I am wrong) of HashMap Class which should be constrained by generic typing", "label": {"api": {"HashMap Class": [[73, 85]]}}}, {"text": "If JAVA doesn't want to constrain it , why does the HashMap.put() method need to match the type it is parameterized with ..", "label": {"api": {"HashMap.put()": [[52, 64]], "put()": [[60, 64]]}}}, {"text": "What is different between both the containsKey() and put()  methods", "label": {"api": {"containsKey()": [[35, 47]], "put()": [[53, 57]]}}}, {"text": "You don't need to throws Exception in this case because ArithmeticException is a RuntimeException, the compiler doesn't know it'll be thrown, so it doesn't force you to deal with it", "label": {"api": {"ArithmeticException": [[56, 74]], "RuntimeException": [[81, 96]]}}}, {"text": "To safely remove objects from an Iterable such as a List while going through it, use Iterator", "label": {"api": {"Iterator": [[85, 92]]}}}, {"text": "Otherwise, Object's .equals() would never work", "label": {"api": {".equals()": [[20, 28]]}}}, {"text": "You can't cast an object to an a primitive type, you need to cast to Integer", "label": {"api": {"Integer": [[69, 75]]}}}, {"text": "needs formatted text, look to JEditorPane or JTextPane", "label": {"api": {"JTextPane": [[45, 53]]}}}, {"text": "There is API String#isEmpty() method to check empty Strings in Java, use it", "label": {"api": {"String#isEmpty()": [[13, 28]]}}}, {"text": "The LogManager class level documentation describes this in detail", "label": {"api": {"LogManager": [[4, 13]]}}}, {"text": "You can also use JConsole to modify the logging level", "label": {"api": {"modify": [[29, 34]]}}}, {"text": "Maybe you want to have a look at javax.inject", "label": {"api": {"javax.inject": [[33, 44]]}}}, {"text": "Your @Autowired here would be @Inject in javax.inject language; the two frameworks above allow injection in pure Java (maybe others, don't know because not interested)", "label": {"api": {"javax.inject": [[41, 52]]}}}, {"text": "Use SimpleDateFormat with the proper mask and convert it to Date and then use a Calendar object to calculate the days between (like in this example", "label": {"api": {"SimpleDateFormat": [[4, 19]], "Calendar": [[80, 87]]}}}, {"text": "Incidentally, this is implemented using  phantom references  from the java.lang.ref package", "label": {"api": {"java.lang.ref package": [[70, 90]]}}}, {"text": "You can use HttpSessionListener", "label": {"api": {"HttpSessionListener": [[12, 30]]}}}, {"text": "For temporary files you might use File.createTemporaryFile or createTemporaryDirectory", "label": {"api": {"File.createTemporaryFile": [[34, 57]]}}}, {"text": "To support your multiple languages you can use Java Resource Bundle API", "label": {"api": {"Java Resource Bundle API": [[47, 70]]}}}, {"text": "This has a writeShort (http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html#writeShort(int)) method", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html#writeShort(int)": [[23, 110]]}}}, {"text": "While regular expressions sometimes result in two problems, I am hesitant to suggest a more strict approach such as URI because I don't know how it will - or even if it will - work with such funky invalid URLs", "label": {"api": {"URI": [[116, 118]]}}}, {"text": "See the ideone example example with a fill-in encodeURIComponent", "label": {"api": {"URI": [[52, 54]]}}}, {"text": "I am using Collection.disjoint to find the disjoint set of two string collections c1, c2", "label": {"api": {"Collection.disjoint": [[11, 29]]}}}, {"text": "Use Integer.parseInt(String s) method to convert a valid number string to int value", "label": {"api": {"Integer.parseInt(String s)": [[4, 29]]}}}, {"text": "Arrays.deepEquals() will perform deep comparison, which will also check for any nested elements", "label": {"api": {"Arrays.deepEquals()": [[0, 18]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html for more details about comparators", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html": [[4, 69]]}}}, {"text": "Obligatory link <-- keep that open and read what you need to :) All the classnames in this answer are documented there", "label": {"api": {"Obligatory link": [[0, 14]]}}}, {"text": "Coming from C#, I got used to the slick interface DateTime and TimeSpan offer", "label": {"api": {"Date": [[50, 53]]}}}, {"text": "As a Java/Android newbie, I understand that the equivalent Java Date class used to have these accessors, but they were removed for back-compatibility reasons", "label": {"api": {"Date": [[64, 67]]}}}, {"text": "Is there an equivalent Java library to ease the manipulation of Date objects in Android", "label": {"api": {"Date": [[64, 67]]}}}, {"text": "Since you want to sort the Strings based on natural ordering itself, you directly create a list and use Collections.sort() on it", "label": {"api": {"Collections.sort()": [[104, 121]]}}}, {"text": "From the Double.toString() documentation", "label": {"api": {"Double.toString()": [[9, 25]]}}}, {"text": "A sand-boxed applet can access System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[31, 56]]}}}, {"text": "not a named logger) as might be obtained from Logger.getAnonymousLogger()", "label": {"api": {"Logger.getAnonymousLogger()": [[46, 72]]}}}, {"text": "According to the documentation of the Number class, the methods byteValue and shortValue were added first in JDK1.1", "label": {"api": {"documentation of the Number class": [[17, 49]]}}}, {"text": "Regarding your first question, since Java 7 you can use Files#move", "label": {"api": {"Files#move": [[56, 65]]}}}, {"text": "If an order-by clause can be supplied, you can then simply use the indexOf in returned collection", "label": {"api": {"indexOf": [[67, 73]]}}}, {"text": "The initial byte order of the newly-created ByteBuffer is always big-endian regardless of JVM, OS or hardware", "label": {"api": {"is always big-endian": [[55, 74]]}}}, {"text": "This implies that xyz class should follow contract for Map keys that is it should define hashCode and equals which are consistent", "label": {"api": {"consistent": [[119, 128]]}}}, {"text": "Check out ProcessBuilder, specifically the method redirectInput(File)", "label": {"api": {"redirectInput(File)": [[50, 68]]}}}, {"text": "Also have a look on Window.sizeToScene() method", "label": {"api": {"Window.sizeToScene()": [[20, 39]]}}}, {"text": "You can define an implementation of a Comparator<T> for that, where T is an array of the type that you wish to sort lexicographically", "label": {"api": {"Comparator<T>": [[38, 50]]}}}, {"text": "As an aside, SwingUtilities.invokeLater() is a cover for EventQueue.invokeLater() since version 1.3", "label": {"api": {"SwingUtilities.invokeLater()": [[13, 40]]}}}, {"text": "Use Double#equals to compare the values", "label": {"api": {"Double#equals": [[4, 16]]}}}, {"text": "It's a generic argument of the Void class", "label": {"api": {"Void class": [[31, 40]]}}}, {"text": "You can see it in the doc", "label": {"api": {"in the doc": [[15, 24]]}}}, {"text": "Simplest approach would be using HttpURLConnection (see this article for more information)", "label": {"api": {"HttpURLConnection": [[33, 49]]}}}, {"text": "What you're looking for is Collections.synchronizedList which can \"wrap around\" any list, including ArrayList", "label": {"api": {"Collections.synchronizedList": [[27, 54]]}}}, {"text": "Magic involving the toString() method", "label": {"api": {"the toString() method": [[16, 36]]}}}, {"text": "Finally, you will need to use the List.add() method, to add the newly created String values to your list score_Number", "label": {"api": {"List.add() method": [[34, 50]]}}}, {"text": "The Integer class has a method called toHexString(int i) that will convert an int to a string representing the Hex, and a valueOf(String s, int radix) that converts from a String with a radix, which for Hex would be 16", "label": {"api": {"Integer": [[4, 10]]}}}, {"text": "I always do it by calling setFocusPainted(boolean b)", "label": {"api": {"setFocusPainted(boolean b)": [[26, 51]]}}}, {"text": "The Console class is the correct way to read passwords from the command line", "label": {"api": {"Console": [[4, 10]]}}}, {"text": "See also SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "If you're using JDK 8 you can write", "label": {"api": {"JDK 8": [[16, 20]]}}}, {"text": "prior to JDK 8 you can use the Joda API", "label": {"api": {"JDK 8": [[9, 13]]}}}, {"text": "System#gc() does not trigger garbage collection", "label": {"api": {"System#gc()": [[0, 10]]}}}, {"text": "Consequently, Object#finalize() is not guaranteed to run at any particular time", "label": {"api": {"Object#finalize()": [[14, 30]]}}}, {"text": "You would do with this a call to append()", "label": {"api": {"append()": [[33, 40]]}}}, {"text": "Or you could do it using new arrays, and the System.arraycopy method", "label": {"api": {"System.arraycopy": [[45, 60]]}}}, {"text": "I haven't actually tested which is faster but System.arraycopy out-sources to a native method and doesn't have as much object creation so I would wager at that one", "label": {"api": {"System.arraycopy": [[46, 61]]}}}, {"text": "Internally it's backed by a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[28, 40]]}}}, {"text": "FilterReader or FilterWriter — extending either one will work", "label": {"api": {"FilterReader": [[0, 11]], "FilterWriter": [[16, 27]]}}}, {"text": "Here, I've chosen to extend FilterWriter", "label": {"api": {"FilterWriter": [[28, 39]]}}}, {"text": "Based on that model, you should be able to implement a UpperCaseFilterWriter as well", "label": {"api": {"FilterWriter": [[64, 75]]}}}, {"text": "Try using an ExecutorService to submit Runnables or Callables to, depending on what suites you best", "label": {"api": {"ExecutorService": [[13, 27]]}}}, {"text": "Within your tasks, you can then submit to the very same ExecutorService, without actually creating threads", "label": {"api": {"ExecutorService": [[56, 70]]}}}, {"text": "For the actual implementation, have a look at ThreadPoolExecutor - it will basically manage all the threading stuff for you", "label": {"api": {"ThreadPoolExecutor": [[46, 63]]}}}, {"text": "Consider using a List instead", "label": {"api": {"List": [[17, 20]]}}}, {"text": "I don't know why Hibernate is wanting that foreignKey attribute on the @JoinColumn annotation, but it was added in JPA 2.1", "label": {"api": {"it was added in JPA 2.1": [[99, 121]]}}}, {"text": "Input and Output operations are performed by the reader class and it's sub-classes", "label": {"api": {"the reader class": [[45, 60]]}}}, {"text": "For that purpose, you can use List.toArray(T[])", "label": {"api": {"List.toArray(T[])": [[30, 46]]}}}, {"text": "And turning bytes into characters and the reverse is made by a Charset{Decoder,Encoder}", "label": {"api": {"Charset": [[63, 69]]}}}, {"text": "See Charset for generic information", "label": {"api": {"Charset": [[4, 10]]}}}, {"text": "You can make use of this class JarFile", "label": {"api": {"JarFile": [[31, 37]]}}}, {"text": "Or if you want to search for particular class inside your jar you can use ZipFile class", "label": {"api": {"ZipFile": [[74, 80]]}}}, {"text": "For each file create a FileInputStream, read it and close it", "label": {"api": {"FileInputStream": [[23, 37]]}}}, {"text": "You can use an IdentityHashMap, with Void as values (or whatever else -- your choice)", "label": {"api": {"IdentityHashMap": [[15, 29]]}}}, {"text": "This is rather strange considering that the internal implementation of HashSet uses a HashMap, so one has to wonder why they didn't do the same for IdentityHashMap..", "label": {"api": {"IdentityHashMap": [[148, 162]]}}}, {"text": "And, of course, IdentityHashMap", "label": {"api": {"IdentityHashMap": [[16, 30]]}}}, {"text": "For those of us using Java 8, Collection#stream() is a clean option", "label": {"api": {"Collection#stream()": [[30, 48]]}}}, {"text": "Using Class.isInterface() you can check if it belongs to a particular interface", "label": {"api": {"Class.isInterface()": [[6, 24]]}}}, {"text": "You can use a CompletionService to get a computed value back for each task wrapped in a Future, so you don't wait for it to be calculated until you actually need the value", "label": {"api": {"CompletionService": [[14, 30]]}}}, {"text": "The difference between a CompletionService and an Executor, which the commentors are recommending, is that the CompletionService uses an Executor for executing tasks, but it makes it easier to get your data back out, see this answer", "label": {"api": {"CompletionService": [[25, 41], [111, 127]]}}}, {"text": "Here's an example of using a CompletionService", "label": {"api": {"CompletionService": [[29, 45]]}}}, {"text": "But for caching purposes I would personally go with ConcurrentHashMap since it's thread safe", "label": {"api": {"ConcurrentHashMap": [[52, 68]]}}}, {"text": "Java has a ReadWriteLock which supports reads concurrently and writes exclusively", "label": {"api": {"ReadWriteLock": [[11, 23]]}}}, {"text": "Use fairness when constructing the ReadWriteLock to enable reader and writer threads to obtain their locks in the order they requested it", "label": {"api": {"ReadWriteLock": [[35, 47]]}}}, {"text": "The benefit of a ReadWriteLock is that many reader may share the same lock without obtaining it, which is an expansive operation", "label": {"api": {"ReadWriteLock": [[17, 29]]}}}, {"text": "To start a long-running task, like sending data to a server, use a SwingWorker or a Callable and an ExecutorService", "label": {"api": {"SwingWorker": [[67, 77]]}}}, {"text": "I prefer using a SwingWorker when implementing a Swing UI, as has it a useful API for publishing updates and makes the callbacks when the task is done automatically happen on the EDT", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "The class WebApplicationException was designed for that but for some reason it ignores and overwrites what you specify as parameter for the message", "label": {"api": {"WebApplicationException": [[10, 32]]}}}, {"text": "According to the javadoc of .min() and .max(), the argument of both should be a Comparator", "label": {"api": {".min()": [[28, 33]], ".max()": [[39, 44]]}}}, {"text": "First, Stream.max() accepts an instance of Comparator so that items in the stream can be compared against each other to find the minimum or maximum, in some optimal order that you don't need to worry too much about", "label": {"api": {"Stream.max()": [[7, 18]], "Comparator": [[43, 52]]}}}, {"text": "So the question is, of course, why is Integer::max accepted", "label": {"api": {"Integer::max": [[38, 49]]}}}, {"text": "So examining the Comparator interface (simple version)", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "If a method is looking for a Comparator<Integer>, then it's essentially looking for this signature", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "Therefore, both Integer.min(int a, int b) and Integer.max(int a, int b) are close enough that autoboxing will allow this to appear as a Comparator<Integer> in a method context", "label": {"api": {"Comparator": [[136, 145]]}}}, {"text": "Read the docs -- you're getting strange characters because it's always pulling 2 bytes and building a character using a modified UTF-8 scheme, which only really maps to characters written by the corresponding DataOutput implementing classes", "label": {"api": {"Read the docs": [[0, 12]]}}}, {"text": "You should research and modify your code to use BufferedReader instead, which will more naturally respect other character encodings like UTF-8, etc", "label": {"api": {"research": [[11, 18]]}}}, {"text": "If you want to do this using indexOf, you need to update the fromIndex parameter each time", "label": {"api": {"fromIndex parameter": [[61, 79]]}}}, {"text": "I've been using a Semaphore for \"pausable runnables\", I find it easier to maintain", "label": {"api": {"Semaphore": [[18, 26]]}}}, {"text": "Since you are using Java 7, don't bother and use a FileVisitor", "label": {"api": {"FileVisitor": [[51, 61]]}}}, {"text": "You may also extend SimpleFileVisitor instead", "label": {"api": {"FileVisitor": [[26, 36]]}}}, {"text": "The default ImageWriter for JPEGs will only let you change some settings that affect the quantization and encoding using the JPEGImageWriteParam class (http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageWriteParam.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageWriteParam.html": [[152, 226]]}}}, {"text": "A better approach is to use a Map<String, Integer>, that way the search is done in constant time (O(1)) and then you can sort the elements in the Set<Map.Entry<String, Integer>> returned by Map.entrySet()", "label": {"api": {"Map.entrySet()": [[190, 203]]}}}, {"text": "Maybe try to using Scanner.nextInt() (http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html) so that you don't need to care about whitespaces", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[38, 100]]}}}, {"text": "There is no method for JOptionPane.showMessageDialog that takes exactly three arguments", "label": {"api": {"JOptionPane.showMessageDialog": [[23, 51]]}}}, {"text": "You can look at System class docs to find out how to use the System.arraycopy() method", "label": {"api": {"System class docs": [[16, 32]]}}}, {"text": "charAt throws IndexOutOfBoundsException", "label": {"api": {"IndexOutOfBoundsException": [[14, 38]]}}}, {"text": "Javadoc mentions that collect() is a mutable reduction", "label": {"api": {"Javadoc mentions that collect() is a mutable reduction": [[0, 53]]}}}, {"text": "You maybe looking for setWindowDecorationStyle(), although some L&Fs may not support the feature", "label": {"api": {"setWindowDecorationStyle()": [[22, 47]]}}}, {"text": "Java provides a utility interface for Observable, but you'll still need to do most of the work", "label": {"api": {"utility interface for Observable": [[16, 47]]}}}, {"text": "Read their javadoc (Thread.State, for example, inheriting Enum, like all the enums), and you'll see what they're for", "label": {"api": {"Thread.State": [[20, 31]], "Enum": [[58, 61]]}}}, {"text": "Swing \"Timers coalesce events by default.\" As noted by @HOFE, re-reading your sprite images is likely slowing things down enough to trigger the effect", "label": {"api": {"Timer": [[7, 11]]}}}, {"text": "Assuming you have a string that represents epoch time in seconds (as you have not told us what your Object actually is), first convert it to a long", "label": {"api": {"convert it to a long": [[127, 146]]}}}, {"text": "Then you can convert it to a java.util.Date using the Date constructor that takes millisecond epoch time", "label": {"api": {"java.util.Date": [[29, 42]], "the Date constructor that takes millisecond epoch time": [[50, 103]]}}}, {"text": "I have resolved this by using the Utilities class", "label": {"api": {"Utilities class": [[34, 48]]}}}, {"text": "java.util.Properties is probably the best class for something simple like this", "label": {"api": {"java.util.Properties": [[0, 19]]}}}, {"text": "A custom RowFactory is a good solution for this problem", "label": {"api": {"RowFactory": [[9, 18]]}}}, {"text": "And as the documentation of shutdown hooks says, they may be invoked in any order, or even in parallel", "label": {"api": {"documentation of shutdown hooks": [[11, 41]]}}}, {"text": "The problem is because Math.sqrt(double a) returns a double and you are trying to set the result to be an Integer", "label": {"api": {"Math.sqrt(double a)": [[23, 41]]}}}, {"text": "What you want to use is the HashMap or the TreeMap to implement a dictionary in Java", "label": {"api": {"HashMap": [[28, 34]], "TreeMap": [[43, 49]]}}}, {"text": "The HashMap class uses hashing to maintain the dictionary while TreeMap uses a Red Black Tree(a variant of the BST) to maintain the dictionary", "label": {"api": {"HashMap": [[4, 10]], "TreeMap": [[64, 70]]}}}, {"text": "Use the Scanner class, and call hasNextInt", "label": {"api": {"Scanner": [[8, 14]], "hasNextInt": [[32, 41]]}}}, {"text": "Read the javadoc for PrintStream, 'cos System.out is a PrintStream", "label": {"api": {"javadoc for PrintStream": [[9, 31]]}}}, {"text": "If you look at the documentation for ArrayList<T>.toArray(T[]), you'll see that it takes an array of T", "label": {"api": {"ArrayList<T>.toArray(T[])": [[37, 61]]}}}, {"text": "If you're looking for concurrency safe containers, try ConcurrentLinkedQueue or ConcurrentHashMap", "label": {"api": {"ConcurrentLinkedQueue": [[55, 75]], "ConcurrentHashMap": [[80, 96]]}}}, {"text": "If you find later that you need some inherent ordering to the way you process the entities in the game, you might want to use a PriorityQueue", "label": {"api": {"PriorityQueue": [[128, 140]]}}}, {"text": "I haven't implemented the Comparator interface into the Movie class; instead, I just use Arrays.sort and a custom Comparator to sort it by some property of the movie", "label": {"api": {"Arrays.sort": [[89, 99]]}}}, {"text": "Scanner does not have a method named nextline(), although it does have one named nextLine()", "label": {"api": {"nextLine()": [[81, 90]]}}}, {"text": "You can use the indexOf method both to find out that the input contains the string, and where its index is", "label": {"api": {"indexOf": [[16, 22]]}}}, {"text": "As others have stated, you may use indexOf to find the location of the substring", "label": {"api": {"indexOf": [[35, 41]]}}}, {"text": "If you have more than one occurrence of the substring and you want to find all of them, you can use the version of indexOf that takes a starting position to continue the search after the current occurrence, e.g", "label": {"api": {"indexOf": [[115, 121]], "the version of indexOf that takes a starting position": [[100, 152]]}}}, {"text": "Note, by the way, that .contains(needle) is essentially the same as .indexOf(needle) > -1 (in fact, that is precisely how contains() is implemented)", "label": {"api": {"indexOf": [[69, 75]]}}}, {"text": "Instead of using += on String objects use StringBuilder", "label": {"api": {"StringBuilder": [[42, 54]]}}}, {"text": "On the other hand, StringBuilder is mutable object, you append to your heart's content & then return a String object", "label": {"api": {"StringBuilder": [[19, 31]]}}}, {"text": "Hashmap is unordered", "label": {"api": {"Hashmap": [[0, 6]]}}}, {"text": "Use Treemap to sort", "label": {"api": {"Treemap": [[4, 10]]}}}, {"text": "TreeMap is an example of a SortedMap, which means that the order of the keys can be sorted, and when iterating over the keys, you can expect that they will be in order", "label": {"api": {"SortedMap": [[27, 35]]}}}, {"text": "With the first release of Java 8 (b132) on Mac OS X (Mavericks), this code using the new java.time package works", "label": {"api": {"java.time package": [[89, 105]]}}}, {"text": "But when I add \"SS\" for fraction-of-second (and \"55\" as input), as specified in the DateTimeFormatter class doc, an exception is thrown", "label": {"api": {"DateTimeFormatter class doc": [[84, 110]]}}}, {"text": "I always get a NoSuchPaddingException on this line, changing the padding to something else, like \"/NoPadding\" doesn't work", "label": {"api": {"NoSuchPaddingException": [[15, 36]]}}}, {"text": "You could use a while loop, so while RW != -1, and use indexof, from the previous RW", "label": {"api": {"indexof": [[55, 61]]}}}, {"text": "You can call createNewFile to create it on your disk", "label": {"api": {"createNewFile": [[13, 25]]}}}, {"text": "Most posts seem to discuss the advantages of LinkedHashMaps (such as this one or the API), but I can't find any reason HashMaps are better", "label": {"api": {"API": [[85, 87]]}}}, {"text": "The String API explains this method overload that also adds a limit field", "label": {"api": {"String API": [[4, 13]]}}}, {"text": "You can wrap your input stream in a PushbackInputStream so that you can push back some bytes and re-parse them", "label": {"api": {"PushbackInputStream": [[36, 54]]}}}, {"text": "Finally I found, that the code, which works much slower, is the call to Graphics2D.fill() method", "label": {"api": {"Graphics2D.fill()": [[72, 88]]}}}, {"text": "On the other hand, the most recent and for years the most anticipated Java API—the Streams API—unashamedly employs bitfields for Spliterator's characteristics", "label": {"api": {"characteristics": [[143, 157]]}}}, {"text": "The O(lg n) time bound for insert is guaranteed by the official documentation", "label": {"api": {"official documentation": [[55, 76]]}}}, {"text": "Its initial value is null, hence accessing it like charDigits[i] would raise an NPE (you should have been able to easily deduce this based on the documentation of NullPointerException)", "label": {"api": {"NullPointerException": [[163, 182]]}}}, {"text": "If the source set is the type of set that uses a custom comparator, then it is actually a SortedSet, and the TreeSet(SortedSet) constructor is used instead, which takes on the same comparator as the source set", "label": {"api": {"TreeSet(SortedSet)": [[109, 126]]}}}, {"text": "In case of duplicates, you can use ArrayList to store the values and then sort the ArrayList using Collections.sort before displaying the results", "label": {"api": {"ArrayList": [[35, 43], [83, 91]], "Collections.sort": [[99, 114]]}}}, {"text": "You can learn a lot from the sql error code", "label": {"api": {"sql error code": [[29, 42]]}}}, {"text": "First it invokes the Arrays.stream(T[]) method, where T is inferred as int[], to get a Stream<int[]>, and then Stream#flatMapToInt() method maps each int[] element to an IntStream using Arrays.stream(int[]) method", "label": {"api": {"Arrays.stream(T[])": [[21, 38]], "Stream#flatMapToInt()": [[111, 131]], "Arrays.stream(int[])": [[186, 205]]}}}, {"text": "To process the elements with their indices, you may use IntStream.range as follows", "label": {"api": {"IntStream.range": [[56, 70]]}}}, {"text": "You need to use the Collectors.toMap overload that accepts a Supplier<Map<K, V>>", "label": {"api": {"the Collectors.toMap overload that accepts a Supplier<Map<K, V>>": [[16, 79]]}}}, {"text": "If you are talking about sockets, normal sockets that connect on a port and wait for a connection on the server side and that connect to a given address on the client side, then I would recommend the boost asio socket on the c++ side and the standard java socket on the java side", "label": {"api": {"standard java socket": [[242, 261]]}}}, {"text": "Use RequestDispatcher instead of sendRedirect()", "label": {"api": {"RequestDispatcher": [[4, 20]]}}}, {"text": "Read more about RequestDispatcher", "label": {"api": {"RequestDispatcher": [[16, 32]]}}}, {"text": "Read the difference between RequestDispatcher and sendRedirect, and whento use both of them", "label": {"api": {"RequestDispatcher": [[28, 44]]}}}, {"text": "ArrayList is a class that comes with Java (its ins the java.util package)", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "I am using RandomAccessFile api to locate data in the file", "label": {"api": {"RandomAccessFile": [[11, 26]]}}}, {"text": "You can use String.startsWith", "label": {"api": {"String.startsWith": [[12, 28]]}}}, {"text": "As of Java 8, there's an actual forEach method on iterables that accepts a lambda function", "label": {"api": {"forEach method": [[32, 45]]}}}, {"text": "I think the problem is that Timer class in Java creates a background thread", "label": {"api": {"Timer class in Java creates a background thread": [[28, 74]]}}}, {"text": "In Java documentation example for Classloader", "label": {"api": {"Classloader": [[34, 44]]}}}, {"text": "You have to delve into the java.nio.file package description to see, right at the end, that", "label": {"api": {"java.nio.file package description": [[27, 59]]}}}, {"text": "The reasons for this behaviour may not be obvious, but consider for instance that two filesystems can define a different separator", "label": {"api": {"different separator": [[111, 129]]}}}, {"text": "If the files conform to the property file format, you can read them using the Properties class", "label": {"api": {"Properties": [[78, 87]]}}}, {"text": "As jarnbjo mentioned, if it conforms to the property file format, you can read the file using the Properties class", "label": {"api": {"Properties": [[98, 107]]}}}, {"text": "When you move int grade = Integer.parseInt(reader.nextLine()); inside loop it (reader.nextLine()) will stop loop until user hits enter", "label": {"api": {"reader.nextLine()": [[43, 59], [79, 95]]}}}, {"text": "What about the next method", "label": {"api": {"method": [[20, 25]]}}}, {"text": "You need to look at the fill method of the Collections API", "label": {"api": {"fill": [[24, 27]]}}}, {"text": "For more information, see the IndexColorModel class documentation", "label": {"api": {"IndexColorModel": [[30, 44]]}}}, {"text": "Use System.arraycopy(theDirectory, 0, newDirectory, 0, theDirectory.length)", "label": {"api": {"System.arraycopy": [[4, 19]]}}}, {"text": "You could use MethodHandles for that", "label": {"api": {"MethodHandles": [[14, 26]]}}}, {"text": "Use SwingUtilities.invokeLater() to run arbitrary code on the swing event thread", "label": {"api": {"SwingUtilities.invokeLater()": [[4, 31]]}}}, {"text": "Something like this, using GregorianCalendar.getActualMaximum(), will do the trick", "label": {"api": {"GregorianCalendar.getActualMaximum()": [[27, 62]]}}}, {"text": "it would be better to use some string formatting to tell the user what the actual maximum floor number is", "label": {"api": {"string formatting": [[31, 47]]}}}, {"text": "While NavigableSet, which extends SortedSet, guarantees that elements will be in the order defined by the elements themselves (if they implement Comparable) or the given Comparator, it does not override Set's contract for .equals()", "label": {"api": {"Set's contract for .equals()": [[203, 230]]}}}, {"text": "The only way you can check for element ordering is to slurp the elements of both sets into Lists and check that these lists are equal -- because List does guarantee element order in its .equals() contract", "label": {"api": {"does guarantee element order in its .equals() contract": [[150, 203]]}}}, {"text": "An array of ints is an object too, but that \"class\" doesn't override the toString method from Object, which is responsible for the \"weird output\" you see", "label": {"api": {"toString method from Object": [[73, 99]]}}}, {"text": "Print the array using Arrays.toString instead", "label": {"api": {"Arrays.toString": [[22, 36]]}}}, {"text": "You can use Pattern and Matcher", "label": {"api": {"Pattern": [[12, 18]], "Matcher": [[24, 30]]}}}, {"text": "Reference the String concat javadoc", "label": {"api": {"concat javadoc": [[21, 34]]}}}, {"text": "Another option, while performance is not the greatest (although it will be sufficient for your application, and has similar performance characteristics to your current code), is to create a temporary Set to hold a list of unique words, then use Collections.frequency() to count the occurrences in the original list, e.g", "label": {"api": {"Collections.frequency()": [[245, 267]]}}}, {"text": "You can use a TreeSet if you want to print the words in alphabetical order, or a LinkedHashSet if you want to print them in the order of first occurrence", "label": {"api": {"TreeSet": [[14, 20]], "LinkedHashSet": [[81, 93]]}}}, {"text": "I have two ways of doing this and I'm using the String#replaceAll() and String#trim() method for this", "label": {"api": {"String#replaceAll()": [[48, 66]], "String#trim()": [[72, 84]]}}}, {"text": "You could also try using the Pattern-Matcher approach", "label": {"api": {"Pattern": [[29, 35]], "Matcher": [[37, 43]]}}}, {"text": "The simplest way to do this is with a prepared statement for the insert", "label": {"api": {"prepared statement": [[38, 55]]}}}, {"text": "You can also use the prepared statement's addBatch() and executeBatch() methods to queue up all the inserts and send them to the database all at once, instead of sending a separate message to the database for each individual inserted row", "label": {"api": {"prepared statement": [[21, 38]]}}}, {"text": "More information can be found at the docs for Pattern and Matcher", "label": {"api": {"Pattern": [[46, 52]], "Matcher": [[58, 64]]}}}, {"text": "I wouldn't pass byte arrays around when doing the serialization - instead I would use java.io.DataOutput and java.io.DataInput", "label": {"api": {"java.io.DataOutput": [[86, 103]], "java.io.DataInput": [[109, 125]]}}}, {"text": "You can initialize the EntityManagerFactory in the contextInitialized method of a ServletContextListener and store the instance in a context attribute (context.setAttribute(key, emf))", "label": {"api": {"ServletContextListener": [[82, 103]]}}}, {"text": "You can use ExecutorService and try different thread pool sizes to see what's more efficient in terms of processing vs", "label": {"api": {"ExecutorService": [[12, 26]]}}}, {"text": "Double.isNaN() will not check whether a number is valid after a parse", "label": {"api": {"Double.isNaN()": [[0, 13]]}}}, {"text": "This method's argument is a double (your id is therefore automatically promoted) and it only checks whether this double is Double.NaN", "label": {"api": {"Double.NaN": [[123, 132]]}}}, {"text": "If you look at ImageIO's javadoc, you'll see, that one may use an (existing) ImageWriter", "label": {"api": {"ImageIO": [[15, 21]]}}}, {"text": "You can sum up the values of a BigDecimal stream using a reusable Collector named summingUp", "label": {"api": {"Collector": [[66, 74]]}}}, {"text": "The Collector can be implemented like this", "label": {"api": {"Collector": [[4, 12]]}}}, {"text": "You could use a Timer to fire off events and draw one point at a time", "label": {"api": {"Timer": [[16, 20]]}}}, {"text": "You can look at evt#getKeyCode() and compare that to one of the VK_ constants", "label": {"api": {"evt#getKeyCode()": [[16, 31]]}}}, {"text": "Alternatively, you can look at evt#getKeyChar() for the exact character", "label": {"api": {"evt#getKeyChar()": [[31, 46]]}}}, {"text": "You want to Field#get() the value of the field for the given Row object", "label": {"api": {"Field#get()": [[12, 22]]}}}, {"text": "setAccessible(..) is necessary if the field is not visible from the calling class", "label": {"api": {"setAccessible(..)": [[0, 16]]}}}, {"text": "You can access a method using Class.getMethod, which returns a Method object", "label": {"api": {"Class.getMethod": [[30, 44]], "Method": [[39, 44], [63, 68]]}}}, {"text": "You then invoke that Method object by passing it the instance and arguments", "label": {"api": {"Method": [[21, 26]]}}}, {"text": "If that's the case, you can get a Field via Class.getField, and get its value via the get method, again passing in the instance on which you want to get the field", "label": {"api": {"Field": [[34, 38], [53, 57]], "Class.getField": [[44, 57]]}}}, {"text": "The nature of the class contained in the List is of no importance - however in this particular case you should be aware that there's already a File class in the standard java.io package, so File may not be the best name to give to a custom class..", "label": {"api": {"there's already a File class in the standard java.io package": [[125, 184]]}}}, {"text": "If your alphabet consists just of 0-z, then you can make use of Java's Integer.toString() method providing a radix of 36, and just do some counting and padding", "label": {"api": {"Integer.toString()": [[71, 88]]}}}, {"text": "Use Double.doubleToRawLongBits(double), and then Long.toBinaryString(long) on the result", "label": {"api": {"Double.doubleToRawLongBits(double)": [[4, 37]], "Long.toBinaryString(long)": [[49, 73]]}}}, {"text": "You need to get the session from the request, you cannot simply expect to get it with HttpSession s ; - There s is null", "label": {"api": {"request": [[37, 43]]}}}, {"text": "You can use the split() method", "label": {"api": {"split()": [[16, 22]]}}}, {"text": "If you look at String.split(String regrex), you will find that it will return an array of strings", "label": {"api": {"String.split(String regrex)": [[15, 41]]}}}, {"text": "You can utilize JDesktopPane.getSelectedFrame that returns currently active frame", "label": {"api": {"JDesktopPane.getSelectedFrame": [[16, 44]]}}}, {"text": "You can use Collections.disjoint()", "label": {"api": {"Collections.disjoint()": [[12, 33]]}}}, {"text": "The simplest way to use this is to use the Random.nextFloat() method for this, and then check which range the random number between 0-1 falls in", "label": {"api": {"Random.nextFloat()": [[43, 60]]}}}, {"text": "Don't use new to create an FXML controller, use FXMLLoader.load()", "label": {"api": {"FXMLLoader.load()": [[48, 64]]}}}, {"text": "The problem is that you don't have a toString() method defined in your LinkedList class, so it inherits the toString() method from Object, which is responsible for the output you see", "label": {"api": {"the toString() method from Object": [[104, 136]]}}}, {"text": "So in actuality, valueOf() is used as opposed to the constructor (and the same goes for the other wrapper classes)", "label": {"api": {"valueOf()": [[17, 25]]}}}, {"text": "intValue() is used (again, it's analogous for the other wrapper types as well)", "label": {"api": {"intValue()": [[0, 9]]}}}, {"text": "But you can get a good start by wrapping your method in a Callable<T> and submitting that to ExecutorService.submit", "label": {"api": {"Callable<T>": [[58, 68]], "ExecutorService.submit": [[93, 114]]}}}, {"text": "That will return back a Future<T>, which has a method get()", "label": {"api": {"Future<T>": [[24, 32]]}}}, {"text": "That last method returns T, but not until the Callable<T> finished", "label": {"api": {"Callable<T>": [[46, 56]]}}}, {"text": "Don't bother with bit shifting etc; Java has ByteBuffer which can handle that for you, and endianness to boot", "label": {"api": {"ByteBuffer": [[45, 54]]}}}, {"text": "Don't forget to specify endianness in your case since ByteBuffers are big endian by default", "label": {"api": {"ByteBuffer": [[54, 63]]}}}, {"text": "You can use a Map (variable name as key, value as value)", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "For the sleeping thread, you can use either a Timer or a ScheduledExecutorService", "label": {"api": {"Timer": [[46, 50]], "ScheduledExecutorService": [[57, 80]]}}}, {"text": "To update the user-interface… I don't know swt, but expect you need to find the equivalent of SwingWorker used in Swing", "label": {"api": {"SwingWorker": [[94, 104]]}}}, {"text": "See the String documentation for which methods you can use on a string", "label": {"api": {"String documentation": [[8, 27]]}}}, {"text": "If you use Java 7, you can use Files.probeContentType()", "label": {"api": {"Files.probeContentType()": [[31, 54]]}}}, {"text": "From java API", "label": {"api": {"java API": [[5, 12]]}}}, {"text": "System.out is a static field of System, yes; it is also a PrintStream, and a PrintStream has a println() method which happens to match the signature of a Consumer in this case, and a Consumer is what forEach() expects", "label": {"api": {"a Consumer is what forEach() expects": [[181, 216]]}}}, {"text": "If you mean getting position of enum constant without having to use extra variable, you can use Enum#ordinal() method", "label": {"api": {"Enum#ordinal()": [[96, 109]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html It depends on the file that is read", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html": [[0, 73]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/javax/swing/JFrame.html  This is the Window used to display all the things, and make them visible", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JFrame.html": [[0, 63]]}}}, {"text": "However, you can improve upon the timing of your method by using getChars method of the string to avoid copying the characters past the end of the substring that you need", "label": {"api": {"getChars method": [[65, 79]]}}}, {"text": "Use this one with Pattern.quote() to deal with regex special characters and treat S2 as a literal pattern", "label": {"api": {"Pattern.quote()": [[18, 32]]}}}, {"text": "Define your own class that implements Comparator<String>", "label": {"api": {"Comparator<String>": [[38, 55]]}}}, {"text": "Then you can pass an instance of your comparator (along with your ArrayList) to Collections.sort", "label": {"api": {"Collections.sort": [[80, 95]]}}}, {"text": "To compare array contents, use Arrays.equals", "label": {"api": {"Arrays.equals": [[31, 43]]}}}, {"text": "Because strings are immutable it is also guaranteed that there is no way to change the result of the String.equals function, provided the same string objects are supplied", "label": {"api": {"String.equals": [[101, 113]]}}}, {"text": "String.equals compares this string to the specified object", "label": {"api": {"String.equals": [[0, 12]]}}}, {"text": "This is the javadoc of Collectors, they wrote a few examples of groupingBy, but I have not been able to get it working", "label": {"api": {"javadoc of Collectors": [[12, 32]]}}}, {"text": "Then you could iterate by its keys (Map.keySet()), which would automatically be ordered", "label": {"api": {"Map.keySet()": [[36, 47]]}}}, {"text": "Alternatively, ZipCode could implement Comparable<ZipCode>, and then Collection.sort(list) would automatically sort a list of them for you", "label": {"api": {"Comparable<ZipCode>": [[39, 57]], "Collection.sort(list)": [[69, 89]]}}}, {"text": "I think this is a good place to use Comparator", "label": {"api": {"Comparator": [[36, 45]]}}}, {"text": "Then you can just use Collections.sort with a Comparator to sort it by town name", "label": {"api": {"Comparator": [[46, 55]]}}}, {"text": "Instead of getting an InputStream from the socket, and filling a byte array to be wrapped, you can get the SocketChannel and read() directly to the ByteBuffer", "label": {"api": {"get the SocketChannel": [[99, 119]], "read()": [[125, 130]]}}}, {"text": "loading property file) on servlet when webapp is started then use ServletContextListener as Bhesh Gurung has suggested", "label": {"api": {"ServletContextListener": [[66, 87]]}}}, {"text": "I would not do this with a SortedSet, even though a custom Comparator could be used", "label": {"api": {"though a custom Comparator could be used": [[43, 82]], "Comparator": [[59, 68]]}}}, {"text": "The actual sorting is \"trivial\" with Collections.sort and a custom Comparator as this is really a \"sort by\" operation, for instance", "label": {"api": {"Collections.sort": [[37, 52]], "Comparator": [[67, 76]]}}}, {"text": "Look at class FileInputStream", "label": {"api": {"FileInputStream": [[14, 28]]}}}, {"text": "You may check RectangularShape.intersects() Javadoc for more information on how this method computes intersection", "label": {"api": {"RectangularShape.intersects()": [[14, 42]]}}}, {"text": "Consider that every Java Object inherits from java.lang.Object, that is why you can call toString() or equals() on any Object", "label": {"api": {"java.lang.Object": [[46, 61]]}}}, {"text": "When setting a Java thread to min priority I know it results in more scheduling time for fellow threads within the same JVM", "label": {"api": {"min priority": [[30, 41]]}}}, {"text": "Also, you might want to use an implementation of the KeyAdapter class, which allows you to define only the methods you want to use instead of all the methods, instead of having your own class KeyListener", "label": {"api": {"KeyAdapter": [[53, 62]]}}}, {"text": "Some resources highlight that it is based on file extension and other resources such as this one indicate that a bug exists", "label": {"api": {"resources": [[5, 13], [70, 78]]}}}, {"text": "I've created a excel file and using save as I've saved it as myexcelfile.txt and ProbeContentType reported it as application/zip hence proving that it is not based on extension, now this has created further confusion as the link I've provided is from Oracle and states both extension wise and byte wise verification", "label": {"api": {"the link": [[220, 227]]}}}, {"text": "You should probably use a java.util.concurrent.BlockingQueue instead and see if that solves the problem", "label": {"api": {"java.util.concurrent.BlockingQueue": [[26, 59]]}}}, {"text": "Also try DefaultTableModel", "label": {"api": {"DefaultTableModel": [[9, 25]]}}}, {"text": "By the way, If your file is relatively big I would recoment you to use StringBuilder", "label": {"api": {"StringBuilder": [[71, 83]]}}}, {"text": "You could use the overloaded method indexOf combined with the substring method", "label": {"api": {"indexOf": [[36, 42]], "substring": [[62, 70]]}}}, {"text": "a.indexOf(',', a.indexOf(',')+1) returns the index of the second comma in the String", "label": {"api": {"indexOf": [[2, 8], [17, 23]]}}}, {"text": "You must set the RetentionPolicy of your annotation to RetentionPolicy.RUNTIME", "label": {"api": {"RetentionPolicy": [[17, 31], [55, 69]]}}}, {"text": "The default RetentionPolicy is RetentionPolicy.CLASS, which means the annotation does not need to be available at runtime", "label": {"api": {"RetentionPolicy": [[12, 26], [31, 45]]}}}, {"text": "Perhaps start with a GridPane and see how far that gets you", "label": {"api": {"GridPane": [[21, 28]]}}}, {"text": "In \"normal\" Java 7 you could use X instead to represent an ISO-8601 time zone offset specifier, but that isn't supported in the Android SimpleDateTime right now", "label": {"api": {"\"normal\" Java 7": [[3, 17]]}}}, {"text": "Z is intended to designate a time zone as by the RFC822Timezone", "label": {"api": {"RFC822Timezone": [[49, 62]]}}}, {"text": "Well, you could use the deprecated destroy() method to stop brutally murder the thread, but you really shouldn't do that because you don't know what it is doing at that moment", "label": {"api": {"destroy()": [[35, 43]]}}}, {"text": "The SocketAddress that this returns is actually a protocol-dependent subclass", "label": {"api": {"protocol-dependent subclass": [[50, 76]]}}}, {"text": "For internet protocols, such as TCP in your case, you can cast it to an InetSocketAddress", "label": {"api": {"InetSocketAddress": [[72, 88]]}}}, {"text": "Then you can use the methods of InetSocketAddress to get the information you need, e.g.", "label": {"api": {"InetSocketAddress": [[32, 48]]}}}, {"text": "Then, you can cast that to an Inet4Address or Inet6Address depending on the address type (if you don't know, use instanceof to find out), e.g", "label": {"api": {"Inet4Address": [[30, 41]], "Inet6Address": [[46, 57]]}}}, {"text": "In any case you are better off using newSingleThreadScheduledExecutor instead", "label": {"api": {"newSingleThreadScheduledExecutor": [[37, 68]]}}}, {"text": "you don't need to schedule your tasks for periodic execution, you could simply schedule next task for single execution in future after completion of current task", "label": {"api": {"schedule": [[18, 25], [79, 86]]}}}, {"text": "Is there any reason why would authors of Java org.w3c.dom library choose not to support the Iterable interface", "label": {"api": {"Iterable": [[92, 99]]}}}, {"text": "For example, the interface NodeList seems like a perfect fit for extending Iterable", "label": {"api": {"Iterable": [[75, 82]], "NodeList": [[27, 34]]}}}, {"text": "If the History type is an enum, then the root of your problem is in the public EnumMap (Class< K > keyType) constructor, because as per javadoc, it", "label": {"api": {"public EnumMap (Class< K > keyType)": [[72, 106]]}}}, {"text": "The general solution would be to use FileChannel, with its MappedByteBuffer", "label": {"api": {"FileChannel": [[37, 47]]}}}, {"text": "Use a LinkedHashMap to store the counts for each character because it maintains insert order", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "As one can read in javadoc of ArrayList", "label": {"api": {"javadoc of ArrayList": [[19, 38]]}}}, {"text": "If you do need to convert cipher text to a String, use an encoding like Base-64 or Base-85", "label": {"api": {"Base-64": [[72, 78]]}}}, {"text": "The other answers that involve writing a custom Collector are probably more efficient (such as Louis Wasserman's, +1), but if you want brevity, I'd suggest the following", "label": {"api": {"Collector": [[48, 56]]}}}, {"text": "Using a Collector", "label": {"api": {"Collector": [[8, 16]]}}}, {"text": "We return an Optional, since we usually can't assume the Collection to contain exactly one element", "label": {"api": {"Optional": [[13, 20]]}}}, {"text": "Implement the interface by creating a compare method that takes two Players", "label": {"api": {"compare method": [[38, 51]]}}}, {"text": "Then you can create your PlayerComparator and pass it (along with your array) to Arrays.sort", "label": {"api": {"Arrays.sort": [[81, 91]]}}}, {"text": "You will need to split by whitespace, not just a single space, so that multiple spaces is considered one single delimiter", "label": {"api": {"split": [[17, 21]], "whitespace": [[26, 35]]}}}, {"text": "Specifically, take a look at JarFile.getEntry() and JarFile.getInputStream()", "label": {"api": {"JarFile.getEntry()": [[29, 46]], "JarFile.getInputStream()": [[52, 75]]}}}, {"text": "If you're using java8 you could look at the replaceAll method", "label": {"api": {"replaceAll": [[44, 53]]}}}, {"text": "Take a look at Response.getEntity()", "label": {"api": {"Response.getEntity()": [[15, 34]]}}}, {"text": "Java comes with a class called HttpURLConnection that would allow you to make requests to your JAX-RS resource", "label": {"api": {"HttpURLConnection": [[31, 47]]}}}, {"text": "Alternatively you could use the Apache HttpComponents library which contains an HTTPClient that arguably has a nicer API than the built in Java HttpURLConnection class", "label": {"api": {"HttpURLConnection": [[144, 160]]}}}, {"text": "In the absence of symbols, you can use many methods of lookup on elements in a data structure (such as an array, a List, or a Map)", "label": {"api": {"Map": [[126, 128]]}}}, {"text": "Alternatively, you can utilize the powerful Map data structure to make it faster and easier to get objects based on some unique \"key\" attribute", "label": {"api": {"Map": [[44, 46]]}}}, {"text": "You could start by looking at How to write a Mouse Listener and the JavaDocs for MouseEvent in particular, the getButton method", "label": {"api": {"JavaDocs for MouseEvent": [[68, 90]], "getButton": [[111, 119]]}}}, {"text": "However, there are cross platform considerations that need to taken into consideration, which are overed by SwingUtilities.isLeftMouseButton and equivalent methods..", "label": {"api": {"SwingUtilities.isLeftMouseButton": [[108, 139]]}}}, {"text": "You can use java.util.Timer class to schedule runs", "label": {"api": {"java.util.Timer": [[12, 26]]}}}, {"text": "Use Java's Comparator and Collections", "label": {"api": {"Comparator": [[11, 20]], "Collections": [[26, 36]]}}}, {"text": "Java has a \"utility\" class called Collections", "label": {"api": {"Collections": [[34, 44]]}}}, {"text": "The method sort from Java's utility Collections class has the following signature", "label": {"api": {"Collections": [[36, 46]]}}}, {"text": "This means it takes some List of generic objects (T), and some Comparator for T or one of the members of its subclass hierarchy", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "Comparator is a simple interface with two methods", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "Or you may also be interested in Scanner.nextInt()", "label": {"api": {"Scanner.nextInt()": [[33, 49]]}}}, {"text": "From what we see in your code here, replacing this BoxLayout with a BorderLayout should not have any impact on your layout inside this panel because you don't add any component to this panel in your code", "label": {"api": {"BorderLayout": [[68, 79]]}}}, {"text": "If this is not the case, please read BorderLayout Javadoc", "label": {"api": {"BorderLayout": [[37, 48]]}}}, {"text": "You are on the right track, overriding hashcode and equals, except you are incorrectly overriding the equals method from Object in HashSquareSpec (and SquareSpec)", "label": {"api": {"equals method from Object": [[102, 126]]}}}, {"text": "On looking up the ArrayList docs, one can easily out that this class does not contain any such field called get", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "the ArrayList#get () method works in a similar way", "label": {"api": {"ArrayList": [[4, 12]], "ArrayList#get ()": [[4, 19]]}}}, {"text": "I am using the FileNameExtensionFilter to filter the file type but when the user selects the open button, they have the option to select \"All files\" from the file type", "label": {"api": {"FileNameExtensionFilter": [[15, 37]]}}}, {"text": "Even your VehicleDetailsCollection class should implement the Serializable interface", "label": {"api": {"Serializable": [[62, 73]]}}}, {"text": "Implementing Serializable in VehicleDetailsCollectionWrapper class makes only the wrapper serializable and not the VehicleDetailsCollection class", "label": {"api": {"Serializable": [[13, 24]]}}}, {"text": "BufferedReader doesn't override toString(), so you're getting the implementation from Object, as documented", "label": {"api": {"documented": [[97, 106]]}}}, {"text": "An excerpt from java.awt.Color", "label": {"api": {"java.awt.Color": [[16, 29]]}}}, {"text": "As you can see from the above extract, the Color white is assigned to two variables namely Color#WHITE and Color#white this is also the same case for", "label": {"api": {"Color#WHITE": [[91, 101]], "Color#white": [[107, 117]]}}}, {"text": "the SimpleDateFormat) to formate that date", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "For a Map that keeps its keys in original insertion order, use LinkedHashMap", "label": {"api": {"Map": [[6, 8], [73, 75]], "LinkedHashMap": [[63, 75]]}}}, {"text": "For a Map that keeps its keys in sorted order (either natural order or by you passing a Comparator), use either TreeMap or ConcurrentSkipListMap", "label": {"api": {"Map": [[6, 8], [116, 118], [141, 143]], "Comparator": [[88, 97]], "TreeMap": [[112, 118]], "ConcurrentSkipListMap": [[123, 143]]}}}, {"text": "For a Map where the key an enum, use EnumMap if you want the entries ordered by the definition order of the enum's objects", "label": {"api": {"Map": [[6, 8], [41, 43]], "EnumMap": [[37, 43]]}}}, {"text": "The other six Map implementations bundled with Java 11 do not promise any order to their entries", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "You could always use the Void type, e.g", "label": {"api": {"Void": [[25, 28]]}}}, {"text": "The method documentation for Component.addPropertyChangeListener clearly lists the properties that are being observed", "label": {"api": {"method documentation": [[4, 23]]}}}, {"text": "Start with something simple like newCachedThreadPool(), and supply a ThreadFactory with an auto incrementing variable as you've done in your code", "label": {"api": {"newCachedThreadPool()": [[33, 53]], "ThreadFactory": [[69, 81]]}}}, {"text": "From the PrintStream docs", "label": {"api": {"PrintStream docs": [[9, 24]]}}}, {"text": "Perhaps WebEngine may be worth a look", "label": {"api": {"WebEngine": [[8, 16]]}}}, {"text": "You could simply use String.split(), first to tokenize the whitespace and then to tokenize on your key/value separator (colon in this case)", "label": {"api": {"String.split()": [[21, 34]]}}}, {"text": "Thread's javadoc states that Thread.notifyAll() is called internally when thread finishes", "label": {"api": {"Thread's javadoc": [[0, 15]]}}}, {"text": "You could use Collections.rotate", "label": {"api": {"Collections.rotate": [[14, 31]]}}}, {"text": "You are modifying your list structurally in update thread while, at the same time, the render thread has created an Iterator and is having fun iterating your objects", "label": {"api": {"modifying your list structurally": [[8, 39]]}}}, {"text": "Java documentation for the Comparable interface strongly recommends you to fix the problem", "label": {"api": {"Java documentation for the Comparable interface": [[0, 46]]}}}, {"text": "I think what you want is the IdentityHashMap", "label": {"api": {"IdentityHashMap": [[29, 43]]}}}, {"text": "Since there is no IdentityHashSet class, if you want a Set with the same characteristics of the IdentityHashMap you can just use the Collections.newSetFromMap utility method", "label": {"api": {"IdentityHashMap": [[96, 110]], "Collections.newSetFromMap": [[133, 157]]}}}, {"text": "Try using a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[12, 24]]}}}, {"text": "Also you could use the nextInt(int n) method from the Random class", "label": {"api": {"nextInt(int n)": [[23, 36]], "Random": [[54, 59]]}}}, {"text": "You start with an ExecutorService, which restricts the number of threads and is shared across all service operations", "label": {"api": {"ExecutorService": [[18, 32]]}}}, {"text": "JList is a generic type, and you're using it as a raw type", "label": {"api": {"JList": [[0, 4]]}}}, {"text": "Use new JList<Object>(uniqueWords.toArray()) or, better, if you want a JList<String>", "label": {"api": {"JList": [[8, 12], [71, 75]]}}}, {"text": "You have been popping and peeking the Stack without checking if it is empty first", "label": {"api": {"Stack": [[38, 42]]}}}, {"text": "Peeking or popping an empty stack generates the EmptyStackException you have been getting", "label": {"api": {"Stack": [[53, 57]], "EmptyStackException": [[48, 66]]}}}, {"text": "As you pointed out, the Stack class does check isEmpty() within peek(), but it only does so to generate the EmptyStackException", "label": {"api": {"Stack": [[24, 28], [113, 117]], "EmptyStackException": [[108, 126]], "isEmpty()": [[47, 55]], "peek()": [[64, 69]]}}}, {"text": "It is your responsibility as the caller of peek() to check isEmpty() yourself first", "label": {"api": {"isEmpty()": [[59, 67]], "peek()": [[43, 48]]}}}, {"text": "If you don't do this then you have created an impossible situation for the Stack- it can't show you the result of a peek if there is nothing to peek from the empty Stack", "label": {"api": {"Stack": [[75, 79], [164, 168]]}}}, {"text": "but the walkaway is that you must check isEmpty() before calling either peek() or pop()", "label": {"api": {"isEmpty()": [[40, 48]], "peek()": [[72, 77]]}}}, {"text": "The if statement executes once the while statement ends, and when the while statement ends you are guaranteed to that the s Stack is non-empty", "label": {"api": {"Stack": [[124, 128]]}}}, {"text": "JLabel is a Swing GUI component", "label": {"api": {"JLabel": [[0, 5]]}}}, {"text": "Use the executeQuery() method to return your ResultSet", "label": {"api": {"executeQuery() method": [[8, 28]]}}}, {"text": "Your JSON represents a Map<String, String>, and you want to get the highest Key, so you may try deserializing your JSON into a TreeMap, which is exactly a Map sorted by Key..", "label": {"api": {"TreeMap": [[127, 133]]}}}, {"text": "If for some reason you cannot deserialize directly into a TreeMap (although I guess you should be able to do it), try deserializing into a generic Map, and then construct a TreeMap from it, like this", "label": {"api": {"TreeMap": [[58, 64], [173, 179]]}}}, {"text": "You have to implement .equals() (and for good measure", "label": {"api": {".equals()": [[22, 30]]}}}, {"text": "assertEquals() will use that .equals() method to assert that the two objects you provided are the same", "label": {"api": {".equals()": [[29, 37]]}}}, {"text": "The javadoc for Set's .add() says that it", "label": {"api": {"javadoc for Set's .add()": [[4, 27]]}}}, {"text": "Instead, use the more conservative fireTableCellUpdated(int,int) and specify each cell that may have been modified due to the time change (presumably, everything in the \"wait time\" column)", "label": {"api": {"fireTableCellUpdated(int,int)": [[35, 63]]}}}]