[{"text":"For converting the array back into a line, you could use join","label":{"api":{"join":[[57,60]]}}},{"text":"You can collect the lines using a String or better a StringBuilder","label":{"api":{"String":[[34,39]],"StringBuilder":[[53,65]]}}},{"text":"If you don't want the content on disk, you could alternatively implement your own in-memory URLStreamHandler, and specify it when creating the URL using the URL(String protocol, String host, int port, String file, URLStreamHandler handler) constructor","label":{"api":{"URLStreamHandler":[[92,107]],"URL":[[143,145]],"URL(String protocol, String host, int port, String file, URLStreamHandler handler)":[[157,238]]}}},{"text":"The parameters are self-explanatory (see javadoc iterate) however","label":{"api":{"iterate":[[49,55]]}}},{"text":"You can use AtomicInteger class","label":{"api":{"AtomicInteger":[[12,24]]}}},{"text":"Further, according to System.nanoTime() documentation and Kevin Bourrillion's answer to another question I concluded that JMH, by default, measures time according to some arbitrary, but fixed, source (just like System.nanoTime())","label":{"api":{"System.nanoTime()":[[22,38],[211,227]]}}},{"text":"String::copyValueOf internally returns new String","label":{"api":{"String::copyValueOf":[[0,18]],"String":[[43,48]]}}},{"text":"The HttpRequest, HttpResponse, and HttpClient classes are from the java.net.http package","label":{"api":{"HttpRequest":[[4,14]],"HttpResponse":[[17,28]],"HttpClient":[[35,44]],"java.net.http":[[67,79]]}}},{"text":"In my DTO I have some fields having Timestamp as a data type","label":{"api":{"Timestamp":[[36,44]]}}},{"text":"Since Java 8, Date and their friends such as Time, Timestamp, Calendar and SimpleDateFormat are legacy classes","label":{"api":{"Date":[[14,17]],"Time":[[45,48]],"Timestamp":[[51,59]],"Calendar":[[62,69]],"SimpleDateFormat":[[75,90]]}}},{"text":"In your situation, you could either use Instant or OffsetDateTime","label":{"api":{"Instant":[[40,46]],"OffsetDateTime":[[51,64]]}}},{"text":"id brings a backport of Java 8 date and time classes to Java 6 and 7, so you can use Instant or OffsetDateTime","label":{"api":{"date":[[31,34]],"time":[[40,43]],"Instant":[[85,91]],"OffsetDateTime":[[96,109]]}}},{"text":"You are using a wrong formatter pattern, you should use ISO date-time formatter","label":{"api":{"ISO date-time formatter":[[56,78]]}}},{"text":"It always returns true","label":{"api":{}}},{"text":"Using DateTimeFormatterBuilder to produce a DateTimeFormatter as suggested by vmrvictor","label":{"api":{"DateTimeFormatterBuilder":[[6,29]],"DateTimeFormatter":[[44,60]]}}},{"text":"The returned LocalDateTime object can be formatted at will, but I assumed that 2019-01-01 00:00:00 in the question indicates an object, compared to \"2019\" that represents a string","label":{"api":{"LocalDateTime":[[13,25]]}}},{"text":"If you look at the documentation of replace(), it mentions","label":{"api":{"replace()":[[36,44]]}}},{"text":"I believe what you are looking for is LinkedHashMap","label":{"api":{"LinkedHashMap":[[38,50]]}}},{"text":"All heavy tasks in Swing should be executed by SwingWorkers","label":{"api":{"SwingWorkers":[[47,58]]}}},{"text":"Integers are object types so for comparing them you should use Integer::equals","label":{"api":{"Integer":[[0,6]],"Integer::equals":[[63,77]]}}},{"text":"You can use printf in Java","label":{"api":{"printf":[[12,17]]}}},{"text":"It does the String.format() internally, so you can write pretty much in the same way as Python (or any language with printf-like functionality)","label":{"api":{"String.format()":[[12,26]]}}},{"text":"System.out is a static field / global object / singleton","label":{"api":{"System.out":[[0,9]]}}},{"text":"But you can call non-static methods even from static methods as long as you have an instance to call them on (such as System.out here)","label":{"api":{"System.out":[[118,127]]}}},{"text":"That is not needed here (unless you want to do System.out.println(this) -- that would not work from inside a static method)","label":{"api":{"System.out.println(this)":[[47,70]]}}},{"text":"None of this is \"special\" about System.out or requires internal JVM magic","label":{"api":{"System.out":[[32,41]]}}},{"text":"The built-in Objects.equals() method does exactly this","label":{"api":{"Objects.equals()":[[13,28]]}}},{"text":"Not knowing the exception, one thing that is wrong, is that you're not calling the close() method on the NamingEnumeration, so you're leaking resources","label":{"api":{"close()":[[83,89]],"NamingEnumeration":[[105,121]]}}},{"text":"Javadoc of Inflater.needsInput()","label":{"api":{"Inflater.needsInput()":[[11,31]]}}},{"text":"Then when I want to check what type of map is returned by the factory method, I found the following note","label":{"api":{}}},{"text":"You could pass a Consumer that accepts a list of strings and calls the builder methods, e.g.","label":{"api":{"Consumer":[[17,24]],"builder":[[71,77]]}}},{"text":"You have to make sure that ArrayOutOfBoundException is not thrown by not mixing rows and columns indices","label":{"api":{"ArrayOutOfBoundException":[[27,50]]}}},{"text":"The given stream is guaranteed to support the mark feature and the detector is expected to mark the stream before reading any bytes from it, and to reset the stream before returning","label":{"api":{}}},{"text":"Javadoc of TikaInputStream says","label":{"api":{"TikaInputStream":[[11,25]]}}},{"text":"The created TikaInputStream instance keeps track of the original resource used to create it, while behaving otherwise just like a normal, buffered InputStream","label":{"api":{"TikaInputStream":[[12,26]],"InputStream":[[147,157]]}}},{"text":"A TikaInputStream instance is also guaranteed to support the mark(int) feature","label":{"api":{"TikaInputStream":[[2,16]],"mark(int)":[[61,69]]}}},{"text":"Which means you should use TikaInputStream to read the content, and try-with-resources to close it","label":{"api":{"TikaInputStream":[[27,41]]}}},{"text":"You can use the add method of JsonObjectBuilder","label":{"api":{"add":[[16,18]],"JsonObjectBuilder":[[30,46]]}}},{"text":"In this specific case I think the isDefault() method should return true","label":{"api":{"isDefault()":[[34,44]]}}},{"text":"From the JToolBar documentation","label":{"api":{"JToolBar":[[9,16]]}}},{"text":"Using IntStream::range should work (for your special step of 20)","label":{"api":{"IntStream::range":[[6,21]]}}},{"text":"The same could be achieved with IntStream::iterate (available since JDK9) which takes seed, IntPredicate and IntUnaryOperator","label":{"api":{"IntStream::iterate":[[32,49]],"IntPredicate":[[92,103]],"IntUnaryOperator":[[109,124]]}}},{"text":"From the Javadoc for TreeMap","label":{"api":{"TreeMap":[[21,27]]}}},{"text":"Converting bytes to a String decodes the bytes, which means some values may be altered or lost","label":{"api":{"bytes":[[11,15],[41,45]],"String":[[22,27]]}}},{"text":"Your data appears to consist entirely of short values, so, assuming the C client is built to regard short as a 16-bit value, and assuming the C compiler didn’t pad your struct members in order to word-align them, you can convert your bytes to a sequence of shorts using ByteBuffer and ShortBuffer","label":{"api":{"ByteBuffer":[[270,279]],"ShortBuffer":[[285,295]]}}},{"text":"To print them, retrieve them as an array and use Arrays.toString","label":{"api":{"Arrays.toString":[[49,63]]}}},{"text":"Note that if you're not using Java 11+ you can replace the use List#of with Arrays#asList(T...)","label":{"api":{"List#of":[[63,69]],"Arrays#asList(T...)":[[76,94]]}}},{"text":"If you are using Java 11+ then consider using the result of List#of directly, rather than copying the result into a modifiable ArrayList (assuming you don't plan on modifying the list)","label":{"api":{"List#of":[[60,66]],"ArrayList":[[127,135]]}}},{"text":"You may also want to consider using the java.time.DayOfWeek enum instead of a String to represent each day of the week","label":{"api":{"java.time.DayOfWeek":[[40,58]],"String":[[78,83]]}}},{"text":"As per Javadoc","label":{"api":{}}},{"text":"Use Number in your calculatory code for int/double/BigDecimal (all are Number) and such","label":{"api":{"Number":[[4,9],[71,76]],"int":[[40,42]],"double":[[44,49]],"BigDecima":[[51,59]]}}},{"text":"To compile and cache your fixed code use newTemplates to create a Templates object, https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newTemplates-javax.xml.transform.Source-, then for each execution in a multi-threaded environment use newTransformer on the Templates object to create a new Transformer","label":{"api":{"newTemplates":[[41,52]],"Templates":[[66,74],[294,302]],"newTransformer":[[272,285]],"Transformer":[[327,337]]}}},{"text":"Since java 8 exist Stream.flatMap, which is well suited for such situations","label":{"api":{"Stream.flatMap":[[19,32]]}}},{"text":"This sets up a cache which wraps any value it stores in a SoftReference","label":{"api":{"SoftReference":[[58,70]]}}},{"text":"A far easier way to go about it would be to replace() all instances of the substring with an empty string, and check whether the resulting string is empty or not","label":{"api":{"replace()":[[44,52]]}}},{"text":"Alternatively, use a regular expression to check whether the string matches() a multiple of the substring","label":{"api":{"matches()":[[68,76]]}}},{"text":"Think about List.indexOf","label":{"api":{"List.indexOf":[[12,23]]}}},{"text":"You may want to define your triangle as a Polygon , and use fillPolygon(Polygon) e.g","label":{"api":{"Polygon":[[42,48]],"fillPolygon(Polygon)":[[60,79]]}}},{"text":"The API documentation for Thread.join says","label":{"api":{"Thread.join":[[26,36]]}}},{"text":"We are building an application using the new (well comparatively) Java HttpClient that was added in Java 11","label":{"api":{"HttpClient":[[71,80]]}}},{"text":"Would java RandomAccessFile class methods help","label":{"api":{"RandomAccessFile":[[11,26]]}}},{"text":"There's nothing in the java.util.function package which applies to this","label":{"api":{"java.util.function":[[23,40]]}}},{"text":"then you could use BiFunction but there is no \"TriFunction\"","label":{"api":{"BiFunction":[[19,28]],"TriFunction":[[47,57]]}}},{"text":"inheritIO() will cause all of the child process’s output to appear in the output of the Java program which calls it, eliminating the need to consume the process’s InputStream and ErrorStream yourself","label":{"api":{"inheritIO()":[[0,10]],"InputStream":[[163,173]],"ErrorStream":[[179,189]]}}},{"text":"allOf returns a new CompletableFuture that is completed when all of the given CompletableFutures complete","label":{"api":{"allOf":[[0,4]],"CompletableFuture":[[20,36]],"CompletableFutures":[[78,95]]}}},{"text":"There is no single Java SE method for it, but with Character.digit it’s fairly straightforward","label":{"api":{"Character.digit":[[51,65]]}}},{"text":"You could use collectingAndThen","label":{"api":{"collectingAndThen":[[14,30]]}}},{"text":"From the Javadoc of Socket.getInputStream()","label":{"api":{"Socket.getInputStream()":[[20,42]]}}},{"text":"If you need the method to take or return data, you could use an existing Functional Interface that matches what you need, or you could write your own","label":{"api":{"Functional":[[73,82]]}}},{"text":"what about rounding that double?","label":{"api":{"double":[[25,30]]}}},{"text":"From the Hashtable Javadoc","label":{"api":{"Hashtable":[[9,17]]}}},{"text":"setExecutable, setReadable, setReadOnly, setWritable are replaced by the Files method setAttribute(Path, String, Object, LinkOption...)","label":{"api":{"setExecutable":[[0,12]],"setReadable":[[15,25]],"setReadOnly":[[28,38]],"setWritable":[[41,51]],"Files":[[73,77]],"setAttribute(Path, String, Object, LinkOption...)":[[86,134]]}}},{"text":"See AclFileAttributeView for more details","label":{"api":{"AclFileAttributeView":[[4,23]]}}},{"text":"Instead, you can use Optional for control flow","label":{"api":{"Optional":[[21,28]]}}},{"text":"This sort of thing is what JPA Attribute Converters are designed to help achieve","label":{"api":{"JPA Attribute Converters":[[27,50]]}}},{"text":"As you can see here https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html Thread.currentThread() returns a reference to the currently executing thread","label":{"api":{"Thread.currentThread()":[[84,105]]}}},{"text":"Thread.currentThread() returns the currently running thread","label":{"api":{"Thread.currentThread()":[[0,21]]}}},{"text":"In any case, when the terminate() method is called directly on some thread, Thread.currentThread() will return that thread","label":{"api":{"terminate()":[[22,32]],"Thread.currentThread()":[[76,97]]}}},{"text":"The thread.interrupt() method doesn't necessarily cause an InterruptedException to be thrown","label":{"api":{"thread.interrupt()":[[4,21]],"InterruptedException":[[59,78]]}}},{"text":"And then in Bar, instead of calling f.terminate(), call fthread.interrupt()","label":{"api":{"Bar":[[12,14]],"f.terminate()":[[36,48]],"fthread.interrupt()":[[56,74]]}}},{"text":"You could use readAllBytes() and create a String using the default charset","label":{"api":{"readAllBytes()":[[14,27]],"String":[[42,47]]}}},{"text":"You might want to look into a SortedMap instead","label":{"api":{"SortedMap":[[30,38]]}}},{"text":"You may also refer to the official Formatter documentation","label":{"api":{"Formatter":[[35,43]]}}},{"text":"If you call setSoTimeout on your instance of ServerSocket, you will be able to set a timeout for your socket","label":{"api":{"setSoTimeout":[[12,23]],"ServerSocket":[[45,56]]}}},{"text":"Then, when you block during calls to accept, your ServerSocket will keep track of the timeout","label":{"api":{"accept":[[37,42]],"ServerSocket":[[50,61]]}}},{"text":"As you can see in the documentation, accept throws a SocketTimeoutException if a timeout has been defined and the wait time has exceeded the timeout","label":{"api":{"accept":[[37,42]],"SocketTimeoutException":[[53,74]]}}},{"text":"Consider using Optional<> instead of null to represent something that can legitimately not be present","label":{"api":{"Optional<>":[[15,24]]}}},{"text":"Optional<> has a handful of methods (map, ifPresent, orElse, and orElseGet) to take different actions depending on whether it has a value","label":{"api":{"Optional<>":[[0,9]],"map":[[37,39]],"ifPresent":[[42,50]],"orElse":[[53,58]],"orElseGet":[[65,73]]}}},{"text":"But I think what you'll find is that if you start this way, the Optional<> paradigm will naturally spread over time and improve the code quality of your project as a whole","label":{"api":{"Optional<>":[[64,73]]}}},{"text":"Instead, maybe consider using a Timer to fire a second event that corresponds to the drawing of the second card, as in the example below","label":{"api":{"Timer":[[32,36]]}}},{"text":"I know I can parse a double from a String using Double.parseDouble(String s)","label":{"api":{"String":[[35,40]],"Double.parseDouble(String s)":[[48,75]]}}},{"text":"I know I can also parse that same string into a BigDecimal using new BigDecimal(String s), and then ask the BigDecimal for a double using BigDecimal.doubleValue()","label":{"api":{"BigDecimal":[[48,57],[108,117]],"BigDecimal(String s)":[[69,88]],"double":[[125,130]],"BigDecimal.doubleValue()":[[138,161]]}}},{"text":"The BigDecimal(String) constructor Javadocs states","label":{"api":{"BigDecimal(String)":[[4,21]]}}},{"text":"However, the Double.parseDouble(String) method states","label":{"api":{"Double.parseDouble(String)":[[13,38]]}}},{"text":"Probably, as workaround you can use longs method introduced in Java 8","label":{"api":{"longs":[[36,40]]}}},{"text":"I will show you a modern and true Java approach employed in Stream API and implemented in the [Int/Long/Double]SummaryStatistics classes","label":{"api":{"Stream":[[60,65]],"Int":[[95,97]],"Long":[[99,102]],"Double":[[104,109]],"SummaryStatistics":[[111,127]]}}},{"text":"For Jax-RS you can use ExceptionMapper to catch the exceptions","label":{"api":{"ExceptionMapper":[[23,37]]}}},{"text":"The LinkedHashMap class works really well for your particular problem","label":{"api":{"LinkedHashMap":[[4,16]]}}},{"text":"You may iterate the character array from your input string, and then add the characters, along with their counts, as keys, into the LinkedHashMap","label":{"api":{"LinkedHashMap":[[132,144]]}}},{"text":"Since LinkedHashMap preserves insertion order, to get the output you want you need only iterate the map and print out all keys whose counts are greater than one","label":{"api":{"LinkedHashMap":[[6,18]]}}},{"text":"Everything works fine until calling the reflection for Modifier.isFinal(), which reports incorrectly that a non-final class is actually final","label":{"api":{"Modifier.isFinal()":[[55,72]]}}},{"text":"From the URLClassLoader documentation","label":{"api":{"URLClassLoader":[[9,22]]}}},{"text":"You can use Arrays::stream to convert String array to Stream of Strings and then use Stream::flatMap and collect to Set using Collectors.toSet","label":{"api":{"Arrays::stream":[[12,25]],"String":[[38,43]],"Stream":[[54,59]],"Strings":[[64,70]],"Stream::flatMap":[[85,99]],"Set":[[116,118]],"Collectors.toSet":[[126,141]]}}},{"text":"I can't reproduce this issue myself, however I know that DecimalFormat is not thread-safe and I probably made a mistake somewhere","label":{"api":{"DecimalFormat":[[57,69]]}}},{"text":"ForkJoinPool.invoke() is not a static method, but you are using as it was","label":{"api":{"ForkJoinPool.invoke()":[[0,20]]}}},{"text":"The Certificate::verify serves this purpose","label":{"api":{"Certificate::verify":[[4,22]]}}},{"text":"Also you can have a look at X509Certificate::verify(PublicKey, Provider) which takes PublicKey and Provider implementation","label":{"api":{"X509Certificate::verify(PublicKey, Provider)":[[28,71]],"PublicKey":[[85,93]],"Provider":[[99,106]]}}},{"text":"You need to combine your predicates using and","label":{"api":{"and":[[42,44]]}}},{"text":"Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another","label":{"api":{}}},{"text":"You must use Predicate::and to combine the Predicates","label":{"api":{"Predicate::and":[[13,26]],"Predicates":[[43,52]]}}},{"text":"You can use the Class.asSubclass() method to change your Class<?> object returned by Class.forName(...) to something you can work with","label":{"api":{"Class.asSubclass()":[[16,33]],"Class<?>":[[57,64]],"Class.forName(...)":[[85,102]]}}},{"text":"In combination with the getConstructor() method (the singular one, the one without the s) you can create a Constructor object with a desired type you want","label":{"api":{"getConstructor()":[[24,39]],"Constructor":[[107,117]]}}},{"text":"You have to rewrite your code that you use getConstructor() instead of getConstructors() (you are using only one anyway) because this method is returning a Constructor<","label":{"api":{"getConstructor()":[[43,58]],"getConstructors()":[[71,87]],"Constructor":[[156,166]]}}},{"text":"Use a BufferedReader, place a mark(...), read the first line","label":{"api":{"BufferedReader":[[6,19]],"mark(...)":[[30,38]]}}},{"text":"If that line contains a \\t tab character, then your file is tab-separated, otherwise assume that it is comma-separated","label":{"api":{}}},{"text":"One way to achieve this is by using Collectors.groupingBy","label":{"api":{"Collectors.groupingBy":[[36,56]]}}},{"text":"There is one method that lets you set a TrustManagerFactory","label":{"api":{"TrustManagerFactory":[[40,58]]}}},{"text":"Although I extend the  class, the method that returns the TrustManagers is final","label":{"api":{"method":[[34,39]],"TrustManager":[[58,69]]}}},{"text":"However, looking at Javadoc for LinkedList, there is no way to change where the last element points","label":{"api":{"LinkedList":[[32,41]]}}},{"text":"Note that if there was a way, you could create a synchronized view of that data structure by call Collections.synchronizedList() like this","label":{"api":{"Collections.synchronizedList()":[[98,127]]}}},{"text":"Then use Collections.synchronizedList() to create a thread-safe view of it","label":{"api":{"Collections.synchronizedList()":[[9,38]]}}},{"text":"Note that Javadoc for Collections.synchronizedList() says","label":{"api":{"Collections.synchronizedList()":[[22,51]]}}},{"text":"The reason you are seeing everything on a single line is because you're calling print() instead of println()","label":{"api":{"print()":[[80,86]],"println()":[[99,107]]}}},{"text":"You could print two lines by making two separate calls to println(), like this","label":{"api":{"println()":[[58,66]]}}},{"text":"the javadoc of File.listFiles() says","label":{"api":{"File.listFiles()":[[15,30]]}}},{"text":"In general though the whole approach seems to be wrong - why do you want to draw text manually instead of using an available component like javax.swing.JLabel","label":{"api":{"javax.swing.JLabel":[[140,157]]}}},{"text":"If ArrayList.removeRange() meets what you're trying to do, you can work around the protected limitation by creating a new ArrayList that contains the first and last sublists, excluding the range in the middle","label":{"api":{"ArrayList.removeRange()":[[3,25]],"ArrayList":[[122,130]]}}},{"text":"You can use Stream and filter to concisely filter items from a list","label":{"api":{"Stream":[[12,17]],"filter":[[23,28]]}}},{"text":"However, since Arrays.asList() supports varargs, I might have called it with two (or more) different int arrays and would have seen no warning at all (for example","label":{"api":{"Arrays.asList()":[[15,29]]}}},{"text":"Arrays.asList() converts an array to a List of objects, which works as expected when converting Integer[] to List<Integer>","label":{"api":{"Arrays.asList()":[[0,14]],"Integer":[[96,102]],"List<Integer>":[[109,121]]}}},{"text":"\"An object is a class instance or an array\" – clearly though, in the case of Arrays.asList(), there's a subtlety about whether it's an array of objects or an array of primitives","label":{"api":{"Arrays.asList()":[[77,91]]}}},{"text":"Why does the Javadoc for Arrays.asList() make no mention of this behavior with primitive arrays","label":{"api":{"Arrays.asList()":[[25,39]]}}},{"text":"You can use the Pattern.quote() method to escape characters that have a special meaning in regular expressions","label":{"api":{"Pattern.quote()":[[16,30]]}}},{"text":"See Optional documentation","label":{"api":{"Optional":[[4,11]]}}},{"text":"URLConnection has getOutputStream()","label":{"api":{"URLConnection":[[0,12]],"getOutputStream()":[[18,34]]}}},{"text":"Please read the documentation for fillRect(), and note that the coordinates are treated differently from drawRect()","label":{"api":{"fillRect()":[[34,43]],"drawRect()":[[105,114]]}}},{"text":"fillRect() fills in a rectangle that's 1 pixels wider and taller than drawRect()","label":{"api":{"fillRect()":[[0,9]],"drawRect()":[[70,79]]}}},{"text":"the parse method does exactly what you are trying to do and LocalDate replace java.util.Date and is immutable","label":{"api":{"parse":[[4,8]],"LocalDate":[[60,68]],"java.util.Date":[[78,91]]}}},{"text":"I would personally not use a String to store Date, and I would not use java.util.Date and SimpleDateFormat to parse Date now that we have LocalDate and LocalDate.parse doing the exact thing you are trying to do","label":{"api":{"String":[[29,34]],"Date":[[45,48],[116,119]],"java.util.Date":[[71,84]],"SimpleDateFormat":[[90,105]],"LocalDate":[[138,146]],"LocalDate.parse":[[152,166]]}}},{"text":"Read Stream.collect(Supplier supplier, BiConsumer, BiConsumer combiner) for more info","label":{"api":{"Stream.collect(Supplier supplier, BiConsumer, BiConsumer combiner)":[[5,70]]}}},{"text":"And if you don't like the way its rendered, you can always add your own ListCellRenderer","label":{"api":{"ListCellRenderer":[[72,87]]}}},{"text":"pow's parameter is an int","label":{"api":{"pow":[[0,2]],"int":[[22,24]]}}},{"text":"BigInteger.pow() only exists for int parameters, so you can't take the power bigger than Integer.MAX_VALUE at once","label":{"api":{"BigInteger.pow()":[[0,15]],"Integer.MAX_VALUE":[[89,105]]}}},{"text":"Note that the \"power with modulus\" operation which is often used in cryptography is implemented using BigInteger.modPow() which does take BigInteger arguments and can therefore handle effectively arbitrarily large values","label":{"api":{"BigInteger.modPow()":[[102,120]],"BigInteger":[[138,147]]}}},{"text":"From the documentation of Condition","label":{"api":{"Condition":[[26,34]]}}},{"text":"Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations","label":{"api":{"Condition":[[0,8]],"Object":[[26,31]],"wait":[[50,53]],"notify":[[56,61]],"notifyAll":[[67,75]]}}},{"text":"Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods","label":{"api":{"Lock":[[8,11]],"Condition":[[72,80]],"Object":[[106,111]]}}},{"text":"Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to \"wait\") until notified by another thread that some state condition may now be true","label":{"api":{"Condition":[[0,8]]}}},{"text":"A Condition instance is intrinsically bound to a lock","label":{"api":{"Condition":[[2,10]]}}},{"text":"To obtain a Condition instance for a particular Lock instance use its newCondition() method","label":{"api":{"Condition":[[12,20]],"Lock":[[48,51]],"newCondition()":[[70,83]]}}},{"text":"As explained, a Condition instance must be associated with a Lock instance1","label":{"api":{"Condition":[[16,24]],"Lock":[[61,64]]}}},{"text":"Having Lock function as a factory for creating instances of Condition makes perfect sense with that in mind as it implies the relationship between the two","label":{"api":{"Condition":[[60,68]]}}},{"text":"Another way this relationship could have been enforced is to give Condition a constructor which accepts a Lock instance, but since Condition is also an interface it cannot declare constructors","label":{"api":{"Condition":[[66,74],[131,139]]}}},{"text":"If it's not already clear, the ReentrantLock class is an implementation of the Lock interface and the ConditionObject class is an implementation of the Condition interface","label":{"api":{"ReentrantLock":[[31,43]],"ConditionObject":[[102,116]],"Condition":[[152,160]]}}},{"text":"The other problem with attempting to use ConditionObject directly is that it's an inner class (i.e","label":{"api":{"ConditionObject":[[41,55]]}}},{"text":"In other words, you have no way to call the constructor of ConditionObject which means the only way to create an instance is via newCondition()","label":{"api":{"ConditionObject":[[59,73]],"newCondition()":[[129,142]]}}},{"text":"To recap, there's at least three reasons why a factory method is used to create Condition objects","label":{"api":{"Condition":[[80,88]]}}},{"text":"It makes the relationship between Lock and Condition clear","label":{"api":{"Lock":[[34,37]],"Condition":[[43,51]]}}},{"text":"With both Lock and Condition being interfaces, you need a way to associate a Condition with a Lock without knowing about the implementations","label":{"api":{"Lock":[[10,13],[94,97]],"Condition":[[19,27],[77,85]]}}},{"text":"Due to ConditionObject being an inner class it cannot be instantiated directly—at least, not by code which doesn't have access to an instance of the enclosing class","label":{"api":{"ConditionObject":[[7,21]]}}},{"text":"The methods of Condition only make sense in the context of owning a Lock","label":{"api":{"Condition":[[15,23]],"Lock":[[68,71]]}}},{"text":"wait/notify), a thread must own the associated Lock before it can legally invoke the methods of the Condition (i.e","label":{"api":{"Lock":[[47,50]],"Condition":[[100,108]]}}},{"text":"There's also AbstractQueuedLongSynchronizer which declares its own ConditionObject inner class","label":{"api":{"AbstractQueuedLongSynchronizer":[[13,42]],"ConditionObject":[[67,81]]}}},{"text":"There is a simple way to copy all bytes from an input stream to a file - Files.copy(in, path)","label":{"api":{"Files.copy(in, path)":[[73,92]]}}},{"text":"Consider using the built in conversion method for binary strings","label":{"api":{"conversion":[[28,37]]}}},{"text":"To represent that range, we can use IntStream#rangeClosed","label":{"api":{"IntStream#rangeClosed":[[36,56]]}}},{"text":"From this answer, we can utilize BigInteger to left-pad the binary String (generated by Integer#toBinaryString) with 0s if its length is less than 8 (denoting that the value is positive)","label":{"api":{"BigInteger":[[33,42]],"Integer#toBinaryString":[[88,109]]}}},{"text":"Otherwise, the value represents a negative number, and its respective binary string will have a length greater than 8, which must be truncated to 8 characters using String#substring","label":{"api":{"String#substring":[[165,180]]}}},{"text":"Finally, the Stream<String> can be collected to a String[] using Stream#toArray","label":{"api":{"Stream<String>":[[13,26]],"String[]":[[50,57]],"Stream#toArray":[[65,78]]}}},{"text":"Alternatively you can use the split()-Method and split by spaces","label":{"api":{"split()":[[30,36]]}}},{"text":"You can use reflection","label":{"api":{"reflection":[[12,21]]}}},{"text":"Take a look at ScheduledThreadPoolExecutor","label":{"api":{"ScheduledThreadPoolExecutor":[[15,41]]}}},{"text":"It looks like scan is an instance of java.util.Scanner","label":{"api":{"java.util.Scanner":[[37,53]]}}},{"text":"For details for how the input is read, look at the documentation for Scannner#nextDouble()","label":{"api":{"Scannner#nextDouble()":[[69,89]]}}},{"text":"Calling start() on a Thread doesn't necessarily result in the thread running immediately after","label":{"api":{"start()":[[8,14]],"Thread":[[21,26]]}}},{"text":"It is possible for other things to happen in between your calling start() and the first line of your thread's run() method actually being run","label":{"api":{"start()":[[66,72]],"run()":[[110,114]]}}},{"text":"I can put this method in an abstract class, and then the actual implementations of the list (array, linked, something else) only have to provide a way to iterate","label":{"api":{}}},{"text":"My question is can, ResultSetMetaData.getColumnLabel(int) return null","label":{"api":{"ResultSetMetaData.getColumnLabel(int)":[[20,56]]}}},{"text":"Note that for this specific case, simply adding volatile to value would have the same effect, but for more complex access patterns synchronized (or it's equivalence in newer APIs Lock) is necessary","label":{"api":{"Lock":[[179,182]]}}},{"text":"Optional::orElseThrow takes a Supplier and this Supplier is used to get an instance of Exception which will be thrown if Optional has null value underneath","label":{"api":{"Optional::orElseThrow":[[0,20]],"Supplier":[[30,37],[48,55]],"Exception":[[87,95]],"Optional":[[121,128]]}}},{"text":"See the implementation for Optional::orElseThrow","label":{"api":{"Optional::orElseThrow":[[27,47]]}}},{"text":"it simply checks if value is there and if not - it gets the Execption instance from Supplier and throws it","label":{"api":{"Execption":[[60,68]],"Supplier":[[84,91]]}}},{"text":"is conformant to Supplier expected by Optional::orElseThrow method - Supplier<","label":{"api":{"Supplier":[[17,24],[69,76]],"Optional::orElseThrow":[[38,58]]}}},{"text":"extends X> exceptionSupplier where X extends Throwable","label":{"api":{"Throwable":[[45,53]]}}},{"text":"The documentation of Files#copy(Path,Path,CopyOption...) says","label":{"api":{"Files#copy(Path,Path,CopyOption...)":[[21,55]]}}},{"text":"May be interesting to note that Files#copy(Path,Path,CopyOption...) does something very similar to the second example, but only if the source and target have the different FileSystemProvider instances","label":{"api":{"Files#copy(Path,Path,CopyOption...)":[[32,66]],"FileSystemProvider":[[172,189]]}}},{"text":"You can use charAt() function to get values sequentially for all characters in the string","label":{"api":{"charAt()":[[12,19]]}}},{"text":"This is clearly stated in the docs","label":{"api":{}}},{"text":"If the mapped keys may have duplicates, use toMap(Function, Function, BinaryOperator) instead","label":{"api":{"toMap(Function, Function, BinaryOperator)":[[44,84]]}}},{"text":"If you look at the docs for Container, you will see that it has a remove() method","label":{"api":{"Container":[[28,36]],"remove()":[[66,73]]}}},{"text":"Since JPanel extends Container, it also has this method","label":{"api":{"JPanel":[[6,11]],"Container":[[21,29]]}}},{"text":"Class Scanner has a constructor that takes a Path","label":{"api":{"Scanner":[[6,12]],"Path":[[45,48]]}}},{"text":"But Path is an interface, so you need to use class Paths to create an appropriate Path","label":{"api":{"Path":[[4,7],[82,85]],"Paths":[[51,55]]}}},{"text":"Furthermore I will store all the Worker objects I create in a collection, a List to be precise","label":{"api":{"Worker":[[33,38]],"List":[[76,79]]}}},{"text":"You should look at reset method in ObjectOutputStream","label":{"api":{"reset":[[19,23]],"ObjectOutputStream":[[35,52]]}}},{"text":"The state is reset to be the same as a new ObjectOutputStream","label":{"api":{"ObjectOutputStream":[[43,60]]}}},{"text":"The current point in the stream is marked as reset so the corresponding ObjectInputStream will be reset at the same point","label":{"api":{"ObjectInputStream":[[72,88]]}}},{"text":"You should call reset before writing the same object again","label":{"api":{"reset":[[16,20]]}}},{"text":"You can also use writeUnshared method","label":{"api":{"writeUnshared":[[17,29]]}}},{"text":"If you decide to use writeUnshared, you should look into readUnshared method from ObjectInputStream","label":{"api":{"writeUnshared":[[21,33]],"readUnshared":[[57,68]],"ObjectInputStream":[[82,98]]}}},{"text":"Use a StringWriter to keep everything as text","label":{"api":{"StringWriter":[[6,17]]}}},{"text":"Using Collectors.groupingBy, you can generate a Map from your Key to a List of Values, provided you can compute the Key from the Value","label":{"api":{"Collectors.groupingBy":[[6,26]],"Map":[[48,50]],"List":[[71,74]]}}},{"text":"Alternatively, you can use Collectors.toMap, provided you can compute both the Key and the Value from an upstream element","label":{"api":{"Collectors.toMap":[[27,42]]}}},{"text":"You probably want the version of toMap with a merge function, because that will allow you to handle multiple keys with the same value (by putting them in a list together)","label":{"api":{"toMap":[[33,37]]}}},{"text":"If you want ordering, there are overloads for toMap and groupingBy that allow you to provide a mapFactory (Supplier<Map>) , such as TreeMap::new","label":{"api":{"toMap":[[46,50]],"groupingBy":[[56,65]],"mapFactory (Supplier<Map>)":[[95,120]],"TreeMap::new":[[132,143]]}}},{"text":"To invert a map, so that its distinct values become keys, and its keys are added to a collection under the corresponding value, use groupingBy() on the map entries","label":{"api":{"groupingBy()":[[132,143]]}}},{"text":"Calling print will output the exact String that you provide to it, whereas calling println will output the String you provide to it, followed by a new line (the line separator for your system)","label":{"api":{"String":[[36,41],[107,112]],"println":[[83,89]]}}},{"text":"I'm using the Java 11+ feature String.repeat to massively simplify the operation of repeating a String here","label":{"api":{"String.repeat":[[31,43]],"String":[[96,101]]}}},{"text":"Dialogs can accept an object as their 2nd parameter which in this case you could pass a custom panel with your inputs","label":{"api":{"Dialogs":[[0,6]]}}},{"text":"Let's say this data is a single int, then the enumerated types could look like this (using IntSupplier)","label":{"api":{"IntSupplier":[[91,101]]}}},{"text":"You need Optional#ifPresent","label":{"api":{"Optional#ifPresent":[[9,26]]}}},{"text":"Starting from Java 8 you can use Long.toUnsignedString(values)","label":{"api":{"Long.toUnsignedString(values)":[[33,61]]}}},{"text":"The javax.ws.rs.core.MultivaluedMap interface defined in Java EE API is an example that achieves what you want to do","label":{"api":{"javax.ws.rs.core.MultivaluedMap":[[4,34]]}}},{"text":"Otherwise, an exception java.lang.IllegalMonitorStateException will be thrown","label":{"api":{"java.lang.IllegalMonitorStateException":[[24,61]]}}},{"text":"From the documentation for Scanner.close()","label":{"api":{"Scanner.close()":[[27,41]]}}},{"text":"if its underlying readable also implements the Closeable interface then the readable's close method will be invoked","label":{"api":{"Closeable":[[47,55]],"readable":[[76,83]],"close":[[87,91]]}}},{"text":"Calendar.DAY_OF_WEEK is a constant 7 so it's working correctly, just not how you expected","label":{"api":{"Calendar.DAY_OF_WEEK":[[0,19]]}}},{"text":"But calendar.get(Calendar.DAY_OF_WEEK) will give you the value you seek","label":{"api":{"calendar.get(Calendar.DAY_OF_WEEK)":[[4,37]]}}},{"text":"You can check the documentation on docs.oracle","label":{"api":{}}},{"text":"Using single thread executor service, I would try something like this","label":{"api":{"single thread executor service":[[6,35]]}}},{"text":"The forEach method that you are calling is not the Stream::forEach method, but the Map::forEach method, as you are calling it on the return value of collect(...), which is a Map","label":{"api":{"forEach":[[4,10]],"Stream::forEach":[[51,65]],"Map::forEach":[[83,94]],"collect(...)":[[149,160]],"Map":[[174,176]]}}},{"text":"A feature of the Map::forEach method is that it takes a BiConsumer, instead of a Consumer","label":{"api":{"Map::forEach":[[17,28]],"BiConsumer":[[56,65]],"Consumer":[[81,88]]}}},{"text":"In that case, you should use flatMap","label":{"api":{"flatMap":[[29,35]]}}},{"text":"N calls to flatMap is required for a map nested N levels deep","label":{"api":{"flatMap":[[11,17]]}}},{"text":"To render the numbers in your output using Western Arabic Numerals you just need to explicitly set the Locale appropriately within your application","label":{"api":{"Locale":[[103,108]]}}},{"text":"See the Javadocs for Locale and NumberFormat for more details","label":{"api":{"Locale":[[21,26]],"NumberFormat":[[32,43]]}}},{"text":"Instead, they use a special type called BigDecimal","label":{"api":{"BigDecimal":[[40,49]]}}},{"text":"If, however, a value of -934 is valid, and -966 is not, just eliminate the sign by calling Math.abs()","label":{"api":{"Math.abs()":[[91,100]]}}},{"text":"The main thing is using ExceptionInInitializerError which is built for this kind of static context initializations","label":{"api":{"ExceptionInInitializerError":[[24,50]]}}},{"text":"Just try using Scanner and System.out.println instead","label":{"api":{"Scanner":[[15,21]],"System.out.println":[[27,44]]}}},{"text":"In case you need to generate whole url in another place try using URLEncoder (but you should also disable URL encoding in RestAssured to prevent double encoding)","label":{"api":{"URLEncoder":[[66,75]],"RestAssured":[[122,132]]}}},{"text":"This will query the system UTC clock to obtain the current instant","label":{"api":{}}},{"text":"Simply use Collectors::groupingBy and pass method reference to MyDto::getName method which will be used as the key for your map","label":{"api":{"Collectors::groupingBy":[[11,32]],"MyDto::getName":[[63,76]]}}},{"text":"You can solve your problem using Stream API by adding the following method to OrderItem","label":{"api":{"Stream":[[33,38]],"OrderItem":[[78,86]]}}},{"text":"You need to add a filter to your stream (before the map operation)","label":{"api":{"map":[[52,54]]}}},{"text":"I haven't found where this is formally stated, but can point to the Javadoc for java.lang.reflect.Method which has no methods exposing anything about local variables","label":{"api":{"java.lang.reflect.Method":[[80,103]]}}},{"text":"Looking at the rest of the the reflection package, there's nothing else would that would be a better fit than Method","label":{"api":{"reflection":[[31,40]],"Method":[[110,115]]}}},{"text":"I've tried to append the username and password using the BindingProvider with no success","label":{"api":{"BindingProvider":[[57,71]]}}},{"text":"You could use reduce to do this","label":{"api":{"reduce":[[14,19]]}}},{"text":"My primary stream has some operations that are needed to be done on Stream.onClose()","label":{"api":{"Stream.onClose()":[[68,83]]}}},{"text":"In my custom logic, I use Iterator from Stream.iterator() for stream processing","label":{"api":{"Iterator":[[26,33]],"Stream.iterator()":[[40,56]]}}},{"text":"But, when I used Stream.flatMap() for constructing a lazy stream, onClose function gets called when I start iterating, which in-turn creates problems for me","label":{"api":{"Stream.flatMap()":[[17,32]],"onClose":[[66,72]]}}},{"text":"For processor component, it requires a java instance of class implementing the java interface Processor when route is being created","label":{"api":{"java interface Processor":[[79,102]]}}},{"text":"Create a Predicate which tests an object and returns a boolean value","label":{"api":{"Predicate":[[9,17]]}}},{"text":"Here's the documentation of List#add(int,E)","label":{"api":{"List#add(int,E)":[[28,42]]}}},{"text":"This would be equivalent to calling List#add(E) every iteration","label":{"api":{"List#add(E)":[[36,46]]}}},{"text":"Looking at the Javadoc for Scanner","label":{"api":{"Scanner":[[27,33]]}}},{"text":"Use the filter method, passing in a DoublePredicate that uses Double.isNaN to filter them out","label":{"api":{"filter":[[8,13]],"DoublePredicate":[[36,50]],"Double.isNaN":[[62,73]]}}},{"text":"You seem to be looking for List#replaceAll such as","label":{"api":{"List#replaceAll":[[27,41]]}}},{"text":"This is what the Collections.emptyList() method does","label":{"api":{"Collections.emptyList()":[[17,39]]}}},{"text":"yes, setting a socket timeout through socket.setSoTimeout(timeout) will be enough to trigger a SocketTimeoutException (a subclass of IOException) if the handshake process doesn't complete after \"some time\" (but not necessarily the specified timeout1)","label":{"api":{"socket.setSoTimeout(timeout)":[[38,65]],"SocketTimeoutException":[[95,116]],"IOException":[[133,143]]}}},{"text":"the handshake protocol performed by startHandshake() involves several reads/writes from the socket Input/OutputStream, which will trigger the timeout itself","label":{"api":{"startHandshake()":[[36,51]],"Input":[[99,103]],"OutputStream":[[105,116]]}}},{"text":"Also, note that you don't need to call startHandshake() yourself","label":{"api":{"startHandshake()":[[39,54]]}}},{"text":"The timeout specified by setSoTimeout(timeout) is for a single read()","label":{"api":{"setSoTimeout(timeout)":[[25,45]],"read()":[[63,68]]}}},{"text":"So the handshake process can timeout (in the worst case) after the number of read() it performs, times the timeout value you specified","label":{"api":{"read()":[[77,82]]}}},{"text":"Use Class.getResourceAsStream or ClassLoader.getResourceAsStream","label":{"api":{"Class.getResourceAsStream":[[4,28]],"ClassLoader.getResourceAsStream":[[33,63]]}}},{"text":"The javadoc of SimpleDateFormat will tell you what combination of letters you need to use","label":{"api":{"SimpleDateFormat":[[15,30]]}}},{"text":"For #1, I'd use Collectors.groupingBy along with Collectors.counting","label":{"api":{"Collectors.groupingBy":[[16,36]],"Collectors.counting":[[49,67]]}}},{"text":"Instead, I'd use the Map.computeIfAbsent operation (introduced in Java 8)","label":{"api":{"Map.computeIfAbsent":[[21,39]]}}},{"text":"For #3, I'd again use Collectors.groupingBy along with Collectors.counting, but I'd use a composite key to group by","label":{"api":{"Collectors.groupingBy":[[22,42]],"Collectors.counting":[[55,73]]}}},{"text":"As it says in the documentation of getSuperclass()","label":{"api":{"getSuperclass()":[[35,49]]}}},{"text":"That method getSuperClass says","label":{"api":{"getSuperClass":[[12,24]]}}},{"text":"To gather information about implemented (or extended) interfaces, use getInterfaces","label":{"api":{"getInterfaces":[[70,82]]}}},{"text":"The equivalent class for that in Java is LocalDate","label":{"api":{"LocalDate":[[41,49]]}}},{"text":"LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day","label":{"api":{"LocalDate":[[0,8]],"date-time":[[26,34]]}}},{"text":"For example, the value \"2nd October 2007\" can be stored in a LocalDate","label":{"api":{"LocalDate":[[61,69]]}}},{"text":"In Java, it can be represented with Instant or OffsetDateTime","label":{"api":{"Instant":[[36,42]],"OffsetDateTime":[[47,60]]}}},{"text":"From the Javadoc of Map.put","label":{"api":{"Map.put":[[20,26]]}}},{"text":"For example, in the Java Stream class, any time a method returns a Stream, this is happening","label":{"api":{"Stream":[[25,30],[67,72]]}}},{"text":"This is because Stream implements BaseStream","label":{"api":{"Stream":[[16,21]],"BaseStream":[[34,43]]}}},{"text":"From the documentation of that method","label":{"api":{}}},{"text":"Use ZonedDateTime.parse to parse the time you are receiving","label":{"api":{"ZonedDateTime.parse":[[4,22]]}}},{"text":"The second parameter for method printf is an array of Object","label":{"api":{"printf":[[32,37]],"Object":[[54,59]]}}},{"text":"Hence the message that there is no printf method that takes two parameters where the first is a String and the second is an int","label":{"api":{"printf":[[35,40]],"String":[[96,101]]}}},{"text":"Create an Integer from the value returned by message.get_counter() and use that as the second argument when you call method printf, i.e","label":{"api":{"Integer":[[10,16]],"message.get_counter()":[[45,65]],"printf":[[124,129]]}}},{"text":"Alternatively, you could use method println instead of printf, as in..","label":{"api":{"println":[[36,42]],"printf":[[55,60]]}}},{"text":"Because Arrays#asList returns the fixed-size List backed by the array","label":{"api":{"Arrays#asList":[[8,20]]}}},{"text":"Here is the doc of Arrays#asList","label":{"api":{"Arrays#asList":[[19,31]]}}},{"text":"First, consult the documentation of ProgressMonitorInputStream","label":{"api":{"ProgressMonitorInputStream":[[36,61]]}}},{"text":"The ProgressMonitor’s maximum should be the size of the download, which you can obtain from the getContentLength() method of URLConnection","label":{"api":{"ProgressMonitor":[[4,18]],"getContentLength()":[[96,113]],"URLConnection":[[125,137]]}}},{"text":"You can use Files.copy for that","label":{"api":{"Files.copy":[[12,21]]}}},{"text":"You need to use another variant of Collectors.toMap such that you pass the merge function and supplier to collect as a TreeMap there","label":{"api":{"Collectors.toMap":[[35,50]],"TreeMap":[[119,125]]}}},{"text":"An alternate way could be determining all the possible headers before completing the build chain for the HttpRequest and using them with HttpRequest.Builder#headers as","label":{"api":{"HttpRequest":[[105,115]],"HttpRequest.Builder#headers":[[137,163]]}}},{"text":"You can do it yourself using AWT/Swing (for example, Canvas) or exploit third-party library (like JFreeChart)","label":{"api":{"Canvas":[[53,58]],"JFreeChart":[[98,107]]}}},{"text":"Then create File object for each directory name and use File#exists() api to check and create new file if not exists","label":{"api":{"File":[[12,15]],"File#exists()":[[56,68]]}}},{"text":"It seems you're looking for Files.html#createDirectories, for example","label":{"api":{"Files.html#createDirectories":[[28,55]]}}},{"text":"For the fixed-delay execution of some code you want to use a timer object, in this case javax.swing.Timer","label":{"api":{"javax.swing.Timer":[[88,104]]}}},{"text":"What you need to do is call flatMap on the stream returned by data.stream(), with the function argument being List::stream (or Collection::stream)","label":{"api":{"flatMap":[[28,34]],"data.stream()":[[62,74]],"List::stream":[[110,121]],"Collection::stream":[[127,144]]}}},{"text":"I think the correct data structure would be a Map","label":{"api":{"Map":[[46,48]]}}},{"text":"The Map key would be Integer (since the key cannot be a primitive, so it cannot be int) which would be the index of the letter, and the value would be a List of the words that have the relevant letter at that index","label":{"api":{"Map":[[4,6]],"Integer":[[21,27]]}}},{"text":"But of course there is Collections.sort which is able sorting a given List using given Comparator","label":{"api":{"Collections.sort":[[23,38]],"Comparator":[[87,96]]}}},{"text":"You can use a StringBuilder","label":{"api":{"StringBuilder":[[14,26]]}}},{"text":"Yes, you can allocate a StringBuilder with enough room for the whole result, and then use its append to append the pieces, converting to string when you're done with toString","label":{"api":{"StringBuilder":[[24,36]],"toStrin":[[166,172]]}}},{"text":"Be sure you don't put any user-derived information in the SQL via StringBuilder or other string-combining methods","label":{"api":{"StringBuilder":[[66,78]]}}},{"text":"Use computeIfAbsent to return the existing instance if the key already exists or create a new one if it doesn't","label":{"api":{"computeIfAbsent":[[4,18]]}}},{"text":"A ConcurrentMap ensures thread safety","label":{"api":{"ConcurrentMap":[[2,14]]}}},{"text":"If you insist of using JTextField, I suggest you to take the DocumentFilter approach, mostly described in this question","label":{"api":{"JTextField":[[23,32]],"DocumentFilter":[[61,74]]}}},{"text":"Why don't you use the built-in Integer#parseInt(s, radix) method","label":{"api":{"Integer#parseInt(s, radix)":[[31,56]]}}},{"text":"You can use the JSONObject class to do the operations you need","label":{"api":{"JSONObject":[[16,25]]}}},{"text":"You can initialize a new ObservableSet object and addAll your list, which takes any kind of collection","label":{"api":{"ObservableSet":[[25,37]],"addAll":[[50,55]]}}},{"text":"From StackWalker docs","label":{"api":{"StackWalker":[[5,15]]}}},{"text":"If you want have access to each stack element of you exception's stack trace - use Throwable::getStackTrace which returns array of StackTraceElement","label":{"api":{"Throwable::getStackTrace":[[83,106]],"StackTraceElement":[[131,147]]}}},{"text":"If you want only to print it Throwable::printStackTrace should be enough","label":{"api":{"Throwable::printStackTrace":[[29,54]]}}},{"text":"The approach that you show (using Class.cast) does work, but has the overhead of handling an exception","label":{"api":{"Class.cast":[[34,43]]}}},{"text":"A clearer and more concise way of doing this is using the Class.isInstance method","label":{"api":{"Class.isInstance":[[58,73]]}}},{"text":"I assume that your professor wants you to change counter to an AtomicInteger","label":{"api":{"AtomicInteger":[[63,75]]}}},{"text":"First you want to import AtomicInteger as well as change the declaration of counter and the constructor to reflect that","label":{"api":{"AtomicInteger":[[25,37]]}}},{"text":"Also, you want to change the increaseVehicleCount and decreaseVehicleCount methods in order to use AtomicInteger instead of int","label":{"api":{"increaseVehicleCount":[[29,48]],"decreaseVehicleCount":[[54,73]],"AtomicInteger":[[99,111]]}}},{"text":"incrementAndGet as well as decrementAndGet do just as they say","label":{"api":{"incrementAndGet":[[0,14]],"decrementAndGet":[[27,41]]}}},{"text":"I am trying to implement a SdkAsyncHttpClient that uses Java 11's java.net.http.HttpClient (specifically sendAsync)","label":{"api":{"SdkAsyncHttpClient":[[27,44]],"java.net.http.HttpClient":[[66,89]]}}},{"text":"You can use DoubleSummaryStatistics for both the max and min of your value attribute","label":{"api":{"DoubleSummaryStatistics":[[12,34]]}}},{"text":"Since Java 8, you should avoid using Date","label":{"api":{"Date":[[37,40]]}}},{"text":"According to your question, a suitable replacement for Date would be LocalDate, which is expected to be in the format yyyy-MM-dd","label":{"api":{"Date":[[55,58]],"LocalDate":[[69,77]]}}},{"text":"And also I would discourage to use Pair class form JavaFX for this purpose and use AbstractMap.SimpleEntry for example","label":{"api":{"Pair":[[35,38]],"JavaFX":[[51,56]],"AbstractMap.SimpleEntry":[[83,105]]}}},{"text":"Here's the java doc to back this up (https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN)","label":{"api":{}}},{"text":"It also seems like this should be possible, seeing as spring-websocket uses the Java WebSocket API under the hood, and they allow MessageHandlers to handle InputStreams (see https://docs.oracle.com/javaee/7/api/javax/websocket/MessageHandler.Whole.html)","label":{"api":{"WebSocket":[[85,93]],"MessageHandlers":[[130,144]],"InputStreams":[[156,167]]}}},{"text":"Integer class does implement Comparable","label":{"api":{"Integer":[[0,6]],"Comparable":[[29,38]]}}},{"text":"You want a Map","label":{"api":{"Map":[[11,13]]}}},{"text":"A common (probably the most common) implementation of Map is HashMap","label":{"api":{"Map":[[54,56]],"HashMap":[[61,67]]}}},{"text":"Map<Boolean, BufferedImage>> is a little hard to follow","label":{"api":{"Map<Boolean, BufferedImage>>":[[0,27]]}}},{"text":"If you look up the Javadoc for DecimalFormat, you'll see that it extends NumberFormat","label":{"api":{"DecimalFormat":[[31,43]],"NumberFormat":[[73,84]]}}},{"text":"You could also call NumberFormat.getNumberInstance() and store the result using one of the interfaces that NumberFormat implements (you can see those in the Javadoc)","label":{"api":{"NumberFormat.getNumberInstance()":[[20,51]],"NumberFormat":[[107,118]]}}},{"text":"new FileOutputStream(filepath + fileName) will only throw FileNotFoundException if the specified path is a directory or if a security manager prevents you from writing to that path, as specified in the documentation","label":{"api":{"FileOutputStream":[[4,19]],"FileNotFoundException":[[58,78]]}}},{"text":"Just use regex and String#toLowerCase","label":{"api":{"String#toLowerCase":[[19,36]]}}},{"text":"Pay attention to default close operation you apply to your top-level JFrame or JDialog","label":{"api":{"close":[[25,29]],"JFrame":[[69,74]],"JDialog":[[79,85]]}}},{"text":"It's unclear where you have imported @CreateTimestamp and @UpdateTimestamp from","label":{"api":{"@CreateTimestamp":[[37,52]],"@UpdateTimestamp":[[58,73]]}}},{"text":"However, as you seem to be using Spring, you could use @CreatedDate and @LastModifiedDate from Spring Data","label":{"api":{"@CreatedDate":[[55,66]],"@LastModifiedDate":[[72,88]]}}},{"text":"Apart from it, since Java 8, with the introduction of the new Date and Time API, you should avoid using Date and related classes such as Timestamp","label":{"api":{"Date":[[62,65],[104,107]],"Time":[[71,74]],"Timestamp":[[137,145]]}}},{"text":"A suitable replacement for Timestamp, in your situation, would be Instant or OffsetDateTime","label":{"api":{"Timestamp":[[27,35]],"Instant":[[66,72]],"OffsetDateTime":[[77,90]]}}},{"text":"You may want to check CountDownLatch for this purpose","label":{"api":{"CountDownLatch":[[22,35]]}}},{"text":"This uses Map.computeIfAbsent to group regions of ReleaseTime objects by start and end dates","label":{"api":{"Map.computeIfAbsent":[[10,28]],"ReleaseTime":[[50,60]]}}},{"text":"getTitle() method will give a window title String","label":{"api":{"getTitle()":[[0,9]]}}},{"text":"I'm using introspection through getDeclaredFields() which means I can't assume a specific type for the field, so I can't use an annotation like","label":{"api":{"getDeclaredFields()":[[32,50]]}}},{"text":"Then instead of having a difficult to debug test failure, you will get an AssertionError or AssumptionViolatedException or TestAbortedException that more clearly points towards the cause of the problem","label":{"api":{"AssertionError":[[74,87]],"AssumptionViolatedException":[[92,118]],"TestAbortedException":[[123,142]]}}},{"text":"A ConcurrentLinkedQueue will do a similar same job without locking, there you'd want to sleep, bot only when no item is available, rather than after every item","label":{"api":{"ConcurrentLinkedQueue":[[2,22]]}}},{"text":"After you have sorted your arrays values1 and values2 you can use the equals function of Arrays (like you already did)","label":{"api":{"Arrays":[[89,94]]}}},{"text":"Or should I adapt all the code to use Java 11 java.net.http","label":{"api":{"java.net.http":[[46,58]]}}},{"text":"I would go with java.time.LocalDate and java.time.Period class","label":{"api":{"java.time.LocalDate":[[16,34]],"java.time.Period":[[40,55]]}}},{"text":"But as you can see in the java.util.function package, which contains interfaces for various number of type parameters, Java does not support this yet and there are no plans to do so","label":{"api":{"java.util.function":[[26,43]]}}},{"text":"Remove all use of p.getInputStream(), and replace it with a call to inheritIO()","label":{"api":{"p.getInputStream()":[[18,35]],"inheritIO()":[[68,78]]}}},{"text":"inheritIO() will cause both the standard output and the standard error of the child process to appear in the Java process's own standard output and standard error","label":{"api":{"inheritIO()":[[0,10]]}}},{"text":"The copy constructor you are using is described in the API as","label":{"api":{}}},{"text":"One option would be to use a ExecutorService provided by the JDK, which can execute Runnable and Callable tasks","label":{"api":{"ExecutorService":[[29,43]],"Runnable":[[84,91]],"Callable":[[97,104]]}}},{"text":"You will need to create a class that implements Runnable, which will execute your Python script, and after receiving a new document, you need to create a new instance of this class and pass it to the ExecutorService","label":{"api":{"Runnable":[[48,55]],"ExecutorService":[[200,214]]}}},{"text":"Then we create main method that creates ExecutorService with a fixed number of parallel threads in the amount of 5 and pass 10 instances of ScriptRunner to it with interruptions of 1 second","label":{"api":{"ExecutorService":[[40,54]],"ScriptRunner":[[140,151]]}}},{"text":"I see Thread() takes both Runnable and String for single argument constructors","label":{"api":{"Thread()":[[6,13]],"Runnable":[[26,33]],"String":[[39,44]]}}},{"text":"The List interface supports the contains() method","label":{"api":{"List":[[4,7]],"contains()":[[32,41]]}}},{"text":"For a cert in a file (or anything that can be accessed as a Stream) in either PEM or DER format (although the javadoc isn't clear on that) all you need is CertificateFactory","label":{"api":{"Stream":[[60,65]],"CertificateFactory":[[155,172]]}}},{"text":"Although JCA APIs like this one are defined to allow a lot of extension,  reading an X.509 cert will actually give you not just Certificate but subclass X509Certificate from which .getNotAfter() gives the expiration date-time directly","label":{"api":{"JCA":[[9,11]],"Certificate":[[128,138]],"X509Certificate":[[153,167]],".getNotAfter()":[[180,193]]}}},{"text":"If you use at least Java 9, you can apply takeWhile(Objects::nonNull) on your stream","label":{"api":{"takeWhile(Objects::nonNull)":[[42,68]]}}},{"text":"If we assume the first approach, you can use the getRGB method of BufferedImage to retrieve the values","label":{"api":{"getRGB":[[49,54]],"BufferedImage":[[66,78]]}}},{"text":"You can use setRGB to convert the bytes back to an image","label":{"api":{"setRGB":[[12,17]]}}},{"text":"The implementation is a ThreadPoolExecutor which lets threads exit when they are unused (look for \"Keep-alive times\" in its docs)","label":{"api":{"ThreadPoolExecutor":[[24,41]]}}},{"text":"As documented, the BigDecimal(double) is unpredictable","label":{"api":{"BigDecimal(double)":[[19,36]]}}},{"text":"This is generally the preferred way to convert a float or double into a BigDecimal, as it doesn't suffer from the unpredictability of the BigDecimal(double) constructor","label":{"api":{"float":[[49,53]],"double":[[58,63]],"BigDecimal":[[72,81]],"BigDecimal(double)":[[138,155]]}}},{"text":"Also note, in the below code, that method getValue() in class CellDataFeatures returns a Part object","label":{"api":{"getValue()":[[42,51]],"CellDataFeatures":[[62,77]],"Part":[[89,92]]}}},{"text":"The javadoc of reduce says","label":{"api":{"reduce":[[15,20]]}}},{"text":"Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value","label":{"api":{}}},{"text":"If you want to see which tools are included you can check out this link https://docs.oracle.com/javase/7/docs/api/","label":{"api":{}}},{"text":"I need to track a few formats (DateTimeFormatter objects) for repeated use in my app","label":{"api":{"DateTimeFormatter":[[31,47]]}}},{"text":"The return value of subSequence() is a CharSequence which is not a String","label":{"api":{"subSequence()":[[20,32]],"CharSequence":[[39,50]],"String":[[67,72]]}}},{"text":"Since you are starting from an array of characters – char [] – you could use Arrays.copyOfRange() to create a new array of some smaller subset of charArray, like this","label":{"api":{"char []":[[53,59]],"Arrays.copyOfRange()":[[77,96]],"charArray":[[146,154]]}}},{"text":"They implementation is going to throw UnsupportedOperationException and nothing else","label":{"api":{"UnsupportedOperationException":[[38,66]]}}},{"text":"But for a simple flag, the easiest approach is probably a Semaphore","label":{"api":{"Semaphore":[[58,66]]}}},{"text":"But Semaphore does require you to plan your logic correctly, otherwise you could end up in a deadlock","label":{"api":{"Semaphore":[[4,12]]}}},{"text":"The above code could be better implemented with for example Exchanger","label":{"api":{"Exchanger":[[60,68]]}}},{"text":"You can use ExecutorService.submit(Callable task) and then call Future.get(long timeout, TimeUnit unit) on the result","label":{"api":{"ExecutorService.submit(Callable task)":[[12,48]],"Future.get(long timeout, TimeUnit unit)":[[64,102]]}}},{"text":"Java 8's CompletableFuture.allOf(CompletableFuture<?>...cfs) will return a CompletableFuture that is completed when all the given futures complete, or throws a CompletionException if one of the futures completes with an exception","label":{"api":{"CompletableFuture.allOf(CompletableFuture<?>...cfs)":[[9,59]],"CompletableFuture":[[75,91]],"CompletionException":[[160,178]]}}},{"text":"you could try to use Base64.Decoder#wrap","label":{"api":{"Base64.Decoder#wrap":[[21,39]]}}},{"text":"For that reason, you should use LocalDate in conjunction with LocalDate#atTime (to get a LocalDateTime object) and LocalDateTime#atZone (with ZoneOffset.UTC to get a ZonedDateTime)","label":{"api":{"LocalDate":[[32,40]],"LocalDate#atTime":[[62,77]],"LocalDateTime":[[89,101]],"LocalDateTime#atZone":[[115,134]],"ZoneOffset.UTC":[[142,155]],"ZonedDateTime":[[166,178]]}}},{"text":"See the Javadoc for String","label":{"api":{"String":[[20,25]]}}},{"text":"I want the contents of a plain text file on the web browser’s machine to load into memory as a String or CharSequence on the server machine","label":{"api":{"String":[[95,100]],"CharSequence":[[105,116]]}}},{"text":"We use an InputStream to manage the flow of arriving octets","label":{"api":{"InputStream":[[10,20]]}}},{"text":"Our InputStream reads each octet as an int with a value in the range from 0-255 inclusive","label":{"api":{"InputStream":[[4,14]]}}},{"text":"We use try-with-resources syntax to automatically close the InputStream that loads bytes from the client to the server","label":{"api":{"InputStream":[[60,70]]}}},{"text":"We collect the arriving octets in a ByteArrayOutputStream","label":{"api":{"ByteArrayOutputStream":[[36,56]]}}},{"text":"That library has a convenience method for taking an InputStream and producing a String","label":{"api":{"InputStream":[[52,62]],"String":[[80,85]]}}},{"text":"However, you can abstract out this locking into the data structure itself by using a concurrent version","label":{"api":{}}},{"text":"As pointed out in the comments, take a look at Collectors.joining","label":{"api":{"Collectors.joining":[[47,64]]}}},{"text":"The compareTo() method needs to return a -1, 0 1","label":{"api":{"compareTo()":[[4,14]]}}},{"text":"If your requirement is to enable concurrent access to the collection, then you should explore java concurrency APIs and especially ConcurrentHashMap or ConcurrentSkipListMap for your case","label":{"api":{"concurrency":[[99,109]],"ConcurrentHashMap":[[131,147]],"ConcurrentSkipListMap":[[152,172]]}}},{"text":"You can use AtomicIntegerArray instead, although if you explain your root problem, there may be a more suitable class to use","label":{"api":{"AtomicIntegerArray":[[12,29]]}}},{"text":"By loading a DLL using Java's System#loadLibrary, I only get a long negative exit code such as -1073741515 instead of a Windows error message stating which DLL is missing","label":{"api":{"System#loadLibrary":[[30,47]]}}},{"text":"If you don't care about losing precision in some cases, you could define the type of the parameters to be Number and then call doubleValue and/ or longValue before doing the addition","label":{"api":{"Number":[[106,111]],"doubleValue":[[127,137]],"longValue":[[147,155]]}}},{"text":"Since foods is an ArrayList you can just use the add(int, E) method to add an element at the beginning, like this","label":{"api":{"ArrayList":[[18,26]],"add(int, E)":[[49,59]]}}},{"text":"If you have such large numbers you can't use ints and longs, you will have to use BigInteger which already defines an isProbablePrime method for you","label":{"api":{"BigInteger":[[82,91]],"isProbablePrime":[[118,132]]}}},{"text":"However you could have control over task completion by using ExecutorsCompletionService for your parallel processing","label":{"api":{"ExecutorsCompletionService":[[61,86]]}}},{"text":"You could use a simple forEach with List#replaceAll to update your existing collection such as","label":{"api":{"forEach":[[23,29]],"List#replaceAll":[[36,50]]}}},{"text":"To sort a Map by key, use a TreeMap","label":{"api":{"Map":[[10,12]],"TreeMap":[[28,34]]}}},{"text":"The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used","label":{"api":{"Comparator":[[73,82]]}}},{"text":"Since XMLGregorianCalendar doesn't implement Comparable, i.e","label":{"api":{"XMLGregorianCalendar":[[6,25]],"Comparable":[[45,54]]}}},{"text":"doesn't have a natural ordering, you have to specify a Comparator in the constructor","label":{"api":{"Comparator":[[55,64]]}}},{"text":"That is because they are defined as final in the Enum class, which implicitly is the base class of all enum types","label":{"api":{"Enum":[[49,52]]}}},{"text":"Since Stack#push method returns an Integer here","label":{"api":{"Stack#push":[[6,15]],"Integer":[[35,41]]}}},{"text":"The documentation of Statement.executeBatch() is not clear on this, but I assume that calling it will empty the Statement object's current list of SQL commands in the same way as clearBatch() does","label":{"api":{"Statement.executeBatch()":[[21,44]],"Statement":[[112,120]],"clearBatch()":[[179,190]]}}},{"text":"I'm also assuming the same is true for PreparedStatement","label":{"api":{"PreparedStatement":[[39,55]]}}},{"text":"I suppose it is possible to continue using the Statement after calling Statement.executeBatch(), i.e","label":{"api":{"Statement":[[47,55]],"Statement.executeBatch()":[[71,94]]}}},{"text":"Unfortunately, file1() closes the PrintWriter, so when file2() runs, all the pw.println(...) calls fails silently","label":{"api":{"file1()":[[15,21]],"PrintWriter":[[34,44]],"file2()":[[55,61]],"pw.println(...)":[[77,91]]}}},{"text":"See javadoc of PrintWriter","label":{"api":{"PrintWriter":[[15,25]]}}},{"text":"The client may inquire as to whether any errors have occurred by invoking checkError()","label":{"api":{"checkError()":[[74,85]]}}},{"text":"If, for some reason, you still want to do this in parallel, then you can use Arrays#parallelSetAll","label":{"api":{"Arrays#parallelSetAll":[[77,97]]}}},{"text":"You can use CopyOnWriteArrayLists, but they are very expensive to write, you can also create a Syncronized Collection, which are not so expensive to write, and you can also work with Queues, it will depend on what you want to achieve","label":{"api":{"CopyOnWriteArrayLists":[[12,32]],"Syncronized Collection":[[95,116]],"Queues":[[183,188]]}}},{"text":"I think you could use ConcurrentHashMap::computeIfPresent in this case assuming that the same List instances are not put for the same keys","label":{"api":{"ConcurrentHashMap::computeIfPresent":[[22,56]],"List":[[94,97]]}}},{"text":"Because ScheduledExecutorService#scheduleAtFixedRate is called, and as the documentation says (bolded is mine)","label":{"api":{"ScheduledExecutorService#scheduleAtFixedRate":[[8,51]]}}},{"text":"Therefore, I guess you can use java.util.Arrays (since Java 8)","label":{"api":{"java.util.Arrays":[[31,46]]}}},{"text":"You'd probably be better off using StreamTokenizer, with quoteChar('\"')","label":{"api":{"StreamTokenizer":[[35,49]],"quoteChar('\"')":[[57,70]]}}},{"text":"Java's String and StringBuilder are limited to a length of Integer.MAX_VALUE","label":{"api":{"String":[[7,12]],"StringBuilder":[[18,30]],"Integer.MAX_VALUE":[[59,75]]}}},{"text":"What I can do at most is replace a method in an existing module, or introduce a new class that replaces String and StringBuilder in that method","label":{"api":{"String":[[104,109]],"StringBuilder":[[115,127]]}}},{"text":"As a temporary workaround, to prevent the OutOfMemory exception thrown when the StringBuilder length exceeds Integer.MAX_VALUE, I implemented the follow safeAppend()","label":{"api":{"OutOfMemory exception":[[42,62]],"StringBuilder":[[80,92]],"Integer.MAX_VALUE":[[109,125]],"safeAppend()":[[153,164]]}}},{"text":"What is a recommended approach to implementing a String and StringBuilder that are NOT limited by an int max size","label":{"api":{"String":[[49,54]],"StringBuilder":[[60,72]]}}},{"text":"Also, a single LimitlessString class that can be appended efficiently like StringBuilder is also adequate","label":{"api":{"LimitlessString":[[15,29]],"StringBuilder":[[75,87]]}}},{"text":"Use JTextPane instead","label":{"api":{"JTextPane":[[4,12]]}}},{"text":"As for your font and color menu actions, use the JTextPane’s getStyledDocument() method","label":{"api":{"JTextPane":[[49,57]],"getStyledDocument()":[[61,79]]}}},{"text":"Among them is SimpleAttributeSet, which is sufficient for your needs","label":{"api":{"SimpleAttributeSet":[[14,31]]}}},{"text":"Rather than setting its attributes directly, use the methods of StyleConstants","label":{"api":{"StyleConstants":[[64,77]]}}},{"text":"Printing is as simple as calling the inherited print() method","label":{"api":{"print()":[[47,53]]}}},{"text":"You can convert a MouseEvent’s coordinates so they’re relative to another component, like a JFrame, using SwingUtilities.convertMouseEvent","label":{"api":{"MouseEvent":[[18,27]],"coordinates":[[31,41]],"JFrame":[[92,97]],"SwingUtilities.convertMouseEvent":[[106,137]]}}},{"text":"If you know something is an array, but may be a primitive array (like int[]), use the java.lang.reflect.Array class to access it","label":{"api":{"int[]":[[70,74]],"java.lang.reflect.Array":[[86,108]]}}},{"text":"You can't concisely get an Object[] from your Object, but you can trivially turn it into a List<Object>, by implementing AbstractList","label":{"api":{"Object[]":[[27,34]],"Object":[[46,51]],"List<Object>":[[91,102]],"AbstractList":[[121,132]]}}},{"text":"It's a lambda expression for the Comparable interface","label":{"api":{"Comparable":[[33,42]]}}},{"text":"The flag is just the value the compareTo method normally returns","label":{"api":{"compareTo":[[31,39]]}}},{"text":"To convert a char to a String, use the method Character.toString(char)","label":{"api":{"char":[[13,16]],"String":[[23,28]],"Character.toString(char)":[[46,69]]}}},{"text":"When you do odtSummer.toLocalDateTime(), you're discarding the fact that the input date/time is UTC, so you've lost the information right there","label":{"api":{"odtSummer.toLocalDateTime()":[[12,38]]}}},{"text":"Instead, convert the OffsetDateTime to a ZonedDateTime the desired time zone, by calling atZoneSameInstant(zoneId)","label":{"api":{"OffsetDateTime":[[21,34]],"ZonedDateTime":[[41,53]],"atZoneSameInstant(zoneId)":[[89,113]]}}},{"text":"Then get the LocalDateTime from that, by calling toLocalDateTime()","label":{"api":{"LocalDateTime":[[13,25]],"toLocalDateTime()":[[49,65]]}}},{"text":"Use ZoneId.systemDefault() to get default time zone, not TimeZone.getDefault().toZoneId()","label":{"api":{"ZoneId.systemDefault()":[[4,25]],"TimeZone.getDefault().toZoneId()":[[57,88]]}}},{"text":"The documentation for MulticastSocket doesn't say it's threadsafe, so you can't assume it's threadsafe","label":{"api":{"MulticastSocket":[[22,36]]}}},{"text":"There is no need to call Files.walk on the matched source files","label":{"api":{"Files.walk":[[25,34]]}}},{"text":"Additionally instead of calling File.listFiles() recursively you can use Files.walk or even better Files.find","label":{"api":{"File.listFiles()":[[32,47]],"Files.walk":[[73,82]],"Files.find":[[99,108]]}}},{"text":"The default model for JTextField is PlainDocument, however JTextField code actually refers to the Document interface which PlainDocument implements","label":{"api":{"JTextField":[[22,31],[59,68]],"PlainDocument":[[36,48],[123,135]],"Document":[[98,105]]}}},{"text":"Apart from DocumentFilter or JFormattedTextField (or even InputVerifier), you can add an ActionListener to JTextField which will execute when you hit Enter in the JTextField","label":{"api":{"DocumentFilter":[[11,24]],"JFormattedTextField":[[29,47]],"InputVerifier":[[58,70]],"ActionListener":[[89,102]],"JTextField":[[107,116],[163,172]]}}},{"text":"And clone will throw a CloneNotSupportedException if called on a object that hasn't overriden it","label":{"api":{"CloneNotSupportedException":[[23,48]]}}},{"text":"Here's the description of the default behavior of clone() when the class implements Cloneable but does not override clone()","label":{"api":{"clone()":[[50,56],[116,122]],"Cloneable":[[84,92]]}}},{"text":"Use Character.compare(character, t.character)","label":{"api":{"Character.compare(character, t.character)":[[4,44]]}}},{"text":"You can use BufferedReader","label":{"api":{"BufferedReader":[[12,25]]}}},{"text":"Just as you use getDeclaredMethod() to invoke (private) method m1(), you can call method getDeclaredConstructor() to get a reference to the private constructor","label":{"api":{"getDeclaredMethod()":[[16,34]],"m1()":[[63,66]],"getDeclaredConstructor()":[[89,112]]}}},{"text":"To ensure a correct ordering; the compareTo method needs to satisfy the contract specified by the Comparable interface","label":{"api":{"compareTo":[[34,42]],"Comparable":[[98,107]]}}},{"text":"Unfortunately, there is no way to extend Person; overriding compareTo in Employee to compare the salary while preserving the contract","label":{"api":{"Person":[[41,46]],"compareTo":[[60,68]],"Employee":[[73,80]]}}},{"text":"Take a look at Lock and Condition if you want to implement thread-safe queue-like structures","label":{"api":{"Lock":[[15,18]],"Condition":[[24,32]]}}},{"text":"The third point is, that instead of using an empty while construct, you should use Thread.onSpinWait","label":{"api":{"Thread.onSpinWait":[[83,99]]}}},{"text":"A LinkedHashMap can be iterated over in the same order you inserted the entries in","label":{"api":{"LinkedHashMap":[[2,14]]}}},{"text":"You could use CompleteableFuture to divide up each non-CPU-bound step","label":{"api":{"CompleteableFuture":[[14,31]]}}},{"text":"The Scanner.nextInt method does not read the newline character when you press the \"Enter\" key, hence Scanner.nextLine returns right after reading that newline","label":{"api":{"Scanner.nextInt":[[4,18]],"Scanner.nextLine":[[101,116]]}}},{"text":"To solve it, you can call Scanner.nextLine after each Scanner.nextInt to consume the pending newline","label":{"api":{"Scanner.nextLine":[[26,41]],"Scanner.nextInt":[[54,68]]}}},{"text":"You could read the file line wise using a BufferedReader","label":{"api":{"BufferedReader":[[42,55]]}}},{"text":"If I have a java.awt.Image object in hand, how can I get a byte array of the image data","label":{"api":{"java.awt.Image":[[12,25]]}}},{"text":"If I had the subclass BufferedImage I could do this","label":{"api":{"BufferedImage":[[22,34]]}}},{"text":"…where ImageIO.write takes an RenderedImage — an interface implemented by BufferedImage but not implemented by its superclass java.awt.Image","label":{"api":{"ImageIO.write":[[7,19]],"RenderedImage":[[30,42]],"BufferedImage":[[74,86]],"java.awt.Image":[[126,139]]}}},{"text":"Unfortunately, I do not have a BufferedImage or RenderedImage","label":{"api":{"BufferedImage":[[31,43]],"RenderedImage":[[48,60]]}}},{"text":"After having called getScaledInstance on my original BufferedImage object to get a reduced thumbnail image, I have only a java.awt.Image object in hand","label":{"api":{"getScaledInstance":[[20,36]],"BufferedImage":[[53,65]],"java.awt.Image":[[122,135]]}}},{"text":"I am trying to get a byte array of the data in that java.awt.Image object","label":{"api":{"java.awt.Image":[[52,65]]}}},{"text":"Java methods start with lower case valueOf","label":{"api":{"valueO":[[35,40]]}}},{"text":"The LocalDate class does exactly what you want","label":{"api":{"LocalDate":[[4,12]]}}},{"text":"The current date can be obtained by LocalDate.now()","label":{"api":{"LocalDate.now()":[[36,50]]}}},{"text":"Looking at the implementation of the clear operation of ArrayDeque (which basically is just a circular array queue), you can see that it uses an O(n) approach through the following two operations","label":{"api":{"ArrayDeque":[[56,65]]}}},{"text":"If you read the javadoc of StoredProcedureQuery, you will find","label":{"api":{"StoredProcedureQuery":[[27,46]]}}},{"text":"j8+ java.util.Base64 provides the newer base64 variants (i.e","label":{"api":{"java.util.Base64":[[4,19]]}}},{"text":"You need to use requestFocusInWindow() after you click on any operator (+,-,*,/,etc)","label":{"api":{"requestFocusInWindow()":[[16,37]]}}},{"text":"PublicKey and PrivateKey are interfaces, as you can see from the linked documentation","label":{"api":{"PublicKey":[[0,8]],"PrivateKey":[[14,23]]}}},{"text":"The object is being created by KeyPairGenerator","label":{"api":{"KeyPairGenerator":[[31,46]]}}},{"text":"The objects in the keypair will be instances of classes that implement the PublicKey and PrivateKey interfaces","label":{"api":{"PublicKey":[[75,83]],"PrivateKey":[[89,98]]}}},{"text":"Code in the KeyPairGenerator implementation being used will create objects in a similar way, ones that are instances of classes implementing PublicKey and PrivateKey","label":{"api":{"KeyPairGenerator":[[12,27]],"PublicKey":[[141,149]],"PrivateKey":[[155,164]]}}},{"text":"You can use Stream API and Arrays#equals to write elegant 1 line checkIdentical","label":{"api":{"Stream":[[12,17]],"Arrays#equals":[[27,39]]}}},{"text":"Your methodRef2 should be of type Supplier","label":{"api":{"methodRef2":[[5,14]],"Supplier":[[34,41]]}}},{"text":"and methodRef4 should be of type Runnable","label":{"api":{"methodRef4":[[4,13]],"Runnable":[[33,40]]}}},{"text":"You could use a Context object containing a ThreadLocal, with static access methods, that stores this kind of information","label":{"api":{"Context":[[16,22]],"ThreadLocal":[[44,54]]}}},{"text":"Clean the ThreadLocal after every Request was processed","label":{"api":{"ThreadLocal":[[10,20]],"Request":[[34,40]]}}},{"text":"One can use existing utility functions, Arrays.binarySearch, and System.arraycopy","label":{"api":{"Arrays.binarySearch":[[40,58]],"System.arraycopy":[[65,80]]}}},{"text":"One option is an annotation processor","label":{"api":{}}},{"text":"Note, however, that the annotation processor API does allow one to use the class of the annotation (e.g","label":{"api":{"annotation processor":[[24,43]],"annotation":[[88,97]]}}},{"text":"You would then need to tell javac to use the annotation processor","label":{"api":{"annotation processor":[[45,64]]}}},{"text":"Note you may not be able to enforce the use of your annotation processor","label":{"api":{"annotation processor":[[52,71]]}}},{"text":"As far as I can tell, Paths.get and Path.of seem to do exactly the same thing, turning one or more strings into a Path object; the documentation https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html#get-java.lang.String-java.lang.String...- and https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Path.html#of(java.lang.String,java.lang.String...) use the same wording","label":{"api":{"Paths.get":[[22,30]],"Path.of":[[36,42]],"Path":[[114,117]]}}},{"text":"java.util.Collections is a library class containing utility methods for dealing with Collection types","label":{"api":{"java.util.Collections":[[0,20]],"Collection":[[85,94]]}}},{"text":"Your first link shows an implementation of the binary search algorithm from scratch, while your second link shows how to use the utility method Collections.binarySearch, which saves writing your own implementation","label":{"api":{"Collections.binarySearch":[[144,167]]}}},{"text":"For example, a variation of binary search can be used to find the first occurrence of the target number, or the smallest number greater than or equal to the target, but the Collections.binarySearch method cannot do either of these things, so you could have to write an implementation yourself","label":{"api":{"Collections.binarySearch":[[173,196]]}}},{"text":"For guaranteed behavior, there needs to be synchronization, through volatile or AtomicBoolean for example","label":{"api":{"AtomicBoolean":[[80,92]]}}},{"text":"You need to use PagedResultsControl","label":{"api":{"PagedResultsControl":[[16,34]]}}},{"text":"You will have to change the declaration of context so it's an LdapContext, and you can pass the PagedResultsControl in the constructor of InitialLdapContext","label":{"api":{"LdapContext":[[62,72]],"PagedResultsControl":[[96,114]],"InitialLdapContext":[[138,155]]}}},{"text":"The producer is submitting tasks to an ExecutorCompletionService that does some fast processing and add the result to its internal completionQueue, an unbounded BlockingQueue","label":{"api":{"ExecutorCompletionService":[[39,63]],"internal completionQueue":[[122,145]],"BlockingQueue":[[161,173]]}}},{"text":"The interesting fact is that ExecutorCompletionService is using add method to output results in the queue and add doesn't block","label":{"api":{"ExecutorCompletionService":[[29,53]],"add":[[64,66]],"queue":[[100,104]]}}},{"text":"What if I have a slow consumer and I want the ExecutorCompletionService to block to avoid memory overflow","label":{"api":{"ExecutorCompletionService":[[46,70]]}}},{"text":"Here is the relevant code in the ExecutorCompletionService class, with javadoc stating that the completionQueue should be treated as unbounded","label":{"api":{"ExecutorCompletionService":[[33,57]],"completionQueue":[[96,110]]}}},{"text":"As a side note, there is a way to throttle the input into the ExecutorCompletionService if the task processing is slow","label":{"api":{"ExecutorCompletionService":[[62,86]]}}},{"text":"What you could do is get the editor component of your cell(s) and if it's a subclass of JTextComponent, call JTextComponent.setCaretColor","label":{"api":{"JTextComponent":[[88,101]],"JTextComponent.setCaretColor":[[109,136]]}}},{"text":"As per Object.hashCode() javadoc","label":{"api":{"Object.hashCode()":[[7,23]]}}},{"text":"If you can use CompletableFuture instead of plain Future you can use CompletableFuture.anyOf() method","label":{"api":{"CompletableFuture":[[15,31]],"CompletableFuture.anyOf()":[[69,93]]}}},{"text":"Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result","label":{"api":{"CompletableFuture":[[14,30]],"CompletableFutures":[[72,89]]}}},{"text":"I dont have experience with the Graphics class, but seems like fillOval() only draws circles, it does not apply for logarithmic functions","label":{"api":{"Graphics":[[32,39]],"fillOval()":[[63,72]]}}},{"text":"You can use the repeat method, so the code is less verbose, also enclosing the generation in a method you can make it dynamic bu setting two arguments","label":{"api":{"repeat":[[16,21]]}}},{"text":"Another approach is to use @PostConstruct like below","label":{"api":{"@PostConstruct":[[27,40]]}}},{"text":"You can use the static Map#entry method to create a single, unmodifiable instance of Map.Entry","label":{"api":{"Map#entry":[[23,31]],"Map.Entry":[[85,93]]}}},{"text":"You can't use ResultSet.equals for this, because that is not what the Object.equals contract is for","label":{"api":{"ResultSet.equals":[[14,29]],"Object.equals":[[70,82]]}}},{"text":"To represent larger numbers than this, you will need to use a different datatype, such as BigInteger, which allows arbitrarily large numbers","label":{"api":{"BigInteger":[[90,99]]}}},{"text":"The constructor new BigInteger(String val) will parse a string as a BigInteger","label":{"api":{"BigInteger(String val)":[[20,41]],"string":[[56,61]],"BigInteger":[[68,77]]}}},{"text":"To solve this problem you will need to use a datatype which can represent larger integers, such as long (up to about 19 digits) or BigInteger (arbitrarily large)","label":{"api":{"long":[[99,102]],"BigInteger":[[131,140]]}}},{"text":"Use FileSystems to access, write and replace the contents of the jar file","label":{"api":{"FileSystems":[[4,14]]}}},{"text":"From Thread:::isAlive docs","label":{"api":{"Thread:::isAlive":[[5,20]]}}},{"text":"From the docs of Thread::start","label":{"api":{"Thread::start":[[17,29]]}}},{"text":"Instead, for any kind of animation or long-heavy task (consider Thread.sleep as one), Swing Timers and Swing Workers should be used","label":{"api":{"Thread.sleep":[[64,75]],"Swing Timers":[[86,97]],"Swing Workers":[[103,115]]}}},{"text":"The problem is that the Scanner class by default uses space as a delimiter (from the class' Javadoc)","label":{"api":{"Scanner":[[24,30]]}}},{"text":"Instead, it receives an abstraction of the compiler’s model of the source code, see the java.compiler module for details","label":{"api":{"java.compiler":[[88,100]]}}},{"text":"You call pack on the JFrame, which sizes components to their preferred sizes","label":{"api":{"pack":[[9,12]],"JFrame":[[21,26]]}}},{"text":"You want to use java.util.Arrays.equals(A, ex.getA())","label":{"api":{"java.util.Arrays.equals(A, ex.getA())":[[16,52]]}}},{"text":"The Collectors.groupingBy stream Collector can help you here","label":{"api":{"Collectors.groupingBy":[[4,24]],"Collector":[[33,41]]}}},{"text":"MultipleSelectionModel (link) extends SelectionModel (link), in which the selectedItemProperty() method is implemented","label":{"api":{"MultipleSelectionModel":[[0,21]],"SelectionModel":[[38,51]],"selectedItemProperty()":[[74,95]]}}},{"text":"selectedItemProperty() returns a ReadOnlyObjectProperty (link) instance, which extends ObservableValue (link), from which the addListener() method is coming","label":{"api":{"selectedItemProperty()":[[0,21]],"ReadOnlyObjectProperty":[[33,54]],"ObservableValue":[[87,101]],"addListener()":[[126,138]]}}},{"text":"Each call forwards the iterator to the next element","label":{"api":{"iterator":[[23,30]]}}},{"text":"Originally I hoped that the TimestampResponseGenerator would automatically include the public certificate in the response if the request had setCertReq(true), but now my understanding is that I have to manually add them in the TimestampTokenGenerator using addCertificates(Store certStore)","label":{"api":{"TimestampResponseGenerator":[[28,53]],"setCertReq(true)":[[141,156]],"TimestampTokenGenerator":[[227,249]],"addCertificates":[[257,271]],"certStore":[[279,287]]}}},{"text":"However, I can only seem to get the certificate into a standard Java certStore, not a BouncyCastle Store, and I can't find a way to convert or create the Store object from scratch","label":{"api":{"certStore":[[69,77]],"BouncyCastle Store":[[86,103]],"Store":[[154,158]]}}},{"text":"This is explained in the ArrayList javadoc, you are modifying the list with remove() and set() while using an Iterator","label":{"api":{"ArrayList":[[25,33]],"remove()":[[76,83]],"set()":[[89,93]],"Iterator":[[110,117]]}}},{"text":"By using LocalDateTime#of(LocalDate,LocalTime) you can create a LocalDateTime from a LocalDate and a LocalTime","label":{"api":{"LocalDateTime#of(LocalDate,LocalTime)":[[9,45]],"LocalDateTime":[[64,76]],"LocalDate":[[85,93]],"LocalTime":[[101,109]]}}},{"text":"I'm working with Joda-Time's Duration","label":{"api":{"Duration":[[29,36]]}}},{"text":"Is there an easy way to achieve the same functionality on the Java 8+ java.time Duration","label":{"api":{"java.time Duration":[[70,87]]}}},{"text":"I'm assuming based on the code and comments that Duration::toMinutes will not necessarily return the desired value","label":{"api":{"Duration::toMinutes":[[49,67]]}}},{"text":"Do any of the same principles apply to handling ClosedChannelException from NIO calls, which can be a ClosedByInterruptException","label":{"api":{"ClosedChannelException":[[48,69]],"ClosedByInterruptException":[[102,127]]}}},{"text":"Here's what the documentation of ClosedByInterruptException says (emphasis mine)","label":{"api":{"ClosedByInterruptException":[[33,58]]}}},{"text":"Also, the ClosedByInterruptException class and its superclass, AsynchronousCloseException, are associated with channels which implement InterruptibleChannel","label":{"api":{"ClosedByInterruptException":[[10,35]],"AsynchronousCloseException":[[63,88]],"InterruptibleChannel":[[136,155]]}}},{"text":"This will cause the channel to be closed, the blocked thread to receive a ClosedByInterruptException, and the blocked thread's interrupt status to be set","label":{"api":{"ClosedByInterruptException":[[74,99]]}}},{"text":"If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a ClosedByInterruptException; its interrupt status will remain set","label":{"api":{"ClosedByInterruptException":[[175,200]]}}},{"text":"In other words, you do not need to call Thread.currentThread().interrupt() after catching a ClosedByInterruptException because the channel will have already set, or simply maintained, the interrupt status of the thread","label":{"api":{"Thread.currentThread().interrupt()":[[40,73]],"ClosedByInterruptException":[[92,117]]}}},{"text":"Integer objects are immutable so you don't need to deep copy them","label":{"api":{"Integer":[[0,6]]}}},{"text":"ArrayList vs LinkedList, we can simply use the ArrayList(Collection) constructor to copy the inner lists","label":{"api":{"ArrayList":[[0,8]],"LinkedList":[[13,22]],"ArrayList(Collection)":[[47,67]]}}},{"text":"A ValueRetriever can mean anything and we already have a DoubleSupplier","label":{"api":{"ValueRetriever":[[2,15]],"DoubleSupplier":[[57,70]]}}},{"text":"In Java we have the constant Double.NaN, which according to the documentation is the same as Double.longBitsToDouble(0x7ff8000000000000L)","label":{"api":{"Double.NaN":[[29,38]],"Double.longBitsToDouble":[[93,115]]}}},{"text":"Your C++ conversion seems faulty, and also according to the docs of Double.longBitsToDouble there can be differences in the bit patterns returned, even if it's IEEE 754 compliant","label":{"api":{"Double.longBitsToDouble":[[68,90]]}}},{"text":"It's part of the JavaFX Button definition","label":{"api":{"JavaFX Button":[[17,29]]}}},{"text":"ChronoUnits have a between method which returns the number of complete units between a start and end date/time","label":{"api":{"ChronoUnits":[[0,10]],"between":[[19,25]]}}},{"text":"As suggested in the comments, Arrays.copyOfRange is a better alternative to the above because it takes care of out-of-bound index and negative ranges","label":{"api":{"Arrays.copyOfRange":[[30,47]]}}},{"text":"First, you have the Comparable interface which roughly looks like","label":{"api":{"Comparable":[[20,29]]}}},{"text":"As you can see, the type parameter of Comparable is used as the parameter of the compareTo method","label":{"api":{"Comparable":[[38,47]],"compareTo":[[81,89]]}}},{"text":"Typically, the type argument for T is the same class which is implementing the Comparable interface","label":{"api":{"Comparable":[[79,88]]}}},{"text":"Used U as the type variable instead of T to show it is separate from the T used in the Comparable interface","label":{"api":{"Comparable":[[87,96]]}}},{"text":"The type variable U is upper-bounded by Comparable<U>","label":{"api":{"Comparable<U>":[[40,52]]}}},{"text":"subtype of) Comparable<U>","label":{"api":{"Comparable<U>":[[12,24]]}}},{"text":"For instance, if we use Name as the type argument it will work because Name is assignable to Comparable<Name>","label":{"api":{"Name":[[24,27],[71,74]],"Comparable<Name>":[[93,108]]}}},{"text":"The reason for specifying the upper-bound as Comparable<U> is that the method needs to call compareTo in order to function properly","label":{"api":{"Comparable<U>":[[45,57]],"compareTo":[[92,100]]}}},{"text":"The difference being the use of Comparable<","label":{"api":{"Comparable":[[32,41]]}}},{"text":"super U> as the upper-bound instead of Comparable<U>","label":{"api":{"Comparable<U>":[[39,51]]}}},{"text":"Explanation of generic <T extends Comparable<","label":{"api":{"Comparable":[[34,43]]}}},{"text":"If you're using Java 9+ then CompletableFuture#delayedExecutor(long,TimeUnit) may fit your needs","label":{"api":{"CompletableFuture#delayedExecutor(long,TimeUnit)":[[29,76]]}}},{"text":"There's also an overload where you can specify the Executor to use in place of the \"default executor\"","label":{"api":{"Executor":[[51,58]]}}},{"text":"You can use Collection.sort(list) to sort your ArrayList but AnimSprite must implement the Comparable Interface to let the sort method to know how to compare two AnimSprite objects","label":{"api":{"Collection.sort(list)":[[12,32]],"ArrayList":[[47,55]],"AnimSprite":[[61,70],[162,171]],"Comparable":[[91,100]]}}},{"text":"From the documentation for this PriorityQueue constructor","label":{"api":{"PriorityQueue":[[32,44]]}}},{"text":"Looking at its documentation","label":{"api":{}}},{"text":"Am I misunderstanding the purpose of createStoredProcedureQuery","label":{"api":{"createStoredProcedureQuery":[[37,62]]}}},{"text":"When executing this procedure without providing any result classes to createStoredProcedureQuery I get two lists both with Bean1 objects","label":{"api":{"createStoredProcedureQuery":[[70,95]],"Bean1":[[123,127]]}}},{"text":"You should use Optional.map() method","label":{"api":{"Optional.map()":[[15,28]]}}},{"text":"You can use a HashSet to store the names of teams in such a manner that the check if a new name was already used happens very efficiently","label":{"api":{"HashSet":[[14,20]]}}},{"text":"The great advantage of this approach is that the check if a name is already in a HashSet takes a constant time (O(1))","label":{"api":{"HashSet":[[81,87]]}}},{"text":"To use getMethod, you must provide not just the name of the method you want to get, but also its argument types as Class<?> objects","label":{"api":{"getMethod":[[7,15]],"Class<?>":[[115,122]]}}},{"text":"The String.length method takes no arguments, so no Class<?> arguments are needed in getMethod","label":{"api":{"String.length":[[4,16]],"Class<?>":[[51,58]],"getMethod":[[84,92]]}}},{"text":"On the other hand, the List.get method takes an int argument, so we need to pass int.class as an argument to getMethod","label":{"api":{"List.get":[[23,30]],"int.class":[[81,89]],"getMethod":[[109,117]]}}},{"text":"Hence, getMethod needs to  be called with two Object.class arguments","label":{"api":{"getMethod":[[7,15]],"Object.class":[[46,57]]}}},{"text":"And if you check the docs of PriorityQueue::iterator it returns iterator that returns elements in no particular order","label":{"api":{"PriorityQueue::iterator":[[29,51]]}}},{"text":"You can call CompletableFuture::join to wait for it to finish and it will block the main Thread until it finishes","label":{"api":{"CompletableFuture::join":[[13,35]]}}},{"text":"You are looking for filter","label":{"api":{"filter":[[20,25]]}}},{"text":"see for example Collections.unmodifiableList","label":{"api":{"Collections.unmodifiableList":[[16,43]]}}},{"text":"In the code below, accessing Random from multiple threads leads to both asserts failing","label":{"api":{"Random":[[29,34]]}}},{"text":"Random is not thread safe so this was to be expected","label":{"api":{"Random":[[0,5]]}}},{"text":"Utilizing SplittableRandom, I expected to get unique and consistent results (both asserts), doesn't work","label":{"api":{"SplittableRandom":[[10,25]]}}},{"text":"Utilizing ThreadLocalRandom has no seed and so cannot provide consistent results","label":{"api":{"ThreadLocalRandom":[[10,26]]}}},{"text":"This is the SplittableRandom code, expected it to be threadsafe - didn't work","label":{"api":{"SplittableRandom":[[12,27]]}}},{"text":"You need to write your own Spliterator, something like this","label":{"api":{"Spliterator":[[27,37]]}}},{"text":"Use String in @RequestBody, and use URLDecoder to decode in UTF-8","label":{"api":{"@RequestBody":[[14,25]],"URLDecoder":[[36,45]]}}},{"text":"Like this - URLDecoder.decode(value, StandardCharsets.UTF_8.toString())","label":{"api":{"URLDecoder.decode(value, StandardCharsets.UTF_8.toString())":[[12,70]]}}},{"text":"It´s a good practice to use the method invokeLater from SwingUtilities class","label":{"api":{"invokeLater":[[39,49]],"SwingUtilities":[[56,69]]}}},{"text":"SwingUtilities.invokeLater takes a Runnable and invokes it in the UI thread later","label":{"api":{"SwingUtilities.invokeLater":[[0,25]],"Runnable":[[35,42]]}}},{"text":"In JDK 8 you have the Duration class where you can perform conversions between units of time","label":{"api":{"Duration":[[22,29]]}}},{"text":"For instance, Java has a built-in HttpServer class","label":{"api":{"HttpServer":[[34,43]]}}},{"text":"Put a wait condition before your print to synchronize your code, using ExecutorService.awaitTermination before printing out the resulting SortedMap","label":{"api":{"ExecutorService.awaitTermination":[[71,102]],"SortedMap":[[138,146]]}}},{"text":"The javadocs are published (https://docs.oracle.com/en/java/javase/13/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html) and there are no visible caveats in the package summary to say that these APIs are intended for internal use only","label":{"api":{}}},{"text":"As the Overview page says","label":{"api":{}}},{"text":"You could do that using System.nanoTime(), but there are some complications -- check out the note on the JavaDoc for more","label":{"api":{"System.nanoTime()":[[24,40]]}}},{"text":"The Duration class has several useful methods you can use to interpret the result","label":{"api":{"Duration":[[4,11]]}}},{"text":"I would use a OneToMany annotation implementation instead","label":{"api":{"OneToMany":[[14,22]]}}},{"text":"As per JTable.doLayout() javadoc","label":{"api":{"JTable.doLayout()":[[7,23]]}}},{"text":"You can see this behavior by setting the column manually with JTableHeader.setResizingColumn() with following code, it will auto-resize the last column","label":{"api":{"JTableHeader.setResizingColumn()":[[62,93]]}}},{"text":"A clue that it's a bug is revealed in the setResizingColumn javadoc","label":{"api":{"setResizingColumn":[[42,58]]}}},{"text":"You are reimplementing a java.util.concurrent.ArrayBlockingQueue with your Buffer","label":{"api":{"java.util.concurrent.ArrayBlockingQueue":[[25,63]]}}},{"text":"The above indicates you're using java.time.Duration when you need to be using javafx.util.Duration","label":{"api":{"java.time.Duration":[[33,50]],"javafx.util.Duration":[[78,97]]}}},{"text":"You definitely want to use Random.nextInt() to get a uniform distribution of your int","label":{"api":{"Random.nextInt()":[[27,42]]}}},{"text":"There is Arrays.equals, and also Streams, which are designed for similar use cases as LINQ","label":{"api":{"Arrays.equals":[[9,21]],"Stream":[[33,38]]}}},{"text":"In this case, the Stream.anyMatch method is very similar to Any in LINQ","label":{"api":{"Stream.anyMatch":[[18,32]]}}},{"text":"Only if you know for sure that your program will never be used outside your own time zone, is it safe to use LocalDateTime","label":{"api":{"LocalDateTime":[[109,121]]}}},{"text":"I receommend you use ZonedDateTime just in case","label":{"api":{"ZonedDateTime":[[21,33]]}}},{"text":"In any case, using that LocalDateTime, the code for your logic as I have understood it is","label":{"api":{"LocalDateTime":[[24,36]]}}},{"text":"The javadoc of sorted(Comparator) says","label":{"api":{"sorted(Comparator)":[[15,32]]}}},{"text":"To delete the first 100 elements of a List, whether ArrayList, LinkedList, or any other kind of mutable list","label":{"api":{"List":[[38,41]],"ArrayList":[[52,60]],"LinkedList":[[63,72]]}}},{"text":"This is documented in the javadoc of subList()","label":{"api":{"subList()":[[37,45]]}}},{"text":"Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list","label":{"api":{}}},{"text":"See the Javadoc for the interface javax.mail.Part, which is implemented by class javax.mail.Message, for more information on setContent() and setText()","label":{"api":{"javax.mail.Part":[[34,48]],"javax.mail.Message":[[81,98]],"setContent()":[[125,136]],"setText()":[[142,150]]}}},{"text":"There is a better solution - declare myarray as AtomicIntegerArray myarray;","label":{"api":{"AtomicIntegerArray":[[48,65]]}}},{"text":"Updates to AtomicIntegerArray are always correctly synchronized; other threads are guaranteed to see them immediately and in the right order","label":{"api":{"AtomicIntegerArray":[[11,28]]}}},{"text":"Using a stream would be an easy way to deal with this","label":{"api":{"stream":[[8,13]]}}},{"text":"When passing a single arg to  ImageIcon that arg is both the filename and description","label":{"api":{"ImageIcon":[[30,38]]}}},{"text":"See the documentation of paintIcon()","label":{"api":{"paintIcon()":[[25,35]]}}},{"text":"Fill a DefaultListModel with the strings that match the search criteria","label":{"api":{"DefaultListModel":[[7,22]]}}},{"text":"Create a new JList with the model of the previous step","label":{"api":{"JList":[[13,17]]}}},{"text":"Pop a JOptionPane with the list of the previous step as its message","label":{"api":{"JOptionPane":[[6,16]]}}},{"text":"Please check https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html for more information","label":{"api":{}}},{"text":"Fortunately, you can provide your own support, by specifying a PersistenceDelegate for each non-Java-bean class you plan to serialize","label":{"api":{"PersistenceDelegate":[[63,81]]}}},{"text":"And two solutions using Stream API","label":{"api":{"Stream":[[24,29]]}}},{"text":"And since arrays don't override the hashCode() method from the Object class you will get the result from the Object.hashCode() method","label":{"api":{"hashCode()":[[36,45]],"Object":[[63,68]],"Object.hashCode()":[[109,125]]}}},{"text":"To fix this problem you use the Arrays.deepHashCode() method","label":{"api":{"Arrays.deepHashCode()":[[32,52]]}}},{"text":"For System.exit() calls you can define and set your own SecurityManager","label":{"api":{"System.exit()":[[4,16]],"SecurityManager":[[56,70]]}}},{"text":"The drawback of this solution is that you have to make sure that your application always runs with SecurityManager enabled","label":{"api":{"SecurityManager":[[99,113]]}}},{"text":"A LinkedList is not synchornized, as highlighted in the documentation","label":{"api":{"LinkedList":[[2,11]]}}},{"text":"But that's not a perfect solution, see the API docs","label":{"api":{}}},{"text":"The answer to this comes straight from the documentation for the method","label":{"api":{}}},{"text":"To have a text field accept a numeric entry, you should use a JFormattedTextField","label":{"api":{"JFormattedTextField":[[62,80]]}}},{"text":"To make it check both a localized number format (one that uses commas) and also the java.lang syntax (like 1e5), you can create a NumberFormatter which does both","label":{"api":{"java.lang":[[84,92]],"NumberFormatter":[[130,144]]}}},{"text":"Let JFormattedTextField do the work of verifying the input","label":{"api":{"JFormattedTextField":[[4,22]]}}},{"text":"It's documented in Map","label":{"api":{"Map":[[19,21]]}}},{"text":"The mutable value problem affects other map/set implementations too (for example TreeMap/TreeSet)","label":{"api":{"map":[[40,42]],"set":[[44,46]],"TreeMap":[[81,87]],"TreeSet":[[89,95]]}}},{"text":"According to docs, you can use \"method\" to specify other kind of methods like PATCH, OPTIONS, TRACE, etc","label":{"api":{"method":[[32,37]],"PATCH":[[78,82]],"OPTIONS":[[85,91]],"TRACE":[[94,98]]}}},{"text":"Simple solution would be to use ClassLoader to obtain InputStream, and use InputStream to load the font","label":{"api":{"ClassLoader":[[32,42]],"InputStream":[[54,64],[75,85]]}}},{"text":"As the specification says","label":{"api":{}}},{"text":"See DateTimeFormatter Javadoc for more information","label":{"api":{"DateTimeFormatter":[[4,20]]}}},{"text":"Streams are basically sequence of elements supporting sequential and parallel aggregate operations","label":{"api":{"Streams":[[0,6]]}}},{"text":"In a now deleted comment I said to look into Optional#map(Function) but I now realize you should actually be using Optional#flatMap(Function), assuming the logging statements are not too important","label":{"api":{"Optional#map(Function)":[[45,66]],"Optional#flatMap(Function)":[[115,140]]}}},{"text":"This method is similar to map(Function), but the mapping function is one whose result is already an Optional, and if invoked, flatMap does not wrap it within an additional Optional","label":{"api":{"map(Function)":[[26,38]],"Optional":[[100,107],[172,179]],"flatMap":[[126,132]]}}},{"text":"You can use SimpleDateFormat with the following pattern","label":{"api":{"SimpleDateFormat":[[12,27]]}}},{"text":"SimpleDateFormat may throw ParseException where argument is invalid","label":{"api":{"SimpleDateFormat":[[0,15]],"ParseException":[[27,40]]}}},{"text":"See section Manifest Attributes in Instrumentation's documentation for more details","label":{"api":{}}},{"text":"Use the groupingBy overload which takes a Supplier<M> mapFactory, to get a map with an ordering guarantee, e.g","label":{"api":{"groupingBy":[[8,17]],"Supplier<M>":[[42,52]]}}},{"text":"The javadoc for groupingBy() says","label":{"api":{"groupingBy()":[[16,27]]}}},{"text":"Look into ScheduledExecutorService.scheduleAtFixedRate","label":{"api":{"ScheduledExecutorService.scheduleAtFixedRate":[[10,53]]}}},{"text":"To get the oldest element from the ArrayList you can use Java streams (stream(), filter(...), min(...), etc)","label":{"api":{"ArrayList":[[35,43]],"streams":[[62,68]],"stream()":[[71,78]],"filter(...)":[[81,91]],"min(...)":[[94,101]]}}},{"text":"Instead of using reflection, treat each constructor as a function","label":{"api":{"reflection":[[17,26]],"function":[[57,64]]}}},{"text":"Specifically, a function which takes a sequence of PathElements as input, and produces a new instance of a particular class as output","label":{"api":{"PathElements":[[51,62]]}}},{"text":"The range returned by a ChronoField defers to IsoChronology.range, which says","label":{"api":{"ChronoField":[[24,34]],"IsoChronology.range":[[46,64]]}}},{"text":"The actual maximum value is defined by Instant.MAX","label":{"api":{"Instant.MAX":[[39,49]]}}},{"text":"In your case, if you don't care about the precision of your values past the thousandths position, you can use DecimalFormat","label":{"api":{"DecimalFormat":[[110,122]]}}},{"text":"This value doesn't impact the close operation, but instead determines the timeout value that is supplied to the Connection.isValid(timeout) operation, which is used to check the validity of the connection","label":{"api":{"Connection.isValid(timeout)":[[112,138]]}}},{"text":"Issue was in Windows the the newline consists of CR (carriage return) + LF (line feed) characters, so we must use the System.lineSeoeartor() or \\r\\n","label":{"api":{"System.lineSeoeartor()":[[118,139]]}}},{"text":"And there is also the method JFileChoose#setApproveButtonText, but I do not think this covers your needs","label":{"api":{"JFileChoose#setApproveButtonText":[[29,60]]}}},{"text":"Don't use Thread with execute, use Runnable","label":{"api":{"Thread":[[10,15]],"execute":[[22,28]],"Runnable":[[35,42]]}}},{"text":"Just one or two, created and started by the ExecutorService in response to the fact you've called execute two or more times and the limit set when creating the service was two threads","label":{"api":{"ExecutorService":[[44,58]],"execute":[[98,104]]}}},{"text":"The work being scheduled by those execute calls is just a single method call (though we have no idea how long that method takes to run)","label":{"api":{"execute":[[34,40]]}}},{"text":"I tend to doubt it (I think the first thread will still be allocated to the first execute call when your second one is made), but my confidence level on that is no more than 60%","label":{"api":{"execute":[[82,88]]}}},{"text":"No, java.lang.Float.compare( double, double ) does not return 0 (equal) for values within a hidden epsilon value of each other","label":{"api":{"java.lang.Float.compare( double, double )":[[4,44]]}}},{"text":"You need to apply Math.abs function to keep the difference always positive","label":{"api":{"Math.abs":[[18,25]]}}},{"text":"You can use merge method","label":{"api":{"merge":[[12,16]]}}},{"text":"There is no field for INDIA in Locale and therefore, you need to create a custom Locale for INDIA","label":{"api":{"Locale":[[31,36],[81,86]]}}},{"text":"So I suggest to use SerialExecutor instead, which is described in the documentation to the  java.util.concurrent.Executor","label":{"api":{"SerialExecutor":[[20,33]],"java.util.concurrent.Executor":[[92,120]]}}},{"text":"You can use the RandomAccessFile to jump to a location where you want to read the next data","label":{"api":{"RandomAccessFile":[[16,31]]}}},{"text":"Use the seek() method to go backwards from a given position","label":{"api":{"seek()":[[8,13]]}}},{"text":"See the FileWriter api","label":{"api":{"FileWriter":[[8,17]]}}},{"text":"From the RandomAccessFile docs","label":{"api":{"RandomAccessFile":[[9,24]]}}},{"text":"If your data source can be easily split multiple times (which, I think, is equivalent to being able to provide the required windows efficiently and concurrently), you can do this with Streams","label":{"api":{"Streams":[[184,190]]}}},{"text":"Console.readPassword() will turn it off until you hit Enter","label":{"api":{"Console.readPassword()":[[0,21]]}}},{"text":"If you want to initialize a type which doesn't provide a no-arg constructor and therefore requires the constructor's caller to provide an argument, you can use the java.lang.reflect.Constructor-API","label":{"api":{"java.lang.reflect.Constructor":[[164,192]]}}},{"text":"You can use PreparedStatement to achieve this, see below example","label":{"api":{"PreparedStatement":[[12,28]]}}},{"text":"Can you try ByteBuffer class","label":{"api":{"ByteBuffer":[[12,21]]}}},{"text":"You can use Collections.shuffle to \"randomize\" an array","label":{"api":{"Collections.shuffle":[[12,30]]}}},{"text":"I tend to use Arrays.deepToString for such cases","label":{"api":{"Arrays.deepToString":[[14,32]]}}},{"text":"The size of a Queue in java is limited by the max integer value","label":{"api":{"Queue":[[14,18]]}}},{"text":"Are there a more bigdata-friendly Queues or similar data structures","label":{"api":{"Queue":[[34,38]]}}},{"text":"You will just need to use String .replaceAll() method","label":{"api":{"String .replaceAll()":[[26,45]]}}},{"text":"No method of Comparator interface does support null values, so be sure to check https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html","label":{"api":{"Comparator":[[13,22]]}}},{"text":"You can use Stream::allMatch which performs exactly what you wish to accomplish","label":{"api":{"Stream::allMatch":[[12,27]]}}},{"text":"You should look into the replaceAll() method, for which you can use a regex expression to match all non alphanumeric","label":{"api":{"replaceAll()":[[25,36]]}}},{"text":"I believe what you're looking for is AsynchronousFileChannel","label":{"api":{"AsynchronousFileChannel":[[37,59]]}}},{"text":"I have a function that takes in a java.net.http.HttpRequest, logs it, sends it via a java.net.http.HttpClient, logs the response and returns the java.net.http.HttpResponse","label":{"api":{"java.net.http.HttpRequest":[[34,58]],"java.net.http.HttpClient":[[85,108]],"java.net.http.HttpResponse":[[145,170]]}}},{"text":"An easier way to do this would be to use the Java String startsWith API","label":{"api":{"String startsWith":[[50,66]]}}},{"text":"You can't use streams to remove elements from a list, but you can use lambda expression by calling removeIf()","label":{"api":{"removeIf()":[[99,108]]}}},{"text":"I'm looking to generate prime numbers using BigInteger#nextProbablePrime","label":{"api":{"BigInteger#nextProbablePrime":[[44,71]]}}},{"text":"Is it safe to assume that every value that this method returns (between BigInteger.TWO and BigInteger.valueOf(Long.MAX_VALUE)) is prime","label":{"api":{"BigInteger.TWO":[[72,85]],"BigInteger.valueOf(Long.MAX_VALUE)":[[91,124]]}}},{"text":"Consider ExecutorService.submit() methods, and the Future.get() method","label":{"api":{"ExecutorService.submit()":[[9,32]],"Future.get()":[[51,62]]}}},{"text":"But Future.get() wraps whatever exception was thrown in a single, well-defined, and declared ExecutableException","label":{"api":{"Future.get()":[[4,15]],"ExecutableException":[[93,111]]}}},{"text":"You can solve this in a single pass (O(n)) using a HashSet, which has O(1) put and lookup time","label":{"api":{"HashSet":[[51,57]]}}},{"text":"Create a comparator chain using thenComparing","label":{"api":{"thenComparing":[[32,44]]}}},{"text":"Java includes since 1.4 a package named javax.crypto, which allows you to encrypt and decrypt data using a Cipher","label":{"api":{"javax.crypto":[[40,51]],"Cipher":[[107,112]]}}}]