[{"text": "I would model the batch job as an Observable and the listener as an Observer", "label": {"api": {"Observable": [[34, 43]], "Observer": [[68, 75]]}}}, {"text": "The state changes within the batch job can be tracked in an object that is used to communicate with Observers through the notifyObservers(object) method", "label": {"api": {"Observer": [[100, 107], [128, 135]], "notifyObservers(object)": [[122, 144]]}}}, {"text": "See http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html for documentation", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html": [[4, 78]]}}}, {"text": "Get the contents of A.java into a string using a java.io.BufferedReader and proceed as follows", "label": {"api": {"java.io.BufferedReader": [[49, 70]]}}}, {"text": "You can use a PrintWriter, and follow the conventions listed in the API", "label": {"api": {"PrintWriter": [[14, 24]]}}}, {"text": "In JavaFX, you use TableColumns with CellFactories and CellValueFactories to populate your TableView", "label": {"api": {"TableColumn": [[19, 29]]}}}, {"text": "Have a look at the ServletContextListener is particular the context Destroyed method", "label": {"api": {"ServletContextListener": [[19, 40]]}}}, {"text": "YOu will be iterate over the entries, and get objects of ZipEntry", "label": {"api": {"ZipEntry": [[57, 64]]}}}, {"text": "One of the accessor methods of ZipEntry is getTime", "label": {"api": {"ZipEntry": [[31, 38]], "getTime": [[43, 49]]}}}, {"text": "java.lang.String has a toCharArray() that does exactly that", "label": {"api": {"toCharArray()": [[23, 35]]}}}, {"text": "The best way to do this would probably be to use Collections.max(), but to do this you need to implement Comparable<DataClass> on the DataClass class", "label": {"api": {"Comparable<DataClass>": [[105, 125]]}}}, {"text": "BufferedReader#read() method reads a single character from your input", "label": {"api": {"BufferedReader#read()": [[0, 20]]}}}, {"text": "I think you need BufferedReader#readLine() method here, which reads a line of text", "label": {"api": {"BufferedReader#readLine()": [[17, 41]]}}}, {"text": "Please refer Example section in javadoc of SimpleDateFormat for more details", "label": {"api": {"SimpleDateFormat": [[43, 58]]}}}, {"text": "If you want to preserve type information, implement the ParameterizedType interface", "label": {"api": {"the ParameterizedType interface": [[52, 82]]}}}, {"text": "You can do this with an ActionListener", "label": {"api": {"ActionListener": [[24, 37]]}}}, {"text": "You can create your own ActionListener class", "label": {"api": {"ActionListener": [[24, 37]]}}}, {"text": "The GridLayout documentation might be useful, and the Visual Guide to Layout Managers is a great place to see other layout managers that might work better for your different situations", "label": {"api": {"GridLayout documentation": [[4, 27]]}}}, {"text": "If you want to write to the same file you're reading from, you should either write to a copy of the file (different filename) and then rename the output file, or use RandomAccessFile interface to edit a file in-place", "label": {"api": {"RandomAccessFile": [[166, 181]]}}}, {"text": "You should use the ScheduledThreadPoolExecutor class, which does exactly that", "label": {"api": {"ScheduledThreadPoolExecutor class": [[19, 51]]}}}, {"text": "If you're on Java 7, you could use Objects.hash()", "label": {"api": {"Objects.hash()": [[35, 48]]}}}, {"text": "Very simple get the text using JPasswordField#getPassword() which returns a char[] of the text, then simply get the length of the array and check if it is equal to 0", "label": {"api": {"JPasswordField#getPassword()": [[31, 58]]}}}, {"text": "String.split() accepts a regular expression (regex for short) and dot is a special char in regexes", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "There is another overload of split that achieves that", "label": {"api": {"overload of split": [[17, 33]]}}}, {"text": "You can use the Math.random() method to obtain a random value between 0.0 (inclusive) and 1.0 (exclusive)", "label": {"api": {"the Math.random() method": [[12, 35]]}}}, {"text": "You can use File.exists() method", "label": {"api": {"File.exists()": [[12, 24]]}}}, {"text": "If what you wanted were possible, it would be via a StackTraceElement, but looking at the API, there's nothing like what you're asking for", "label": {"api": {"StackTraceElement": [[52, 68]]}}}, {"text": "Check out the String.format() method", "label": {"api": {"String.format()": [[14, 28]]}}}, {"text": "You can provide a Comparator for the Arrays.sort() method", "label": {"api": {"Comparator": [[18, 27]], "Arrays.sort()": [[37, 49]]}}}, {"text": "You can also make your common class implement the Comparable interface,like this", "label": {"api": {"Comparable": [[50, 59]]}}}, {"text": "You could listen to the dialogs close event, and interrupt the thread", "label": {"api": {"interrupt": [[49, 57]]}}}, {"text": "It can be done using the methods Float.floatToRawIntBits() or Double.doubleToRawLongBits()", "label": {"api": {"Float.floatToRawIntBits()": [[33, 57]], "Double.doubleToRawLongBits()": [[62, 89]]}}}, {"text": "The method you should use instead is void setAttribute(java.lang.String name, java.lang.Object o)", "label": {"api": {"void setAttribute(java.lang.String name, java.lang.Object o)": [[37, 96]]}}}, {"text": "This avoids the warnings because asSubclass is checked and getEnumConstants returns null if the Class object \"does not represent an enum type\"", "label": {"api": {"asSubclass": [[33, 42]], "getEnumConstants": [[59, 74]]}}}, {"text": "ConcurrentHashMap is thread safe, so storing and retrieving the byte arrays should be as well", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "The ConcurrentHashMap will safely publish those to all threads and since they are never modified (meaning they're effectively immutable), thread safety is guaranteed", "label": {"api": {"ConcurrentHashMap": [[4, 20]]}}}, {"text": "Have a look at Math.ulp(double)", "label": {"api": {"Math.ulp(double)": [[15, 30]]}}}, {"text": "The reason for the DateFormat displaying the 'wrong' year after converting the XMLGregorianCalendar to a GregorianCalendar is the fact that GregorianCalendar.getGregorianChange() defaults to 1582-10-15", "label": {"api": {"GregorianCalendar": [[82, 98], [105, 121], [140, 156]]}}}, {"text": "If the GregorianCalendar is set to a date before the Gregorian Calendar change date, it will actually be representing dates in the Julian calendar, which results in the year appearing to be 'wrong', because the length of a year is different for these two calendars", "label": {"api": {"GregorianCalendar": [[7, 23]]}}}, {"text": "A fix for this could be using GregorianCalendar.setGregorianChange() to set this value to an earlier date in order to avoid it changing to the Julian calendar", "label": {"api": {"GregorianCalendar": [[30, 46]]}}}, {"text": "Take a look at HttpServletResponseWrapper", "label": {"api": {"HttpServletResponseWrapper": [[15, 40]]}}}, {"text": "Assuming you already have the sentence stored as a string, you could use the String.replaceAll(\"[./,]\",\" \") method to remove the stop words and then use the String.split(\"\\\\s+\") to obtain the individual words making up the phrase", "label": {"api": {"String.replaceAll(\"[./,]\",\" \")": [[77, 106]], "String.split(\"\\\\s+\")": [[157, 176]]}}}, {"text": "I would Say StringTokenizer might help You", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "java.sql.Date does not store info about time", "label": {"api": {"java.sql.Date": [[0, 12]]}}}, {"text": "To conform with the definition of SQL DATE, the millisecond values wrapped by a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero in the particular time zone with which the instance is associated", "label": {"api": {"java.sql.Date": [[80, 92]]}}}, {"text": "In this case, the easiest way would be to use an ExecutorService", "label": {"api": {"ExecutorService": [[49, 63]]}}}, {"text": "See ExecutorService docs for details", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "In that MouseEvent, you can check the selection of your JTextPane, using JTextComponent.getSelectedText(), i.e", "label": {"api": {"JTextComponent.getSelectedText()": [[73, 104]]}}}, {"text": "If you have a map with data, make it a ConcurrentHashMap, and place it so that you can access it", "label": {"api": {"ConcurrentHashMap": [[39, 55]]}}}, {"text": "I know JFileChooser supports something like this but it just doesn't look native", "label": {"api": {"JFileChooser": [[7, 18]]}}}, {"text": "Is it possible to do this using AWT's FileDialog directly (which does use the native file dialog)", "label": {"api": {"FileDialog": [[38, 47]]}}}, {"text": "Since Java 1.5 we can use the method java.lang.String.format(String, Object...) and use printf like format", "label": {"api": {"java.lang.String.format(String, Object...)": [[37, 78]]}}}, {"text": "I'm not sure why you would need to use those sun.net.www.protocol.http objects directly in your code, as those are used internally by HttpUrlConnection", "label": {"api": {"HttpUrlConnection": [[134, 150]]}}}, {"text": "As for base 64 encoding, you can use the one supplied with Java Mail like this", "label": {"api": {"Java Mail": [[59, 67]]}}}, {"text": "If you're just drawing your shapes with fill and draw methods in Graphics then there's no way of getting the information back out again, not out og the Graphics object anyway", "label": {"api": {"Graphics": [[65, 72], [152, 159]]}}}, {"text": "If the objects in your list inherit from Shape then you can get check if the click is within the bounds of each shape", "label": {"api": {"Shape": [[41, 45]]}}}, {"text": "Use Swing timer", "label": {"api": {"Swing timer": [[4, 14]]}}}, {"text": "If I were you, I'd rewrite the function using Thread.sleep()", "label": {"api": {"Thread.sleep()": [[46, 59]]}}}, {"text": "If you need to do it in a different thread, take a look on Timer", "label": {"api": {"Timer": [[59, 63]]}}}, {"text": "Have a look at Timer or better ScheduledExecutorService", "label": {"api": {"Timer": [[15, 19]], "ScheduledExecutorService": [[31, 54]]}}}, {"text": "Probably Arrays.toString(int[]) is what you are looking for", "label": {"api": {"Arrays.toString(int[])": [[9, 30]]}}}, {"text": "If you check the javadoc for Math.acos, you see the following", "label": {"api": {"Math.acos": [[29, 37]]}}}, {"text": "The docs for AssertionError say that it's descended from Throwable, and that it's always constructed with the asserted expression as the ctor argument (after being converted to a string)", "label": {"api": {"AssertionError": [[13, 26]]}}}, {"text": "Isn't AssertionError always supposed to include something about the condition which triggered it", "label": {"api": {"AssertionError": [[6, 19]]}}}, {"text": "Try using a TreeMap with a suitable Comparator, then putAll entries you have in your HashMap", "label": {"api": {"TreeMap": [[12, 18]]}}}, {"text": "You will want to use a SortedMap, for example TreeMap", "label": {"api": {"TreeMap": [[46, 52]]}}}, {"text": "This class will let you use your own Comparator, and thus lets you sort its contents anyway you want it", "label": {"api": {"Comparator": [[37, 46]]}}}, {"text": "From the TreeMap(Comparator<", "label": {"api": {"TreeMap": [[9, 15]], "Comparator": [[17, 26]]}}}, {"text": "If you need to start with a HashMap, you can create a new TreeMap(myHashMap)", "label": {"api": {"new TreeMap(myHashMap)": [[54, 75]]}}}, {"text": "It sounds like you're looking for Class.forName and Class.newInstance", "label": {"api": {"Class.forName": [[34, 46]], "Class.newInstance": [[52, 68]]}}}, {"text": "you probably want to take Class<T> in the constructor for TESPluginDynListener and use Class.isInstance rather than instanceof within onDynEvent", "label": {"api": {"Class.isInstance": [[87, 102]]}}}, {"text": "But if you are sure it's not going to be null then the better way to check if a string is empty is to use the String.isEmpty() method, that's what the code seems to be trying to do", "label": {"api": {"String.isEmpty()": [[110, 125]]}}}, {"text": ", you should go for a singleton session bean (using the JavaEE 6 @Singleton annotation)", "label": {"api": {"@Singleton": [[65, 74]]}}}, {"text": "What is the URL Fetch low level API equivalent of HttpUrlConnection.getResponseMessage():String", "label": {"api": {"HttpUrlConnection.getResponseMessage():String": [[50, 94]]}}}, {"text": "http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/management/ThreadMXBean.html which seems not to directly define what \"Thread CPU time\" is a direct measurement of", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/management/ThreadMXBean.html": [[0, 82]]}}}, {"text": "I think you are looking for the RandomAccessFile class", "label": {"api": {"RandomAccessFile": [[32, 47]]}}}, {"text": "The error page location must refer exactly the resource path which will produce the desired result when being passed as argument to RequestDispatcher#forward()", "label": {"api": {"RequestDispatcher#forward()": [[132, 158]]}}}, {"text": "Since Java 8 new feature Optional you should not use @Nullable or @Notnull anymore", "label": {"api": {"Optional": [[25, 32]]}}}, {"text": "With the addition of Java 9 ifPresentOrElse, the function could even be written as", "label": {"api": {"ifPresentOrElse": [[28, 42]]}}}, {"text": "You can make use of java.util.Properties, which is a convenient utility for creating a map of keys and values, storing it in a file, and loading a related Properties object from that file", "label": {"api": {"java.util.Properties": [[20, 39]]}}}, {"text": "You can find it in the package java.util.prefs", "label": {"api": {"java.util.prefs": [[31, 45]]}}}, {"text": "I did this little test using Calendar.set(int year,int month, int date)", "label": {"api": {"Calendar.set(int year,int month, int date)": [[29, 70]]}}}, {"text": "Use Properties object", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "To parse String to Date in Java use SimpleDateFormat (parse method)", "label": {"api": {"SimpleDateFormat": [[36, 51]]}}}, {"text": "Attribute values which are EL expressions (ValueExpressions) are been set by UIComponent#setValueExpression()", "label": {"api": {"ValueExpression": [[43, 57], [92, 106]], "UIComponent#setValueExpression()": [[77, 108]]}}}, {"text": "Better is to delegate the getters/setters of attributes which can hold an EL value expression to UIComponent#getStateHelper() instead of to local properties", "label": {"api": {"UIComponent#getStateHelper()": [[97, 124]], "StateHelper": [[112, 122]]}}}, {"text": "The setValueExpression() will namely ultimately also end up in the StateHelper", "label": {"api": {"ValueExpression": [[7, 21]], "StateHelper": [[67, 77]]}}}, {"text": "The UIComponent#getAttributes() also resolves the values from the StateHelper", "label": {"api": {"UIComponent#getAttributes()": [[4, 30]], "StateHelper": [[66, 76]]}}}, {"text": "In order to achieve your initial functional requirement, which is the logging of the set attribute, you might want to add the logging statement to the setValueExpression() override which delegates to super", "label": {"api": {"ValueExpression": [[154, 168]]}}}, {"text": "You need to create a new ServerSocket class, and then use the accept() method to use the Socket created when someone connects to your listening server/ port", "label": {"api": {"ServerSocket": [[25, 36]]}}}, {"text": "Just wanted to add that Guava with its Files.newReader(File,Charset) helper method makes creating such a BufferedReader a lot readable (pardon the pun)", "label": {"api": {"BufferedReader": [[105, 118]]}}}, {"text": "If you want to validate if the file exists, you can use Files.exist(Path,LinkOption...) method", "label": {"api": {"Files.exist(Path,LinkOption...)": [[56, 86]], "File": [[56, 59]]}}}, {"text": "This way you won't need to create File at all", "label": {"api": {"File": [[34, 37]]}}}, {"text": "The Javadoc for hashCode() and toString() in the Object class should be able to clarify this for you", "label": {"api": {"hashCode()": [[16, 25]], "toString()": [[31, 40]]}}}, {"text": "Alternatively you can use String.equalsIgnoreCase() and eliminate the conjunction", "label": {"api": {"String.equalsIgnoreCase()": [[26, 50]]}}}, {"text": "if a List is empty, List#get(0) with throw an exception, not return null", "label": {"api": {"List#get(0) with throw an exception": [[20, 54]]}}}, {"text": "Per The Javadoc for readline() A line is considered to be terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a linefeed.", "label": {"api": {"The Javadoc for readline()": [[4, 29]]}}}, {"text": "ExecutorCompletionService (thread pool with callbacks that remembers submitted tasks) seems like a goof git", "label": {"api": {"ExecutorCompletionService": [[0, 24]]}}}, {"text": "The trick is to use AsyncResult wrapper to wrap internal responses (it creates Future that is immediately done and returns passed value)", "label": {"api": {"AsyncResult": [[20, 30]]}}}, {"text": "AsyncResult will return immediately as the value was already computer when it was created (synchResponse)", "label": {"api": {"AsyncResult": [[0, 10]]}}}, {"text": "In 90% of the cases you should probably use the HashMap class instead of Hashtable", "label": {"api": {"HashMap": [[48, 54]], "Hashtable": [[73, 81]]}}}, {"text": "MyHashMap by copying over the source code of the HashMap implementation from your Java Development Kit", "label": {"api": {"HashMap": [[2, 8], [49, 55]]}}}, {"text": "You can find the OpenJDK HashMap implementation here", "label": {"api": {"HashMap": [[25, 31]]}}}, {"text": "You could theoretically try accessing the HashMap internals using reflection, but the resulting code would be atrocious and the performance even worse..", "label": {"api": {"HashMap": [[42, 48]]}}}, {"text": "i  would strongly recommend you to use PreparedStatements, rather than simple Statement (which would lead to SQl injection)", "label": {"api": {"PreparedStatements": [[39, 56]]}}}, {"text": "Also, like other have mentioned, if you will use PreparedStatement you will not have to worry about SQL-injection issues and will not hit this issue", "label": {"api": {"PreparedStatement": [[49, 65]]}}}, {"text": "You may use ClassFileTransformer and ASM for it", "label": {"api": {"ClassFileTransformer": [[12, 31]]}}}, {"text": "Here is an example of using javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[28, 44]]}}}, {"text": "Did Java change something in HttpsURLConnection.getServerCertificates()", "label": {"api": {"HttpsURLConnection.getServerCertificates()": [[29, 70]]}}}, {"text": "Here's a good link to start off with which talks about the Queue interface in Java", "label": {"api": {"Here's a good link": [[0, 17]]}}}, {"text": "My suggested solution would be to use an uncaught exception handler for this by setting it as the default exception handler", "label": {"api": {"uncaught exception handler": [[41, 66]], "setting it as the default exception handler": [[80, 122]]}}}, {"text": "I believe you can make this work if your event listener extends RemoteObject", "label": {"api": {"RemoteObject": [[64, 75]]}}}, {"text": "cal.getTime() returns Date object, which is independent from time zone", "label": {"api": {"cal.getTime()": [[0, 12]], "Date": [[22, 25]]}}}, {"text": "But Date.toString() always prints this date with systems' time zone", "label": {"api": {"Date": [[4, 7]], "Date.toString()": [[4, 18]]}}}, {"text": "Date.toString() is so counterintuitive (it displays calendar time with system time zone while it barely stores number of millliseconds) that it should have been banned/deprecated", "label": {"api": {"Date": [[0, 3]], "Date.toString()": [[0, 14]]}}}, {"text": "To have accurate logging use SimpleDateFormat or call various Calendar.get*() methods instead", "label": {"api": {"Date": [[35, 38]], "SimpleDateFormat": [[29, 44]]}}}, {"text": "This error does not seem to be directly related to memory shortage - usually memory errors in Java are OutOfMemoryError errors or refer to limited space for the permanent generation and such", "label": {"api": {"OutOfMemoryError": [[103, 118]]}}}, {"text": "NullPointerException exceptions, on the other hand, are almost certainly programming errors in the executed code", "label": {"api": {"NullPointerException": [[0, 19]]}}}, {"text": "You should start with the servlet specification (or at least the HttpServlet javadoc)", "label": {"api": {"HttpServlet javadoc": [[65, 83]]}}}, {"text": "Look at the methods in the java.io.File class", "label": {"api": {"java.io.File class": [[27, 44]]}}}, {"text": "This is not true", "label": {"api": {"This is not true": [[0, 15]]}}}, {"text": "If your only requirement is to manipulate the variable and the rest of the code won't depend of that you can use synchronize (killing a fly with a cannon) or AtomicInteger (the choice with better performance)", "label": {"api": {"AtomicInteger": [[158, 170]]}}}, {"text": "If your points are unique, you could store them in a HashSet instead of an ArrayList", "label": {"api": {"a HashSet": [[51, 59]]}}}, {"text": "Set contain no dublicates while you can hold dublicates in List", "label": {"api": {"Set": [[0, 2]], "List": [[59, 62]]}}}, {"text": "List stores items in the inserted order", "label": {"api": {"List": [[0, 3]]}}}, {"text": "After converting all my code to use java.nio.Path EVERYTHING started working", "label": {"api": {"java.nio.Path": [[36, 48]]}}}, {"text": "And I replaced org.apache.commons.io.FileUtils (which has the same problem) with java.nio.Files..", "label": {"api": {"java.nio.Files": [[81, 94]]}}}, {"text": "You can define a FilenameFilter to match against the filenames, and return true if the filename matches what you're looking for", "label": {"api": {"FilenameFilter": [[17, 30]]}}}, {"text": "as the return type for getText() is already a String", "label": {"api": {"getText()": [[23, 31]]}}}, {"text": "In Java you can use BigInteger", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "You can use the API method setCurrentDirectory when initializing your JFileChooser objects", "label": {"api": {"setCurrentDirectory": [[27, 45]]}}}, {"text": "A typical example is the implementation of the Comparator interface", "label": {"api": {"the Comparator interface": [[43, 66]]}}}, {"text": "In Java you have Method and MethodHandles which can invoke a method via reflection but that is not supported in the language yet", "label": {"api": {"MethodHandles": [[28, 40]]}}}, {"text": "For older versions, use oldFile.renameTo(newFile)", "label": {"api": {"oldFile.renameTo(newFile)": [[24, 48]]}}}, {"text": "From the docs for Class", "label": {"api": {"the docs for Class": [[5, 22]]}}}, {"text": "setAttribute(java.lang.String name, java.lang.Object o) stores an object called name in the request", "label": {"api": {"setAttribute(java.lang.String name, java.lang.Object o)": [[0, 54]]}}}, {"text": "getAttribute(java.lang.String name) retrieve an object called name from the request", "label": {"api": {"getAttribute(java.lang.String name)": [[0, 34]]}}}, {"text": "You can use java.util.Calendar", "label": {"api": {"java.util.Calendar": [[12, 29]]}}}, {"text": "It's simpler if you use the split() method of the String class for splitting a line, it's the preferred way to split by spaces (instead of using StringTokenizer, which is considered deprecated for all practical purposes)", "label": {"api": {"split()": [[28, 34]]}}}, {"text": "You can use a CountDownLatch with a count of 5 in your example so you can do whatever you need to after all threads have invoked their respective countDowns", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "If you are using JPA or Hibernate as ORM then you can look for NamedQuery, it will help in attaining what you are trying to do", "label": {"api": {"NamedQuery": [[63, 72]]}}}, {"text": "Simply put, Collections.newSetFromMap uses the provided Map<E> implementation to store the Set<E> elements", "label": {"api": {"Collections.newSetFromMap": [[12, 36]]}}}, {"text": "The split(String regex) does not take an entire array (unlike C#), just a string representing a valid regular expression", "label": {"api": {"split(String regex)": [[4, 22]]}}}, {"text": "What you could do would be to define a Set which contains your operators and 2 ArrayLists", "label": {"api": {"Set": [[39, 41]], "ArrayLists": [[79, 88]]}}}, {"text": "Finally, you can then use toArray(new String\\[arraySize\\]) to get back your ArrayLists as String arrays", "label": {"api": {"ArrayLists": [[76, 85]], "toArray(new String\\[arraySize\\])": [[26, 57]]}}}, {"text": "First of all, char takes a single character (think of it as a String of exactly length 1)", "label": {"api": {"character": [[34, 42]]}}}, {"text": "Doing 20 is not considered a char but an array containing 2 characters", "label": {"api": {"character": [[60, 68]]}}}, {"text": "Obviously, I can never use a char, so a String is the best way of representing characters of length greater than 1", "label": {"api": {"character": [[79, 87]]}}}, {"text": "Here is a resource to understand Java Primitive Types and here is the definition of a character", "label": {"api": {"character": [[86, 94]]}}}, {"text": "You use the Runtime#exec method for this", "label": {"api": {"Runtime#exec": [[12, 23]]}}}, {"text": "More info on ThreadLocals you can find in ThreadLocal javadocs", "label": {"api": {"ThreadLocal javadocs": [[42, 61]]}}}, {"text": "now use the [Timer's Schedule] passing an int as an argument", "label": {"api": {"[Timer's Schedule]": [[12, 29]]}}}, {"text": "Class String and Class StringBuffer", "label": {"api": {"Class String": [[0, 11], [17, 28]], "Class StringBuffer": [[17, 34]]}}}, {"text": "If you work with NavigableMap (e.g", "label": {"api": {"NavigableMap": [[17, 28]]}}}, {"text": "TreeMap), you can use benefits of underlying tree data structure, and do something like this (with O(lg(N)) complexity)", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "You could check to see if there's data available before calling BufferedReader.readLine(), i.e", "label": {"api": {"if there's data available": [[23, 47]]}}}, {"text": "Consider making you're class BookDetails an abstract and annotating it as MappedSuperclass", "label": {"api": {"MappedSuperclass": [[74, 89]]}}}, {"text": "java.util.LinkedList is already available in library, you may use it", "label": {"api": {"java.util.LinkedList": [[0, 19]]}}}, {"text": "Use a timer to invalidate the component - see http://docs.oracle.com/javase/tutorial/uiswing/misc/timer.html and update the the animation based on the current time, for example current milliseconds modulo 5000 will give a cycle which repeats every five seconds", "label": {"api": {"current milliseconds": [[177, 196]]}}}, {"text": "Java's integer covers values from -2^31 to 2^31-1 (2147483647)", "label": {"api": {"integer": [[7, 13]]}}}, {"text": "Your value is (4281297749) in decimal which is too big for java's integer", "label": {"api": {"integer": [[66, 72]]}}}, {"text": "Java's long covers a much higher range of -2^63 to 2^63-1", "label": {"api": {"long": [[7, 10]]}}}, {"text": "Which includes your value, so a suggestion would be to use Long.valueOf(colorStr, 16) and switch to using longs", "label": {"api": {"long": [[106, 109]]}}}, {"text": "(A suggestion that comes into play when the values that you are working with are outside of the range of integer values)", "label": {"api": {"integer": [[105, 111]]}}}, {"text": "For the executing part, the problem is that the Runtime.exec()-method can't launch your executable file", "label": {"api": {"Runtime.exec()-method": [[48, 68]]}}}, {"text": "Java 7 has a LinkedTransferQueue which sounds like what you are looking for, or check out the parent type BlockingQueue, I'm sure one of them will fit the bill", "label": {"api": {"LinkedTransferQueue": [[13, 31]], "BlockingQueue": [[106, 118]]}}}, {"text": "Use String.format() instead", "label": {"api": {"String.format()": [[4, 18]]}}}, {"text": "Using a String instead of a charArray will allow you to use replaceAll", "label": {"api": {"replaceAll": [[60, 69]]}}}, {"text": "In Java, \"dictionaries\" are called Maps", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "Refer to the various interfaces and implementations in java.util", "label": {"api": {"java.util": [[55, 63]]}}}, {"text": "The main interface you'd probably want is Map", "label": {"api": {"Map": [[42, 44]]}}}, {"text": "Which implementation you want (HashMap, et", "label": {"api": {"Map": [[35, 37]], "HashMap": [[31, 37]]}}}, {"text": "How you convert whatever it is you're starting with into a Map depends entirely on what you have to start with", "label": {"api": {"Map": [[59, 61]]}}}, {"text": "Consider accessing a directory through the File Object by passing a directory, for example C:\\Source", "label": {"api": {"File": [[43, 46]]}}}, {"text": "You could also create a File object with \\\\server\\Source when the Source is located on server and is a network share", "label": {"api": {"File": [[24, 27]]}}}, {"text": "Have a look at the documentation of the File object linked above to get further information", "label": {"api": {"File": [[40, 43]]}}}, {"text": "The Class.getDeclaredMethod() can be used to do that", "label": {"api": {"Class.getDeclaredMethod()": [[4, 28]]}}}, {"text": "The getModifiers() and getReturnType() methods of the Method class can be used to do that", "label": {"api": {"getModifiers()": [[4, 17]], "getReturnType()": [[23, 37]]}}}, {"text": "You can use the Random class from java", "label": {"api": {"Random class": [[16, 27]]}}}, {"text": "in case of a stackoverflow your program will terminate prematurely with a StackOverflowError", "label": {"api": {"StackOverflowError": [[74, 91]]}}}, {"text": "Have you looked at the URL class", "label": {"api": {"URL class": [[23, 31]]}}}, {"text": "I think you are looking for java.net.URI", "label": {"api": {"java.net.URI": [[28, 39]]}}}, {"text": "Secondly, you're calling createNativeQuery, which takes an SQL query string as a parameter", "label": {"api": {"createNativeQuery": [[25, 41]]}}}, {"text": "You should be calling createQuery, or better yet, the overload createQuery(String, Class), which creates a TypedQuery, for better type-safety", "label": {"api": {"createQuery": [[22, 32], [63, 73]], "createQuery(String, Class)": [[63, 88]]}}}, {"text": "I think you have a simple way out by using the Java 2D Shape.contains(), which is implemented by Ellipse2D", "label": {"api": {"Shape.contains()": [[55, 70]], "Ellipse2D": [[97, 105]]}}}, {"text": "So essentially you create an instance of Ellipse2D.Double or Ellipse2D.Float for the greater circle, and then just call contains() each time you generate the coordinates to check they are within it before drawing them", "label": {"api": {"Ellipse2D": [[41, 49], [61, 69]]}}}, {"text": "I'd suggest defining four Comparator objects, one for each field as the key", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "Then you can define your selection sort to use a Comparator<State> to do the item comparisons and you can pick which comparator to use based on the key designation", "label": {"api": {"Comparator": [[49, 58]]}}}, {"text": "You should call the newInstance() method to create an object of the class at a given index", "label": {"api": {"newInstance()": [[20, 32]]}}}, {"text": "The Collections class provides a utility method for sorting a list in place, using a Comparator", "label": {"api": {"Collections": [[4, 14]]}}}, {"text": "Now define a Comparator to sort, one for each field that you need to sort on", "label": {"api": {"Comparator": [[13, 22]]}}}, {"text": "And finally, a Collections sort which accepts a comparator as an argument", "label": {"api": {"Collections sort": [[15, 30]]}}}, {"text": "A HashSet seems to be exactly what you need", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "Even though using a Set<Node> looks better than using a Map<Node, Boolean>, java.util.HashSet is using a HashMap internally in it's implementation", "label": {"api": {"HashSet": [[86, 92]]}}}, {"text": "To set the thread's daemon status, you can call setDaemon() before starting the thread", "label": {"api": {"setDaemon()": [[48, 58]]}}}, {"text": "Looking at the documentation for Integer.decode, I see no indication that binary should work", "label": {"api": {"Integer.decode": [[33, 46]]}}}, {"text": "Fail-fast iterators attempt to detect that they are not supposed to be valid and throw a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[89, 119]]}}}, {"text": "The JavaDoc for Thread does mention this", "label": {"api": {"JavaDoc for Thread": [[4, 21]]}}}, {"text": "Java's SimpleDateFormat is used to format a Date object to a string", "label": {"api": {"SimpleDateFormat": [[7, 22]]}}}, {"text": "For example, A SimpleDateFormat initialized with yyyy.MM.dd G 'at' HH:mm:ss z will format a date to something like 2001.07.04 AD at 12:08:56 PDT", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "I would like to add some pattern letters to SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[44, 59]]}}}, {"text": "What's the right way to extend SimpleDateFormat with these new pattern letters", "label": {"api": {"SimpleDateFormat": [[31, 46]]}}}, {"text": "If you want it in hebrew, then initialize the SimpleDateFormat instance with the hebrew locale", "label": {"api": {"initialize the SimpleDateFormat instance with the hebrew locale": [[31, 93]]}}}, {"text": "Since Connection implements AutoCloseable, you can use a try-with-resources block for this", "label": {"api": {"Connection": [[6, 15]], "AutoCloseable": [[28, 40]]}}}, {"text": "The hard way is to consider the car's route to be an arbitrary Shape (which you can define using Bezier curves, for example), extract a flattened PathIterator from it, advance in equally-spaced jumps along that iterator, and calculate the rotation you need from the position along the curve and the heading at any given point (you can estimate the heading by taking 2 successive samples, and aligning the car according to these samples)", "label": {"api": {"Shape": [[63, 67]]}}}, {"text": "How about the String method contains", "label": {"api": {"contains": [[28, 35]]}}}, {"text": "You can create a new thread for creating your reports and set a low priority with setPriority() for it", "label": {"api": {"setPriority()": [[82, 94]]}}}, {"text": "Comparison methods using for example the Comparator or Comparable, were updated to support generics, and thus take the right type (avoiding the instanceof) of your class directly", "label": {"api": {"Comparator": [[41, 50]], "Comparable": [[55, 64]]}}}, {"text": "Most collections have been updated to support Comparator, Comparable etc", "label": {"api": {"Comparator": [[46, 55]], "Comparable": [[58, 67]]}}}, {"text": "Finally, Vector3d comes with a few bits of inbuilt functionality that might be of use", "label": {"api": {"Vector3d": [[9, 16]]}}}, {"text": "I believe the easiest choice would be a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[40, 60]]}}}, {"text": "ByteBuffer has an API which makes manipulation of the buffer easier, but you would have to build the resize functionality yourself", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "ByteArrayOutputStream will allow for writing to a dynamic byte array", "label": {"api": {"ByteArrayOutputStream": [[0, 20]]}}}, {"text": "If you want to write a literal byte array in Scala code, it is easy to go from that to a normal Java class, simply by calling Classloader.defineClass", "label": {"api": {"Classloader.defineClass": [[126, 148]]}}}, {"text": "You probably didn't override the hashCode method", "label": {"api": {"hashCode": [[33, 40]]}}}, {"text": "You must always override both or none of the two equals and hashCode methods", "label": {"api": {"hashCode": [[60, 67]]}}}, {"text": "You might take a look at ConcurrentMap", "label": {"api": {"ConcurrentMap": [[25, 37]]}}}, {"text": "As an example for a lock which might help you, see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReadWriteLock.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReadWriteLock.html": [[51, 136]]}}}, {"text": "You can use @ManagedProperty annotation then you can access to same instance of SideBarBean", "label": {"api": {"@ManagedProperty": [[12, 27]]}}}, {"text": "File.createNewFile() creates only an empty file", "label": {"api": {"File.createNewFile()": [[0, 19]]}}}, {"text": "If you just need to create an empty file, then use File.createNewFile()", "label": {"api": {"File.createNewFile()": [[51, 70]]}}}, {"text": "If you need to write to a file, use FileWriter", "label": {"api": {"FileWriter": [[36, 45]]}}}, {"text": "The constructor FileWriter(String fileName, boolean append) has append boolean parameter which is useful in most cases", "label": {"api": {"FileWriter": [[16, 25]], "FileWriter(String fileName, boolean append)": [[16, 58]]}}}, {"text": "However, I recommend to use PrintWriter rather than using FileWriter to write char-based data to a file, because of its useful methods such as println()", "label": {"api": {"FileWriter": [[58, 67]], "PrintWriter": [[28, 38]], "println()": [[143, 151]]}}}, {"text": "Here is a JavaFX based sample, which generates a menu based on a set of hyperlinks to different content items", "label": {"api": {"hyperlinks": [[72, 81]]}}}, {"text": "The sample is styled via css, similar to a web page", "label": {"api": {"css": [[25, 27]]}}}, {"text": "The proper way to do this is to use javax.lang.model.SourceVersion.isName method (part of Java standard library)", "label": {"api": {"javax.lang.model.SourceVersion.isName": [[36, 72]]}}}, {"text": "This would be best done via a description tag", "label": {"api": {"description": [[30, 40]]}}}, {"text": "Basically, set the description to the images like below, then swap them if they have the same description", "label": {"api": {"description": [[19, 29], [94, 104]]}}}, {"text": "One in particular you might want to research is CyclicBarrier", "label": {"api": {"CyclicBarrier": [[48, 60]]}}}, {"text": "Instead of using collections of raw Thread instances for this, you should be submitting Runnable instances to an ExecutorService", "label": {"api": {"ExecutorService": [[113, 127]]}}}, {"text": "If all your threads are computing results of some kind, you probably want to use Callable<?> and ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[97, 121]]}}}, {"text": "You should consider using UUID's for unique identifiers", "label": {"api": {"UUID's": [[26, 31]]}}}, {"text": "check out String.endsWith(suffix) method from String API", "label": {"api": {"String.endsWith(suffix)": [[10, 32]]}}}, {"text": "Check out SwingUtilities.invokeLater() and the SwingWorker class", "label": {"api": {"SwingUtilities.invokeLater()": [[10, 37]], "SwingWorker": [[47, 57]]}}}, {"text": "Here's a tutorial on SwingWorker", "label": {"api": {"SwingWorker": [[21, 31]]}}}, {"text": "If you need to draw strings, you can do so directly in the paintComponent method (and assuming you don't need anything too fancy, it's pretty easy)", "label": {"api": {"draw strings": [[15, 26]]}}}, {"text": "Convert string representation, using Integer.parseInt() and etc.", "label": {"api": {"Integer.parseInt()": [[37, 54]]}}}, {"text": "Use String.replaceAll(regex, replacement) to find all occurrences of the parenthesized numbers, and replace them with \"\", then split", "label": {"api": {"String.replaceAll(regex, replacement)": [[4, 40]]}}}, {"text": "You can use the removeAll() method", "label": {"api": {"removeAll()": [[16, 26]]}}}, {"text": "Add @SuppressWarnings to your class definition", "label": {"api": {"@SuppressWarnings": [[4, 20]]}}}, {"text": "See What is the list of valid @SuppressWarnings warning names in Java", "label": {"api": {"@SuppressWarnings": [[30, 46]]}}}, {"text": "Read the two files into a normalised form so they can be compared", "label": {"api": {"Read the two files": [[0, 17]]}}}, {"text": "Use Set of these entries and retainAll() to find the intersection of these two sets", "label": {"api": {"Set": [[4, 6]], "retainAll()": [[29, 39]]}}}, {"text": "JList inside of a JScrollPane", "label": {"api": {"JList": [[0, 4]], "JScrollPane": [[18, 28]]}}}, {"text": "To add and remove items dynamically, you will want to make use of a DefaultListModel as follows", "label": {"api": {"DefaultListModel": [[68, 83]]}}}, {"text": "The standard Calendar class might not, but the Joda Time library does", "label": {"api": {"Calendar": [[13, 20]]}}}, {"text": "The JSR223 Bindings class allows you to expose arbitrary Java objects to scripting languages", "label": {"api": {"JSR223 Bindings class": [[4, 24]]}}}, {"text": "You could also, create implementation of XmlAdapter for specific serialization but I think it is a little more complicated", "label": {"api": {"XmlAdapter": [[41, 50]]}}}, {"text": "Are we talking about standard java.io.FileReader", "label": {"api": {"java.io.FileReader": [[30, 47]]}}}, {"text": "To match the input string against the regex, use String.matches()", "label": {"api": {"String.matches()": [[49, 64]]}}}, {"text": "You could use the Scanner class to parse the input and store it in the array", "label": {"api": {"Scanner": [[18, 24]]}}}, {"text": "You need to call the transform() method on your transform object, passing in the co-ordinates of your rectangle in an array", "label": {"api": {"transform()": [[21, 31]]}}}, {"text": "Have a look at Arrays.sort() for doing the actual sorting", "label": {"api": {"Arrays.sort()": [[15, 27]]}}}, {"text": "Java 7 still uses UTF-16 internally (Read the last section of the Charset Javadoc), and it's very unlikely that will change to UCS-4", "label": {"api": {"Read the last section of the Charset Javadoc": [[37, 80]]}}}, {"text": "You can make use of javax.swing.text.DefaultHighlighter, which handles character spacing of a text component in order to do background painting on that component", "label": {"api": {"javax.swing.text.DefaultHighlighter": [[20, 54]]}}}, {"text": "You can take  a look for RenderingHints and other thing is Font mismatching", "label": {"api": {"RenderingHints": [[25, 38]]}}}, {"text": "For the first requirement, you are looking for Class", "label": {"api": {"Class": [[47, 51]]}}}, {"text": "You can find more details at http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#dt", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#dt": [[29, 96]]}}}, {"text": "But you can do that yourself using trimToSize", "label": {"api": {"trimToSize": [[35, 44]]}}}, {"text": "Another way is to use a QueueBrowser", "label": {"api": {"QueueBrowser": [[24, 35]]}}}, {"text": "You can use Application#evaluateExpressionGet() for this", "label": {"api": {"Application#evaluateExpressionGet()": [[12, 46]]}}}, {"text": "Make both objects implements Comparable<Derivedparent> interface (or parent implements and subclass override) and then in the CompareTo method put something like this", "label": {"api": {"Comparable<Derivedparent> interface": [[29, 63]]}}}, {"text": "The toString() method for the AbstractCollection class (which is what PriorityQueue uses) states that it", "label": {"api": {"toString() method for the AbstractCollection class": [[4, 53]]}}}, {"text": "If you look at the docs for the PriorityQueue iterator, it states", "label": {"api": {"docs for the PriorityQueue iterator": [[19, 53]]}}}, {"text": "The goal is reachable via getResourceAsStream() although", "label": {"api": {"getResourceAsStream()": [[26, 46]]}}}, {"text": "If you want to load a class for which the class file is not on the class path, you need to use ClassLoader.defineClass", "label": {"api": {"ClassLoader.defineClass": [[95, 117]]}}}, {"text": "Try the Pattern and Matcher class", "label": {"api": {"Pattern": [[8, 14]], "Matcher": [[20, 26]]}}}, {"text": "You could of course also perform trivial String parsing using indexOf(), substring(), etc methods or perhaps even using some good regex", "label": {"api": {"String": [[41, 46]]}}}, {"text": "By creating an instance of the Random class", "label": {"api": {"Random": [[31, 36]]}}}, {"text": "You can also use the setSeed method to (re-)set the seed on an already created Random instance", "label": {"api": {"Random": [[79, 84]], "setSeed": [[21, 27]]}}}, {"text": "Instead of using the boolean modal arguement in the JDialog constructor, you may want to use the JDialog constructor with modality, and pass in the MODELESS enum", "label": {"api": {"JDialog constructor with modality": [[97, 129]]}}}, {"text": "The easiest is to create a StringBuilder and use the setCharAt() method", "label": {"api": {"StringBuilder": [[27, 39]], "setCharAt()": [[53, 63]]}}}, {"text": "If you make multiple modifications to your string, you can (and indeed should) reuse your StringBuilder", "label": {"api": {"StringBuilder": [[90, 102]]}}}, {"text": "Just format the output, you syntax is meaningless because the value of 01 is 1, the compiler just store the value as a number, not as a sequence of digits", "label": {"api": {"format": [[5, 10]]}}}, {"text": "You will need to create a custom popup menu for this, which can be done utilizing MouseListener (or MouseAdapter) and a JPopupMenu", "label": {"api": {"MouseListener": [[82, 94]], "MouseAdapter": [[100, 111]], "JPopupMenu": [[120, 129]]}}}, {"text": "IF I were you, I would use OS specific Runtime methods", "label": {"api": {"Runtime": [[39, 45]]}}}, {"text": "If you know how many rows and columns there are you can use the Scanner class like this (recently learned this from this answer)", "label": {"api": {"Scanner": [[64, 70]]}}}, {"text": "You're looking for Float.parseFloat()", "label": {"api": {"Float.parseFloat()": [[19, 36]]}}}, {"text": "You can use a custom Comparator and sort your ArrayList, like this", "label": {"api": {"Comparator": [[21, 30]], "sort": [[36, 39]], "ArrayList": [[46, 54]]}}}, {"text": "I noticed that in the KeyEvent class are constants such as KeyEvent.REDO", "label": {"api": {"KeyEvent": [[22, 29], [59, 66]], "KeyEvent.REDO": [[59, 71]]}}}, {"text": "Is this the proper use of KeyEvent.VK_UNDO and if so, what am I doing wrong", "label": {"api": {"KeyEvent": [[26, 33]]}}}, {"text": "I have used the java.util.concurrent package classes for the multithreading bit", "label": {"api": {"java.util.concurrent": [[16, 35]]}}}, {"text": "you should be using getResourceAsStream(String) to access files like this, you'll need to ensure that they are present on the classpath", "label": {"api": {"getResourceAsStream(String)": [[20, 46]]}}}, {"text": "Looks like you can use ButtonGroup and get the elements to iterate through it", "label": {"api": {"Looks like you can use ButtonGroup": [[0, 33]]}}}, {"text": "You can use the special Array.newInstance() method to create an array object with the specific component type", "label": {"api": {"Array.newInstance()": [[24, 42]]}}}, {"text": "Instead of using System.arraycopy, use Arrays.copyOf, which instantiates the array as the generic type", "label": {"api": {"Arrays.copyOf": [[39, 51]]}}}, {"text": "Just use bufferedReader.ready()", "label": {"api": {"bufferedReader.ready()": [[9, 30]]}}}, {"text": "You can add any AbstractButton to a ButtonGroup", "label": {"api": {"AbstractButton": [[16, 29]], "ButtonGroup": [[36, 46]]}}}, {"text": "Is there a regex that would work with String.split() to break a String into contiguous characters - ie split where the next character is different to the previous character", "label": {"api": {"String.split()": [[38, 51]]}}}, {"text": "To serialize an object to a File, I've used ObjectOutputStream with good success", "label": {"api": {"ObjectOutputStream": [[44, 61]]}}}, {"text": "Your code checks Scanner.hasNextLine() but neglect to invoke Scanner.nextLine() to advance to the next line", "label": {"api": {"Scanner.nextLine()": [[61, 78]]}}}, {"text": "Java provides non-blocking i/o through the java.nio package (see here)", "label": {"api": {"see here": [[61, 68]]}}}, {"text": "If you're stuck with the existing java.io streams, then you'll either have to use a thread-per-client model; or you'll need to devise a system for having a single thread (or pool of threads) manage a bunch of clients by looping over them repeatedly, polling instream.available() to figure out which ones have data ready to be handled", "label": {"api": {"instream.available()": [[258, 277]]}}}, {"text": "See the whole date pattern on SimpleDateFormat javadoc", "label": {"api": {"SimpleDateFormat": [[30, 45]]}}}, {"text": "You could use a PrintWriter (example here)", "label": {"api": {"PrintWriter": [[16, 26]]}}}, {"text": "While the DataOutputStream.write method takes an int argument, it actually only writes the bottom 8 bits of that argument", "label": {"api": {"DataOutputStream.write": [[10, 31]]}}}, {"text": "Easy way to have portable solution is to use TableGenerator", "label": {"api": {"TableGenerator": [[45, 58]]}}}, {"text": "That means \"UTF-16LE\", and every java platform implementation is required to support it", "label": {"api": {"required": [[65, 72]]}}}, {"text": "Randomly shuffle the list and print out its contents", "label": {"api": {"Randomly shuffle": [[0, 15]]}}}, {"text": "use SimpleDateFormat and Calendar, or Joda-Time for a more intuitive and robust API", "label": {"api": {"SimpleDateFormat": [[4, 19]], "Calendar": [[25, 32]]}}}, {"text": "For this Java 8 comes with a set of commonly-used interface types in java.util.function (thanks to Maurice Naftalin for the hint about the JavaDoc)", "label": {"api": {"java.util.function": [[69, 86]]}}}, {"text": "For this specific use case there's java.util.function.IntBinaryOperator with a single int applyAsInt(int left, int right) method, so you could write your method like this", "label": {"api": {"java.util.function": [[35, 52]], "java.util.function.IntBinaryOperator": [[35, 70]], "a single int applyAsInt(int left, int right) method": [[77, 127]]}}}, {"text": "NB This answer was written before the Java 8 GA documentation became publicly available", "label": {"api": {"publicly available": [[69, 86]]}}}, {"text": "You could just perform a logged-in check by checking the presence of HttpServletRequest#getRemoteUser() and a role check by HttpServletRequest#isUserInRole() and render restricted components accordingly", "label": {"api": {"HttpServletRequest#getRemoteUser()": [[69, 102]], "HttpServletRequest#isUserInRole()": [[124, 156]]}}}, {"text": "Use Arrays.equals() which contains overloaded methods for the various primitive types", "label": {"api": {"Arrays.equals()": [[4, 18]]}}}, {"text": "Personnaly I prefere to use LinkedList#clear because it is more clearly to understand during reading the code what you are doing", "label": {"api": {"LinkedList#clear": [[28, 43]]}}}, {"text": "Is there a reason that using an ExecutorService is not an option", "label": {"api": {"ExecutorService": [[32, 46]]}}}, {"text": "See ExecutorService and Executors", "label": {"api": {"ExecutorService": [[4, 18]], "Executors": [[24, 32]]}}}, {"text": "I would suggest something like Executors.newCachedThreadPool() or Executors.newFixedThreadPool(int)", "label": {"api": {"Executors": [[31, 39], [66, 74]]}}}, {"text": "I tend to use Float.NaN (not-a-number) for this", "label": {"api": {"Float.NaN": [[14, 22]]}}}, {"text": "Use replace() instead of replaceAll()", "label": {"api": {"replace()": [[4, 12]], "replaceAll()": [[25, 36]]}}}, {"text": "replaceAll() uses regular expression and you don't need them plus they are overhead", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "If the array list does not change, one possibility might be to pre-sort it and then repeatedly use binary search", "label": {"api": {"binary search": [[99, 111]]}}}, {"text": "Otherwise you'll need to employ a different data structure, such as a Set", "label": {"api": {"Set": [[70, 72]]}}}, {"text": "Thread.sleep() takes a long value, which is the number of milliseconds to sleep", "label": {"api": {"Thread.sleep()": [[0, 13]]}}}, {"text": "To fix this, generate a random integer from an appropriate range, and pass that to Thread.sleep()", "label": {"api": {"Thread.sleep()": [[83, 96]]}}}, {"text": "Here, random is an object of type Random", "label": {"api": {"Random": [[34, 39]]}}}, {"text": "You need to catch IOException because openStream() method may throw IOException in abnormal case", "label": {"api": {"openStream()": [[38, 49]]}}}, {"text": "GroupLayout suits your needs", "label": {"api": {"GroupLayout": [[0, 10]]}}}, {"text": "You'll need to add the images to the jar file, and then use getClass().getResource() or getClass().getResourceAsStream() to load it", "label": {"api": {"getClass().getResource()": [[60, 83]], "getClass().getResourceAsStream()": [[88, 119]]}}}, {"text": "If you read the documentation for getClasses()..", "label": {"api": {"getClasses()": [[34, 45]]}}}, {"text": "Reading the documentation of URLConnection, you need to call the connect() method after opening the connection and setting the request type", "label": {"api": {"URLConnection": [[29, 41]]}}}, {"text": "Calling start starts the thread", "label": {"api": {"start": [[8, 12], [14, 18]]}}}, {"text": "It does the underlying work to create and launch the new thread, and then calls run on that new thread", "label": {"api": {"run": [[80, 82]]}}}, {"text": "Calling run just calls the run method, on the current thread", "label": {"api": {"run": [[8, 10], [27, 29]]}}}, {"text": "You never call run directly, use start", "label": {"api": {"start": [[33, 37]], "run": [[15, 17]]}}}, {"text": "And yes, you should use PreparedStatement for executing your query rather than Statement", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "See the API documentation of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[29, 44]]}}}, {"text": "For other threads, you can use setUncaughtExceptionHandler", "label": {"api": {"setUncaughtExceptionHandler": [[31, 57]]}}}, {"text": "This is exactly the thing what UncaughtExceptionHandler concept is about", "label": {"api": {"UncaughtExceptionHandler concept is about": [[31, 71]]}}}, {"text": "You have to wait for the process to execute and you must separate the arguments", "label": {"api": {"wait": [[12, 15]]}}}, {"text": "BTW, any time you have a problem in running a process, it's a good idea to look also at the error stream", "label": {"api": {"the error stream": [[88, 103]]}}}, {"text": "You can make use of the plusMonths and minusDays methods in Java 8", "label": {"api": {"plusMonths": [[24, 33]], "minusDays": [[39, 47]]}}}, {"text": "you could implement comparable on person object that uses country id as value to compare, your person objects could then be ordered by country", "label": {"api": {"comparable": [[20, 29]]}}}, {"text": "You can use Collections.shuffle() method to shuffle a list", "label": {"api": {"Collections.shuffle()": [[12, 32]]}}}, {"text": "One way to ensure uniqueness of the IDs is to use the UUID class", "label": {"api": {"use the UUID class": [[46, 63]]}}}, {"text": "it provides a very convenient randomUUID() method, providing you with a unique identifier", "label": {"api": {"randomUUID()": [[30, 41]]}}}, {"text": "in the above Pair I've implemented the Comparable<T> interface which the Collections sorting mechanisms will make use of", "label": {"api": {"Comparable<T>": [[39, 51]]}}}, {"text": "In this case, you could use Integer.toUnsignedLong, which is equivalent to durron597's answer", "label": {"api": {"Integer.toUnsignedLong": [[28, 49]]}}}, {"text": "Use javax.ws.rs.core.Context instead", "label": {"api": {"javax.ws.rs.core.Context": [[4, 27]]}}}, {"text": "For an easier way of doing this, you might try subclassing JTable and overriding prepareRenderer", "label": {"api": {"prepareRenderer": [[81, 95]]}}}, {"text": "This is handy for changes that affect entire rows like this, so you can use custom renderers for the individual cells, and tweak all renderers for a row in the prepareRenderer method", "label": {"api": {"prepareRenderer": [[160, 174]]}}}, {"text": "Also have a look at AWT's Desktop-Class which can be used to open a program associated with a specific file type", "label": {"api": {"Desktop-Class": [[26, 38]]}}}, {"text": "Since I am using Java 7, I was planning to use the built-in hash method in the Objects class instead of the Apache Commons HashCodeBuilder", "label": {"api": {"hash method in the Objects class": [[60, 91]]}}}, {"text": "Refer to http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/Class.html#forName(java.lang.String)", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/Class.html#forName(java.lang.String": [[9, 98]]}}}, {"text": "All of this is covered in the DriverManager javadocs", "label": {"api": {"DriverManager": [[30, 42]]}}}, {"text": "You can override the isCellEditable() method of DefaultTreeCellEditor  in a way that limits editing to leaf nodes, as shown in this example", "label": {"api": {"isCellEditable()": [[21, 36]], "DefaultTreeCellEditor": [[48, 68]]}}}, {"text": "While I question the wisdom of serializing an object that is being updated so often, using a ConcurrentHashMap should at least alleviate your concurrency issues", "label": {"api": {"ConcurrentHashMap": [[93, 109]]}}}, {"text": "As for your first question regarding the collection, you could look at the PriorityBlockingQueue which is a thread-safe version of the PriorityQueue", "label": {"api": {"PriorityBlockingQueue": [[75, 95]]}}}, {"text": "Try using java.awt.image.VolatileImage", "label": {"api": {"java.awt.image.VolatileImage": [[10, 37]]}}}, {"text": "Why not use PreparedStatement instead, avoid the tedious and error-prone issue of escaping quotes in sql queries altogether", "label": {"api": {"PreparedStatement": [[12, 28]]}}}, {"text": "If you want a tokenizer-like functionality, you can use Scanner, as it considers delimeter string as a regular expression", "label": {"api": {"Scanner": [[56, 62]]}}}, {"text": "The retainAll(...) method does what you want", "label": {"api": {"retainAll(...)": [[4, 17]]}}}, {"text": "As stated in the JavaDoc a TreeMap \"...is sorted according to the natural ordering of its keys...\" (emphasis is mine)", "label": {"api": {"stated in the JavaDoc": [[3, 23]]}}}, {"text": "I would define a subclass of RecursiveAction that would take all the rows from the excel sheet and break them down into single row and performs the operations mentioned on each row in the base-case-section, use a ForkJoinPool's invoke() method on this RecursiveAction object to wait for the operation to complete, then report it", "label": {"api": {"RecursiveAction": [[29, 43], [252, 266]], "ForkJoinPool": [[213, 224]]}}}, {"text": "Use SimpleDateFormat.parse() to parse your string into a date/time", "label": {"api": {"SimpleDateFormat.parse()": [[4, 27]]}}}, {"text": "You should not parse the date manually - use a date format instead", "label": {"api": {"date format": [[47, 57]]}}}, {"text": "For really simple data storage needs you can just use the java File Writer library for writing simple primitive data types to a file, then when you need to retrieve the data just use the File Reader Library", "label": {"api": {"java File Writer library": [[58, 81]], "File Reader Library": [[187, 205]]}}}, {"text": "Why don't you use the Java StringTokenizer class and then just use the regex on the tokens you get out of this", "label": {"api": {"StringTokenizer": [[27, 41]]}}}, {"text": "For that to happen, you have to specify it in the TLD file with a <dynamic-attributes>true</dynamic-attributes> declaration and your tag handler class must implement the DynamicAttributes interface", "label": {"api": {"DynamicAttributes": [[170, 186]]}}}, {"text": "Serializable, DynamicAttributes, IterationTag, JspTag, Tag, TryCatchFinally, EditorAwareTag", "label": {"api": {"DynamicAttributes": [[14, 30]]}}}, {"text": "Although this is not kosher on java-ee, in general, have a look at UncaughtExceptionHandler", "label": {"api": {"UncaughtExceptionHandler": [[67, 90]]}}}, {"text": "In earlier days, you had to manage a threadgroup to intercept uncaught exceptions, but now you can set the default handler", "label": {"api": {"set the default handler": [[99, 121]]}}}, {"text": "ImageIcon(Image image), BufferedImage extends Image", "label": {"api": {"ImageIcon(Image image)": [[0, 21]]}}}, {"text": "Furthermore, the swing timer is affected by anything else in the swing event queue", "label": {"api": {"affected by anything else in the swing event queue": [[32, 81]]}}}, {"text": "If you don't want to use some media framework or use APIs that describe the motion of objects (rather than actually moving the objects), you should use the swing timer as a way to schedule the next computation, but determine the time elapsed since last computation by looking at the difference between System.nanoTime() now and the nanoTime during the last computation", "label": {"api": {"System.nanoTime()": [[302, 318]]}}}, {"text": "From what I can tell rooting through the code, it handles any audio format that can be converted via a registered FormatConversionProvider", "label": {"api": {"FormatConversionProvider": [[114, 137]]}}}, {"text": "But none seem to support a FormatConversionProvider", "label": {"api": {"FormatConversionProvider": [[27, 50]]}}}, {"text": "Does anyone know how to plug tab A into slot B and enable a FormatConversionProvider for mpeg-4 audio", "label": {"api": {"FormatConversionProvider": [[60, 83]]}}}, {"text": "I think the problem is more the use of setSize(..), you should rather use appropriate LayoutManager and call pack() on JFrame instance after adding all components to JFrame and before setting JFrame visible, also no need for panel.setVisible(..)", "label": {"api": {"pack()": [[109, 114]]}}}, {"text": "You can use GradientPaint to create a gradient effect", "label": {"api": {"GradientPaint": [[12, 24]]}}}, {"text": "As far as how to do this yourself, just put the connection code in the constructor, save the connection to a field, and have the methods described above do the queries (preferably using PreparedStatement)", "label": {"api": {"PreparedStatement": [[186, 202]]}}}, {"text": "If you want to pass the deep copy, use implement Cloneable iface and method clone() or you can use a copy constructor", "label": {"api": {"Cloneable": [[49, 57]]}}}, {"text": "The system property os.name provides the name of the operating system", "label": {"api": {"os.name": [[20, 26]]}}}, {"text": "According to it's doc page, java.util.Properties.load() only accepts a java.io.InputStream", "label": {"api": {"doc page": [[18, 25]]}}}, {"text": "Why is it that I can safely load a FileReader, when it is clearly not a child of InputStream", "label": {"api": {"FileReader": [[35, 44]]}}}, {"text": "You should look into using java.nio.channels.FileChannel", "label": {"api": {"java.nio.channels.FileChannel": [[27, 55]]}}}, {"text": "If you want to be sure to resolve it locally, take a look at the EntityResolver interface", "label": {"api": {"EntityResolver": [[65, 78]]}}}, {"text": "If you want client time zone, you need to send it and use something SimpleDateFormat to convert server time to client timezone", "label": {"api": {"SimpleDateFormat": [[68, 83]]}}}, {"text": "Write your query as follows and use PreparedStatement", "label": {"api": {"PreparedStatement": [[36, 52]]}}}, {"text": "First you need a way to decide if a String represents a number; the method below uses Double.valueOf() to decide", "label": {"api": {"Double.valueOf()": [[86, 101]]}}}, {"text": "II cannot understand how should the natural ordering of class be \"consistent with equals\" when implementing the Comparable interface", "label": {"api": {"Comparable": [[112, 121]]}}}, {"text": "I detected a flaw in my program and therefore I checked it in the documentantion of the interface Comparable", "label": {"api": {"Comparable": [[98, 107]]}}}, {"text": "Your compareTo() method is not consistent with equals()", "label": {"api": {"consistent with equals()": [[31, 54]]}}}, {"text": "However, it is far wiser to use File.separator instead", "label": {"api": {"File.separator": [[32, 45]]}}}, {"text": "You probably need to close() the socket", "label": {"api": {"close()": [[21, 27]]}}}, {"text": "If that's not important, then the whole thing can be replaced by two calls to System.arraycopy()", "label": {"api": {"System.arraycopy()": [[78, 95]]}}}, {"text": "I've never done something like that, but after a quick research on the web, I guess it can be achieved via the The AudioSystem Class", "label": {"api": {"AudioSystem Class": [[115, 131]]}}}, {"text": "In this use case, you may be interested to learn about Pattern.quote", "label": {"api": {"Pattern.quote": [[55, 67]]}}}, {"text": "You can do Pattern.quote(\"|\")", "label": {"api": {"Pattern.quote": [[11, 23]]}}}, {"text": "See the documentation for ResourceBundle and PropertyResourceBundle for more information", "label": {"api": {"ResourceBundle": [[26, 39], [53, 66]], "PropertyResourceBundle": [[45, 66]]}}}, {"text": "You could use a NavigableSet that would keep the data in the order you prefer ( use a custom comparator for this) and allows you to query a headset, subset or a tailset", "label": {"api": {"NavigableSet": [[16, 27]]}}}, {"text": "Also better to use endsWith()  String method over the file name as", "label": {"api": {"endsWith()": [[19, 28]]}}}, {"text": "You can use the overload of split that takes a limit parameter", "label": {"api": {"overload of split": [[16, 32]]}}}, {"text": "Check ArrayList javadoc for further informations", "label": {"api": {"ArrayList javadoc": [[6, 22]]}}}, {"text": "As with any list, you can find out how many objects it is holding with List#size()", "label": {"api": {"List#size()": [[71, 81]]}}}, {"text": "For example, if you look at the example code in the CyclicBarrier JavaDoc the call to barrier.await() is inside the loop inside the worker", "label": {"api": {"CyclicBarrier JavaDoc": [[52, 72]]}}}, {"text": "And I need to use a PriorityQueue", "label": {"api": {"PriorityQueue": [[20, 32]]}}}, {"text": "But I don't really know how to write such a compare method because I have never used a PriorityQueue", "label": {"api": {"PriorityQueue": [[87, 99]]}}}, {"text": "You can also paint other things, like outlining a rectangle or filling an oval", "label": {"api": {"outlining a rectangle": [[38, 58]], "filling an oval": [[63, 77]]}}}, {"text": "For more advanced graphics functions, try casting to a Graphics2D object", "label": {"api": {"Graphics2D": [[55, 64]]}}}, {"text": "This is a typical BorderLayout scenario", "label": {"api": {"BorderLayout": [[18, 29]]}}}, {"text": "Use SwingUtilities.getWindowAncestor(Component) to find the parent window of the current component", "label": {"api": {"SwingUtilities.getWindowAncestor(Component)": [[4, 46]]}}}, {"text": "According to the javadoc for the iterator", "label": {"api": {"javadoc for the iterator": [[17, 40]]}}}, {"text": "Following the format you want to use in the input file then it would be better if you make use of java.util.Properties", "label": {"api": {"java.util.Properties": [[98, 117]]}}}, {"text": "You can read more about the simple line-oriented format", "label": {"api": {"simple line-oriented format": [[28, 54]]}}}, {"text": "You need to use indexOf(object) to get the index", "label": {"api": {"index": [[16, 20], [43, 47]]}}}, {"text": "Enhanced for loop uses iterator internally, so you couldn't get hold of index", "label": {"api": {"index": [[72, 76]]}}}, {"text": "Notice I also used the utility method Arrays.toString, which is necessary because arrays themselves don't override toString to show their contents", "label": {"api": {"Arrays.toString": [[38, 52]]}}}, {"text": "You need to specify the position and other settings using GridBagConstraints", "label": {"api": {"GridBagConstraints": [[58, 75]]}}}, {"text": "GridBagConstraints.gridx and GridBagConstraints.gridy determine the row and column for this element", "label": {"api": {"GridBagConstraints": [[0, 17], [29, 46]]}}}, {"text": "This requires Providing a Custom Renderer; the API includes an example", "label": {"api": {"example": [[63, 69]]}}}, {"text": "You should use ExecutorService.html#shutdownNow() when you're done with the ExecutorService and you don't intend to submit new tasks to it", "label": {"api": {"ExecutorService.html#shutdownNow()": [[15, 48]]}}}, {"text": "Method ExecutorService.html#submit returns a Future that can be used to cancel execution and/or wait for completion", "label": {"api": {"Future": [[45, 50]]}}}, {"text": "The class LinkedList<E> implements the interface Queue<E>", "label": {"api": {"LinkedList<E>": [[10, 22]], "Queue<E>": [[49, 56]]}}}, {"text": "You should set your parameters the same way as you do, and then use void addBatch() declared by PreparedStatement", "label": {"api": {"void addBatch()": [[68, 82]]}}}, {"text": "You can do this with AWT or Swing by using Frame#setUndecorated(boolean)", "label": {"api": {"Frame#setUndecorated(boolean)": [[43, 71]]}}}, {"text": "BitSet does bit manipulation behind the scenes", "label": {"api": {"BitSet": [[0, 5]]}}}, {"text": "First convert the String to a BitSet", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "Then, use nextSetBit to find the 1's", "label": {"api": {"nextSetBit": [[10, 19]]}}}, {"text": "you have to invoke ResultSet.next() before retriving the rows from your ResultSet Object", "label": {"api": {"ResultSet.next()": [[19, 34]]}}}, {"text": "A priority queue is a decent approach - all you need to do is get the Entry set from the map, and override a Comparator as the input to the queue", "label": {"api": {"get the Entry set": [[62, 78]]}}}, {"text": "Instead add them to the JTable and use columnAtPoint, rowAtPoint", "label": {"api": {"columnAtPoint": [[39, 51]]}}}, {"text": "Use String.equals() to compare two strings in Java", "label": {"api": {"String.equals()": [[4, 18]]}}}, {"text": "Check out the ArrayIndexOutOfBoundsException documentation", "label": {"api": {"ArrayIndexOutOfBoundsException": [[14, 43]]}}}, {"text": "Set.containsAll() does what you want", "label": {"api": {"Set.containsAll()": [[0, 16]]}}}, {"text": "There is String#contains", "label": {"api": {"String#contains": [[9, 23]]}}}, {"text": "Then, getDeclaredFields() only returns String filedC as you have seen", "label": {"api": {"getDeclaredFields()": [[6, 24]]}}}, {"text": "Anyway, in case of C extends B and B extends A, method getFields() returns only public fields (including inherited)", "label": {"api": {"getFields()": [[55, 65]]}}}, {"text": "And getDeclaredFields() returns all fields declared in the class (not including inherited)", "label": {"api": {"getDeclaredFields()": [[4, 22]]}}}, {"text": "Serializable interface is used for Java native serialization", "label": {"api": {"serialization": [[47, 59]]}}}, {"text": "AMF serialization has nothing common with it and is used for serializing and deserializing Flash player data", "label": {"api": {"serialization": [[4, 16]]}}}, {"text": "From OutputStream.flush() docs", "label": {"api": {"OutputStream.flush()": [[5, 24]]}}}, {"text": "Use SimpleDateFormat to format the Date as a String, in any format you need", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "I am assuming the user clicks on another component (JButton) when he wishes to save data", "label": {"api": {"JButton": [[52, 58]]}}}, {"text": "The stopCellEditing() should save the state of the model and allow you to save all the contents, including the currently selected / edited cell", "label": {"api": {"stopCellEditing()": [[4, 20]]}}}, {"text": "OutputStream does not have a print() method", "label": {"api": {"OutputStream": [[0, 11]]}}}, {"text": "Is there any behind the scenes syncing between OutputStream and InputStream or should I always call flush before polling for a reply", "label": {"api": {"OutputStream": [[47, 58]]}}}, {"text": "Well, for starters, you run ArrayList.contains() (labelsUsed.contains(..))a LOT of times, each is O(n) - you should consider using more efficient data structure - such as a Set if possible (no dupe elements)", "label": {"api": {"Set": [[173, 175]]}}}, {"text": "You could implement the Reader interface, and then extend the writer class to implement a writer that excepts short[]", "label": {"api": {"writer class": [[62, 73]]}}}, {"text": "There's built in httpserver http://docs.oracle.com/javase/6/docs/jre/api/net/httpserver/spec/index.html  so you can easily implement a simple webservice in standalone java", "label": {"api": {"http://docs.oracle.com/javase/6/docs/jre/api/net/httpserver/spec/index.html": [[28, 102]]}}}, {"text": "use SimpleDateFormat.setTimeZone(TimeZone) to set TimeZone", "label": {"api": {"SimpleDateFormat.setTimeZone(TimeZone)": [[4, 41]]}}}, {"text": "I'm trying to write an annotation processor to insert methods and fields on a class..", "label": {"api": {"annotation processor": [[23, 42]]}}}, {"text": "The processing environment provides a Filer object which has handy methods for creating new source and class files", "label": {"api": {"Filer": [[38, 42]]}}}, {"text": "If the animation is using a Swing Timer the simple answer would be to call stop()", "label": {"api": {"Timer": [[34, 38]], "stop()": [[75, 80]]}}}, {"text": "I highly recommend using the Timer for animation since it ensures the actions are performed on the EDT", "label": {"api": {"Timer": [[29, 33]]}}}, {"text": "From the docs for setDefaultCloseOperation(int)", "label": {"api": {"setDefaultCloseOperation(int)": [[18, 46]]}}}, {"text": "newInstance() requires a parameterless constructor, and Color has no such constructor", "label": {"api": {"newInstance()": [[0, 12]], "Color": [[56, 60]]}}}, {"text": "You need to find an appropriate Constructor, and use that", "label": {"api": {"Constructor": [[32, 42]]}}}, {"text": "As you can see the LinkedList class implements the List interface", "label": {"api": {"LinkedList class": [[19, 34]]}}}, {"text": "Remember that the Interfaces are like a contract, so A*LL THE METHODS THAT ARE DEFINIED IN* List interface MUST BE IMPLEMENTED in the LinkedList class", "label": {"api": {"LinkedList class": [[134, 149]]}}}, {"text": "In that way List interface has the same methods as the LinkedList class", "label": {"api": {"LinkedList class": [[55, 70]]}}}, {"text": "A more suitable data structure would be a tree set or prefix tree (or trie)", "label": {"api": {"tree set": [[42, 49]]}}}, {"text": "For a tree set, the ceiling() method would be handy", "label": {"api": {"tree set": [[6, 13]], "ceiling()": [[20, 28]]}}}, {"text": "You CAN modify a List while iterating IF you use a ListIterator to iterate", "label": {"api": {"ListIterator": [[51, 62]]}}}, {"text": "PreparedStatement.setnull(paraIndex, SQLType) sets the SQL varchar type to Null for the specified placeholder", "label": {"api": {"PreparedStatement.setnull(paraIndex, SQLType)": [[0, 44]]}}}, {"text": "stmt.setInt(2,2290); sets an int value 2290 at 2nd placeholder", "label": {"api": {"stmt.setInt(2,2290);": [[0, 19]]}}}, {"text": "To avoid the exception, use iter.remove() instead", "label": {"api": {"iter.remove()": [[28, 40]]}}}, {"text": "Detailed styling information for JavaFX can be found in the default caspian.css stylesheet for JavaFX 2.2 and the JavaFX 2 CSS reference guide", "label": {"api": {"JavaFX 2 CSS reference guide": [[114, 141]]}}}, {"text": "If so, you may well want to use DateFormat.getDateInstance() instead of SimpleDateFormat", "label": {"api": {"DateFormat.getDateInstance()": [[32, 59]]}}}, {"text": "You can use wrapper java.lang.Boolean instead", "label": {"api": {"java.lang.Boolean": [[20, 36]]}}}, {"text": "I would suggest you to store the inputStreams for every entry in you array using zipFile.getInputStream and then extract your contents from the inputstream and finally close these streams when they are useless to you", "label": {"api": {"zipFile.getInputStream": [[81, 102]]}}}, {"text": "Note that when you create instances of Database on the server, you need to give it a stub for the RemoteDatabaseImpl implementation, rather than the real thing (i think)", "label": {"api": {"stub": [[85, 88]]}}}, {"text": "You could use a HashMap to store the mapping (!) - Assuming the KEY_XX are integers, for example, it could look like this", "label": {"api": {"a HashMap": [[14, 22]]}}}, {"text": "You probably want to use Matcher#start() to determine the start of your match", "label": {"api": {"Matcher#start()": [[25, 39]]}}}, {"text": "You should take a look at the invalidate() method of HttpSession", "label": {"api": {"invalidate()": [[30, 41]]}}}, {"text": "The session can be retrieved via HttpServletRequest getSession() method", "label": {"api": {"getSession()": [[52, 63]]}}}, {"text": "You should use the returned Process to get the result", "label": {"api": {"Process": [[28, 34]]}}}, {"text": "Runtime#exec executes the command as a separate process and returns an object of type Process", "label": {"api": {"Process": [[86, 92]], "Runtime#exec": [[0, 11]]}}}, {"text": "You should call Process#waitFor so that your program waits until the new process finishes", "label": {"api": {"Process": [[16, 22]], "Process#waitFor": [[16, 30]]}}}, {"text": "Then, you can invoke Process.html#getOutputStream() on the returned Process object to inspect the output of the executed command", "label": {"api": {"Process": [[21, 27], [68, 74]], "Process.html#getOutputStream()": [[21, 50]]}}}, {"text": "An alternative way of creating a process is to use ProcessBuilder", "label": {"api": {"Process": [[51, 57]], "ProcessBuilder": [[51, 64]]}}}, {"text": "With a ProcessBuilder, you list the arguments of the command as separate arguments", "label": {"api": {"Process": [[7, 13]], "ProcessBuilder": [[7, 20]]}}}, {"text": "See Difference between ProcessBuilder and Runtime.exec() and ProcessBuilder vs Runtime.exec() to learn more about the differences between Runtime#exec and ProcessBuilder#start", "label": {"api": {"Process": [[23, 29], [61, 67], [155, 161]], "Runtime#exec": [[138, 149]], "ProcessBuilder": [[23, 36], [61, 74], [155, 168]], "ProcessBuilder#start": [[155, 174]]}}}, {"text": "Use ArrayList.contains(Object elem)  to check if item is exist in ArrayList or not Change your code as", "label": {"api": {"ArrayList.contains(Object elem)": [[4, 34]]}}}, {"text": "But, I strongly advise you to use PreparedStatement instead (See How do I make a prepared statement?, https://stackoverflow.com/a/396765/130224, PreparedStatements and performance, and Using Prepared Statements)", "label": {"api": {"PreparedStatement": [[34, 50], [145, 161]]}}}, {"text": "PreparedStatement yields higher performance and security", "label": {"api": {"PreparedStatement": [[0, 16]]}}}, {"text": "You can use int[].class to get the class literal of int [] and pass it to Class.getMethod", "label": {"api": {"Class.getMethod": [[74, 88]]}}}, {"text": "It contains a .toArray() method that will give you back an array after you've constructed the set, if that is what you require", "label": {"api": {".toArray()": [[14, 23]]}}}, {"text": "Use a Set", "label": {"api": {"Set": [[6, 8]]}}}, {"text": "The document you linked indicates that you should use Service as a reusable Task-like object", "label": {"api": {"Service": [[54, 60]]}}}, {"text": "It appears that a Service has a method createTask() that creates its task instances as needed", "label": {"api": {"Service": [[18, 24]]}}}, {"text": "Look up FontMetrics", "label": {"api": {"FontMetrics": [[8, 18]]}}}, {"text": "If string is an instance of java.lang.String, this behaviour is specifically guaranteed", "label": {"api": {"specifically guaranteed": [[64, 86]]}}}, {"text": "DatagramPacket's getData returns the payload as a byte[]", "label": {"api": {"getData": [[17, 23]]}}}, {"text": "You can use Arrays.copyOfRange to get the individual fields (I'm assuming you meant bytes in your question, not bits)", "label": {"api": {"Arrays.copyOfRange": [[12, 29]]}}}, {"text": "split the string with / as a delimiter using String#Split(\"/\"):", "label": {"api": {"String#Split(\"/\"):": [[45, 62]]}}}, {"text": "You could save all that code and use String#split to split the line", "label": {"api": {"String#split": [[37, 48]]}}}, {"text": "However, in a replacement string, it means something completely different", "label": {"api": {"completely different": [[53, 72]]}}}, {"text": "What you need to do is to escape any escape characters you have in the replacement string, such as with Matcher.quoteReplacement()", "label": {"api": {"Matcher.quoteReplacement()": [[104, 129]]}}}, {"text": "Alternatively, you can also use useDelimiter to add - as delimiter and use nextInt to read number without having to deal with - separately", "label": {"api": {"useDelimiter": [[32, 43]]}}}, {"text": "Java's reflection APIs allow references to member variables via the Field type", "label": {"api": {"Field type": [[68, 77]]}}}, {"text": "You should use the String.compareTo(String) method as it also checks the size of the inputs", "label": {"api": {"String.compareTo(String)": [[19, 42]]}}}, {"text": "It's behaving exactly as documented", "label": {"api": {"documented": [[25, 34]]}}}, {"text": "getBytes converts each character to its character code in byte form; it doesn't parse out byte values from the string itself", "label": {"api": {"getBytes": [[0, 7]]}}}, {"text": "In my application this was not the problem because I was using GridBagLayout", "label": {"api": {"GridBagLayout": [[63, 75]]}}}, {"text": "I have a series of JComponents one of which was an extension of ImageScrollPane that did not have an empty border", "label": {"api": {"ImageScrollPane": [[64, 78]]}}}, {"text": "The usual way to read character data from an InputStream is to wrap it in a Reader", "label": {"api": {"Reader": [[76, 81]]}}}, {"text": "InputStreams are for binary data, Readers are for character data", "label": {"api": {"Reader": [[34, 39]]}}}, {"text": "The appropriate Reader to read from an InputStream is the aptly named InputStreamReader", "label": {"api": {"Reader": [[16, 21], [81, 86]], "InputStreamReader": [[70, 86]]}}}, {"text": "The hashCode of String is based on the content of the String (in a very specific way, documented in the documentation linked to above)", "label": {"api": {"The hashCode of String": [[0, 21]]}}}, {"text": "That is part of the contract for hashcode defined in Object", "label": {"api": {"in Object": [[50, 58]]}}}, {"text": "java.text.SimpleDateFormat will parse it", "label": {"api": {"java.text.SimpleDateFormat": [[0, 25]]}}}, {"text": "Using the standard API, you can use a ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[38, 62]]}}}, {"text": "Using the ExecutorCompletionService#take() method", "label": {"api": {"ExecutorCompletionService": [[10, 34]], "ExecutorCompletionService#take()": [[10, 41]]}}}, {"text": "If you need to do two different things with the same data, you're better off storing it somewhere (possibly copying it into two Queue<String>), and then reading it that way", "label": {"api": {"Queue<String>": [[128, 140]]}}}, {"text": "The class ThreadPoolManager should override the methods contextInitilized(ServletContextEvent) and contextDestroyed(ServletContextEvent)", "label": {"api": {"contextInitilized(ServletContextEvent)": [[56, 93]], "contextDestroyed(ServletContextEvent)": [[99, 135]]}}}, {"text": "The method contextInitilized(ServletContextEvent) gets invoked the web application initialization process is starting", "label": {"api": {"contextInitilized(ServletContextEvent)": [[11, 48]]}}}, {"text": "Similarly, the method contextDestroyed(ServletContextEvent) gets invoked when the servlet context is about to be shut down", "label": {"api": {"contextDestroyed(ServletContextEvent)": [[22, 58]]}}}, {"text": "If you really want to replace the Animal in the list with a whole new Animal, use List#set", "label": {"api": {"List#set": [[82, 89]]}}}, {"text": "To use List#set, you'll need to know the index of the Animal you want to replace", "label": {"api": {"List#set": [[7, 14]]}}}, {"text": "You can find that with List#indexOf", "label": {"api": {"List#indexOf": [[23, 34]]}}}, {"text": "It is called TemporaryQueue and it should be used as follows", "label": {"api": {"TemporaryQueue": [[13, 26]]}}}, {"text": "NoSuchElementException will be thrown if no more tokens are available", "label": {"api": {"if no more tokens are available": [[38, 68]]}}}, {"text": "This is caused by invoking nextInt() without checking if there's any integer available", "label": {"api": {"if there's any integer available": [[54, 85]]}}}, {"text": "this is not about creating a mock object; and ByteArrayInputStream is not an option either", "label": {"api": {"ByteArrayInputStream": [[46, 65]]}}}, {"text": "Before you start doing interactive console stuff with Java you should become familiar with the Console class and the readline to Java port", "label": {"api": {"Console": [[95, 101]]}}}, {"text": "StringBuilder is always faster, especially if you can predict the capacity well", "label": {"api": {"capacity": [[66, 73]]}}}, {"text": "Check SimpleDateFormat, it has a parse function", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "It does the following", "label": {"api": {"the following": [[8, 20]]}}}, {"text": "You don't necessarily need to make a class of your own for this - a map is also a possibility", "label": {"api": {"map": [[68, 70]]}}}, {"text": "If you use the standard Java preferences API (java.util.prefs.Preferences), you will see this in the registry on Windows", "label": {"api": {"java.util.prefs.Preferences": [[46, 72]]}}}, {"text": "Typically, I just use the userNodeForPackage method, since it does not require an admin on Windows", "label": {"api": {"userNodeForPackage": [[26, 43]]}}}, {"text": "How about just making a single ArrayList of type Point", "label": {"api": {"Point": [[49, 53]], "ArrayList": [[31, 39]]}}}, {"text": "An ArrayList will grow to the size of the content, so it should be as simple as doing something like this (psuedocode)..", "label": {"api": {"ArrayList": [[3, 11]]}}}, {"text": "The Point class is designed as a container for 2 double values, used to represent any abstract point, which should suit your need perfectly", "label": {"api": {"Point": [[4, 8]]}}}, {"text": "Refer to the Point documentation", "label": {"api": {"Point": [[13, 17]]}}}, {"text": "If you really need to use 2 arrays, my recommendation is to use an ArrayList<Double>..", "label": {"api": {"ArrayList": [[67, 75]]}}}, {"text": "Refer to the ArrayList documentation for more information about this", "label": {"api": {"ArrayList": [[13, 21]]}}}, {"text": "If you really need to use arrays, you can convert the ArrayList to an array like this..", "label": {"api": {"ArrayList": [[54, 62]]}}}, {"text": "catch the InvocationTargetException and then try exception.getCause()", "label": {"api": {"exception.getCause()": [[49, 68]]}}}, {"text": "Check after doing this whether you are getting NullPointerException or not", "label": {"api": {"NullPointerException": [[47, 66]]}}}, {"text": "for Java if you want to read a write a .jpg file then you should just use the ImageIO package and not worry about the specific representation", "label": {"api": {"ImageIO": [[78, 84]]}}}, {"text": "Take a look at Java Executors", "label": {"api": {"Java Executors": [[15, 28]]}}}, {"text": "In the Java 8+ Concurrency API you can set an explicit time for a lock to wait when it's condition is set", "label": {"api": {"Java 8+ Concurrency API": [[7, 29]]}}}, {"text": "In this case, HttpURLConnection links to a page on Networking Properties", "label": {"api": {"Networking Properties": [[51, 71]]}}}, {"text": "StreamTokenizer, examined here, may be worth profiling", "label": {"api": {"StreamTokenizer": [[0, 14]]}}}, {"text": "you can use stringPropertyNames() method , which return a Set keys", "label": {"api": {"stringPropertyNames()": [[12, 32]]}}}, {"text": "But remember that a call to stringPropertyNames() returns a Set which is un-ordered, this works only if your properties file is sorted", "label": {"api": {"stringPropertyNames()": [[28, 48]]}}}, {"text": "TrackContainer<T> is not a List - if you want to use Collections.sort(List,Comparator) on it, you should make it implements List<T> (and implement all interface methods, of course)", "label": {"api": {"Collections.sort(List,Comparator)": [[53, 85]]}}}, {"text": "What is Observer and Observable and when should we use them", "label": {"api": {"Observable": [[21, 30]], "Observer": [[8, 15]]}}}, {"text": "I wasn't aware of these terms, so when I got back home and started Googling about Observer and Observable, I found some points from different resources", "label": {"api": {"Observable": [[95, 104]], "Observer": [[82, 89]]}}}, {"text": "1) Observable is a class and Observer is an interface", "label": {"api": {"Observable": [[3, 12]], "Observer": [[29, 36]]}}}, {"text": "2) The Observable class maintains a list of Observers", "label": {"api": {"Observable": [[7, 16]], "Observer": [[44, 51]]}}}, {"text": "3) When an Observable object is updated, it invokes the update() method of each of its Observers to notify that, it is changed", "label": {"api": {"Observable": [[11, 20]], "Observer": [[87, 94]]}}}, {"text": "But I don't understand why we need Observer and Observable", "label": {"api": {"Observable": [[48, 57]], "Observer": [[35, 42]]}}}, {"text": "What are the setChanged() and notifyObservers(message) methods for", "label": {"api": {"Observer": [[36, 43]]}}}, {"text": "You could also use some of the class's from java.util.Concurrent package such as java.util.concurrent.CopyOnWriteArrayList which wouldn't throw ConcurrentModificationException when you modify the list while iterating", "label": {"api": {"java.util.Concurrent": [[44, 63]], "java.util.concurrent.CopyOnWriteArrayList": [[81, 121]]}}}, {"text": "You could create a new Seam component that is an EJB Session Bean and use a UserTransaction to perform your updates/inserts in batches", "label": {"api": {"UserTransaction": [[76, 90]]}}}, {"text": "UserTransaction also lets you specify the transaction timeout", "label": {"api": {"UserTransaction": [[0, 14]]}}}, {"text": "Check this version of Runtime.exec(String[] cmdarray)", "label": {"api": {"Check this version of Runtime.exec(String[] cmdarray)": [[0, 52]]}}}, {"text": "Have a look at nio documentation for more info", "label": {"api": {"nio documentation": [[15, 31]]}}}, {"text": "For more info, see the docs on Serializable", "label": {"api": {"Serializable": [[31, 42]]}}}, {"text": "To actually serialize the class, look at ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[41, 58]]}}}, {"text": "ProcessBuilder allows this, as do most of all APIs that spawn processes", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "If you use MouseListener to perform the task then this code might be helpful", "label": {"api": {"MouseListener": [[11, 23]]}}}, {"text": "Create a CustomMouseListener class and when ever click happens then just call the getSelectedData(..) method such that it will set the value to the JTextField", "label": {"api": {"MouseListener": [[15, 27]]}}}, {"text": "Have you read the API for JSONObject it defines the operations you will need", "label": {"api": {"JSONObject": [[26, 35]]}}}, {"text": "I therefore suggest you look at the JWindow documentation, which does exactly this", "label": {"api": {"JWindow": [[36, 42]]}}}, {"text": "For doing \"dumb\" serialization/deserialization of Java objects to/from XML, your best bet is to use the static methods of the javax.xml.bind.JAXB class", "label": {"api": {"javax.xml.bind.JAXB": [[126, 144]]}}}, {"text": "I strongly recommend you to use PreparedStatement rather than simple Statement to prevent SQL Injection", "label": {"api": {"PreparedStatement": [[32, 48]]}}}, {"text": "The interface was created in the Scene Builder and a FXML file (main.fxml) was created", "label": {"api": {"FXML": [[53, 56]]}}}, {"text": "To use the interface in my application I must load the FXML file using the FXMLLoader, but there is a problem because the load() method returns an Object, and to build a Scene I need an instance of Parent class", "label": {"api": {"FXML": [[55, 58], [75, 78]], "FXMLLoader": [[75, 84]]}}}, {"text": "Here is the FXML file (main.fxml)", "label": {"api": {"FXML": [[12, 15]]}}}, {"text": "To draw a rect use fillRect, it's quite self-explanatory if you take time to read the documentation", "label": {"api": {"fillRect": [[19, 26]]}}}, {"text": "Sockets are created by Socket Factories", "label": {"api": {"Socket Factories": [[23, 38]]}}}, {"text": "See the java api documentation for detailed information", "label": {"api": {"java api documentation": [[8, 29]]}}}, {"text": "I think Container.isAncestorOf (which JComponent inherits) will do what you want", "label": {"api": {"Container.isAncestorOf": [[8, 29]]}}}, {"text": "Put it in a File separated by line breaks and use a Scanner to read line by line, putting them into an array", "label": {"api": {"Scanner": [[52, 58]]}}}, {"text": "An example taken from Scanner documentation page", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "If it does not return the value you expect or desire, then you could always check the mime type based on the file extension of the uploaded file by ExternalContext#getMimeType()", "label": {"api": {"ExternalContext#getMimeType()": [[148, 176]]}}}, {"text": "The standard Java SE API offers the ZipFile constructor for this", "label": {"api": {"ZipFile": [[36, 42]]}}}, {"text": "If passport and flight_id are primary keys of their respectable entities, you can use getReference() to obtain a proxy object of required type with the given primary key", "label": {"api": {"getReference()": [[86, 99]]}}}, {"text": "Also note that if Passengers_Flights is just a link table without extra fields you can model the relationship between passengers and flights using @ManyToMany, without separate entity for the link table", "label": {"api": {"@ManyToMany": [[147, 157]]}}}, {"text": "Synchronization between master and workers can be achieved using Semaphore", "label": {"api": {"Semaphore": [[65, 73]]}}}, {"text": "The javadoc you link to, clearly states that it is an implementation of navigable and sorted map interfaces", "label": {"api": {"navigable": [[72, 80]], "sorted": [[86, 91]]}}}, {"text": "You can use BlockingQueue here", "label": {"api": {"BlockingQueue": [[12, 24]]}}}, {"text": "The <p:calendar> uses under the covers SimpleDateFormat which in turn uses by default lenient parsing, causing the overflowed values to roll over into the next date metric level", "label": {"api": {"SimpleDateFormat": [[39, 54]], "lenient": [[86, 92]]}}}, {"text": "In plain Java terms, this can be turned off by DateFormat#setLenient(), passing false", "label": {"api": {"DateFormat#setLenient()": [[47, 69]]}}}, {"text": "In JSF terms, you basically need to provide a custom converter which uses a non-lenient DateFormat", "label": {"api": {"lenient": [[80, 86]]}}}, {"text": "But he can send you the public key as a java.security.PublicKey", "label": {"api": {"java.security.PublicKey": [[40, 62]]}}}, {"text": "However, you may want to swallow any exceptions that occur during close", "label": {"api": {"close": [[66, 70]]}}}, {"text": "IOUtils.finallyClose() can be used to remove the need for the catch on close", "label": {"api": {"close": [[71, 75]]}}}, {"text": "Java doesn't quite have the concept of destructors, but it does have finalize() that get's call when an object is garbage collected", "label": {"api": {"finalize()": [[69, 78]]}}}, {"text": "You should never depend on finialize() to close or otherwise cleanup an object", "label": {"api": {"close": [[42, 46]]}}}, {"text": "Btw, Java 7 introduced a shorter syntax for closing objects that implement Closeable", "label": {"api": {"Closeable": [[75, 83]]}}}, {"text": "I expanded on finally..close", "label": {"api": {"close": [[23, 27]]}}}, {"text": "Also, I'm just curious, why is it that MOUSE_MOVED in MouseEvent is considered an int", "label": {"api": {"MOUSE_MOVED": [[39, 49]]}}}, {"text": "You're looking for the Class.isInstance() method", "label": {"api": {"Class.isInstance() method": [[23, 47]]}}}, {"text": "Because the SortedMap.keySet() specification tells it returns a Set object, it may not be safe to cast it to NavigableSet", "label": {"api": {"SortedMap.keySet()": [[12, 29]]}}}, {"text": "You're better off using a Comparator instead to encapsulate this particular comparation logic", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "You can do as many Comparator object as possible comparations you want to make or, as suggested, have the Comparator to compare based on a determined field", "label": {"api": {"Comparator": [[19, 28], [106, 115]]}}}, {"text": "Since the addShutdownHook method takes a Thread, each individual shutdown hook is its own Thread", "label": {"api": {"addShutdownHook": [[10, 24]]}}}, {"text": "Would ReentrantLock#tryLock() work for you", "label": {"api": {"ReentrantLock#tryLock()": [[6, 28]]}}}, {"text": "I think you're probably best off using java.util.concurrent.Semaphore", "label": {"api": {"java.util.concurrent.Semaphore": [[39, 68]]}}}, {"text": "For example, MouseAdapter provides corresponding empty methods for each listener method", "label": {"api": {"MouseAdapter": [[13, 24]]}}}, {"text": "I was trying to find a spinner component like JSpinner to use in my JavaFX application but there is no such component", "label": {"api": {"JSpinner": [[46, 53]]}}}, {"text": "Also, as others have mentioned, if you need values bigger than what long can support you should use BigInteger, which supports arbitrary precision", "label": {"api": {"BigInteger": [[100, 109]]}}}, {"text": "How do I set tab width of JavaFX TextArea", "label": {"api": {"TextArea": [[33, 40]]}}}, {"text": "When I use tabulation (tab key) in TextArea, the width of the tabulation is wide", "label": {"api": {"TextArea": [[35, 42]]}}}, {"text": "I tried this code (where taInput is a TextArea), but it is not working as it should", "label": {"api": {"TextArea": [[38, 45]]}}}, {"text": "You may want to use ConcurrentLinkedDeque, it offers getFirst() and getLast() methods", "label": {"api": {"ConcurrentLinkedDeque": [[20, 40]]}}}, {"text": "See javadoc to @return  of binarySearch", "label": {"api": {"javadoc to @return  of binarySearch": [[4, 38]]}}}, {"text": "You can use Arrays.fill to fill a one dimensional array but you'll have to loop for multi-dimensional arrays", "label": {"api": {"Arrays.fill": [[12, 22]]}}}, {"text": "Use Comparator for this issue", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "Assuming these objects are of type Foo which does not implement Comparable<Foo> but does have a method public int getBar(), you can pass your own Comparator<Foo> to Collections#sort() like so", "label": {"api": {"Comparator<Foo>": [[146, 160]], "Collections#sort()": [[165, 182]]}}}, {"text": "Note that Integer#compare(int, int) is only since Java 7", "label": {"api": {"Integer#compare(int, int) is only since Java 7": [[10, 55]]}}}, {"text": "Also using Random.nextInt instead of Math.random() will make it easier to keep within range based on the current size of the panel", "label": {"api": {"Random.nextInt": [[11, 24]]}}}, {"text": "If you're returning an object of an interface type, you can use Proxy.newProxyInstance to get an instance of an interface that dynamically sends method invocations to an InvocationHandler object which you can write to do whatever custom behavior you want", "label": {"api": {"Proxy.newProxyInstance": [[64, 85]], "InvocationHandler": [[170, 186]]}}}, {"text": "You want to look into the split() function in the String class, this will allow you to return an array of Strings split around a particular String or regex", "label": {"api": {"String": [[50, 55], [106, 111], [140, 145]]}}}, {"text": "You should throw an Exception and handle it in your main(), IllegakArgumentException is probably the best fit here", "label": {"api": {"IllegakArgumentException": [[60, 83]]}}}, {"text": "Try using a date formatter to format the time when the TV show starts", "label": {"api": {"date formatter": [[12, 25]]}}}, {"text": "Check out the javadocs for SwingUtilities.convertPointToScreen", "label": {"api": {"SwingUtilities.convertPointToScreen": [[27, 61]]}}}, {"text": "The documentation recommends using toString() instead of name() in most cases, but you have explicitly asked for the name here", "label": {"api": {"The documentation recommends using toString() instead of name() in most cases": [[0, 76]]}}}, {"text": "What you need is Arrays.sort() with two comparator", "label": {"api": {"Arrays.sort()": [[17, 29]]}}}, {"text": "You can create a new string by using String#substring(int idx)", "label": {"api": {"String#substring(int idx)": [[37, 61]]}}}, {"text": "The most obvious is a ReentrantLock with fairness set to true", "label": {"api": {"ReentrantLock": [[22, 34]]}}}, {"text": "Another is a Semaphore with a single permit and fairness set to true", "label": {"api": {"Semaphore": [[13, 21]]}}}, {"text": "See the Instrumentation API", "label": {"api": {"Instrumentation API": [[8, 26]]}}}, {"text": "This answer just provides sample code (base on zonski's forum post) for a Timeline approach to modifying a css style", "label": {"api": {"Timeline": [[74, 81]]}}}, {"text": "You may use vecmath for vector operations", "label": {"api": {"vecmath": [[12, 18]]}}}, {"text": "The formats it supports by default are given by AudioSystem.getAudioFileTypes() & that list will not include MP3", "label": {"api": {"AudioSystem.getAudioFileTypes()": [[48, 78]]}}}, {"text": "The easiest way to do this is to fill an array list with the numbers in sequence, and then use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[95, 115]]}}}, {"text": "And from what I see, it is definetely not included in the java.util package (java 6 util, java 7 util)", "label": {"api": {"java 6 util": [[77, 87]], "java 7 util": [[90, 100]]}}}, {"text": "Use String.replace() instead of String.replaceAll()", "label": {"api": {"String.replace()": [[4, 19]], "String.replaceAll()": [[32, 50]]}}}, {"text": "String.replaceAll() uses Regular Expression, while String.replace() uses plain text", "label": {"api": {"String.replace()": [[51, 66]], "String.replaceAll()": [[0, 18]]}}}, {"text": "replaceAll takes a regular expression, and", "label": {"api": {"replace": [[0, 6]]}}}, {"text": "You should use replace in this case, since you don't need a regex", "label": {"api": {"replace": [[15, 21]]}}}, {"text": "longstring = longstring.replace(..), notice the assignment", "label": {"api": {"replace": [[24, 30]]}}}, {"text": "Instead, execute it from within a new thread or a SwingWorker", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "Read this answer to know more about SwingWorker", "label": {"api": {"SwingWorker": [[36, 46]]}}}, {"text": "Your class with given entry (i think, that Entry is that class) must implements Comparable interface", "label": {"api": {"Comparable": [[80, 89]]}}}, {"text": "Order is given by natural ordering (it's up to you to make your own order in implemented method of Comparable interface)", "label": {"api": {"Comparable": [[99, 108]]}}}, {"text": "You need to override the method paintComponent(Graphics g) of JPanel and use drawImage() on the Graphics object g as in this example", "label": {"api": {"paintComponent(Graphics g)": [[32, 57]], "JPanel": [[62, 67]], "drawImage()": [[77, 87]], "Graphics": [[47, 54], [96, 103]]}}}, {"text": "Your getElementValue method can probably be replace by a simple call to elem.getTextContent()", "label": {"api": {"elem.getTextContent()": [[72, 92]]}}}, {"text": "In an AWT application, whenever you want to draw, you generally create a subclass of Canvas overriding the paint(Graphics) method", "label": {"api": {"Canvas": [[85, 90]], "paint(Graphics)": [[107, 121]]}}}, {"text": "See Java AWT Canvas  Freelance Drawing for an example", "label": {"api": {"Canvas": [[13, 18]]}}}, {"text": "One exception to this is a Graphics reference obtained from BufferedImages (a so-called software graphics context)", "label": {"api": {"BufferedImages": [[60, 73]]}}}, {"text": "Instead of using an array to hold a node's children, use a variable-sized List implementation, like ArrayList or LinkedList", "label": {"api": {"ArrayList": [[100, 108]], "LinkedList": [[113, 122]]}}}, {"text": "Your image is drawn with dimensions", "label": {"api": {"drawn": [[14, 18]]}}}, {"text": "Maybe this needs a JRadioButtonMenuItem given the user will be drawing one of the elements at a time  (e.g", "label": {"api": {"JRadioButtonMenuItem": [[19, 38]]}}}, {"text": "JRadioButtonMenuItem has an accelerator", "label": {"api": {"JRadioButtonMenuItem": [[0, 19]]}}}, {"text": "Use Shape.contains(Point2D) - something like this", "label": {"api": {"Shape.contains(Point2D)": [[4, 26]]}}}, {"text": "But the kind of map you are referring to will probably be made of a number of GeneralPath objects (one for each country) that do not overlap", "label": {"api": {"GeneralPath": [[78, 88]]}}}, {"text": "You would need to use a Highlighter for that", "label": {"api": {"Highlighter": [[24, 34]]}}}, {"text": "One of the things to note is what String.split() returns - it gives you back an array of String, which you do correctly note", "label": {"api": {"String.split()": [[34, 47]]}}}, {"text": "Recall what Scanner.next() actually does - you would be best served creating local variables to hold either the String or the split String[]", "label": {"api": {"Scanner.next()": [[12, 25]]}}}, {"text": "You cannot do this with synchronized methods or blocks but you can do it using java.util.concurrent.locks.Lock interface instead", "label": {"api": {"java.util.concurrent.locks.Lock": [[79, 109]]}}}, {"text": "You can also use String.getChars()", "label": {"api": {"String.getChars()": [[17, 33]]}}}, {"text": "In general you should use executeUpdate for UPDATE, INSERT and DELETE", "label": {"api": {"executeUpdate": [[26, 38]]}}}, {"text": "Also I'd advise you to follow the JDBC Basics Tutorial and check the Javadocs of the classes in the package java.sql (for better usability go to http://docs.oracle.com/javase/7/docs/api/ and select java.sql in the top-left frame)", "label": {"api": {"package java.sql": [[100, 115]], "http://docs.oracle.com/javase/7/docs/api/": [[145, 185]]}}}, {"text": "One way to handle this is to use a latch if this is a one off operation or a CyclicBarrier if this needs to be repeated", "label": {"api": {"latch": [[35, 39]], "CyclicBarrier": [[77, 89]]}}}, {"text": "On MacOS, you can use the FileDialog which looks like what you are describing", "label": {"api": {"FileDialog": [[26, 35]]}}}, {"text": "Date.getTime returns milliseconds, not seconds", "label": {"api": {"Date.getTime": [[0, 11]]}}}, {"text": "You're getting this error because Calendar#add() method doesn't return anything (see void) and adds the input date/month/year etc in the supplied Calendar instance itself", "label": {"api": {"Calendar#add()": [[34, 47]]}}}, {"text": "Process.waitFor() gives you the exit code of the spawned process, and is likely returning a non-zero (i.e", "label": {"api": {"Process.waitFor()": [[0, 16]]}}}, {"text": "Why don't you use Runtime.exec(String[] args) which takes multiple arguments", "label": {"api": {"Runtime.exec(String[] args)": [[18, 44]]}}}, {"text": "Otherwise, I guess you could use a proxy servlet in www.abc.com that proxies the call to the getRemoteAddr, assuming there's no proxy in-between", "label": {"api": {"getRemoteAddr": [[93, 105]]}}}, {"text": "You should consider using List#sublist() instead of clone(), or even adding parameters to your method to pass down indexes towards a single set of initial List objects", "label": {"api": {"List#sublist()": [[26, 39]]}}}, {"text": "Use Graphics.setColor() to change the color of anything you do", "label": {"api": {"Graphics.setColor()": [[4, 22]]}}}, {"text": "You could convert the Integer-array to a byte buffer using the ByteBuffer class", "label": {"api": {"ByteBuffer": [[63, 72]]}}}, {"text": "MessageDigest.getInstance is a factory method rather than a singleton so has significant overhead attached", "label": {"api": {"MessageDigest.getInstance": [[0, 24]]}}}, {"text": "So better to re-use and avoid the overhead of calling MessageDigest.getInstance again", "label": {"api": {"MessageDigest.getInstance": [[54, 78]]}}}, {"text": "You would generally use this type with a Transformer", "label": {"api": {"Transformer": [[41, 51]]}}}, {"text": "In Java 7 you can use a ZipFile(File, Charset) indicating the character encoding", "label": {"api": {"ZipFile(File, Charset)": [[24, 45]]}}}, {"text": "The best was is to not use Thread directly, but instead use a Future", "label": {"api": {"Future": [[62, 67]]}}}, {"text": "you can run a FutureTask via a Thread if you desire, or get a Future by submitting a Callable to an Executor (the preferred method)", "label": {"api": {"Future": [[14, 19], [62, 67]], "FutureTask": [[14, 23]]}}}, {"text": "the Future gives you a convenient way to wait for the task to complete and to deal with the results (regular or exceptional)", "label": {"api": {"Future": [[4, 9]]}}}, {"text": "Note that for portability, you need to use PortableRemoteObject.narrow on the return value of ctx.lookup before casting to the target interface", "label": {"api": {"PortableRemoteObject.narrow": [[43, 69]]}}}, {"text": "Finding a value (contains) in HashSet is a constant-time operation (O(1)) on average, which is better than a List, where contains is linear (O(n))", "label": {"api": {"HashSet": [[30, 36]]}}}, {"text": "Also, if you use a Set, you get a guarantee that each value is unique, so if you try to add a value that already exists, add will return false", "label": {"api": {"add a value that already exists, add will return false": [[88, 141]]}}}, {"text": "This will not work if you use a List, because add always returns true on a List)", "label": {"api": {"add always returns true on a List": [[46, 78]]}}}, {"text": "Here's a way to do that using TreeSet", "label": {"api": {"TreeSet": [[30, 36]]}}}, {"text": "Set::add returns a boolean indicating whether the addition modified the set; we can use that as the return value from the method", "label": {"api": {"Set::add": [[0, 7]]}}}, {"text": "NavigableSet is an obscure but standard subinterface of SortedSet which is sadly neglected", "label": {"api": {"NavigableSet": [[0, 11]], "SortedSet": [[56, 64]]}}}, {"text": "Although you could actually use a plain SortedSet here with only minor modifications", "label": {"api": {"SortedSet": [[40, 48]]}}}, {"text": "The NavigableSet::subSet method (like SortedSet::subSet) returns a lightweight view on the underlying set which is restricted to a given range", "label": {"api": {"NavigableSet": [[4, 15]], "SortedSet": [[38, 46]], "NavigableSet::subSet": [[4, 23]], "SortedSet::subSet": [[38, 54]]}}}, {"text": "It would be possible to make a version which ran in O(m) by writing an implementation of SortedSet which described a range of integers and then using Set::addAll, because TreeSet's implementation of this contains a special case for adding other SortedSets in linear time", "label": {"api": {"TreeSet": [[171, 177]], "Set::add": [[150, 157]], "SortedSet": [[89, 97], [245, 253]], "Set::addAll": [[150, 160]]}}}, {"text": "If going that route, check out the Java 5+ ExecutorService and related classes", "label": {"api": {"ExecutorService": [[43, 57]]}}}, {"text": "You can create a new String array or List<String> wiht the file names only, using the getName() method from the File class", "label": {"api": {"getName()": [[86, 94]], "File": [[112, 115]]}}}, {"text": "You can use Utilities.getRowStart to determine the 'start' of the line for a JTextPane giving you a resulting lineCount", "label": {"api": {"Utilities.getRowStart": [[12, 32]]}}}, {"text": "It seems you're looking for Executors.newSingleThreadScheduledExecutor()", "label": {"api": {"Executors.newSingleThreadScheduledExecutor()": [[28, 71]]}}}, {"text": "If you need (almost) real time notifications, check out JMS (and especially topics)", "label": {"api": {"topics": [[76, 81]]}}}, {"text": "Use TemporalType.TIMESTAMP, which corresponds to a java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[51, 68]]}}}, {"text": "As per the TemporalType JavaDocs, TemporalType.DATE maps to a java.sql.Date, which as you're seeing as no time component", "label": {"api": {"the TemporalType JavaDocs": [[7, 31]], "java.sql.Date": [[62, 74]]}}}, {"text": "To conform with the definition of SQL DATE, the millisecond values wrapped by a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero in the particular time zone with which the instance is associated", "label": {"api": {"java.sql.Date": [[80, 92]]}}}, {"text": "If you're looking to pass in a specific day, take a look at the Calendar class, or better yet, Joda Time", "label": {"api": {"Calendar": [[64, 71]]}}}, {"text": "The behaviour in this case is described in the section Comparison to Perl 5 of the Pattern api", "label": {"api": {"Comparison to Perl 5": [[55, 74]]}}}, {"text": "You could use Window#setImageIcons(List<Image>) which allows you to supply a series of different sized, which allows the underlying platform to choose a icon that is best suited to the platform and look and feel..", "label": {"api": {"Window#setImageIcons(List<Image>)": [[14, 46]]}}}, {"text": "More info on these methods here - File - JavaDoc", "label": {"api": {"File - JavaDoc": [[34, 47]]}}}, {"text": "You must check for errors explicitly using the ioException() method", "label": {"api": {"ioException()": [[47, 59]]}}}, {"text": "If the problem is an encoding error you need to pass the encoding of the file explicitly when you instantiate the scanner", "label": {"api": {"pass the encoding of the file explicitly": [[48, 87]]}}}, {"text": "If the file is a corrupt text file, you may need to provide your own reader that does more fault-tolerant decoding", "label": {"api": {"your own reader": [[60, 74]]}}}, {"text": "From the docs for the Swing Timer", "label": {"api": {"Timer": [[28, 32]]}}}, {"text": "Although all Timers perform their waiting using a single, shared thread (created by the first Timer object that executes), the action event handlers for Timers execute on another thread -- the event-dispatching thread", "label": {"api": {"Timer": [[13, 17], [94, 98], [153, 157]]}}}, {"text": "This means that the action handlers for Timers can safely perform operations on Swing components", "label": {"api": {"Timer": [[40, 44]]}}}, {"text": "You could add a shutdown hook", "label": {"api": {"shutdown hook": [[16, 28]]}}}, {"text": "If you want to load classes yourself, and be able to use SM you should extend SecureClassLoader", "label": {"api": {"SecureClassLoader": [[78, 94]]}}}, {"text": "In which you should provide a CodeSource for your class", "label": {"api": {"CodeSource": [[30, 39]]}}}, {"text": "Which will return PermissionCollection for classes from given CodeSource", "label": {"api": {"CodeSource": [[62, 71]]}}}, {"text": "The methods would take an instance of StringBuilder or StringBuffer (or perhaps even Appendable if you can implement your functionality in terms of Appendable)", "label": {"api": {"Appendable": [[85, 94], [148, 157]]}}}, {"text": "It's unfortunate that you can't implement an interface representing StringBuilder (unless Appendable is suitable?)", "label": {"api": {"Appendable": [[90, 99]]}}}, {"text": "As per the SwingWorker documentation (http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingWorker.html#execute())", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingWorker.html#execute()": [[38, 116]]}}}, {"text": "Why not use String#contains instead of regex here", "label": {"api": {"String#contains": [[12, 26]]}}}, {"text": "If I have understood your question correctly You can use Future and then you can call get with timeout", "label": {"api": {"Future": [[57, 62]], "get": [[86, 88]]}}}, {"text": "Note get is blocking call and it throws TimeoutException if wait timed out", "label": {"api": {"get": [[5, 7]]}}}, {"text": "Since Comparable exports only one function and since that function accepts only one parameter that is of type \"this\" (The class that implements Comparable), why is Comparable parameterized", "label": {"api": {"Comparable": [[6, 15], [144, 153], [164, 173]], "that function": [[53, 65]]}}}, {"text": "Given that Comparable is used for natural ordering, why would anyone pass a class different from the one that implements this interface", "label": {"api": {"Comparable": [[11, 20]]}}}, {"text": "You may need to use SimpleDatFormat (or) Joda library", "label": {"api": {"SimpleDatFormat": [[20, 34]]}}}, {"text": "So, you look at the Javadoc for the deprecated method which specifies", "label": {"api": {"Javadoc for the deprecated method": [[20, 52]]}}}, {"text": "As of JDK version 1.1, replaced by DateFormat.parse(String s)", "label": {"api": {"DateFormat.parse": [[35, 50]]}}}, {"text": "You then look up DateFormat.parse and proceed accordingly", "label": {"api": {"DateFormat.parse": [[17, 32]]}}}, {"text": "You can't place nodes in a Canvas as it is not Parent, therefore it is a leaf Node and can have no children", "label": {"api": {"Canvas": [[27, 32]], "Parent": [[47, 52]], "Node": [[78, 81]]}}}, {"text": "You could place the Canvas in a Group then add other Nodes to the group to overlay the Canvas", "label": {"api": {"Canvas": [[20, 25], [87, 92]], "Node": [[53, 56]], "Group": [[32, 36]]}}}, {"text": "Or you could take snapshot images of nodes and place the snapshots in the canvas", "label": {"api": {"snapshot": [[18, 25], [57, 64]]}}}, {"text": "What you need is java.io.File", "label": {"api": {"java.io.File": [[17, 28]]}}}, {"text": "The Java String.hashcode() makes a tradeoff between being a really good hash function and being as efficient as possible", "label": {"api": {"String.hashcode()": [[9, 25]]}}}, {"text": "The error is quite ObviousJframe.add(Component) expects a java.awt.Component as an argument and you are passing a Square to it, thus the error", "label": {"api": {"Jframe.add(Component)": [[26, 46]], "java.awt.Component": [[58, 75]]}}}, {"text": "Have a look at KeyGenerator and SecretKey", "label": {"api": {"KeyGenerator": [[15, 26]], "SecretKey": [[32, 40]]}}}, {"text": "Have a look at SecretKeyFactory and DESKeySpec", "label": {"api": {"SecretKeyFactory": [[15, 30]], "DESKeySpec": [[36, 45]]}}}, {"text": "You can get the key material from a DES key using getEncoded()", "label": {"api": {"getEncoded()": [[50, 61]]}}}, {"text": "You can make use of StringBuilder#reverse() method like this", "label": {"api": {"StringBuilder#reverse()": [[20, 42]]}}}, {"text": "Use an InputStreamReader, which knows how to interpret sequences of bytes using a given encoding", "label": {"api": {"InputStreamReader": [[7, 23]]}}}, {"text": "To convert a hex string to an int, you could simply use Integer.parseInt(str, 16)", "label": {"api": {"Integer.parseInt(str, 16)": [[56, 80]]}}}, {"text": "The WriteAbortedException API describes the issue rather well", "label": {"api": {"WriteAbortedException API": [[4, 28]]}}}, {"text": "Instead of using integer comparisons, the algorithm would need to use String.compareTo() and compare the result to zero", "label": {"api": {"String.compareTo()": [[70, 87]]}}}, {"text": "It sounds like you are looking for a ConcurrentHashMap but without a little more detail it is difficult to tell", "label": {"api": {"ConcurrentHashMap": [[37, 53]]}}}, {"text": "Use the ae.getSource() method to get the button object itself", "label": {"api": {"ae.getSource()": [[8, 21]]}}}, {"text": "Another approach is to make x a BigDecimal, where you can specify that you want a particular precision", "label": {"api": {"BigDecimal": [[32, 41]]}}}, {"text": "See JavaSE Manual", "label": {"api": {"JavaSE Manual": [[4, 16]]}}}, {"text": "Use String.format(...), maybe that helps (if I understood your question)", "label": {"api": {"String.format(...)": [[4, 21]]}}}, {"text": "You convert your arrays to a List using the method Arrays.asList, and use the method contains to verify if the word of the first file is on the second file", "label": {"api": {"Arrays.asList": [[51, 63]]}}}, {"text": "I would just use a java.util.Properties - that's exactly what it was designed for", "label": {"api": {"java.util.Properties": [[19, 38]]}}}, {"text": "You may reuse threads if you want, see SwingWorker and ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[55, 72]]}}}, {"text": "URLClassLoader appeared to offer salvation", "label": {"api": {"URLClassLoader": [[0, 13]], "URL": [[0, 2]]}}}, {"text": "It only accepts an array of URL objects", "label": {"api": {"URL": [[28, 30]]}}}, {"text": "So I tried to subclass URL to override its openConnection method to return my class bytes that way, but the URL class is final", "label": {"api": {"URL": [[23, 25], [108, 110]]}}}, {"text": "Then I tried creating a custom URLStreamHandler with an overridden openConnection method and passing it to the constructor of a URL", "label": {"api": {"URL": [[31, 33], [128, 130]], "URLStreamHandler": [[31, 46]]}}}, {"text": "So then I tried calling URL.setStreamHandlerFactory with a custom factory that would return my custom stream handler", "label": {"api": {"URL": [[24, 26]]}}}, {"text": "So then I tried creating a javax.management.loading.MLet", "label": {"api": {"javax.management.loading.MLet": [[27, 55]]}}}, {"text": "I have no clue what it's for but it's a subclass of URLClassLoader that allows specifying a custom URLStreamHandlerFactory in its constructor and doesn't mention throwing a security exception, but it still did anyway", "label": {"api": {"URLClassLoader": [[52, 65]], "URL": [[52, 54], [99, 101]], "URLStreamHandler": [[99, 114]]}}}, {"text": "In desperation I tried calling ProxySelector.setDefault with a custom ProxySelector, hoping to incercept a URL and somehow route it back into my applet, but I don't have permission for that either", "label": {"api": {"URL": [[107, 109]], "ProxySelector": [[31, 43], [70, 82]]}}}, {"text": "Finally, the only remaining way I can think of to do this is to send my class bytes up to a remote server that will generate a temporary URL that I can use in conjunction with URLClassLoader.newInstance(URL[])", "label": {"api": {"URLClassLoader": [[176, 189]], "URL": [[137, 139], [176, 178], [203, 205]]}}}, {"text": "Apparently the SecurityManager is only too happy to let you create a URLClassLoader, but gets spontaneously upset when you try to use it", "label": {"api": {"URLClassLoader": [[69, 82]], "URL": [[69, 71]]}}}, {"text": "If the SecurityManager is happy about loading classes from arbitrary external URLs it shouldn't mind loading one from a byte array in a local variable", "label": {"api": {"URL": [[78, 80]]}}}, {"text": "The change I would make would be to use an AtomicReference since this is obviously multi-threaded and you wouldn't have to write your own wrapper", "label": {"api": {"AtomicReference": [[43, 57]]}}}, {"text": "Btw Onetomany mappings are lazy by default", "label": {"api": {"Onetomany": [[4, 12]]}}}, {"text": "I am having the hardest time trying to fix an ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[46, 75]]}}}, {"text": "You'll need to get the Bomb using next", "label": {"api": {"next": [[34, 37]]}}}, {"text": "This can easily be done with a LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[31, 49]]}}}, {"text": "AtomicInteger is what you are looking for", "label": {"api": {"AtomicInteger": [[0, 12]]}}}, {"text": "Using AtomicInteger does what you want, and it makes explicit the intent to have operations on x be atomic", "label": {"api": {"AtomicInteger": [[6, 18]]}}}, {"text": "AudioSystem.getAudioInputStream has an overloaded method that takes a URL", "label": {"api": {"overloaded method": [[39, 55]]}}}, {"text": "You need to URL encode the string", "label": {"api": {"URL encode": [[12, 21]]}}}, {"text": "No, ArrayList is an implementation of the List interface that uses a backing array to store the data", "label": {"api": {"ArrayList": [[4, 12]], "List": [[9, 12], [42, 45]]}}}, {"text": "It sounds like the assignment wants you to write your own singly-linked List implementation", "label": {"api": {"List": [[72, 75]]}}}, {"text": "You can use a java.util.Formatter or the printf method on a PrintStream", "label": {"api": {"java.util.Formatter": [[14, 32]], "the printf method": [[37, 53]]}}}, {"text": "From formatting syntax documented on Java's Formatter class", "label": {"api": {"Formatter": [[44, 52]]}}}, {"text": "Use a Scanner", "label": {"api": {"Scanner": [[6, 12]]}}}, {"text": "Use Collections.sort, which is able to sort any List", "label": {"api": {"Collections.sort": [[4, 19]]}}}, {"text": "I'm assuming that you're talking about a list of strings, in which case you can simply call Collections.sort on your list to sort it alphabetically", "label": {"api": {"Collections.sort": [[92, 107]]}}}, {"text": "Have the class implement the Comparable interface, then call Collections.sort on the list with no arguments other than the list itself", "label": {"api": {"Collections.sort": [[61, 76]], "Comparable": [[29, 38]]}}}, {"text": "Write a custom Comparator that works with your class, and pass an instance of it to the sort method as a second argument along with your list", "label": {"api": {"Comparator": [[15, 24]]}}}, {"text": "If alphabetical ordering is the 'natural' way in which instances of your class should be ordered, you should probably implement Comparable", "label": {"api": {"Comparable": [[128, 137]]}}}, {"text": "If not, you should probably write a Comparator", "label": {"api": {"Comparator": [[36, 45]]}}}, {"text": "Reference its interface CachedRowSet not the implementation", "label": {"api": {"CachedRowSet": [[24, 35]]}}}, {"text": "As a simple diagnostic tool, I frequently swap out the JVM's ThreadMXBean with a wrapped one that exposes ThreadInfos using this technique", "label": {"api": {"ThreadMXBean": [[61, 72]], "ThreadInfo": [[106, 115]]}}}, {"text": "and use the servlet request method ServletRequest.getParameter() to extract the values", "label": {"api": {"ServletRequest.getParameter()": [[35, 63]]}}}, {"text": "Note that ServletRequest.getRemoteAddr() gives you the client address", "label": {"api": {"ServletRequest.getRemoteAddr()": [[10, 39]]}}}, {"text": "Instead look to the JOptionPane methods that start with 'showInternal..'", "label": {"api": {"JOptionPane methods": [[20, 38]]}}}, {"text": "Thus kind of method adds no value - you should just call the replace() method of String directly", "label": {"api": {"replace()": [[61, 69]]}}}, {"text": "You could make your program open a dummy file for writing with a FileWriter when your program starts, and keep the file open until the program is finished", "label": {"api": {"FileWriter": [[65, 74]]}}}, {"text": "When you now start a second instance of your program, it will also try to open this file for writing, which will throw an IOException, because only one process can have a write handle to a file at the same time", "label": {"api": {"IOException": [[122, 132]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/javax/swing/JOptionPane.html for more details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/JOptionPane.html": [[4, 72]]}}}, {"text": "You can limit the max size by using a DocumentFilter, check this documentation section, it has a working example of what you need", "label": {"api": {"DocumentFilter": [[38, 51]]}}}, {"text": "In http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html#execute%28java.lang.String,%20int%29 it is said that it may throw only java.sql.SQLException", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html#execute%28java.lang.String,%20int%29": [[3, 103]]}}}, {"text": "Also, Graphics2D.rotate expects radians, not degrees", "label": {"api": {"Graphics2D.rotate": [[6, 22]]}}}, {"text": "Instead (for example) you could specify the encoding directly by converting the string to bytes yourself using a specified encoding (see String.getBytes for an example)", "label": {"api": {"String.getBytes": [[137, 151]]}}}, {"text": "The numbers you're seeing are the hash codes of the array objects", "label": {"api": {"hash codes of the array objects": [[34, 64]]}}}, {"text": "To see the contents of the arrays, use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[39, 55]]}}}, {"text": "Use a data structure to know if a character has already been found, such as a Set", "label": {"api": {"Set": [[78, 80]]}}}, {"text": "You can, for instance, use its add() method and check its return value", "label": {"api": {"add()": [[31, 35]]}}}, {"text": "Also, you might consider using StringBuilder for repetitive concatenation, it's much more efficient", "label": {"api": {"StringBuilder": [[31, 43]]}}}, {"text": "use the java.util.UUID class", "label": {"api": {"java.util.UUID": [[8, 21]]}}}, {"text": "There are loads of options in SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[30, 45]]}}}, {"text": "I think what you are looking for is the setCharAt method", "label": {"api": {"setCharAt": [[40, 48]]}}}, {"text": "The only solution I currently have is poll each small milliseconds, get heap + non-heap memory using getHeapMemoryUsage() and getNonHeapMemoryUsage() from MemoryMXBean, and check whether it has exceeded the limit", "label": {"api": {"MemoryMXBean": [[155, 166]]}}}, {"text": "To find out how much memory your process is using get the CommittedVirutalMemorySize attribute from ManagementFactory.getOperatingSystemMXBean() (but there's not a getter for it)", "label": {"api": {"ManagementFactory.getOperatingSystemMXBean()": [[100, 143]]}}}, {"text": "I am not sure why DataInputStream is not working, I suggest to use Scanner for getting input from console in getUserInfo method", "label": {"api": {"Scanner": [[67, 73]]}}}, {"text": "You can mitigate that by preallocating it to be the size (or larger) you expect using the constructor that accepts an initialCapacity", "label": {"api": {"constructor that accepts an initialCapacity": [[90, 132]]}}}, {"text": "anyways, quick way to implement parallel processing is to start an ExecutorService and submit it a Runnable with file path as a parameter", "label": {"api": {"ExecutorService": [[67, 81]]}}}, {"text": "The best I've found is that SwingWorker seems to do this, but I can't find out how", "label": {"api": {"SwingWorker": [[28, 38]]}}}, {"text": "A class should be created as a Servlet extending the HttpServlet class", "label": {"api": {"HttpServlet": [[53, 63]]}}}, {"text": "Take a look at ByteBuffer#allocateDirect(int)", "label": {"api": {"ByteBuffer#allocateDirect(int)": [[15, 44]]}}}, {"text": "Use BorderLayout and add the top panel to NORTH and the scroll pane to the CENTER", "label": {"api": {"BorderLayout": [[4, 15]]}}}, {"text": "I think you want List#indexOf", "label": {"api": {"List#indexOf": [[17, 28]]}}}, {"text": "In order to do that, you have to create a Process object using a ProcessBuilder", "label": {"api": {"Process": [[42, 48], [65, 71]], "ProcessBuilder": [[65, 78]]}}}, {"text": "Why is there no isCancelled method for a java.util.Timer object", "label": {"api": {"java.util.Timer": [[41, 55]]}}}, {"text": "Use ExecutorService instead, which has isShutdown and has a slew of other benefits to boot", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "A general recommendation as of Java 5 has been to replace Timers with ExecutorServices", "label": {"api": {"ExecutorService": [[70, 84]]}}}, {"text": "There's a ScheduledExecutorService interface specifically for scheduled executor services", "label": {"api": {"ExecutorService": [[19, 33]]}}}, {"text": "You can write bytecode from Java by using some of the libraries out there like ASM, but my suggestion is to use the ScriptEngine (Java 6+) interface to use JavaScript or some other sccripting language to execute your maths", "label": {"api": {"ScriptEngine": [[116, 127]]}}}, {"text": "Install a SecurityManager1 for the user code", "label": {"api": {"SecurityManager": [[10, 24]]}}}, {"text": "All exceptions in Java must subclass java.lang.Throwable, and although it may not be good practice, you can catch every type of exception like so", "label": {"api": {"java.lang.Throwable": [[37, 55]]}}}, {"text": "See the java.lang.Throwable documentation for more information", "label": {"api": {"java.lang.Throwable": [[8, 26]]}}}, {"text": "You should create your FileWriter using the contructor that takes an extra boolean argument, that indicates that you want to append", "label": {"api": {"the contructor that takes an extra boolean argument": [[40, 90]]}}}, {"text": "Use setSoTimeout(), and catch SocketTimeoutException instead", "label": {"api": {"setSoTimeout()": [[4, 17]]}}}, {"text": "You can retrieve the list of attributes defined for a UIComponent using getAttributes()", "label": {"api": {"UIComponent": [[54, 64]]}}}, {"text": "UIComponent - See getAttributes method", "label": {"api": {"UIComponent": [[0, 10]]}}}, {"text": "java.util.Map - Javadoc for Map class", "label": {"api": {"java.util.Map": [[0, 12]]}}}, {"text": "The reason that selection is in the order Orange, Pear is that the DefaultListSelectionModel calls fireValueChanged solely based on the items index location in the ListModel rather than the new selection index", "label": {"api": {"fireValueChanged": [[99, 114]]}}}, {"text": "You can use the deepToString method", "label": {"api": {"deepToString": [[16, 27]]}}}, {"text": "TreeSet is implemented that way because you can alternatively provide a Comparator, in which case the elements don't need to be Comparable", "label": {"api": {"alternatively provide": [[48, 68]], "Comparator": [[72, 81]], "Comparable": [[128, 137]]}}}, {"text": "READ the javadoc and pay attention to methods starting with remove http://docs.oracle.com/javase/6/docs/api/java/util/Vector.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Vector.html": [[67, 128]]}}}, {"text": "Add a MouseListener to the canvas, and in the mouseClicked() method of the listener, change the state of the objects painted by the canvas, and call the canvas repaint() method in order for the canvas to repaint itself, based on the modified state", "label": {"api": {"Add a MouseListener": [[0, 18]]}}}, {"text": "Checkout JDialog and the swing tutorial about dialogs", "label": {"api": {"JDialog": [[9, 15]]}}}, {"text": "Replace HashMap with LinkedHashMap which additionally remembers the order of insertion", "label": {"api": {"LinkedHashMap": [[21, 33]]}}}, {"text": "As Dave suggested, a DateFormat is definitely the way to go here", "label": {"api": {"DateFormat": [[21, 30]]}}}, {"text": "For what you want to do, a SimpleDateFormat will do the trick", "label": {"api": {"DateFormat": [[33, 42]], "SimpleDateFormat": [[27, 42]]}}}, {"text": "If you're starting your java program from within a terminal then, after you've called exec() on the runtime, and get a Process you need to call the getInputStream() to read the output of the command, then you can print it out to System.out", "label": {"api": {"a Process": [[117, 125]]}}}, {"text": "I haven't tried it but from clicking through the API SecretKeySpec could be what you are looking for", "label": {"api": {"SecretKeySpec": [[53, 65]]}}}, {"text": "You can also make your DirectoryNode implement the Iterable interface so you can use the foreach loop", "label": {"api": {"Iterable": [[51, 58]]}}}, {"text": "Take a look at this link http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html": [[25, 96]]}}}, {"text": "Yes - you can use System.arraycopy instead of the inner loop", "label": {"api": {"System.arraycopy": [[18, 33]]}}}, {"text": "Try to use a List or any other ordered data structure - it'll solve your problem", "label": {"api": {"List": [[13, 16]]}}}, {"text": "This what the API docs for java.util.HashMap says", "label": {"api": {"java.util.HashMap": [[27, 43]]}}}, {"text": "You can use Timer and TimerTask", "label": {"api": {"Timer": [[12, 16], [22, 26]], "TimerTask": [[22, 30]]}}}, {"text": "I've tried to catch key events via ComboBox.setOnKeyPressed() and event.consume() but without success", "label": {"api": {"ComboBox.setOnKeyPressed()": [[35, 60]], "event.consume()": [[66, 80]]}}}, {"text": "Painful as it is, the Preferences API, Preferences.systemNodeForPackage, seems the wisest alternative, if there is little structured config data", "label": {"api": {"Preferences.systemNodeForPackage": [[39, 70]]}}}, {"text": "The point of ForkJoinTasks is to execute them within a ForkJoinPool", "label": {"api": {"ForkJoinPool": [[55, 66]]}}}, {"text": "Additionally, instantiating 100 threads yourself with new introduces a lot of overhead - though I appreciate this is just a toy example, a more efficient way to do this would be to use a Java thread pool", "label": {"api": {"Java thread pool": [[187, 202]]}}}, {"text": "For instance, the javax.swing.colorchooser package appears to have only four classes, but it actually has 17 (actual number may vary depending on the version of Java)", "label": {"api": {"javax.swing.colorchooser": [[18, 41]]}}}, {"text": "Calling setDaemon(true) on your thread before you start it will make your process terminate (more or less) as soon are your main() function returns", "label": {"api": {"setDaemon(true)": [[8, 22]]}}}, {"text": "But you can draw Line2D in both double or float precision, or use GeneralPath [which uses float]", "label": {"api": {"Line2D": [[17, 22]], "GeneralPath": [[66, 76]]}}}, {"text": "You can't specify it in the GUI Designer, locale should be specified in your application code, like this", "label": {"api": {"specified in your application code": [[59, 92]]}}}, {"text": "The category entities will be cached, so unless each \"goods\" entity refers to a different category, you probably will have acceptable performance", "label": {"api": {"cached": [[30, 35]]}}}, {"text": "If you are really worried about it, you can use EntityManager.getReference to retrieve a lightweight version of the category entity", "label": {"api": {"EntityManager.getReference": [[48, 73]]}}}, {"text": "One such example is a stream socket", "label": {"api": {"socket": [[29, 34]]}}}, {"text": "Also I think you should consider cached thread pool or calibrate ThreadPoolSize according server hardware", "label": {"api": {"cached thread pool": [[33, 50]]}}}, {"text": "From the spec it seems that it is not possible but I am asking just in case anybody aware of some kind of trick..", "label": {"api": {"spec": [[9, 12]]}}}, {"text": "If you want them to be called something else, you can use the Thread.setName() method", "label": {"api": {"Thread.setName()": [[62, 77]]}}}, {"text": "Collections.shuffle(List<?> list, Random rnd) built-in library available in java", "label": {"api": {"Collections.shuffle(List<?> list, Random rnd)": [[0, 44]]}}}, {"text": "out is a public static final variable of type PrintStream", "label": {"api": {"out is a public static final variable of type PrintStream": [[0, 56]]}}}, {"text": "Similar to @Steve McLeod's answer that uses ManagementFactory, since Java 8 this can also be written in a single line using Java streams", "label": {"api": {"ManagementFactory": [[44, 60]], "Java streams": [[124, 135]]}}}, {"text": "Please look again at the Font API, deriveFont(...) method", "label": {"api": {"Font API": [[25, 32]]}}}, {"text": "I am using an ExecutorService for a connection task as below", "label": {"api": {"ExecutorService": [[14, 28]]}}}, {"text": "You might want to use PreparedStatements", "label": {"api": {"PreparedStatements": [[22, 39]]}}}, {"text": "Sure, just use the Date(long) constructor, which receives the time in millisecods as parameter", "label": {"api": {"Date(long)": [[19, 28]]}}}, {"text": "Given the List API", "label": {"api": {"List API": [[10, 17]]}}}, {"text": "Direct ByteBuffers were introduced in Java 1.4 for this purpose", "label": {"api": {"ByteBuffers": [[7, 17]]}}}, {"text": "See the Formatter documentation for more details about formatted strings", "label": {"api": {"Formatter": [[8, 16]]}}}, {"text": "In addition to NumberFormat for the display of your number, I would suggest you step back from the code and check out the BigDecimal class for your numeric computing needs", "label": {"api": {"BigDecimal": [[122, 131]]}}}, {"text": "You can set the scale BigDecimal(BigInteger unscaledVal, int scale) and effectively (read correctly) perform numeric calculations", "label": {"api": {"BigDecimal": [[22, 31]]}}}, {"text": "One easy option is to use a Set like container instead of an array", "label": {"api": {"Set like container": [[28, 45]]}}}, {"text": "the session is not the same thing as the servlet context", "label": {"api": {"the session": [[0, 10]], "the servlet context": [[37, 55]]}}}, {"text": "Forget that :) - Channels.newReader() would be the way to go", "label": {"api": {"Channels.newReader()": [[17, 36]]}}}, {"text": "If you use a ConcurrentSkipListMap is can be faster and doesn't have this issue", "label": {"api": {"ConcurrentSkipListMap": [[13, 33]]}}}, {"text": "If you don't need the keys to be sorted you can use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[54, 70]]}}}, {"text": "Java already has a LinkedList class amongst its rather large selection of collection classes", "label": {"api": {"LinkedList": [[19, 28]], "large selection of collection classes": [[55, 91]]}}}, {"text": "You can use afterExecute method", "label": {"api": {"afterExecute": [[12, 23]]}}}, {"text": "Because each time when you call nextElement() so each time you call this method will get next element from Enumeration", "label": {"api": {"call": [[27, 30], [63, 66]]}}}, {"text": "So simply change your code and call nextElement() only once", "label": {"api": {"call": [[31, 34]]}}}, {"text": "When you have a floating point number, you need the type Double (high precision) or Float (low precision)", "label": {"api": {"Double": [[57, 62]], "Float": [[84, 88]]}}}, {"text": "Double, Float and Integer are all extensions of a common base class Number", "label": {"api": {"Double": [[0, 5]], "Float": [[8, 12]], "Number": [[68, 73]]}}}, {"text": "When you turn your map into a map of Number, you can put Integers, Floats and Doubles into it", "label": {"api": {"Double": [[78, 83]], "Float": [[67, 71]], "Number": [[37, 42]]}}}, {"text": "Since the empty string isn't in any way anchored, Pattern.find() will find at least one instance of it in any input", "label": {"api": {"Pattern.find()": [[50, 63]]}}}, {"text": "With java 7 you can use pretty handy ProcessBuilder and merge your error stream into the output one ..", "label": {"api": {"ProcessBuilder": [[37, 50]]}}}, {"text": "I would use ProcessBuilder (similar to what Jan said earlier) and if your using Java 5 at least something like below might tell you what the error is if any..", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "If you want to set a system property, you can use System.setProperty(key,value)", "label": {"api": {"System.setProperty(key,value)": [[50, 78]]}}}, {"text": "You can start it with Runtime.exec()", "label": {"api": {"Runtime.exec()": [[22, 35]]}}}, {"text": "Have a look at LinkedBlockingQueues", "label": {"api": {"LinkedBlockingQueues": [[15, 34]]}}}, {"text": "I would rethink your solution, using ScheduledExecutorService for executing a Runnable in background", "label": {"api": {"ScheduledExecutorService": [[37, 60]]}}}, {"text": "If you have to use an array, I would use Arrays.sort() with a custom comparator", "label": {"api": {"Arrays.sort()": [[41, 53]]}}}, {"text": "If I'm understanding what you're looking for, Files.readAllLines is the simplest solution (if Java 7 is available)", "label": {"api": {"Files.readAllLines": [[46, 63]]}}}, {"text": "String.split doesn't split the string by another string, it splits it by a regular expression", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "If they are just dots you may consider drawing them on an WritableImage and save a lot of memory", "label": {"api": {"WritableImage": [[58, 70]]}}}, {"text": "For more complex cases you may want to use Canvas", "label": {"api": {"Canvas": [[43, 48]]}}}, {"text": "In JavaFX, I'm trying to use Tasks to do things in the background, but I can't figure out how to update the Task state", "label": {"api": {"Task": [[29, 32], [108, 111]]}}}, {"text": "There is nothing that does that in the Task API", "label": {"api": {"Task": [[39, 42]], "Task API": [[39, 46]]}}}, {"text": "directly instantiate ScheduledThreadPoolExecutor)", "label": {"api": {"ScheduledThreadPoolExecutor": [[21, 47]], "ThreadPoolExecutor": [[30, 47]]}}}, {"text": "ThreadPoolExecutor provides getActiveCount() for obtaining the number of active threads", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "The next decision is whether to call scheduleAtFixedRate or scheduleWithFixedDelay", "label": {"api": {"scheduleAtFixedRate": [[37, 55]], "scheduleWithFixedDelay": [[60, 81]]}}}, {"text": "Am leaning towards scheduleWithFixedDelay() since the polling regularity isn't all that important and I don't like the idea of multiple polls occurring in quick succession after a bottleneck", "label": {"api": {"scheduleWithFixedDelay": [[19, 40]]}}}, {"text": "The main part I'm not sure about here is the first scheduleWithFixedDelay() parameter", "label": {"api": {"scheduleWithFixedDelay": [[51, 72]]}}}, {"text": "In order to remove the commas from the output I would suggest to use String.split()", "label": {"api": {"String.split()": [[69, 82]]}}}, {"text": "Use constructor FileWriter(String filename, boolean append) that can instruct the file to be opened in append mode", "label": {"api": {"FileWriter(String filename, boolean append)": [[16, 58]]}}}, {"text": "Use the Collections.sort() method", "label": {"api": {"Collections.sort()": [[8, 25]]}}}, {"text": "You will have to create a custom Comparator for this, but there are many available tutorials on this", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "What you basically do is you subclass the Comparator to compare two User objects, and return a result based on the name", "label": {"api": {"Comparator": [[42, 51]]}}}, {"text": "Use a single thread executor service, and each time you want to call a lotus notes method, submit a task to the executor, get the returned Future, and get the result of the method call from the Future", "label": {"api": {"single thread executor service": [[6, 35]]}}}, {"text": "You might try implementing something around a PushBackReader, which has an unread method that allows you to push unwanted characters into a pushback buffer", "label": {"api": {"PushBackReader": [[46, 59]]}}}, {"text": "Make a java.net.URL object from the url string and call openStream() on it", "label": {"api": {"openStream()": [[56, 67]]}}}, {"text": "If you look at the method in the PreparedStatement class, you need to create a TimeStamp object that you will replace your null with", "label": {"api": {"method": [[19, 24]], "TimeStamp": [[79, 87]]}}}, {"text": "Learn about how to construct your ImageIcon from a URL and how to find a URL to it relative to the location of the compiled .class file", "label": {"api": {"URL": [[51, 53], [73, 75]], "find a URL": [[66, 75]]}}}, {"text": "I want to create a Singleton main class in JavaFX but I am having difficulties because the main class must extend Application, so the constructor can't be private", "label": {"api": {"Application": [[114, 124]]}}}, {"text": "You have to create the button with the Action or use setAction(); addActionListener() by itself is not sufficient", "label": {"api": {"Action": [[39, 44], [56, 61], [69, 74]]}}}, {"text": "Here's a complete example; see How to Use Actions for examples and Action for more on bound properties", "label": {"api": {"Action": [[42, 47], [67, 72]]}}}, {"text": "Random.nextInt(n) takes an int argument as the upperbound which returns an integer between 0 and (but not including) n", "label": {"api": {"Random.nextInt(n)": [[0, 16]]}}}, {"text": "Use Class#getResource() instead of passing a relative path to the ImageIcon constructor", "label": {"api": {"Class#getResource()": [[4, 22]]}}}, {"text": "You could either fix the layout of your JAR file, which would be to just arrange the folders accordingly as they are in Eclipse, or just do as Matt Ball said and use Class#getResource or Class#getResourceAsStream", "label": {"api": {"Class#getResource": [[166, 182], [187, 203]], "Class#getResourceAsStream": [[187, 211]]}}}, {"text": "You can do this by using Package.getPackages(), which returns an array of all packages known to the current class loader", "label": {"api": {"Package.getPackages()": [[25, 45]], "getPackages()": [[33, 45]]}}}, {"text": "You'll have to manually loop through the array and find the ones with the appropriate prefix using getName()", "label": {"api": {"getName()": [[99, 107]]}}}, {"text": "Use reflection to call the (normally protected) method getPackages() on the appropriate class loader", "label": {"api": {"getPackages()": [[55, 67]]}}}, {"text": "When comparing objects in java that are not primitive data types (int, char, boolean, etc...), you have to use the method Object#equals(Object), which returns a boolean", "label": {"api": {"Object#equals(Object)": [[122, 142]]}}}, {"text": "Yes; URLClassLoader is intended for this purpose", "label": {"api": {"URLClassLoader": [[5, 18]]}}}, {"text": "Use a CategoryAxis for your x axis", "label": {"api": {"CategoryAxis": [[6, 17]]}}}, {"text": "The documentation for TrayIcon seems to imply that clicking on the balloon message can trigger an ActionEvent, which is the same as, for your case, double-clicking on the icon itself", "label": {"api": {"TrayIcon": [[22, 29]]}}}, {"text": "You can use DecimalFormat to format the display of the number as you wish, for example", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "Use BigDecimal to keep the monetary value", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "Read the answer of this question to find out why you should use BigDecimal", "label": {"api": {"BigDecimal": [[64, 73]]}}}, {"text": "The JavaMail API (as of version 1.5, I think), allows you to set the system property mail.mime.multipart.allowempty to true to work around this", "label": {"api": {"JavaMail API": [[4, 15]]}}}, {"text": "HashSet also calls equals() to determine if an element is already contained in the set, see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html#add%28E%29", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html#add%28E%29": [[92, 165]]}}}, {"text": "Therefore, it is the return value of o1.compareTo(o2) which is important (or, if you created the tree map with the constructor http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#TreeMap%28java.util.Comparator%29, the comparator is used)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#TreeMap%28java.util.Comparator%29": [[127, 223]]}}}, {"text": "The class Matcher has two methods \"start\" and \"end\" which return the start index and end index of the last match", "label": {"api": {"Matcher": [[10, 16]], "start": [[35, 39], [69, 73]], "end": [[47, 49], [85, 87]]}}}, {"text": "Further, the method find has an optional parameter \"start\" at which it starts searching", "label": {"api": {"start": [[52, 56], [71, 75]], "find": [[20, 23]]}}}, {"text": "According to the documentation of java.lang.instrument.Instrumentation#setNativeMethodPrefix(), it should be possible for java agents to replace the native method with a non-native stub method and add another native method with that prefix in its name which is then bound to the original native method's native code", "label": {"api": {"java.lang.instrument.Instrumentation#setNativeMethodPrefix()": [[34, 93]]}}}, {"text": "If I call the method tree.getModel().getChildCount(rootNode), I only get the number of direct children (e.g", "label": {"api": {"tree.getModel().getChildCount(rootNode)": [[21, 59]]}}}, {"text": "You can sort the list after it's created using Collections.sort method", "label": {"api": {"Collections.sort": [[47, 62]]}}}, {"text": "Or, even better, you could free yourself from the problems of basic floating point rounding problems, and use BigDecimal", "label": {"api": {"BigDecimal": [[110, 119]]}}}, {"text": "Warning if very large values are considered, be sure to use the BigDecimal, as that preserves the precision, while floating point numbers can lose precision", "label": {"api": {"BigDecimal": [[64, 73]]}}}, {"text": "If the server closes its end of the socket on that timeout, then readLine() will return null", "label": {"api": {"readLine()": [[65, 74]]}}}, {"text": "In Java, the tool to use for this is RandomAccessFile", "label": {"api": {"RandomAccessFile": [[37, 52]]}}}, {"text": "Use  getWindowAncestor  method from SwingUtilities", "label": {"api": {"getWindowAncestor": [[5, 21]]}}}, {"text": "Not sure if you need to use regex, but if you don't why not use String.split", "label": {"api": {"String.split": [[64, 75]]}}}, {"text": "[Edit] I wouldn't use regular expressions for this problem; instead I would simply use the String#lastIndexOf(...) method to find the bounds of the last ( and ) characters and return substrings from those values", "label": {"api": {"String#lastIndexOf(...)": [[91, 113]]}}}, {"text": "Sounds like you should use an ExecutorService", "label": {"api": {"ExecutorService": [[30, 44]]}}}, {"text": "Make a class that performs your query and implements Runnable", "label": {"api": {"Runnable": [[53, 60]]}}}, {"text": "You get given back a Future object for each submission and you simply call get() on that to get your result", "label": {"api": {"Future": [[21, 26]]}}}, {"text": "Why not store the exceptions in an ArrayList", "label": {"api": {"ArrayList": [[35, 43]]}}}, {"text": "Or if you want to name the index, you could use a HashMap", "label": {"api": {"HashMap": [[50, 56]]}}}, {"text": "Obviously you would have to modify the code to use either ArrayList or HashMap, but I think this would be a better solution than using Enums", "label": {"api": {"ArrayList": [[58, 66]], "HashMap": [[71, 77]]}}}, {"text": "To read properties from an arbitrary path use one of the load functions of the Properties class itself", "label": {"api": {"Properties": [[79, 88]]}}}, {"text": "toString is a special method of the Object class, here is its description", "label": {"api": {"description": [[62, 72]]}}}, {"text": "The constructor is defined as public Semaphore(int permits)", "label": {"api": {"public Semaphore(int permits)": [[30, 58]]}}}, {"text": "During runtime, you need to compile it yourself by JavaCompiler and then load by URLClassLoader", "label": {"api": {"JavaCompiler": [[51, 62]], "URLClassLoader": [[81, 94]]}}}, {"text": "You'd need to do a Class#forName(), passing the FQN and the URLClassLoader", "label": {"api": {"URLClassLoader": [[60, 73]]}}}, {"text": "You have to add the serialization interface to those objects to", "label": {"api": {"serialization interface": [[20, 42]]}}}, {"text": "scanner.next() will throw a NoSuchElementException if there are no more tokens available", "label": {"api": {"scanner.next() will throw a NoSuchElementException if there are no more tokens available": [[0, 87]]}}}, {"text": "Scanner.next throws a NoSuchElement exception if there are no more tokens", "label": {"api": {"Scanner.next": [[0, 11]]}}}, {"text": "You could do worse than SAX, by extending DefaultHandler2 or DefaultHandler", "label": {"api": {"DefaultHandler2": [[42, 56]], "DefaultHandler": [[42, 55], [61, 74]]}}}, {"text": "Now, you will need to flush the stream (or writer, or RandomAccessFile, or whatever you use) during this time", "label": {"api": {"flush": [[22, 26]]}}}, {"text": "Also, it is recommended to use the ProcessBuilder to create a process", "label": {"api": {"ProcessBuilder": [[35, 48]]}}}, {"text": "IdentityHashMap uses == to determine if two objects are the same while HashSet uses equals", "label": {"api": {"IdentityHashMap": [[0, 14]], "HashSet": [[71, 77]]}}}, {"text": "If you want a Set with identical semantics to an IdentityHashMap, you may wish to check out Collections.newSetFromMap", "label": {"api": {"IdentityHashMap": [[49, 63]], "Collections.newSetFromMap": [[92, 116]]}}}, {"text": "as mentioned by @AndrewThompson in his comment, you should be using a swing Timer instead of a Thread", "label": {"api": {"Timer": [[76, 80]]}}}, {"text": "You are adding a url for your encrypted jar to the URLClassLoader", "label": {"api": {"ClassLoader": [[54, 64]]}}}, {"text": "how do you expect the URLClassLoader to decrypt the jar when it loads it", "label": {"api": {"ClassLoader": [[25, 35]]}}}, {"text": "extend SecureClassLoader and implement the relevant methods", "label": {"api": {"ClassLoader": [[13, 23]]}}}, {"text": "there's a basic example in the ClassLoader javadocs", "label": {"api": {"ClassLoader": [[31, 41]]}}}, {"text": "BufferedReader#readLine() method does not read the newline character at the end of the line", "label": {"api": {"BufferedReader#readLine()": [[0, 24]]}}}, {"text": "You can use BufferedReader#skip() to skip the newline character after every readLine in your for loop", "label": {"api": {"BufferedReader#skip()": [[12, 32]]}}}, {"text": "Thread.getAllStackTraces() may work", "label": {"api": {"Thread.getAllStackTraces()": [[0, 25]]}}}, {"text": "- Or walk up the ThreadGroup hierarchy to the top and get all threads from the root ThreadGroup (getParent() == null)", "label": {"api": {"hierarchy": [[29, 37]]}}}, {"text": "Try using System.getenv() instead", "label": {"api": {"System.getenv()": [[10, 24]]}}}, {"text": "Have you tried using putChar method of ByteBuffer", "label": {"api": {"putChar": [[21, 27]]}}}, {"text": "Create your regular expressions using a Pattern", "label": {"api": {"Pattern": [[40, 46]]}}}, {"text": "matcher(pageHTML) to get a Matcher", "label": {"api": {"Matcher": [[27, 33]]}}}, {"text": "The Matcher allows you to know if there is any matches, find is there is a next match, and take the group representing the last match's sub-sequence", "label": {"api": {"Matcher": [[4, 10]]}}}, {"text": "Intersection is using contains, which uses equals", "label": {"api": {"contains": [[22, 29]]}}}, {"text": "As in this answer, use Collection methods retainAll(Collection)- intersection and #addAll(Collection)- union", "label": {"api": {"Collection": [[23, 32], [52, 61], [90, 99]]}}}, {"text": "You have to define a java.math.BigDecimal field, and put your double or float value into that field", "label": {"api": {"java.math.BigDecimal": [[21, 40]]}}}, {"text": "Check out PrintWriter", "label": {"api": {"PrintWriter": [[10, 20]]}}}, {"text": "Another alternative is to use a CharArrayReader and call the statement.setCharacterStream", "label": {"api": {"CharArrayReader": [[32, 46]], "statement.setCharacterStream": [[61, 88]]}}}, {"text": "When instantiating a Locale object with either one of the following language codes", "label": {"api": {"Locale": [[21, 26]]}}}, {"text": "Use a hashmap to store them", "label": {"api": {"hashmap": [[6, 12]]}}}, {"text": "To customize how the path is resolved you need to implement a EntityResolver", "label": {"api": {"EntityResolver": [[62, 75]]}}}, {"text": "This EntityResolver can return an InputSource referring to a copy of the dtd loaded from the classpath", "label": {"api": {"EntityResolver": [[5, 18]], "InputSource": [[34, 44]]}}}, {"text": "From the documentation for Statement.close()", "label": {"api": {"Statement.close()": [[27, 43]]}}}, {"text": "HashMap is based on hashCode() and Integer.hashCode() is as fast as you can get (it's an identity function)", "label": {"api": {"Integer.hashCode()": [[35, 52]]}}}, {"text": "Runtime.exec(String[] cmdarray, String[] envp, File dir)", "label": {"api": {"Runtime.exec(String[] cmdarray, String[] envp, File dir)": [[0, 55]]}}}, {"text": "Instead, per the Play 2.0 docs, it uses Spring data binding and JSR-303 under the hood, so how about using the javax.validation @Valid annotation on it", "label": {"api": {"javax.validation @Valid": [[111, 133]]}}}, {"text": "I believe the problem you are having is that a HashMap is completely unordered", "label": {"api": {"HashMap": [[47, 53]]}}}, {"text": "If you want to add order to the data in a HashMap, the classic solution is to use a TreeMap", "label": {"api": {"HashMap": [[42, 48]], "TreeMap": [[84, 90]]}}}, {"text": "Depending on your situation, perhaps you cannot start out using a TreeMap", "label": {"api": {"TreeMap": [[66, 72]]}}}, {"text": "If so, you will want to convert your HashMap to a TreeMap", "label": {"api": {"HashMap": [[37, 43]], "TreeMap": [[50, 56]]}}}, {"text": "The resulting TreeMap will be ordered based upon the \"keys\" of your HashMap", "label": {"api": {"HashMap": [[68, 74]], "TreeMap": [[14, 20]]}}}, {"text": "If you want to sort an ArrayList of HashMaps using values inside your each HashMap, all you need to do is create a TreeMap and place it into a TreeList", "label": {"api": {"HashMap": [[36, 42], [75, 81]], "TreeMap": [[115, 121]]}}}, {"text": "If you want to sort your ArrayList by something other than the keys of the original HashMap, you have a problem and will need to rethink your choice of data structure", "label": {"api": {"HashMap": [[84, 90]]}}}, {"text": "You can see the Keystroke class for more details on setting up the keys for mapping", "label": {"api": {"Keystroke class": [[16, 30]]}}}, {"text": "SourceVersion.isName can be used to check fully qualified names", "label": {"api": {"SourceVersion.isName": [[0, 19]]}}}, {"text": "Just add a DelayQueue", "label": {"api": {"DelayQueue": [[11, 20]]}}}, {"text": "If you're using Java 7, you can use java.nio.file.Files and its SetLastModifiedTime(Path, FileTime) static method", "label": {"api": {"java.nio.file.Files": [[36, 54]], "SetLastModifiedTime(Path, FileTime)": [[64, 98]]}}}, {"text": "You can use the Formatter class introduced in Java 5, like this", "label": {"api": {"Formatter": [[16, 24]]}}}, {"text": "If you really want to dump heap before you run out of memory, you could add a worker thread that periodically polls for memory usage (see freeMemory)", "label": {"api": {"freeMemory": [[138, 147]]}}}, {"text": "This is specified in Cookie#setValue() javadoc as follows", "label": {"api": {"Cookie#setValue()": [[21, 37]]}}}, {"text": "Can you just use servlets on the server and post the byte array of the files in Restful manner", "label": {"api": {"servlets": [[17, 24]]}}}, {"text": "Then on the server side I would just make servlets to accept the http posts your sending", "label": {"api": {"servlets": [[42, 49]]}}}, {"text": "Using netbeans or eclipse with the appropriate plugins (can't remember which ones, web developer tools(wdt) in eclipse I think) makes building servlets much easier as it sets up the doPost and doGet methods", "label": {"api": {"servlets": [[143, 150]]}}}, {"text": "As you can see in the docs for Random.nextInt(int), the value of the argument specifies the range of available answers between 0 and the argument", "label": {"api": {"Random.nextInt(int)": [[31, 49]]}}}, {"text": "Have you considering using a HashMap", "label": {"api": {"HashMap": [[29, 35]]}}}, {"text": "A HashMap is an extremely fast, lightweight, and standard data structure", "label": {"api": {"HashMap": [[2, 8]]}}}, {"text": "Make sure you read and understand the method Thread.getAllStackTraces() before using them", "label": {"api": {"Thread.getAllStackTraces()": [[45, 70]]}}}, {"text": "I don't know how you are handling your concurrency, but take a look at java.util.concurrent and the concurrency tutorial if you haven't already", "label": {"api": {"java.util.concurrent": [[71, 90]]}}}, {"text": "Sometimes the higher level java.util.concurrent framework is more expressive, less error prone, easier to work with and easier to reason about than the lower level object monitor wait/notify methods", "label": {"api": {"java.util.concurrent": [[27, 46]]}}}, {"text": "You may want to mark some of the threads you are using as daemon threads", "label": {"api": {"daemon threads": [[58, 71]]}}}, {"text": "You may also want to add some logic to handle interruption of threads or cancellation of processes, similar to the examples in the JavaFX Task documentation", "label": {"api": {"Task": [[138, 141]]}}}, {"text": "Often, concurrent work is offloaded from the JavaFX application thread to worker threads using the Task/Service framework", "label": {"api": {"Task": [[99, 102]], "Task/Service framework": [[99, 120]]}}}, {"text": "Consider Timer class to shrink your code a bit and avoid the problem above", "label": {"api": {"Timer": [[9, 13]]}}}, {"text": "I assume, the Student class implements the Serializable interface", "label": {"api": {"Serializable": [[43, 54]]}}}]