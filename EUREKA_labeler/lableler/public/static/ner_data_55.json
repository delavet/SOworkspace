[{"text": "You can create a HashMap using SoftReferences instead of WeakReferences - the garbage collector will be a bit less eager about GCing it", "label": {"api": {"SoftReferences": [[31, 44]]}}}, {"text": "Just copy the WeakHashMap source code, replacing the WeakReferences with SoftReferences", "label": {"api": {"SoftReferences": [[73, 86]]}}}, {"text": "Create a FileOutputStream (which can control whether to append to a file), then wrap that stream in your PrintWriter", "label": {"api": {"FileOutputStream": [[9, 24]]}}}, {"text": "PrintWriter#append does not append data to a file", "label": {"api": {"PrintWriter#append": [[0, 17]]}}}, {"text": "Then use System.arraycopy to copy the contents of the original arrays into the new array, being careful to copy them into the destination array at the correct start index", "label": {"api": {"System.arraycopy": [[9, 24]]}}}, {"text": "You might want to enforce this from the time it's initialized by using Collections.unmodifiableMap or Guava's ImmutableMap", "label": {"api": {"Collections.unmodifiableMap": [[71, 97]]}}}, {"text": "If not, a quick solution would be wrapping each list using Collections.synchronizedList at creation time", "label": {"api": {"Collections.synchronizedList": [[59, 86]]}}}, {"text": "Or you could look at using ConcurrentLinkedQueues instead", "label": {"api": {"ConcurrentLinkedQueue": [[27, 47]]}}}, {"text": "Your pattern is fine (for Java), just use Matcher.matches() instead of Matcher.find()", "label": {"api": {"matches": [[50, 56]], "find": [[79, 82]]}}}, {"text": "From the Class Matcher documentation", "label": {"api": {"Class Matcher documentation": [[9, 35]]}}}, {"text": "The matches method attempts to match the entire input sequence against the pattern", "label": {"api": {"matches": [[4, 10]]}}}, {"text": "The lookingAt method attempts to match the input sequence, starting at the beginning, against the pattern", "label": {"api": {"lookingAt": [[4, 12]]}}}, {"text": "The find method scans the input sequence looking for the next subsequence that matches the pattern", "label": {"api": {"matches": [[79, 85]], "find": [[4, 7]]}}}, {"text": "So, the problem is, the find method will find your empty string alternative in any string", "label": {"api": {"find": [[24, 27], [41, 44]]}}}, {"text": "To find an exact match in Java, use the matches() method", "label": {"api": {"matches": [[40, 46]], "find": [[3, 6]]}}}, {"text": "In the interim, I would suggest you wrap the problematic code segment with a ReentrantLock which each thread must acquire in order to reach the synchronized block", "label": {"api": {"ReentrantLock": [[77, 89]]}}}, {"text": "Effectively, you are replacing the synchronized behaviour (from which a thread cannot be pulled out of) with a lock which has the same guarding properties, but for which you can timeout the acquiring threads (so the threads don't pile-up and stop your system) by having them acquire the lock with a tryLock(long timeout, TimeUnit unit) with an appropriate timeout", "label": {"api": {"tryLock(long timeout, TimeUnit unit)": [[299, 334]]}}}, {"text": "The ReentrantLock also has a layer of \"instrumentation", "label": {"api": {"ReentrantLock": [[4, 16]]}}}, {"text": "Use Graphics2D.setStroke(Stroke) as seen in this answer", "label": {"api": {"Graphics2D.setStroke(Stroke)": [[4, 31]]}}}, {"text": "So subGraph[i].nodeDelay will obviously throw a NullPointerException, because you are trying to access or modify the field of a null object", "label": {"api": {"NullPointerException": [[48, 67]]}}}, {"text": "Use System.getenv() to read the value", "label": {"api": {"System.getenv()": [[4, 18]]}}}, {"text": "Use EnumSet on an enum with default constructors", "label": {"api": {"EnumSet": [[4, 10]]}}}, {"text": "Call the enum Permission, call the EnumSet Permissions", "label": {"api": {"EnumSet": [[35, 41]]}}}, {"text": "Using split(\"\\\\|\") is the same as split(\"\\\\|\", 0), where the limit parameter 0 tells the function \"omit trailing empty strings\"", "label": {"api": {"split(\"\\\\|\")": [[6, 17]], "split(\"\\\\|\", 0)": [[34, 48]]}}}, {"text": "You can also modify a thread's priority at any time after its creation using the setPriority() method", "label": {"api": {"setPriority()": [[81, 93]]}}}, {"text": "Thread priorities are integers ranging between MIN_PRIORITY and MAX_PRIORITY (constants defined in the Thread class)", "label": {"api": {"MIN_PRIORITY": [[47, 58]], "MAX_PRIORITY": [[64, 75]]}}}, {"text": "Or, as suggested by mKorbel, you may wish to adjust your approach and use a DocumentListener to validate the contents of your JTextFields on the fly", "label": {"api": {"DocumentListener": [[76, 91]]}}}, {"text": "What you are using to parse the XML is this method", "label": {"api": {"this method": [[39, 49]]}}}, {"text": "Transform it to an array with the toArray method", "label": {"api": {"toArray": [[34, 40]]}}}, {"text": "or by code", "label": {"api": {"by code": [[3, 9]]}}}, {"text": "This seems a lot like an X-Y problem; as pointed out in the comments it doesn't make a lot of sense to be comparing arbitrary Number objects; why not just make your maps Map<BigDecimal, String> and just always use BigDecimal directly (normalized with stripTrailingZeros() if necessary)", "label": {"api": {"stripTrailingZeros()": [[251, 270]], "Number": [[126, 131]]}}}, {"text": "Notably, Number doesn't implement Comparable, which should be a pretty clear hint that you shouldn't try to compare arbitrary Number instances", "label": {"api": {"Number": [[9, 14], [126, 131]]}}}, {"text": "You can use the getReaderFileSuffixes method of the javax.imageio.ImageIO class to get an array of the available file extensions", "label": {"api": {"getReaderFileSuffixes": [[16, 36]]}}}, {"text": "From the Oracle docs of notExists", "label": {"api": {"Oracle docs": [[9, 19]]}}}, {"text": "As we see from Files.exists the return result is", "label": {"api": {"Files.exists": [[15, 26]]}}}, {"text": "And from Files.notExists the return result is", "label": {"api": {"Files.notExists": [[9, 23]]}}}, {"text": "So if !Files.exists(path) return TRUE means it not exists or the existence cannot be determined (2 possibilities) and for Files.notExists(path) return TRUE means it not exists (just 1 possibility)", "label": {"api": {"Files.exists": [[7, 18]], "Files.notExists": [[122, 136]]}}}, {"text": "The conclusion !Files.exists(path) != Files.notExists(path) or 2 possibilities not equals to 1 possibility (see the explanation above about the possibilities)", "label": {"api": {"Files.exists": [[16, 27]], "Files.notExists": [[38, 52]]}}}, {"text": "You should be using DataInputStream instead", "label": {"api": {"DataInputStream": [[20, 34]]}}}, {"text": "For more details you could read the java doc of the method in the class Class", "label": {"api": {"Class": [[72, 76]]}}}, {"text": "It's not deprecated", "label": {"api": {"not deprecated": [[5, 18]]}}}, {"text": "msg = \"d1 is null!\"; and msg=null are two different String objects", "label": {"api": {"String": [[52, 57]]}}}, {"text": "Strings are immutable in Java.The reference is passed by value, i.e., a copy of the reference is passed", "label": {"api": {"String": [[0, 5]]}}}, {"text": "and since a String is immutable object , the assignment inside the method creates a new String object that the copy of the reference now points to", "label": {"api": {"String": [[12, 17], [88, 93]]}}}, {"text": "The original reference still points to the null String", "label": {"api": {"String": [[48, 53]]}}}, {"text": "You can also use a StringTokenizer object to split your string according to the correct pattern", "label": {"api": {"StringTokenizer": [[19, 33]]}}}, {"text": "To retain precision, use BigInteger", "label": {"api": {"BigInteger": [[25, 34]]}}}, {"text": "A BigInteger is arbitrary precision and will not lose any precision", "label": {"api": {"BigInteger": [[2, 11]]}}}, {"text": "You can use basic arithmetic and comparisons directly between BigIntegers", "label": {"api": {"BigInteger": [[62, 71]]}}}, {"text": "You could use Thread.sleep in computerMove() to pause the execution", "label": {"api": {"Thread.sleep": [[14, 25]]}}}, {"text": "You can use clip.getMicrosecondsLength to get the length of the sound effect in microseconds", "label": {"api": {"clip.getMicrosecondsLength": [[12, 37]]}}}, {"text": "The simplest solution is to use AtomicInteger without going throughout the trouble of synchronizing the increment", "label": {"api": {"AtomicInteger": [[32, 44]]}}}, {"text": "Use a Semaphore with five permits", "label": {"api": {"Semaphore": [[6, 14]]}}}, {"text": "Comparable#compareTo(T) is meant to return the difference between two objects, allowing an algorithm to decide whether one item i equal, less than or greater than another", "label": {"api": {"Comparable#compareTo(T)": [[0, 22]]}}}, {"text": "You might also want to look into performing the actual colour change in the GUI thread using something like invokeLater", "label": {"api": {"invokeLater": [[108, 118]]}}}, {"text": "If using repeatedly with String.matches(), you would be better to use the following code, because every call to String.matches() compiles the regex again (there is no caching)", "label": {"api": {"String.matches()": [[25, 40], [112, 127]]}}}, {"text": "For discrete objects you can use a producer/consumer pattern with ConcurrentLinkedQueues or BlockingQueues - each module has its own queue, and it will continually poll its queue (or use take if it's a BlockingQueue), process the object, and offer it to the next module's queue", "label": {"api": {"ConcurrentLinkedQueues": [[66, 87]], "BlockingQueues": [[92, 105]]}}}, {"text": "Take a look at System.setOut(PrintStream)", "label": {"api": {"System.setOut(PrintStream)": [[15, 40]]}}}, {"text": "See the JFileChooser documentation for an example", "label": {"api": {"JFileChooser documentation": [[8, 33]]}}}, {"text": "for natural language texts), then have a look at Collator and CollationKey", "label": {"api": {"Collator": [[49, 56]], "CollationKey": [[62, 73]]}}}, {"text": "From the Collections.singleton javadoc", "label": {"api": {"Collections.singleton": [[9, 29]]}}}, {"text": "Because if every object ( including the object of user-defined class) can be cloned just by using clone method then it might lead to the unintentional mutation of the original object being cloned as clone provides shallow copy of the original object", "label": {"api": {"clone": [[77, 81], [98, 102], [189, 193], [199, 203]]}}}, {"text": "So to avoid such scenario , the prevalence is given to the programmer while defining the class whether he/she wants the object of that class to be cloned or not", "label": {"api": {"clone": [[147, 151]]}}}, {"text": "As the Java API states, the contains method should rely on your equals method, so object equality should work as you expect it", "label": {"api": {"the Java API": [[3, 14]]}}}, {"text": "The session scope is programmatically available by ExternalContext#getSessionMap() which delegates under the covers to HttpSession#get/setAttribute()", "label": {"api": {"ExternalContext#getSessionMap()": [[51, 81]]}}}, {"text": "The more adventurous could create a patch to add Boomah's suggested feature by modifying the StyleManager code to support removal of global stylesheets and modifying Application class source code to provide a public API for the new feature which makes use of the updated StyleManager, then submit the patch to openjfx-dev for inclusion in the JavaFX platform", "label": {"api": {"Application": [[166, 176]]}}}, {"text": "Regardless, you probably want to use something like a PrintWriter with the file instead, rather than writing raw bytes", "label": {"api": {"PrintWriter": [[54, 64]]}}}, {"text": "If getFile() returns a FileWriter, then you probably have to close and reopen the file each time, and use the constructor that lets you indicate that you do NOT want it to append additional data", "label": {"api": {"constructor": [[110, 120]]}}}, {"text": "Take a look at the String API", "label": {"api": {"String API": [[19, 28]]}}}, {"text": "String.split(regex) is a good place to start", "label": {"api": {"String.split(regex)": [[0, 18]]}}}, {"text": "String.replaceAll(regex,\"\") is another thing to consider", "label": {"api": {"String.replaceAll(regex,\"\")": [[0, 26]]}}}, {"text": "You can compress the image to bytes, send these, and decode them on the other side", "label": {"api": {"compress the image to bytes": [[8, 34]]}}}, {"text": "One way I think you can do it(though verbose) is to implement your own HttpSessionListener", "label": {"api": {"HttpSessionListener": [[71, 89]]}}}, {"text": "Override its sessionCreated() method, you can get a reference to the HttpSession from the HttpSessionEvent and by invoking HttpSession#getMaxInactiveInterval(), you can get the session-timeout value in seconds", "label": {"api": {"sessionCreated()": [[13, 28]], "HttpSession#getMaxInactiveInterval()": [[123, 158]]}}}, {"text": "Use String's split() method for this, it's the right tool for the job", "label": {"api": {"split()": [[13, 19]]}}}, {"text": "Try using a memory-mapped file instead of reading the data into heap memory", "label": {"api": {"memory-mapped file": [[12, 29]]}}}, {"text": "Pass the data to the digest using a ByteBuffer instead of a byte[] array", "label": {"api": {"using a ByteBuffer": [[28, 45]]}}}, {"text": "Since Picture extends Object you can store it in an array like you would any other object", "label": {"api": {"Object": [[22, 27]]}}}, {"text": "You can also put Picture objects into an ArrayList or any other data structure", "label": {"api": {"ArrayList": [[41, 49]]}}}, {"text": "I would suggest looking into the split method", "label": {"api": {"method": [[39, 44]]}}}, {"text": "Use the FileOutputStream(File file, boolean append) constructor when you open the file for writing", "label": {"api": {"FileOutputStream(File file, boolean append)": [[8, 50]]}}}, {"text": "You might want to check out http://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/nimbus/NimbusStyle.html for some useful information on overriding the Nimbus color scheme", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/plaf/nimbus/NimbusStyle.html": [[28, 108]]}}}, {"text": "You can eliminate the for loop and just do employee.remove(company)", "label": {"api": {"employee.remove(company)": [[43, 66]]}}}, {"text": "The idea behind NIO is that you have a thread with one Selector which owns multiple Channels (a channel can be a network socket or any other IO interface)", "label": {"api": {"Selector": [[55, 62]], "Channels": [[84, 91]]}}}, {"text": "You then call selector.select() in a loop", "label": {"api": {"selector.select()": [[14, 30]]}}}, {"text": "You could concatenate both the Strings, use a SimpleDateFormat to parse that concatenated String, which would give a Date object", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "In the end, since you don't want to have a lot of code to close a basic stream, just move it into a method that handles a Closeable (note that both FileReader and FileWriter implements this interface)", "label": {"api": {"Closeable": [[122, 130]]}}}, {"text": "For known number of tasks the CountDownLatch is just perfect but there are cases, when you don't know how many tasks you will have, in that case I use Semaphore", "label": {"api": {"CountDownLatch": [[30, 43]], "Semaphore": [[151, 159]]}}}, {"text": "You could use the String#contains method along with String#startsWithinstead of splitting your String and searching each token", "label": {"api": {"String#contains": [[18, 32]], "String#startsWith": [[52, 68]]}}}, {"text": "You must make sure that the created Transferable contains the DataFlavor#javaFileListFlavor and that the data for that flavor is the File contained in your MyFile instance (to be more precise", "label": {"api": {"DataFlavor#javaFileListFlavor": [[62, 90]]}}}, {"text": "To test whether two line segments intersect, you can use Java's 2D API, specifically the methods of Line2D", "label": {"api": {"Line2D": [[100, 105]]}}}, {"text": "Sounds like you want an ExecutorService configured with a single thread", "label": {"api": {"ExecutorService": [[24, 38]]}}}, {"text": "The @SuppressWarnings(\"unchecked\") annotation will just tell the compiler not to show the warning", "label": {"api": {"@SuppressWarnings(\"unchecked\")": [[4, 33]]}}}, {"text": "Maybe you read that @Deprecated is an annotation instead", "label": {"api": {"@Deprecated": [[20, 30]]}}}, {"text": "Use an URLClassLoader for this", "label": {"api": {"URLClassLoader": [[7, 20]]}}}, {"text": "The UriBuilder does exactly what you need", "label": {"api": {"UriBuilder": [[4, 13]]}}}, {"text": "I studied http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html but, there wasn't any restriction to the type of floorEntry arguman", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html": [[10, 72]]}}}, {"text": "This number is way bigger than Integer.MAX_VALUE", "label": {"api": {"Integer.MAX_VALUE": [[31, 47]]}}}, {"text": "You can convert it to BigInteger", "label": {"api": {"BigInteger": [[22, 31]]}}}, {"text": "If the later, read about BigDecimal", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "FXML is used just for designing the layout, for styling you can use css and reference it from your FXML file", "label": {"api": {"css": [[68, 70]]}}}, {"text": "To add an image to a fx:id=\"btn\" button in your css", "label": {"api": {"css": [[48, 50]]}}}, {"text": "Override the toString() method in your class StockList and StockItem", "label": {"api": {"toString()": [[13, 22]]}}}, {"text": "If you dont do it, you use the default Object.toString() method which print it that way", "label": {"api": {"that way": [[79, 86]]}}}, {"text": "You can subclass ServerSocket, and override ServerSocket.implAccept(Socket socket)", "label": {"api": {"ServerSocket": [[17, 28], [44, 55]], "ServerSocket.implAccept(Socket socket)": [[44, 81]], "Socket": [[23, 28], [50, 55], [68, 73]]}}}, {"text": "This method, in your override, will receive an \"empty\" Socket instance on which you can call Socket.setSendBufferSize(int)", "label": {"api": {"Socket": [[55, 60], [93, 98]], "Socket.setSendBufferSize(int)": [[93, 121]]}}}, {"text": "String#matches checks if a string matches a pattern", "label": {"api": {"String#matches": [[0, 13]]}}}, {"text": "Set the window action on close, as dispose on close", "label": {"api": {"window action on close, as dispose on close": [[8, 50]]}}}, {"text": "To quote the javadoc for notifyAll()", "label": {"api": {"javadoc for notifyAll()": [[13, 35]]}}}, {"text": "but it's very important to use AtomicLong, not a regular int or long, if you want to keep unique ids", "label": {"api": {"AtomicLong": [[31, 40]]}}}, {"text": "Look at Throwable.getStackTrace()", "label": {"api": {"Throwable.getStackTrace()": [[8, 32]]}}}, {"text": "Each StackTraceElement has getClassName()", "label": {"api": {"getClassName()": [[27, 40]]}}}, {"text": "I don't know the library you're using, but with plain java you could use the split(string) method of String in each of the lines of the csv file as this", "label": {"api": {"split(string)": [[77, 89]]}}}, {"text": "You're breaking the contract of Object.equals(Object), which starts with", "label": {"api": {"Object.equals(Object)": [[32, 52]]}}}, {"text": "Put the properties file in the same directory as the class and use the getResourceAsStream() method instead", "label": {"api": {"getResourceAsStream()": [[71, 91]]}}}, {"text": "It will return an InputStream so there is no need to construct the File", "label": {"api": {"InputStream": [[18, 28]], "File": [[67, 70]]}}}, {"text": "You can use one of the replace methods that does use a regular expression such as replaceAll", "label": {"api": {"replaceAll": [[82, 91]]}}}, {"text": "The Matcher#group(int) throws", "label": {"api": {"Matcher#group(int)": [[4, 21]]}}}, {"text": "Consturtor with a one String parameter require a filepath", "label": {"api": {"Consturtor with a one String parameter": [[0, 37]]}}}, {"text": "Running this thread and calling isShowing() on the InitFrame object", "label": {"api": {"isShowing()": [[32, 42]]}}}, {"text": "Don't use an array, use a Deque, probably a LinkedList", "label": {"api": {"Deque": [[26, 30]], "LinkedList": [[44, 53]]}}}, {"text": "With Java, you can use ResouceBundles", "label": {"api": {"ResouceBundles": [[23, 36]]}}}, {"text": "You might use a GroupLayout for that first section", "label": {"api": {"GroupLayout": [[16, 26]]}}}, {"text": "If you can accept a performance hit, then use BigDecimal, which is arbitrary precision", "label": {"api": {"BigDecimal": [[46, 55]]}}}, {"text": "Now regarding optimizing it big time, as others suggested, you could use the System#arrayCopy", "label": {"api": {"System#arrayCopy": [[77, 92]]}}}, {"text": "From the FontMetrics API, which defines advance in terms of charWidth(), \"Note that the advance of a String is not necessarily the sum of the advances of its characters.\" Moreover, a font named \"Courier\" may be monospaced, but it may not be the same font specified by Font.MONOSPACED", "label": {"api": {"FontMetrics": [[9, 19]]}}}, {"text": "Creating a Comparator is the correct way to solve this", "label": {"api": {"Comparator": [[11, 20]]}}}, {"text": "Whether you then use Arrays.sort() or Collections.sort() is up to you", "label": {"api": {"Arrays.sort()": [[21, 33]], "Collections.sort()": [[38, 55]]}}}, {"text": "Look at the Java API javadoc if you want to see if some information is available before asking a question on Stackoverflow", "label": {"api": {"Java API javadoc": [[12, 27]]}}}, {"text": "If you look at the Javadoc of DatabaseMetaData.getIndexInfo(), you will see that the returned resultset contains a lot more columns than just COLUMN_NAME", "label": {"api": {"DatabaseMetaData.getIndexInfo()": [[30, 60]]}}}, {"text": "An implementation of ExecutorService runs tasks on threads", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "A Callable<T> is a task implementation", "label": {"api": {"Callable<T>": [[2, 12]]}}}, {"text": "A Future<T> holds a promise for a task result", "label": {"api": {"Future<T>": [[2, 10]]}}}, {"text": "Creation of a Comparator will solve your problem", "label": {"api": {"Comparator": [[14, 23]]}}}, {"text": "However, I think that the use of Comparator is the right \"java-way\" to solve it", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "You need to implement a Comparator for this, and pass it to the sort() method of the container", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Are you sure you don't want to use a HashMap for this", "label": {"api": {"HashMap": [[37, 43]]}}}, {"text": "Finally, if you don't want duplicate objects consider using a Set", "label": {"api": {"Set": [[62, 64]]}}}, {"text": "On Unix, one way is using the ManagementFactory to get the OperatingSystemMxBean and if it is a UnixOperatingSystemMXBean, you can use the getOpenFileDescriptorCount() method", "label": {"api": {"ManagementFactory": [[30, 46]], "OperatingSystemMxBean": [[59, 79]]}}}, {"text": "The API docs for those constructors are as-follows (respectively)", "label": {"api": {"API docs": [[4, 11]]}}}, {"text": "But Collections.shuffle(List<?> list) uses new Random() by default which uses a 48-bit seed and can therefore only create 2^48 unique shuffles - which is only 3.49*10^(-52) percent of all possible shuffles", "label": {"api": {"48-bit seed": [[80, 90]]}}}, {"text": "The javadoc of Object.equals() explains the rules you need to follow to correctly override the method", "label": {"api": {"The javadoc of Object.equals()": [[0, 29]]}}}, {"text": "Actions (with AbstractAction) allow you to do what you want", "label": {"api": {"Action": [[0, 5], [22, 27]], "AbstractAction": [[14, 27]]}}}, {"text": "Why not use java.util.concurrent.BlockingQueue", "label": {"api": {"java.util.concurrent.BlockingQueue": [[12, 45]]}}}, {"text": "The SynchronousQueue class will give a one-to-one correspondence between putting and taking from the queue, so you won't rack up a large stash of unprocessed or unwritten integers, which can be good for memory but bad if the thread creating the stash hangs for some reason", "label": {"api": {"SynchronousQueue": [[4, 19]]}}}, {"text": "Other implementations such as LinkedBlockingQueue allow a buildup of elements sup to a fixed capacity, which improves performance while it's running but also might waste CPU time and memory generating unused elements", "label": {"api": {"LinkedBlockingQueue": [[30, 48]]}}}, {"text": "But a more correct way would be to use Graphics.drawString", "label": {"api": {"Graphics.drawString": [[39, 57]]}}}, {"text": "Isn't Picture supposed to be the Image class, with the import java.awt.Image; added on top of your class", "label": {"api": {"Image": [[33, 37], [71, 75]]}}}, {"text": "Your Files.newOutputStream(....) method call needs to have the TRUNCATE_EXISTING option set as well as the WRITE OPTION", "label": {"api": {"TRUNCATE_EXISTING": [[63, 79]]}}}, {"text": "If it's outside the jar I just use FileInputStream", "label": {"api": {"FileInputStream": [[35, 49]]}}}, {"text": "The java.io.InputStream.close() method is declared to throw an IOException", "label": {"api": {"java.io.InputStream.close()": [[4, 30]]}}}, {"text": "If you want to stop a task executing, cancel it", "label": {"api": {"cancel": [[38, 43]]}}}, {"text": "Besides that, your cancel task will be scheduled to run as soon as the StreamManager is initialized - if there is a gap between initialize and run you could get into trouble", "label": {"api": {"cancel": [[19, 24]]}}}, {"text": "I would suggest to create and schedule a new task right before attempting to read from the socket, and cancel it after the read succeeded", "label": {"api": {"cancel": [[103, 108]]}}}, {"text": "Write unit tests and perhaps small integration tests to verify that the cancelling works", "label": {"api": {"cancel": [[72, 77]]}}}, {"text": "MouseEvent extends EventObject which has the method getSource()", "label": {"api": {"MouseEvent": [[0, 9]], "getSource()": [[52, 62]]}}}, {"text": "As an aside, it is better to add an ActionListener to buttons, since it will react not only to the mouse, but also to the keyboard", "label": {"api": {"ActionListener": [[36, 49]]}}}, {"text": "You can use JTextPane for this purpose", "label": {"api": {"JTextPane": [[12, 20]]}}}, {"text": "You can use addWindowListener", "label": {"api": {"addWindowListener": [[12, 28]]}}}, {"text": "See void windowClosing(WindowEvent e) and Class WindowAdapter too", "label": {"api": {"void windowClosing(WindowEvent e)": [[4, 36]], "Class WindowAdapter": [[42, 60]]}}}, {"text": "You should use getSelectedIndex() to retrieve the selected item and use it to set the next", "label": {"api": {"getSelectedIndex()": [[15, 32]]}}}, {"text": "Use JList.setModel to set your own instance of the DefaultListModel", "label": {"api": {"JList.setMode": [[4, 16]], "DefaultListModel": [[51, 66]]}}}, {"text": "One way would be returning Character, a wrapper around the char primitive", "label": {"api": {"Character": [[27, 35]]}}}, {"text": "Get the TableView  from your TableCell", "label": {"api": {"TableCell": [[29, 37]]}}}, {"text": "Then,  the TablePosition from the first SelectionModel", "label": {"api": {"TablePosition": [[11, 23]], "SelectionModel": [[40, 53]]}}}, {"text": "Use createXMLEventReader(InputStream stream, String encoding) with UTF-16 as encoding", "label": {"api": {"createXMLEventReader(InputStream stream, String encoding)": [[4, 60]]}}}, {"text": "Anyway, the item class is too similar to the concept of Future", "label": {"api": {"Future": [[56, 61]]}}}, {"text": "If you store Future implementation as map values (e.g", "label": {"api": {"Future": [[13, 18]]}}}, {"text": "FutureTask), your problem is solved", "label": {"api": {"Future": [[0, 5]], "FutureTask": [[0, 9]]}}}, {"text": "getClass will return to you a Class object", "label": {"api": {"Class object": [[30, 41]]}}}, {"text": "The Class object contains a method called getName", "label": {"api": {"Class object": [[4, 15]], "getName": [[42, 48]]}}}, {"text": "Random#nextInt accepts an integer value as its upper bound", "label": {"api": {"Random#nextInt": [[0, 13]]}}}, {"text": "If you need a sorted map take a look at TreeMap", "label": {"api": {"TreeMap": [[40, 46]]}}}, {"text": "Maybe there is more to it, but XMLEventReader delivers XMLEvent-Objects that give you a little more flexibility and functionality whereas XMLStreamReader does not create these Objects for you", "label": {"api": {"XMLEventReader": [[31, 44]], "XMLEvent": [[31, 38], [55, 62]], "XMLStreamReader": [[138, 152]]}}}, {"text": "Therefore, XMLStreamReader is performing better while XMLEventReader gives you some more functionality out of the box", "label": {"api": {"XMLEventReader": [[54, 67]], "XMLEvent": [[54, 61]], "XMLStreamReader": [[11, 25]]}}}, {"text": "Where yourJson can be a String, any Reader, a JsonReader or a JsonElement", "label": {"api": {"String": [[24, 29]], "Reader": [[36, 41], [50, 55]]}}}, {"text": "A better hash would make use of the built-in Arrays class from java.util (http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[74, 135]]}}}, {"text": "To implement compareTo, you'll want your class to implement Comparable", "label": {"api": {"Comparable": [[60, 69]]}}}, {"text": "You can add a listener to be notified of selection events", "label": {"api": {"add a listener": [[8, 21]]}}}, {"text": "You'll want to create a class that implements ListSelectionListener, then use that to do whatever you want to do when something is selected", "label": {"api": {"ListSelectionListener": [[46, 66]]}}}, {"text": "with higher permission levels, so it would make more sense to install/remove the shortcuts and menu items using the IntegrationService - which allows an app", "label": {"api": {"IntegrationService": [[116, 133]]}}}, {"text": "To transport arbitrary data via url parameters you have to use the format as it's generated by UrlEncoder with all that % and hex numbers", "label": {"api": {"UrlEncoder": [[95, 104]]}}}, {"text": "You can see this in the Javadoc for BigInteger#longValue()", "label": {"api": {"Javadoc for BigInteger#longValue()": [[24, 57]]}}}, {"text": "The reason is that the equals method doesn't depend on generics to work correctly", "label": {"api": {"equals": [[23, 28]]}}}, {"text": "If this happens to be SingularNode<String> and you compare it with a SingularNode<Integer>, then ((SingularNode<?>)other).value.equals(value) is perfectly fine because calling Integer.equals with a String argument will correctly return false", "label": {"api": {"equals": [[128, 133], [184, 189]]}}}, {"text": "Use a StringBuilder (I assume you don't need synchronization)", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "The time complexity of the above code is O(n log (n)), as stated in the Javadoc for Arrays.sort()", "label": {"api": {"Arrays.sort()": [[84, 96]]}}}, {"text": "Have the child class return an instance of an Action instead", "label": {"api": {"Action": [[46, 51]]}}}, {"text": "I need to be able to write an instance of this database to a file, but the Field object doesn't implement serializable and is final", "label": {"api": {"Field object": [[75, 86]]}}}, {"text": "All objects in Java inherit from the class Object", "label": {"api": {"Object": [[43, 48]]}}}, {"text": "If you look at that document, you'll see that Object specifies a toString method which converts the object into a String", "label": {"api": {"Object": [[46, 51]]}}}, {"text": "Since all non-primitive types (including Classes) are Objects, anything can be converted into a string using its toString method", "label": {"api": {"Object": [[54, 59]]}}}, {"text": "For example, the String class overrides Object.toString to return itself", "label": {"api": {"Object": [[40, 45]]}}}, {"text": "The easiest solution seems to be to transform your StringBuilder to a String, use the replace() method, and then just replace the StringBuilder with a new one", "label": {"api": {"replace()": [[86, 94]]}}}, {"text": "You can achiveve that using String's split() method", "label": {"api": {"String's split() method": [[28, 50]]}}}, {"text": "You can use String#substring", "label": {"api": {"String#substring": [[12, 27]]}}}, {"text": "Add a WindowListener for the closing event", "label": {"api": {"WindowListener": [[6, 19]]}}}, {"text": "For more help, look at this tutorial on WindowListener's", "label": {"api": {"WindowListener": [[40, 53]]}}}, {"text": "In Java we compare strings with String#equals", "label": {"api": {"String#equals": [[32, 44]]}}}, {"text": "response.getSOAPBody() will give you a Dom node for the body, getting to its children won't be any different from navigating a normal Dom tree", "label": {"api": {"response.getSOAPBody()": [[0, 21]]}}}, {"text": "To test strings for equality, use String.equals()", "label": {"api": {"String.equals()": [[34, 48]]}}}, {"text": "If you want case-insensitive matching, there's also String.equalsIgnoreCase()", "label": {"api": {"String.equalsIgnoreCase()": [[52, 76]]}}}, {"text": "Easier is to realise that the File object has an isDirectory method, which would seem as if it were written to answer this very question", "label": {"api": {"File": [[30, 33]], "isDirectory": [[49, 59]]}}}, {"text": "Iterator is a generic interface, but your ListIterator is neither generic nor parameterizes Iterator", "label": {"api": {"Iterator is a generic interface": [[0, 30]]}}}, {"text": "The simplest might be just to use java.util.Timer which will allow you to schedule a TimerTask to be executed at some time in the future..", "label": {"api": {"java.util.Timer": [[34, 48]]}}}, {"text": "You could also take a look at ScheduledExecutorService which I believe is it's Executor equivalent", "label": {"api": {"ScheduledExecutorService": [[30, 53]]}}}, {"text": "Starting from Java 8, the suggested way is to use the Date-Time API rather than Calendar", "label": {"api": {"Date-Time API": [[54, 66]]}}}, {"text": "Returns the \"logical size\" of this BitSet", "label": {"api": {"size": [[21, 24]]}}}, {"text": "your bitSet is fine, as would have been clear if you had used the size method", "label": {"api": {"size": [[66, 69]]}}}, {"text": "Javadoc for BitSet#length(),says Returns the \"logical size\" of this BitSet", "label": {"api": {"BitSet#length()": [[12, 26]]}}}, {"text": "Please refer the documentations of getMethod() and inovke() methods", "label": {"api": {"getMethod()": [[35, 45]], "inovke()": [[51, 58]]}}}, {"text": "In your case, you're trimming the String in your isEmpty method", "label": {"api": {"trimming": [[21, 28]]}}}, {"text": "The only difference that can occur now can't occur (the case you gives it \" \") because you're trimming it (Removing the trailing whitespace - which is in this case is like removing all spaces)", "label": {"api": {"trimming": [[94, 101]]}}}, {"text": "Java's DataOutputStream.writeUTF adds the number of bytes send as the first byte", "label": {"api": {"DataOutputStream": [[7, 22]], "writeUTF": [[24, 31]]}}}, {"text": "If you want it this way use an OutputStreamWriter with the encoding UTF-8", "label": {"api": {"OutputStreamWriter": [[31, 48]]}}}, {"text": "You're trying to re-invent an ExecutorService", "label": {"api": {"ExecutorService": [[30, 44]]}}}, {"text": "Look at Jon Skeet's answer, and then look at the TableModel interface, documented at  http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html": [[86, 159]]}}}, {"text": "You will need to copy it - there are several ways to do it, for example", "label": {"api": {"for example": [[60, 70]]}}}, {"text": "Alternatively you can use a list and call the subList method which avoids the copy", "label": {"api": {"the subList method": [[42, 59]]}}}, {"text": "If the number of pattern letters is 3 or more, the month is interpreted as text; otherwise, it is interpreted as a number", "label": {"api": {"text": [[75, 78]], "number": [[7, 12], [115, 120]]}}}, {"text": "Click the link behind \"text\" in the documentation", "label": {"api": {"text": [[23, 26]]}}}, {"text": "For formatting, if the number of pattern letters is 4 or more, the full form is used; otherwise a short or abbreviated form is used if available", "label": {"api": {"number": [[23, 28]]}}}, {"text": "For parsing, both forms are accepted, independent of the number of pattern letters", "label": {"api": {"number": [[57, 62]]}}}, {"text": "Try using DefaultTreeModel", "label": {"api": {"DefaultTreeModel": [[10, 25]]}}}, {"text": "Take a look at the javadoc for @UniqueConstraint", "label": {"api": {"Take a look at the javadoc for @UniqueConstraint": [[0, 47]]}}}, {"text": "Use the built-in String method replaceAll, with a regular expression \"/+\", replacing one or more slashes with one slash", "label": {"api": {"replaceAll": [[31, 40]]}}}, {"text": "IllegalMonitorStateException ,Thrown to indicate that a thread has attempted to wait on an object's monitor or to notify other threads waiting on an object's monitor without owning the specified monitor", "label": {"api": {"IllegalMonitorStateException": [[0, 27]]}}}, {"text": "It behaves as defined in the javadoc", "label": {"api": {"in the javadoc": [[22, 35]]}}}, {"text": "To also get the trailing empty string, you can use the other split method, that takes two arguments", "label": {"api": {"the other split method, that takes two arguments": [[51, 98]]}}}, {"text": "I am getting started on Java concurrency features and while here at the interface ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[82, 105]]}}}, {"text": "to throw a RuntimeException", "label": {"api": {"RuntimeException": [[11, 26]]}}}, {"text": "Could you use an HttpSession", "label": {"api": {"HttpSession": [[17, 27]]}}}, {"text": "To compare string values, use String#equals instead", "label": {"api": {"String#equals": [[30, 42]]}}}, {"text": "You can add a ComponentListener to your frame and check into componentResized(ComponentEvent e) if the new values for width&height are allowed and, in case they are, you resize the frame through setSize", "label": {"api": {"ComponentListener": [[14, 30]]}}}, {"text": "Generic Jlist introduced in JDK 7 while in case of older version this feature was not availible", "label": {"api": {"Generic Jlist": [[0, 12]], "older version": [[51, 63]]}}}, {"text": "Java SE comes with a standard tool for doing just this, the Robot class", "label": {"api": {"Robot": [[60, 64]]}}}, {"text": "This method returns a Set of keys (for more info, Docs from Oracle about Map)", "label": {"api": {"Docs from Oracle about Map": [[50, 75]]}}}, {"text": "Get an URL of the plugin file using getResource(), then open an input stream on it", "label": {"api": {"getResource()": [[36, 48]]}}}, {"text": "You should instead extract that from the jar (using ClassLoader.getResourceAsStream(), perhaps?), save it to a temporary file, and then point Ant to that instead", "label": {"api": {"save it to a temporary file": [[98, 124]]}}}, {"text": "If you have not overridden the toString() method in your object's class, it will invokes the default implementation defined in the Object class, which says", "label": {"api": {"toString()": [[31, 40]]}}}, {"text": "So, you will get the hashCode() representation of the Object , which may or may not be its address as it is implementation dependent", "label": {"api": {"hashCode()": [[21, 30]]}}}, {"text": "This is what Javadoc says about hashCode()", "label": {"api": {"hashCode()": [[32, 41]]}}}, {"text": "By default the name attribute of a component is not set so this must be done explicitly before getName() will return a value", "label": {"api": {"getName()": [[95, 103]]}}}, {"text": "Just use the Thread.join() method", "label": {"api": {"Thread.join()": [[13, 25]]}}}, {"text": "Why is org.w3c.dom.NodeList not an extension of java.lang.Iterable interface", "label": {"api": {"org.w3c.dom.NodeList": [[7, 26]], "java.lang.Iterable": [[48, 65]]}}}, {"text": "One solution for this is to use shared Semaphores to lock each thread until the other one has finished its task", "label": {"api": {"Semaphore": [[39, 47]]}}}, {"text": "How about JPA 2.1 ConstructorResult", "label": {"api": {"ConstructorResult": [[18, 34]]}}}, {"text": "Check the Collator class", "label": {"api": {"the Collator class": [[6, 23]]}}}, {"text": "You can find all date and time pattern symbols on the SimpleDateFormat Javadoc page", "label": {"api": {"SimpleDateFormat Javadoc page": [[54, 82]]}}}, {"text": "You can use the substring method of String", "label": {"api": {"substring": [[16, 24]]}}}, {"text": "You are misusing Random", "label": {"api": {"Random": [[17, 22]]}}}, {"text": "You have invoked the Random constructor that sets the initial seed to a specific value", "label": {"api": {"Random": [[21, 26]]}}}, {"text": "The nextInt() method returns a random, unrestricted int", "label": {"api": {"nextInt()": [[4, 12]]}}}, {"text": "The nextInt(int) method restricts the random integers returned to the range 0 to i - 1", "label": {"api": {"nextInt(int)": [[4, 15]]}}}, {"text": "Also, the parameterless Random constructor uses the system time to generate a different random seeding (and thus different random numbers) each time", "label": {"api": {"Random": [[24, 29]]}}}, {"text": "Random numbers in Java using Random are pseudo-random - they are deterministic but they require a seed to get started", "label": {"api": {"Random": [[0, 5], [29, 34]]}}}, {"text": "That's why it's important to use different seeds each time, and the parameterless Random constructor handles that for you", "label": {"api": {"Random": [[82, 87]]}}}, {"text": "In addition, you don't need to be creating another Random object each time your rand object is called", "label": {"api": {"Random": [[51, 56]]}}}, {"text": "You thought you used Random#nextInt(bound) instead, which yields the random integer within the range 0 (incl.) - bound (excl.)", "label": {"api": {"Random#nextInt(bound)": [[21, 41]]}}}, {"text": "I think you're looking for LinkedHashMap<K, V>", "label": {"api": {"LinkedHashMap<K, V>": [[27, 45]], "HashMap<K, V>": [[33, 45]]}}}, {"text": "And yes, you're right that HashMap<K, V> doesn't maintain any documented order", "label": {"api": {"HashMap<K, V>": [[27, 39]]}}}, {"text": "You have to set the options in JavaCompiler.getTask (see JavaCompiler javadoc)", "label": {"api": {"JavaCompiler javadoc": [[57, 76]]}}}, {"text": "You can also use String.format for that", "label": {"api": {"String.format": [[17, 29]]}}}, {"text": "For instance, PrintStream (the class of System.out) implements a print(Object) method that relies on it", "label": {"api": {"PrintStream": [[14, 24]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/lang/String.html  For example, the split() method", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[0, 61]]}}}, {"text": "You can do this by using the addBatch(String) method on Statement", "label": {"api": {"addBatch(String)": [[29, 44]]}}}, {"text": "Parent, Child) and only commit if all succeed", "label": {"api": {"commit": [[24, 29]]}}}, {"text": "Use a SimpleDateFormat object to extract the date and put it into a util.Date object", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "You can use SimpleDateFormat from standard library", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Reference these formats Java Date Format Docs", "label": {"api": {"Java Date Format Docs": [[24, 44]]}}}, {"text": "the structure of a database using Connection.getMetaData()", "label": {"api": {"Connection.getMetaData()": [[34, 57]]}}}, {"text": "If we knew the overall number of threads, we could use CountDownLatch initialized with the number of threads", "label": {"api": {"CountDownLatch": [[55, 68]]}}}, {"text": "But as we don't know the number of threads, we need an extended CountDownLatch which allows to increase the counter after its creation", "label": {"api": {"CountDownLatch": [[64, 77]]}}}, {"text": "Unfortunately we cannot just extend the class CountDownLatch as underlying counter is private", "label": {"api": {"CountDownLatch": [[46, 59]]}}}, {"text": "One way is to duplicate the original code of CountDownLatch to make access to the underlying counter", "label": {"api": {"CountDownLatch": [[45, 58]]}}}, {"text": "Less verbose way is to extend Semaphore to get access to the reducePermits method as it is done in Reduceable Semaphore", "label": {"api": {"Semaphore": [[30, 38], [110, 118]]}}}, {"text": "In principle, CountDownLatch and Semaphore are similar tools but differ in interpretation of the internal counter", "label": {"api": {"CountDownLatch": [[14, 27]], "Semaphore": [[33, 41]]}}}, {"text": "If you've Java 7, then you could use the Files#copy to directly copy the file from source to target", "label": {"api": {"Files#copy": [[41, 50]]}}}, {"text": "System.out performs transcoding operations from UTF-16 strings to the default JRE character encoding", "label": {"api": {"default JRE character encoding": [[70, 99]]}}}, {"text": "If you are using a terminal, the Console does a better job of determining the device encoding", "label": {"api": {"the Console": [[29, 39]]}}}, {"text": "it is better to use the try-with-resources or at least try-finally to close streams; use the standard encoding constants if available", "label": {"api": {"the standard encoding constants": [[89, 119]]}}}, {"text": "Considering the java documentation FileWriter, you can directly write things to a file using the FileWriter, without using a BufferedWriter", "label": {"api": {"FileWriter": [[35, 44], [97, 106]]}}}, {"text": "Use ArrayList instead", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "ArrayList is dynamically-extendable", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "You can create ArrayList both for rows and cols", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "As ArrayList is a template class, you are able to create ArrayList<ArrayList<double>>, or if you want to have a \"static\" number of rows, you can create ArrayList<double[2]>", "label": {"api": {"ArrayList": [[3, 11], [57, 65], [67, 75], [152, 160]]}}}, {"text": "This can be achieve by using a Java agent", "label": {"api": {"Java agent": [[31, 40]]}}}, {"text": "A Java agent can be installed at application startup via the command line or at runtime via the Attach API", "label": {"api": {"Java agent": [[2, 11]]}}}, {"text": "The Date object in Java uses universal time (UTF) internally", "label": {"api": {"universal time (UTF)": [[29, 48]]}}}, {"text": "When formatting a date for a user, you can use setTimezone in DateFormatter and everything else should work fine", "label": {"api": {"setTimezone": [[47, 57]]}}}, {"text": "For the full list of options, check the JavaDoc of java.util.Formatter", "label": {"api": {"the JavaDoc of java.util.Formatter": [[36, 69]]}}}, {"text": "MessageFormat is what you are looking for", "label": {"api": {"MessageFormat": [[0, 12]]}}}, {"text": "Have a look at the Java API documentation for exec", "label": {"api": {"Java API documentation for exec": [[19, 49]]}}}, {"text": "See Java API documentation", "label": {"api": {"Java API documentation": [[4, 25]]}}}, {"text": "Use the following constructor for TextArea", "label": {"api": {"following constructor": [[8, 28]]}}}, {"text": "To represent 5.0E22 you should either use BigDecimal or else use a library that has a Rational data type, e.g", "label": {"api": {"BigDecimal": [[42, 51]]}}}, {"text": "Try taking a look at RecursiveAction as well", "label": {"api": {"RecursiveAction": [[21, 35]]}}}, {"text": "Then use the ResourceBundle and let it detect the language and load the appropriate file", "label": {"api": {"ResourceBundle": [[13, 26]]}}}, {"text": "Just use String.replace", "label": {"api": {"String.replace": [[9, 22]]}}}, {"text": "A superclass fields cannot be serialized if it is not Serializable.Here is a summary of some rules of Java serialization", "label": {"api": {"Serializable": [[54, 65]]}}}, {"text": "An object is serializable only if its class or its superclass implements the Serializable (or  Externalizable) interface", "label": {"api": {"Serializable": [[77, 88]], "Externalizable": [[95, 108]]}}}, {"text": "An object is serializable (itself implements the Serializable interface) even if its superclass is not", "label": {"api": {"Serializable": [[49, 60]]}}}, {"text": "However, the firstsuperclass in the hierarchy of the serializable class, that does not   implements Serializable interface, MUST have a no-arg constructor", "label": {"api": {"Serializable": [[100, 111]]}}}, {"text": "If this is violated, readObject() will produce a java.io.InvalidClassException in runtime", "label": {"api": {"java.io.InvalidClassException": [[49, 77]]}}}, {"text": "A class that implements Serializablemust mark -transient fields of classes that do not support serialization (e.g., a file stream)", "label": {"api": {"Serializable": [[24, 35]]}}}, {"text": "You pass System.arraycopy the array, not the array element", "label": {"api": {"System.arraycopy": [[9, 24]]}}}, {"text": "Java has provided a rich set of APIs in java.util.concurrent package to achieve such tasks", "label": {"api": {"java.util.concurrent": [[40, 59]]}}}, {"text": "One of these APIs is ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "This code will execute the Runnable task after every 30 seconds for upto 5 minutes", "label": {"api": {"Runnable": [[27, 34]]}}}, {"text": "Did u try javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[10, 26]]}}}, {"text": "I would recommend java.util.Timer if you are not using Swing for GUI/Graphics (not familiar with CraftBukkit, so that will be up to you to determine)", "label": {"api": {"java.util.Timer": [[18, 32]]}}}, {"text": "There are methods like System.gc() and Runtime.gc() which is used to send request of Garbage collection to JVM but its not guaranteed that garbage collection will happen", "label": {"api": {"System.gc()": [[23, 33]], "Runtime.gc()": [[39, 50]]}}}, {"text": "The docs for ObjectInputStream say", "label": {"api": {"ObjectInputStream": [[13, 29]]}}}, {"text": "An ObjectInputStream deserializes primitive data and objects previously written using an ObjectOutputStream..", "label": {"api": {"ObjectInputStream": [[3, 19]]}}}, {"text": "Also , never create more than one JFrame in an application", "label": {"api": {"JFrame": [[34, 39]]}}}, {"text": "To achieve such tasks you can use JOptionPane or JDialog or JInternalFrames", "label": {"api": {"JOptionPane": [[34, 44]], "JDialog": [[49, 55]], "JInternalFrames": [[60, 74]]}}}, {"text": "The Iterable interface allows the \"foreach\" syntax to work, so the cleanest way is likely", "label": {"api": {"Iterable": [[4, 11]]}}}, {"text": "It's better to use JTable in your case", "label": {"api": {"JTable": [[19, 24]]}}}, {"text": "Additionally, store the result of Math.pow in a new variable -- a double, because that's what Math.pow returns", "label": {"api": {"Math.pow": [[34, 41], [94, 101]]}}}, {"text": "Or you can use iterator", "label": {"api": {"iterator": [[15, 22]]}}}, {"text": "What you seem to be rewriting here is a ArrayList", "label": {"api": {"ArrayList": [[40, 48]]}}}, {"text": "What you could try to do, instead of using Regular Expressions, is to use a Normalizer", "label": {"api": {"Normalizer": [[76, 85]]}}}, {"text": "To detect such failures, you'll need to examine the Future instance that results from each call to submit()", "label": {"api": {"examine": [[40, 46]], "Future": [[52, 57]]}}}, {"text": "There are other methods for submitting a list of tasks in bulk, and waiting for them to complete, that might be better suited to your application", "label": {"api": {"other methods for submitting a list of tasks": [[10, 53]]}}}, {"text": "To compare String values, use String#equals instead", "label": {"api": {"String#equals": [[30, 42]]}}}, {"text": "You can check this doc for more information", "label": {"api": {"this doc": [[14, 21]]}}}, {"text": "Assign it back to string str variable, .String#replaceAll doesn't changes the string itself, it returns a new String", "label": {"api": {"String#replaceAll": [[40, 56]]}}}, {"text": "ResourceBundles can help you", "label": {"api": {"ResourceBundles": [[0, 14]]}}}, {"text": "Host the existing JSF application in a WebView, incrementally enhancing and migrating parts of it to pure JavaFX on an as required/time permits basis", "label": {"api": {"WebView": [[39, 45]]}}}, {"text": "WebView is not a full browser engine only an HTML viewer, so if you need a bit more functionality, you could adapt something like Willow or WebFX to handle some of the page navigation aspects that a browser normally would do", "label": {"api": {"WebView": [[0, 6]]}}}, {"text": "Having read this oracle java link I would like to know what the writers of this class exactly meant by the term \"Random\", if the buffer has its own position, limit, capacity indicators", "label": {"api": {"link": [[29, 32]]}}}, {"text": "For that, use the object StandardCharsets.US_ASCII", "label": {"api": {"StandardCharsets.US_ASCII": [[25, 49]]}}}, {"text": "The method HttpServletResponse.setDateHeader adds an HTTP date header for a given time-stamp", "label": {"api": {"HttpServletResponse.setDateHeader": [[11, 43]]}}}, {"text": "Object[] toArray(), returns an Object[] which cannot be cast to String[] or any other type array", "label": {"api": {"Object[] toArray()": [[0, 17]]}}}, {"text": "Use File.length() to obtain the size number of bytes of the file", "label": {"api": {"File.length()": [[4, 16]]}}}, {"text": "One option is to use Timers/TimerTasks to schedule commands - here is a tutorial", "label": {"api": {"Timers": [[21, 26]], "TimerTasks": [[28, 37]]}}}, {"text": "Another option is to put the commands in a DelayQueue (with the delay set to the time that the task should fire), then use a consumer thread to repeatedly call take on the queue and fire the commands it removes", "label": {"api": {"DelayQueue": [[43, 52]]}}}, {"text": "Use the builtin java.util.Timer class to schedule code to run at a given future time or after a given delay", "label": {"api": {"the builtin java.util.Timer class": [[4, 36]]}}}, {"text": "removeLast() is a method of LinkedList", "label": {"api": {"removeLast()": [[0, 11]], "LinkedList": [[28, 37]]}}}, {"text": "To remove the last element of ArrayList, use", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "Use SimpleDateFormat twice", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Double.TYPE == double.class will return true", "label": {"api": {"Double": [[0, 5]]}}}, {"text": "Double.class != Double.TYPE will also return true", "label": {"api": {"Double": [[0, 5], [16, 21]]}}}, {"text": "They (double.class and Double.TYPE) somehow represent the same thing, don't ask me why..", "label": {"api": {"Double": [[23, 28]]}}}, {"text": "If you want to compare against Double, compare against Double.class", "label": {"api": {"Double": [[31, 36], [55, 60]]}}}, {"text": "If you want to compare against double, compare against double.class or Double.TYPE", "label": {"api": {"Double": [[71, 76]]}}}, {"text": "If you think you need to override hashCode(), then you need to override equals() and vice versa", "label": {"api": {"hashCode()": [[34, 43]]}}}, {"text": "The general contract of hashCode() is", "label": {"api": {"hashCode()": [[24, 33]]}}}, {"text": "Use new String(value, offset, count), reference", "label": {"api": {"reference": [[38, 46]]}}}, {"text": "MappedByteBuffer is a subclass of ByteBuffer on which you can call asCharBuffer", "label": {"api": {"ByteBuffer": [[6, 15], [34, 43]], "CharBuffer": [[69, 78]]}}}, {"text": "That returns a CharBuffer which implements Readable, which can then be supplied to Scanner", "label": {"api": {"CharBuffer": [[15, 24]], "Scanner": [[83, 89]]}}}, {"text": "That way you can use Scanner on the file via MappedByteBuffer", "label": {"api": {"ByteBuffer": [[51, 60]], "Scanner": [[21, 27]]}}}, {"text": "As another alternative check out CharBuffer, which is backed by a char[]", "label": {"api": {"CharBuffer": [[33, 42]]}}}, {"text": "Say that I want to make a button in Java in such a way so that when you click on it, a JPopupMenu appears", "label": {"api": {"JPopupMenu": [[87, 96]]}}}, {"text": "The relevant code for it appearing is menu.show(button, button.getWidth()/2, button.getHeight()/2);, which makes the JPopupMenu be displayed with its top left corner at the center of the button, as shown below", "label": {"api": {"JPopupMenu": [[117, 126]]}}}, {"text": "I tried to make this happen by getting the height of the JPopupMenu and adding it to the y coordinate that the popup menu is being displayed at, but I found out that the JPopupMenu has a height of 0 before it is visible, which doesn't help me since I'm trying to tell the computer where to make it visible", "label": {"api": {"JPopupMenu": [[57, 66], [170, 179]]}}}, {"text": "How can I make it so my JPopupMenu with an unknown height can be displayed so that it's bottom left coordinate matches a given coordinate", "label": {"api": {"JPopupMenu": [[24, 33]]}}}, {"text": "There are methods in java.util.Collections that do almost what you need; unfortunately, they don't check the type of elements in the original wrapped collection", "label": {"api": {"There are methods in java.util.Collections": [[0, 41]]}}}, {"text": "I'm not quite sure what output you require, but the BufferedReader class will allow you to read a text file line by line", "label": {"api": {"BufferedReader": [[52, 65]]}}}, {"text": "Testing is expression null is done via predicate returned from CriteriaBuilder.isNull(Expression)", "label": {"api": {"CriteriaBuilder.isNull(Expression)": [[63, 96]]}}}, {"text": "Adhere to the Oracle Swing Threading Policy", "label": {"api": {"Oracle Swing Threading Policy": [[14, 42]]}}}, {"text": "You'll notice that this class implements Comparable<Product> and has a method compareTo", "label": {"api": {"Comparable<Product>": [[41, 59]]}}}, {"text": "In this case, you need Comparators", "label": {"api": {"Comparators": [[23, 33]]}}}, {"text": "You can use a DecimalFormat to generate a representation with a fixed number of digits, then transfer that string to the database and let it handle conversion to internal representation on the database server", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "Well, you can also go by yourself using Timer and TimerTask, otherwise", "label": {"api": {"Timer": [[40, 44], [50, 54]], "TimerTask": [[50, 58]]}}}, {"text": "It is sorting lexicographically (the default sort method)", "label": {"api": {"default": [[37, 43]]}}}, {"text": "A LinkedHashSet should fit the bill", "label": {"api": {"LinkedHashSet": [[2, 14]]}}}, {"text": "You want an ordered set, which is implemented by LinkedHashSet", "label": {"api": {"LinkedHashSet": [[49, 61]]}}}, {"text": "As far as I can tell from the information posted you're getting a List of Elements", "label": {"api": {"List": [[66, 69]], "Elements": [[74, 81]]}}}, {"text": "I'm not 100% this would work but I believe what you're looking for is DecimalFormat", "label": {"api": {"DecimalFormat": [[70, 82]]}}}, {"text": "It's very easy (and more efficient) using Java 7's FileSystem WatchService (see 45 lines of example code here)", "label": {"api": {"FileSystem": [[51, 60]], "WatchService": [[62, 73]]}}}, {"text": "You can get the text from a JTextPane with getText()", "label": {"api": {"getText()": [[43, 51]]}}}, {"text": "If you want to remove duplicates, why not just populate a TreeSet (providing the appropriate Comparator) with your list", "label": {"api": {"TreeSet": [[58, 64]]}}}, {"text": "Is there a regex that works with String.split() to grab (up to) two words at a time, such that", "label": {"api": {"String.split()": [[33, 46]]}}}, {"text": "You can simply use the get method", "label": {"api": {"get": [[23, 25]]}}}, {"text": "You set with put and access with get", "label": {"api": {"get": [[33, 35]]}}}, {"text": "If you want to get a specific element, just chain the get method for ArrayList", "label": {"api": {"get": [[15, 17], [54, 56]]}}}, {"text": "Use Arrays.asList() method to do the same", "label": {"api": {"Arrays.asList()": [[4, 18]]}}}, {"text": "On render, you could either replace the the current bitmap with the one you want to draw, or you can draw the image in place without scaling (much faster than drawing with scaling)", "label": {"api": {"draw the image in place without scaling": [[101, 139]]}}}, {"text": "Note that this is the only situation when Collection#add will return false (other reasons will trigger an exception)", "label": {"api": {"this is the only situation when Collection#add will return false": [[10, 73]]}}}, {"text": "The problem here is that the MessageFormat class uses the locale to format numbers", "label": {"api": {"MessageFormat": [[29, 41]]}}}, {"text": "You could optionally change from using MessageFormat in this case to Integer.toString", "label": {"api": {"MessageFormat": [[39, 51]]}}}, {"text": "With an ArrayList, use the get method to access an element", "label": {"api": {"get": [[27, 29]]}}}, {"text": "By choosing to implement Runnable, you make no demands of what the lineage of the implementer is, and you can use powerful abstractions like the ExecutorService to abstract away the nuts and bolts of running a chunk of code", "label": {"api": {"ExecutorService": [[145, 159]]}}}, {"text": "Use getSelectedIndex() rather than getSelectedItem()", "label": {"api": {"getSelectedIndex()": [[4, 21]]}}}, {"text": "You have created your own ArrayList class and aren't using the built-in Java class", "label": {"api": {"built-in Java class": [[63, 81]]}}}, {"text": "It would be more efficient to use a ThreadPoolExecutor to execute your runnables, however this precludes the option of creating a thread, reading its id, and starting the thread later", "label": {"api": {"ThreadPoolExecutor": [[36, 53]]}}}, {"text": "The input string must conform to the syntax described in the javadocs for Double.valueOf(String)", "label": {"api": {"javadocs for Double.valueOf(String)": [[61, 95]]}}}, {"text": "Graphics.drawImage(Image, int, int, int, int, ImageObserver) method can be used to specify the location along with the size of the image when drawing", "label": {"api": {"Graphics.drawImage(Image, int, int, int, int, ImageObserver)": [[0, 59]]}}}, {"text": "I'm planning to use an instance of DatagramSocket and call its send method from different threads..", "label": {"api": {"send": [[63, 66]]}}}, {"text": "to send UDP packets to different clients", "label": {"api": {"send": [[3, 6]]}}}, {"text": "You are getting the error because there is a checked exception associated with FileOutputStream which you are not catching/throw-declaring", "label": {"api": {"FileOutputStream": [[79, 94]]}}}, {"text": "I would make the class MyObject cloneable by implementing the Cloneable interface, see Cloneable Javadoc", "label": {"api": {"Cloneable Javadoc": [[87, 103]]}}}, {"text": "Java webapps can declare a ServletContextListener to be notified when the application is started and destroyed", "label": {"api": {"ServletContextListener": [[27, 48]]}}}, {"text": "They can also declare an HttpSessionListener to be notified when a session is started and destroyed", "label": {"api": {"HttpSessionListener": [[25, 43]]}}}, {"text": "I've never used a SynchronousQueue but, from the JavaDocs, it might be just what you want", "label": {"api": {"SynchronousQueue": [[18, 33]]}}}, {"text": "You could also use an ArrayBockingQueue with a capacity of 1", "label": {"api": {"ArrayBockingQueue ": [[22, 39]]}}}, {"text": "Use the .clone() method, present in any Java Object subclass, namely, all of them, far as I can tell", "label": {"api": {".clone()": [[8, 15]]}}}, {"text": "It is clear that you can call Math.random() without ever having created an instance of class Math; random() is a static method, that means it is not bound to an instance of the class, it can be used without one", "label": {"api": {"Math.random()": [[30, 42]]}}}, {"text": "You are not using an EventListener, there is no way your program can detect the changes if you don't tell it the selection has changed", "label": {"api": {"EventListener": [[21, 33]]}}}, {"text": "Both FileWriter and FileOutputStream have a constructor taking a boolean append as argument", "label": {"api": {"FileWriter": [[5, 14]], "FileOutputStream": [[20, 35]]}}}, {"text": "java.util.Collections.sort(list) will sort the array in the natural ordering of its elements as long as the elements implent the Compareable interface", "label": {"api": {"java.util.Collections.sort(list)": [[0, 31]], "Compareable": [[129, 139]]}}}, {"text": "You could use String#matches() together with a simple regular expression to see if the input contains only digits", "label": {"api": {"String#matches()": [[14, 29]]}}}, {"text": "Also, if you want to compare two Strings, take a look at String.compareTo", "label": {"api": {"String.compareTo": [[57, 72]]}}}, {"text": "I suggest that you use a BorderLayout, and place your 30px panel in the NORTH position, while your Minecraft applet in the CENTER position", "label": {"api": {"BorderLayout": [[25, 36]]}}}, {"text": "I think you may be able to use java.io.RandomAccessFile http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html": [[56, 125]]}}}, {"text": "You could use java's Runtime and Process class", "label": {"api": {"Process": [[33, 39]]}}}, {"text": "add(E e) and add(int index,E e)", "label": {"api": {"add(E e)": [[0, 7]], "add(int index,E e)": [[13, 30]]}}}, {"text": "See Java 7 Documentation for AclFileAttributeView for how to use them with createFile and createDirectory methods", "label": {"api": {"Java 7 Documentation for AclFileAttributeView": [[4, 48]]}}}, {"text": "Repeatedly use Matcher.find(int start) and Matcher.start() to find out, at which String index to look next", "label": {"api": {"Matcher.find(int start)": [[15, 37]], "Matcher.start()": [[43, 57]]}}}, {"text": "Replace LinkedList<Email> with LinkedBlockingDequeue<Email>, start your thread immediately, and pass it the queue", "label": {"api": {"LinkedBlockingDequeue<Email>": [[31, 58]]}}}, {"text": "Try LinkedHashMap instead", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "Simple, use a CountDownLatch", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "Initialize the CountDownLatch to 1 in the main()", "label": {"api": {"CountDownLatch": [[15, 28]]}}}, {"text": "As you can see in the JavaDocs (http://docs.oracle.com/javase/7/docs/api/javax/swing/JFrame.html#addImpl%28java.awt.Component,%20java.lang.Object,%20int%29), overriding that method, children are added to the contentPane instead of the frame", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JFrame.html#addImpl%28java.awt.Component,%20java.lang.Object,%20int%29": [[32, 154]]}}}, {"text": "If you want only the image files, you can use File.listFiles( FileFilter filter )", "label": {"api": {"File.listFiles( FileFilter filter )": [[46, 80]]}}}, {"text": "Try using a PixelGrabber", "label": {"api": {"PixelGrabber": [[12, 23]]}}}, {"text": "repaint() method is part of java.awt.Component.Point is not a subclass of java.awt.Component", "label": {"api": {"repaint()": [[0, 8]]}}}, {"text": "You cannot reuse the same ResultSet instance for numerous queries", "label": {"api": {"ResultSet": [[26, 34]]}}}, {"text": "One ResultSet instance can only be used only to fetch the results of one query", "label": {"api": {"ResultSet": [[4, 12]]}}}, {"text": "Moreover as written in the ResultSet JavaDoc", "label": {"api": {"ResultSet": [[27, 35]]}}}, {"text": "ResultSet object is automatically closed when the Statement object that generated it is closed, re-executed, or used to retrieve the next result from a sequence of multiple results", "label": {"api": {"ResultSet": [[0, 8]]}}}, {"text": "Take a look at Document", "label": {"api": {"Document": [[15, 22]]}}}, {"text": "Every text component in Swing has a Document model which controls the state of the text (and where applicable, the attributes and structure)", "label": {"api": {"Document": [[36, 43]]}}}, {"text": "You can use the JTextArea's Document to remove characters directly", "label": {"api": {"Document": [[28, 35]]}}}, {"text": "Just change Exception to NumberFormatException and you should be fine", "label": {"api": {"NumberFormatException": [[25, 45]]}}}, {"text": "What you need is matcher.find() and Long.valueOf()", "label": {"api": {"matcher.find()": [[17, 30]], "Long.valueOf()": [[36, 49]]}}}, {"text": "A Fork/Join framework was introduced in Java 7", "label": {"api": {"Fork/Join": [[2, 10]]}}}, {"text": "Use the character version of replace instead of the string version", "label": {"api": {"character version of replace": [[8, 35]]}}}, {"text": "java.lang.Double is a subclass of java.lang.Number", "label": {"api": {"java.lang.Double": [[0, 15]], "java.lang.Number": [[34, 49]]}}}, {"text": "Hence the posted code shouldn't show any compilation error if you are returning a java.lang.Double from a method which returns java.lang.Number", "label": {"api": {"java.lang.Double": [[82, 97]], "java.lang.Number": [[127, 142]]}}}, {"text": "Please double check to see if you are using java.lang.Double and java.lang.Number", "label": {"api": {"java.lang.Double": [[44, 59]], "java.lang.Number": [[65, 80]]}}}, {"text": "To add the Map to the List , use add(E e) method", "label": {"api": {"add(E e)": [[33, 40]]}}}, {"text": "is much better with CPU, but is \"subject to the precision and accuracy of system timers and schedulers\" (http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#sleep(long))", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#sleep(long)": [[105, 178]]}}}, {"text": "Basically, what you would do is to use HttpServletRequest.getRequestURL() to parse out the subomain of the request, and then redirect your visitor to the appropriate page", "label": {"api": {"HttpServletRequest.getRequestURL()": [[39, 72]]}}}, {"text": "You could create a redirection-servlet, and use HttpServletRequest#getRequestURL() to distinguish between the URLs requested by the user and redirect based on that", "label": {"api": {"HttpServletRequest#getRequestURL()": [[48, 81]]}}}, {"text": "You can make use of Connection#isValid in order to verify whether or not your connection is still open", "label": {"api": {"Connection#isValid": [[20, 37]]}}}, {"text": "Can you use a Regular expression like \"/(\".*?\"|[^\",\\s]+)(?=\\s*,|\\s*$)/g\" and use split() and check if it works", "label": {"api": {"split()": [[81, 87]]}}}, {"text": "You can use javax.swing.Timer class", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "if you don't care about order a HashSet is a better option which has a fast contains()", "label": {"api": {"HashSet": [[32, 38]]}}}, {"text": "Use a SpinnerDateModel in a JSpinner", "label": {"api": {"SpinnerDateModel": [[6, 21]]}}}, {"text": "Use equals() method of Integer class", "label": {"api": {"equals()": [[4, 11]], "Integer": [[23, 29]]}}}, {"text": "I suggest replacing your Thread.sleep call a PauseTransition", "label": {"api": {"PauseTransition": [[45, 59]]}}}, {"text": "If the name is \"FX Application Thread\" then, you should use another mechanism such as the animation framework or a Task to handle the pause", "label": {"api": {"Task": [[115, 118]]}}}, {"text": "Use the split method which parses a string accorign tot a given delimiter and returns an array out of it", "label": {"api": {"split": [[8, 12]]}}}, {"text": "I see a lot of answers telling you to use Log4J, but you can use Java's own logger to do this by simply creating a FileHandler", "label": {"api": {"FileHandler": [[115, 125]]}}}, {"text": "If you are using Java 7, then you can take advantage of the fact ResultSet extends AutoCloseable and use a try-with-resources statement", "label": {"api": {"ResultSet": [[65, 73]], "AutoCloseable": [[83, 95]]}}}, {"text": "yyyy-MM-dd'T'HH:mm:ss.SSSZ as per the JavaDoc for SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[50, 65]]}}}, {"text": "Arrays.toList(array).contains(x) which does exactly you are doing right now", "label": {"api": {"Arrays.toList(array).contains(x)": [[0, 31]]}}}, {"text": "Arrays.binarySearch(x,array) provided if your array is sorted", "label": {"api": {"Arrays.binarySearch(x,array)": [[0, 27]]}}}, {"text": "A DSA private key contains the algorithm parameters as well as the x value", "label": {"api": {"the x value": [[63, 73]]}}}, {"text": "You could simply encrypt the x value, however that assumes your recipient already knows the algorithm parameters p, q and g", "label": {"api": {"the x value": [[25, 35]]}}}, {"text": "Or you can send the x value encrypted and the parameters unencrypted (thanks GregS)", "label": {"api": {"the x value": [[16, 26]]}}}, {"text": "Use a DecimalFormat", "label": {"api": {"DecimalFormat": [[6, 18]]}}}, {"text": "There is a getFields method that will return all public fields of this class and its superclass", "label": {"api": {"getFields": [[11, 19]]}}}, {"text": "If you want all fields of this class and its superclass, just use getSuperClass() and call the same method", "label": {"api": {"getSuperClass": [[66, 78]]}}}, {"text": "For many components in one space, use a CardLayout as see in this short example", "label": {"api": {"CardLayout": [[40, 49]]}}}, {"text": "The Character class provides a getType() method that maps to at least some of the defined character categories in the Unicode spec, so this is probably the best place to start", "label": {"api": {"getType()": [[31, 39]]}}}, {"text": "Try the combinations of unicode binary classifications", "label": {"api": {"binary classifications": [[32, 53]]}}}, {"text": "Try using the Path class to read the file", "label": {"api": {"Path": [[14, 17]]}}}, {"text": "I was hoping that someone could tell me why java has java.lang.reflect.Type, when everything already inherits from Object", "label": {"api": {"java.lang.reflect.Type": [[53, 74]]}}}, {"text": "or use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[7, 23]], "toString()": [[14, 23]]}}}, {"text": "array is an object, hence you are calling println(Object) of PrintStream (System.out), which calls toString() on the passed object internally", "label": {"api": {"println(Object)": [[42, 56]], "PrintStream": [[61, 71]], "Object": [[50, 55]], "toString()": [[99, 108]]}}}, {"text": "The array's toString() is similar to Object's toString()", "label": {"api": {"Object": [[37, 42]], "toString()": [[12, 21], [46, 55]]}}}, {"text": "756a7c99 is the value returned from hashCode() as a hex number", "label": {"api": {"hashCode()": [[36, 45]]}}}, {"text": "Read also Class.getName() JavaDoc", "label": {"api": {"Class.getName() JavaDoc": [[10, 32]]}}}, {"text": "Another solution that may make sense (especially under heavy read/write) is ConcurrentLinkedQueue (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html": [[99, 186]]}}}, {"text": "Use String#equals to compare String values", "label": {"api": {"String#equals": [[4, 16]]}}}, {"text": "In fact, String#equalsIgnoreCase is better in your case, to cut down on the number of conditions in each if statement", "label": {"api": {"String#equals": [[9, 21]], "String#equalsIgnoreCase": [[9, 31]]}}}, {"text": "You may verify whether or not your connection is valid in your openConnection method You also may use some Connection Pool", "label": {"api": {"is valid": [[46, 53]]}}}, {"text": "Try setting the Content-length before writing to the stream", "label": {"api": {"Content-length": [[16, 29]]}}}, {"text": "You should be passing tasks from this thread to Swing's invokeLater() utility", "label": {"api": {"invokeLater()": [[56, 68]]}}}, {"text": "Use SwingWorker , so that the UI thread is not blocked", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You might use a Clip for this, or if the clip is too large, feed the bytes directly to a SourceDataLine", "label": {"api": {"SourceDataLine": [[89, 102]]}}}, {"text": "Use a CountDownLatch", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "If you're on java 9 or later and you have an input stream to read you can use InputStream#readAllBytes()", "label": {"api": {"InputStream#readAllBytes()": [[78, 103]]}}}, {"text": "Instead you can have a Scheduler/Timer(use Timer & TimerTask) which would call the runInBG() periodically and check for the updates in the DB", "label": {"api": {"Timer": [[33, 37], [43, 47], [51, 55]], "TimerTask": [[51, 59]]}}}, {"text": "Use a HttpSessionListener, which is an interface for receiving notification events about HttpSession lifecycle changes", "label": {"api": {"HttpSessionListener": [[6, 24]]}}}, {"text": "Override its sessionCreated(HttpSessionEvent) method", "label": {"api": {"sessionCreated(HttpSessionEvent)": [[13, 44]]}}}, {"text": "As @Luiggi pointed out if you are using Servlet 3.0 complaint Container like Tomcat 7, you can just define the listener class with @WebListener annotation instead of declaring the listener in web.xml, though I prefer the orthodox approach because you can find all the listener information(except binding listeners) in one file itself", "label": {"api": {"@WebListener": [[131, 142]]}}}, {"text": "When you reflect your code you can use class  java.lang.reflect.Array that represent Array", "label": {"api": {"java.lang.reflect.Array": [[46, 68]]}}}, {"text": "Use Collections sort() method to sort the data and then iterate through it and insert", "label": {"api": {"Collections": [[4, 14]], "sort()": [[16, 21]]}}}, {"text": "You can customize the compareTo() to determine the order", "label": {"api": {"compareTo()": [[22, 32]]}}}, {"text": "Using Comparator, you can do something like this", "label": {"api": {"Comparator": [[6, 15]]}}}, {"text": "javax.persistence.Table has no attribute named indexes", "label": {"api": {"javax.persistence.Table": [[0, 22]]}}}, {"text": "Note that you do need to have both annotations in place, javax.persistence.Table and org.hibernate.annotations.Table as stated by the hibernate docs", "label": {"api": {"javax.persistence.Table": [[57, 79]]}}}, {"text": "In the documentation of java.io.File, before the Interoperability with java.nio.file package", "label": {"api": {"java.io.File": [[24, 35]]}}}, {"text": "There isn't anything native to java that lets you do this like async/await keywords, but what you can do if you really want to is use a CountDownLatch", "label": {"api": {"CountDownLatch": [[136, 149]]}}}, {"text": "That would be extremely shoddy as CountDownLatch depends on you effectively counting down the right number of times and in the right places", "label": {"api": {"CountDownLatch": [[34, 47]]}}}, {"text": "You can add a Windows Listener to your frame", "label": {"api": {"Windows Listener": [[14, 29]]}}}, {"text": "From the official documentation , a ResultSet is", "label": {"api": {"official documentation": [[9, 30]]}}}, {"text": "If all else fails, you can use Runtime.exec()", "label": {"api": {"Runtime.exec()": [[31, 44]]}}}, {"text": "Use a synchronizedList via Collections.synchronizedList and follow the javadoc instructions for iteration", "label": {"api": {"synchronizedList": [[6, 21], [39, 54]]}}}, {"text": "You could add a lookahead to your regular expression for splitting", "label": {"api": {"lookahead": [[16, 24]]}}}, {"text": "If you only want to split into substrings starting with String<digit>, so String1, String2, String3, String4..., but not String11, String31 etc (these have 2 digits), you can use a lookahead (along with the \"&\" delimiter) that checks the next substring is of that form", "label": {"api": {"lookahead": [[181, 189]]}}}, {"text": "You want to use BigDecimal in order to preserve precision", "label": {"api": {"BigDecimal": [[16, 25]]}}}, {"text": "TreeMap has a descendingMap method (note that it returns a view on the original map, it does not copy it)", "label": {"api": {"descendingMap method": [[14, 33]]}}}, {"text": "you need to pass the user home dir through Matcher.quoteReplacement() before using it as a replacement pattern (as covered in the javadoc for the relevant method)", "label": {"api": {"javadoc for the relevant method": [[130, 160]]}}}, {"text": "You can try something like this with BigInteger class", "label": {"api": {"BigInteger": [[37, 46]]}}}, {"text": "You can use String#substring(int beginIndex,int endIndex) method of String to take substring from the given string", "label": {"api": {"String#substring(int beginIndex,int endIndex)": [[12, 56]]}}}, {"text": "Because that way I can tell the server to send out this CA as the only accepted one getAcceptedIssuers()", "label": {"api": {"getAcceptedIssuers()": [[84, 103]]}}}, {"text": "Annotations declared as Qualifiers let CDI disambiguate between implementations of the same type", "label": {"api": {"Qualifier": [[24, 32]]}}}, {"text": "If you are working with multiple threads you might also look at ConcurrentMap", "label": {"api": {"ConcurrentMap": [[64, 76]]}}}, {"text": "You can use the focusedProperty of Node to attach a ChangeListener", "label": {"api": {"focusedProperty": [[16, 30]]}}}, {"text": "If you do need a regex, the method you're looking for is String.replaceAll (as you mentioned)", "label": {"api": {"String.replaceAll": [[57, 73]]}}}, {"text": "Ruby's String#sub corresponding java version would be String.replaceFirst", "label": {"api": {"String.replaceFirst": [[54, 72]]}}}, {"text": "Be sure that you have a unique worker thread (see Executors and submit) that is in charge of writing the bytes told by each thread", "label": {"api": {"Executors": [[50, 58]], "submit": [[64, 69]]}}}, {"text": "yourThreadPoolExecutor.getActiveCount(); will return 0 when all tasks have completed", "label": {"api": {"yourThreadPoolExecutor.getActiveCount(); will return 0 when all tasks have completed": [[0, 83]]}}}, {"text": "Potentially the simplest route is to use an ObjectOutputStream instead of PrintWriter and you can read the results using an ObjectInputStream", "label": {"api": {"ObjectOutputStream": [[44, 61]], "ObjectInputStream": [[124, 140]]}}}, {"text": "This is assuming that the Objects contained in your HashMap are either Serializable or Externalizable", "label": {"api": {"Serializable": [[71, 82]], "Externalizable": [[87, 100]]}}}, {"text": "XMLEncoder and XMLDecoder may allow for more portability if you ever need to read the files outside the Java environment or want them to be human readable", "label": {"api": {"XMLEncoder": [[0, 9]], "XMLDecoder": [[15, 24]]}}}, {"text": "You might have success running the program with an agent that calls Toolkit.addAWTEventListener", "label": {"api": {"agent": [[51, 55]], "Toolkit.addAWTEventListener": [[68, 94]]}}}, {"text": "I think java.util.concurrent.ScheduledExecutorService is enough", "label": {"api": {"java.util.concurrent.ScheduledExecutorService": [[8, 52]]}}}, {"text": "If you look at the JavaDocs for getImage(String) it states", "label": {"api": {"getImage(String)": [[32, 47]]}}}, {"text": "Applet offers instead Applet.getImage(URL) & getImage(URL,String)", "label": {"api": {"Applet.getImage(URL)": [[22, 41]], "getImage(URL,String)": [[45, 64]]}}}, {"text": "It is also worth noting that StringBuilder should be preferred to StringBuffer", "label": {"api": {"StringBuilder": [[29, 41]], "StringBuffer": [[66, 77]]}}}, {"text": "You can use the Collections class", "label": {"api": {"Collections class": [[16, 32]]}}}, {"text": "A quick search for the java string API  would have given you what you needed", "label": {"api": {"java string API ": [[23, 38]]}}}, {"text": "10, and then use format()", "label": {"api": {"format()": [[17, 24]]}}}, {"text": "You should use AtomicInteger for that purpose.But since only one instance of the Servlet exists which is reused for multiple requests from multiple clients.Hence don't declare any instance or class variable in a Servlet and don't make methods synchronized.You can do something like below, if you want to use primitive int", "label": {"api": {"AtomicInteger": [[15, 27]]}}}, {"text": "You'll want to use Pattern and Matcher from Java", "label": {"api": {"Pattern": [[19, 25]], "Matcher": [[31, 37]]}}}, {"text": "Make your Compartimentoclass implements Cloneable", "label": {"api": {"Cloneable": [[40, 48]]}}}, {"text": "Rectangle class can already handle all of your calculations", "label": {"api": {"Rectangle": [[0, 8]]}}}, {"text": "Alternatively you can use setFrameFromDiagonal", "label": {"api": {"setFrameFromDiagonal": [[26, 45]]}}}, {"text": "I recall that the Class::getResourceAsStream variant deals with paths slightly differently than simply Class::getResource - I am sure it should work for the latter one", "label": {"api": {"Class::getResourceAsStream": [[18, 43]], "Class::getResource": [[18, 35], [103, 120]]}}}, {"text": "Use API link to know how to append instead of overwriting..", "label": {"api": {"API": [[4, 6]]}}}, {"text": "Since JPA 2.1, you can use the @javax.persistence.ForeignKey annotation", "label": {"api": {"@javax.persistence.ForeignKey": [[31, 59]]}}}, {"text": "You can use java's Double.valueOf() defined here instead; then you can convert the resulting double to an int", "label": {"api": {"defined here": [[36, 47]]}}}, {"text": "Have you tried API class LinkedList", "label": {"api": {"LinkedList": [[26, 35]]}}}, {"text": "Use the getReference call of the entityManager to load customer object using the id and then set that onto the customer history", "label": {"api": {"getReference": [[8, 19]]}}}, {"text": "file.writeChars writes each char to the file as two bytes", "label": {"api": {"file.writeChars": [[0, 14]]}}}, {"text": "Similarly, file.readChar reads two bytes from the file and interprets them as a char", "label": {"api": {"file.readChar": [[11, 23]]}}}, {"text": "You need to use, e.g., java.lang.Class.getResourceAsStream() to access the file", "label": {"api": {"java.lang.Class.getResourceAsStream()": [[23, 59]]}}}, {"text": "With try-with-resource introduced in Java 7, I was surprised to see that that the Lock has not been retrofitted to be an AutoCloseable", "label": {"api": {"Lock": [[82, 85]], "AutoCloseable": [[121, 133]]}}}, {"text": "This works with an AutoCloseableReentrantReadWiteLock class and usage is as follows", "label": {"api": {"Lock": [[49, 52]], "AutoCloseable": [[19, 31]]}}}, {"text": "pause/resume functionality can be achieved using stop/start respectively", "label": {"api": {"stop": [[49, 52]], "start": [[54, 58]]}}}, {"text": "If you know the list is going to be dynamic use ArrayList", "label": {"api": {"ArrayList": [[48, 56]]}}}, {"text": "Here's the documentation", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Split uses a regex so do", "label": {"api": {"Split uses a regex": [[0, 17]]}}}, {"text": "There is (as of Java 7) a built in way to do this, Files.walkFileTree, which is much more efficient and removes the need to reinvent the wheel", "label": {"api": {"Files.walkFileTree": [[51, 68]]}}}, {"text": "It calls into a FileVisitor for every entry it finds", "label": {"api": {"FileVisitor": [[16, 26]]}}}, {"text": "There are a couple of examples on the FileVisitor page to get you started", "label": {"api": {"FileVisitor": [[38, 48]]}}}, {"text": "with the Class.newInstance() method", "label": {"api": {"Class.newInstance()": [[9, 27]]}}}, {"text": "Use getGeneratedKeys() after you have executed the statement to get generated keys", "label": {"api": {"getGeneratedKeys()": [[4, 21]]}}}, {"text": "My initial thought would be to use a CipherInputStream with a Cipher initialized with the right parameters, but the API for that doesn't do seeking and states to not support mark and reset", "label": {"api": {"the API for that": [[112, 127]]}}}, {"text": "Look into JLayeredPane and similar strategies", "label": {"api": {"JLayeredPane": [[10, 21]]}}}, {"text": "You can use a Set", "label": {"api": {"Set": [[14, 16]]}}}, {"text": "Then you can use Set#toArray()", "label": {"api": {"Set": [[17, 19]], "Set#toArray()": [[17, 29]]}}}, {"text": "You can also have an ArrayList from the Set", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "The easiest way is to use JTextComponent.read(Reader,Object) which", "label": {"api": {"JTextComponent.read(Reader,Object)": [[26, 59]]}}}, {"text": "It is defined as", "label": {"api": {"defined as": [[6, 15]]}}}, {"text": "out is a static field in System", "label": {"api": {"System": [[25, 30]]}}}, {"text": "Its type is PrintStream", "label": {"api": {"PrintStream": [[12, 22]]}}}, {"text": "You just have to do it with Iterator.remove()", "label": {"api": {"Iterator.remove()": [[28, 44]]}}}, {"text": "ConcurrentModificationException may be thrown, for example, if another thread has modified the collection during iteration", "label": {"api": {"ConcurrentModificationException": [[0, 30]]}}}, {"text": "To skip the first 12 characters from each line, you could use the substring(int) method of String", "label": {"api": {"substring(int)": [[66, 79]]}}}, {"text": "From the IllegalArgumentException javadocs", "label": {"api": {"IllegalArgumentException javadocs": [[9, 41]]}}}, {"text": "You could use Window#setAlwaysOnTop", "label": {"api": {"Window#setAlwaysOnTop": [[14, 34]]}}}, {"text": "JavaFX 2.2 TextField has a public focusedProperty inherited from the Node class, just add a ChangeListener and implement the changed method", "label": {"api": {"TextField": [[11, 19]], "focusedProperty": [[34, 48]], "Node": [[69, 72]], "ChangeListener": [[92, 105]], "changed": [[125, 131]]}}}, {"text": "toArray with no arguments would just give you a Object[], you need to give it an array as a \"example\"", "label": {"api": {"toArray with no arguments": [[0, 24]], "an array as a \"example\"": [[78, 100]]}}}, {"text": "From the Java API documentation", "label": {"api": {"Java API documentation": [[9, 30]]}}}, {"text": "That is forbidden by the Swing threading policy", "label": {"api": {"Swing threading policy": [[25, 46]]}}}, {"text": "@PersistenceContext is a very specific annotation and it's saying \"inject this field with a persistence context\"", "label": {"api": {"@PersistenceContext": [[0, 18]]}}}, {"text": "@Inject on the other hand, is very generic", "label": {"api": {"@Inject": [[0, 6]]}}}, {"text": "If you want to go straight to the source of what @Inject is, you can read the spec here", "label": {"api": {"@Inject": [[49, 55]]}}}, {"text": "@Inject, identifies a point at which a dependency on a Java class or interface can be injected", "label": {"api": {"@Inject": [[0, 6]]}}}, {"text": "Rather set preferred sizes as above and make sure to invoke JFrame#pack", "label": {"api": {"JFrame#pack": [[60, 70]]}}}, {"text": "If you want to stack one component on top of another, don't use a GridPane for layout, instead use a parent that allows layout components to be placed on top of one another", "label": {"api": {"GridPane": [[66, 73]], "Pane": [[70, 73]]}}}, {"text": "For example, a standard Pane, a StackPane, Group or Region", "label": {"api": {"Pane": [[24, 27], [37, 40]], "StackPane": [[32, 40]], "Group": [[43, 47]], "Region": [[52, 57]]}}}, {"text": "In your sample code you are already extending Pane, so get rid of all of the grid code and just do", "label": {"api": {"Pane": [[46, 49]]}}}, {"text": "you can call goButton.relocate(xPos, yPos)", "label": {"api": {"goButton.relocate(xPos, yPos)": [[13, 41]]}}}, {"text": "You have some custom stuff in the layoutChildren method you override that may mess up the default Pane layout processing logic", "label": {"api": {"Pane": [[98, 101]]}}}, {"text": "The javax.persistence.Column's length attribute is used to define the column length of String fields (it is ignored for other types) and is only used when the persistence framework will generate the database schema (several CREATE TABLEs) from the entities, such as this option (for Hibernate on hibernate.cfg.xml)", "label": {"api": {"javax.persistence.Column": [[4, 27]]}}}, {"text": "From the Javadoc of ConcurrentHashMap (emphasis added)", "label": {"api": {"ConcurrentHashMap": [[20, 36]]}}}, {"text": "So the regular ConcurrentHashMap.values().iterator() will give you a \"consistent\" iterator, but only for one-time use by a single thread", "label": {"api": {"ConcurrentHashMap": [[15, 31]]}}}, {"text": "It's all explained in the BigDecimal API", "label": {"api": {"BigDecimal API": [[26, 39]]}}}, {"text": "ExecutorService#invokeAll executes all the tasks concurrently, but the call itself blocks until all the tasks complete", "label": {"api": {"ExecutorService#invokeAll": [[0, 24]]}}}, {"text": "One is the ProcessBuilder and the other is Robot", "label": {"api": {"ProcessBuilder": [[11, 24]], "Robot": [[43, 47]]}}}, {"text": "ProcessBuilder can be used to run external commands", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "Robot can literally take control of your computer", "label": {"api": {"Robot": [[0, 4]]}}}, {"text": "Use the ResultSet.getMetadata() method to obtain ResultSetMetaData which provides the column Type (and other information, such as numeric precision)", "label": {"api": {"ResultSetMetaData": [[49, 65]]}}}, {"text": "The column type is returned as a java.sql.Types int constant, not a Class object", "label": {"api": {"java.sql.Types": [[33, 46]]}}}, {"text": "See the Javadoc for java.lang.Integer, or 4.2.1 \"Integral Types and Values\" of The Java Language Specification, Java SE 7 Edition", "label": {"api": {"the Javadoc for java.lang.Integer": [[4, 36]]}}}, {"text": "Check the doc", "label": {"api": {"Check the doc": [[0, 12]]}}}, {"text": "To use UTF-8, specifically, you should use InputStreamReader (with a FileInputStream) and PrintWriter (with the socket's OutputStream) and use the variants of the constructor that allow you to specify the desired character set (in this case, UTF-8)", "label": {"api": {"InputStreamReader": [[43, 59]], "FileInputStream": [[69, 83]], "PrintWriter": [[90, 100]], "OutputStream": [[121, 132]]}}}, {"text": "Check out the grammar in the documentation of Scanner class regarding number syntax", "label": {"api": {"the grammar": [[10, 20]]}}}, {"text": "According to Oracle Jai Docs you could use getCompression method and check if your compression is equal to COMPRESSION_GROUP4 (int)", "label": {"api": {"Oracle Jai Docs": [[13, 27]]}}}, {"text": "In Java, you can do this with a BufferedReader", "label": {"api": {"BufferedReader": [[32, 45]]}}}, {"text": "One simple option is to present your items in a JList", "label": {"api": {"JList": [[48, 52]]}}}, {"text": "I haven't used number at all in my solution, this is because I used an ArrayList, which is essentially a much more advanced version of an array that can grow dynamically and do loads of other cool stuff", "label": {"api": {"ArrayList": [[71, 79]]}}}, {"text": "Unfortunately ArrayLists need to contain objects, so I wrap each int inside an Integer object and this is fine", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "That's what the method does and is documented to do", "label": {"api": {"is documented": [[32, 44]]}}}, {"text": "You can use a different getObject() method where you can indicate what type you are expecting", "label": {"api": {"getObject()": [[24, 34]]}}}, {"text": "For classifying characters you should use the Character.getType(char) method", "label": {"api": {"Character.getType(char)": [[46, 68]]}}}, {"text": "Use EnumMap, this is the best map implementation if you have enums as key, for both performance and memory usage", "label": {"api": {"EnumMap": [[4, 10]]}}}, {"text": "According to java.lang.Charset, the \"UTF-16\" encoding will use big endian byte order, whereas your PHP code may be defaulting to little endian because it's running on x86 and no byte order mark is present (I don't know PHP well enough to tell if this behaviour is well defined)", "label": {"api": {"java.lang.Charset": [[13, 29]]}}}, {"text": "On a practical note, you can guard your collections using the Collections utility methods", "label": {"api": {"Collections": [[62, 72]]}}}, {"text": "Use Pattern.matcher() to obtain a Matcher for the input string, then use Matcher.find() to find the pattern you want", "label": {"api": {"Pattern.matcher()": [[4, 20]], "Matcher": [[34, 40], [73, 79]], "Matcher.find()": [[73, 86]]}}}, {"text": "Matcher.find() will find substring(s) that matches the Pattern provided", "label": {"api": {"Matcher": [[0, 6]], "Matcher.find()": [[0, 13]]}}}, {"text": "Pattern.split() will use your pattern as delimiter to split the string (then the delimiter part is discarded), which is obviously not what you want in this case", "label": {"api": {"Pattern.split()": [[0, 14]]}}}, {"text": "use setComponentPopupMenu, it will take care of all the extra work and OS-specific right-click issues", "label": {"api": {"setComponentPopupMenu": [[4, 24]]}}}, {"text": "From your description a CachedThreadPool might be suitable", "label": {"api": {"CachedThreadPool": [[24, 39]]}}}, {"text": "Check out http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html for some guidelines how to implement", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html": [[10, 91]]}}}, {"text": "From the documentation for JTable", "label": {"api": {"JTable": [[27, 32]]}}}, {"text": "This links to the following", "label": {"api": {"links": [[5, 9]]}}}, {"text": "For example, if a TableModel is attached to a JTable, the TableModel should only be modified on the event dispatching thread", "label": {"api": {"JTable": [[46, 51]]}}}, {"text": "But why do that when it's easy enough to create a SwingWorker and guarantee that your code is thread-safe", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "Use String#replaceAll() with the regex", "label": {"api": {"String#replaceAll()": [[4, 22]]}}}, {"text": "The closest thing I've found is the ResultSetMetaData", "label": {"api": {"ResultSetMetaData": [[36, 52]]}}}, {"text": "The method Files.readAllLines reads a file into a List<String>, one String per line in the original file", "label": {"api": {"Files.readAllLines": [[11, 28]]}}}, {"text": "The method Files.readAllBytes just reads a file into a byte array if that's your style", "label": {"api": {"Files.readAllBytes": [[11, 28]]}}}, {"text": "The W3C dom method for namespaced elements", "label": {"api": {"W3C dom": [[4, 10]]}}}, {"text": "Another example is Objects class from jdk 7 that contains utility operations you can perform on any object instance", "label": {"api": {"Objects": [[19, 25]]}}}, {"text": "Or it's more straightforward in Java 1.5 and above as you can call getTextContent() directly", "label": {"api": {"getTextContent()": [[67, 82]]}}}, {"text": "queue.toArray() returns a Object[], which your provided Comparator can't handle", "label": {"api": {"toArray()": [[6, 14]]}}}, {"text": "You will need to use the alternate toArray(), that takes an array of the expected type", "label": {"api": {"toArray()": [[35, 43]]}}}, {"text": "Page scope (handled by PageContext)", "label": {"api": {"PageContext": [[23, 33]]}}}, {"text": "Request scope (handled by ServletRequest)", "label": {"api": {"ServletRequest": [[26, 39]]}}}, {"text": "Session scope (handled by HttpSession)", "label": {"api": {"HttpSession": [[26, 36]]}}}, {"text": "Application scope (handled by ServletContext)", "label": {"api": {"ServletContext": [[30, 43]]}}}, {"text": "For the array base type, DatabaseMetaData.getColumns() returns a ResultSet containing column metadata", "label": {"api": {"DatabaseMetaData.getColumns()": [[25, 53]]}}}, {"text": "Iterate through an String#split(regex) generated array and check each value to make sure your source String is \"valid\"", "label": {"api": {"String#split(regex)": [[19, 37]]}}}, {"text": "This is a way of doing it with StringTokenizer class, just iterate the tokens and if the obtained token is empty then you have a invalid String, also, convert the tokens to integers by the parseInt method to check if they are valid integer numbers", "label": {"api": {"StringTokenizer": [[31, 45]], "parseInt": [[189, 196]]}}}, {"text": "I'd like to repeat an HTTP request automatically if a database deadlock occurs; however, FilterChain.doFilter() is defined as a unidirectional chain (so I cannot reset its state)", "label": {"api": {"FilterChain.doFilter()": [[89, 110]]}}}, {"text": "Even if you repeat the request, you will need to buffer the request InputStream", "label": {"api": {"InputStream": [[68, 78]]}}}, {"text": "In order to do so you are going to be forced to buffer the InputStream for all requests, even if a deadlock never occurs", "label": {"api": {"InputStream": [[59, 69]]}}}, {"text": "By limiting the number of active threads, we limit the number of InputStreams we need to buffer (the remaining requests get blocked before sending the HTTP body)", "label": {"api": {"InputStream": [[65, 75]]}}}, {"text": "Use DataInputStream and DataOutStream if you want to read and write the primitive types respectively", "label": {"api": {"DataInputStream": [[4, 18]], "DataOutStream": [[24, 36]]}}}, {"text": "You can use Thread class static sleep() method", "label": {"api": {"sleep()": [[32, 38]]}}}, {"text": "In JavaFX FXML documentation about controllers, it is said that if the controller has a public void initialize() method, it is called once the FXML graph is loaded", "label": {"api": {"FXML documentation about controllers": [[10, 45]]}}}, {"text": "Yes, if the super class implements serializable, then so do the sub classes", "label": {"api": {"serializable": [[35, 46]]}}}, {"text": "You can use the format functionality to print the Java UTF-16 string escapes", "label": {"api": {"format": [[16, 21]]}}}, {"text": "You can either use removeAll(), which takes an object that implements the Collection interface as the parameter like this", "label": {"api": {"removeAll()": [[19, 29]], "Collection interface": [[74, 93]]}}}, {"text": "Or you need do some sort of iteration in order to go through all of the values as you want to remove as remove() doesn't take another list as a parameter, only an index or an object", "label": {"api": {"remove()": [[104, 111]]}}}, {"text": "When value comes from database sequence, GenerationType.SEQUENCE should be used as a strategy", "label": {"api": {"GenerationType.SEQUENCE": [[41, 63]]}}}, {"text": "The simplest, cleanest approach is to  use split()", "label": {"api": {"split()": [[43, 49]]}}}, {"text": "The regex passed to split()specifies the separator, which is consumed, so by including optional whitespace before and after the delimiting strings, leading and trailing blanks around the strings are automatically removed", "label": {"api": {"split()": [[20, 26]]}}}, {"text": "You could just pass null to the Timer's constructor and add the ActionListener afterwards, using addActionListener", "label": {"api": {"constructor": [[40, 50]], "addActionListener": [[97, 113]]}}}, {"text": "Given that Integer.parseInt takes a String argument, it's safe to say that sortedData is a 3D String array", "label": {"api": {"Integer.parseInt": [[11, 26]]}}}, {"text": "Make sure these elements have been assigned values prior to invoking Integer.parseInt", "label": {"api": {"Integer.parseInt": [[69, 84]]}}}, {"text": "You can use the String#indexOf(String str) method to find the first occurence of 2010", "label": {"api": {"String#indexOf(String str)": [[16, 41]]}}}, {"text": "The intensive processing done in doSomething is blocking the EDT, preventing UI updates", "label": {"api": {"done": [[25, 28]]}}}, {"text": "Use execute to start the worker", "label": {"api": {"execute": [[4, 10]]}}}, {"text": "Move any required calls to console.write to either doInBackground or done", "label": {"api": {"doInBackground": [[51, 64]], "done": [[69, 72]]}}}, {"text": "Please check API doc for AbstractListModel", "label": {"api": {"API doc for AbstractListModel": [[13, 41]]}}}, {"text": "It should be noted that List.subList(), returns a view of the list, so modifications to the origianl list will be reflected in the sub list, hence creating the new list and passing the sub list to the constructor", "label": {"api": {"List.subList()": [[24, 37]]}}}, {"text": "The retainAll() method returns true if the list changed because of the operation", "label": {"api": {"retainAll()": [[4, 14]]}}}, {"text": "One way to achieve your goal is to use setComposite() method on the Graphics2D of the BufferedImage to be converted, this solution is discussed briefly here and here", "label": {"api": {"setComposite()": [[39, 52]], "Graphics2D": [[68, 77]], "BufferedImage": [[86, 98]]}}}, {"text": "In the case of Set you are specifying the object to remove and hence it actually removes values 0, 1 and 2 from the set", "label": {"api": {"the object to remove": [[38, 57]]}}}, {"text": "In the case of List you are specifying the index of object to remove and hence it actually removes values at indices 0, 1 and 2 from the list", "label": {"api": {"the index of object to remove": [[39, 67]]}}}, {"text": "You can use the Character#toUpperCase for that", "label": {"api": {"Character#toUpperCase": [[16, 36]]}}}, {"text": "to store this position maybe try a Point object that contains a Point x,y", "label": {"api": {"Point x,y": [[64, 72]]}}}, {"text": "The array is then accessed thanks to the Enum.ordinal() method when getting or putting data, which takes contant time", "label": {"api": {"Enum.ordinal()": [[41, 54]]}}}, {"text": "Looking at the documentation for EnumMap", "label": {"api": {"documentation for EnumMap": [[15, 39]]}}}, {"text": "The standard API provides the BreakIterator for this sort of boundary analysis but the Oracle Java 7 locale support doesn't break the sample string", "label": {"api": {"BreakIterator": [[30, 42]]}}}, {"text": "When I used the ICU4J v51.1 BreakIterator it broke the sample into [, , , , ]", "label": {"api": {"BreakIterator": [[28, 40]]}}}, {"text": "However, my suggestion is that you rely on java.util.concurrent.BlockingQueue having a second queue to return them from consumers back to the producer, and on java.nio.ByteByffer to keep track of lengths", "label": {"api": {"java.util.concurrent.BlockingQueue": [[43, 76]], "java.nio.ByteByffer": [[159, 177]]}}}, {"text": "If you really don't want to copy data (and are sure that the source does not change until all consumers have read it!), your better option is to use a single blocking queue and insert buffers obtained with ByteBuffer.slice() from your source buffer for each chunk of data to be handed down to consumers", "label": {"api": {"ByteBuffer.slice()": [[206, 223]]}}}, {"text": "IMO the far superior approach is to create AbstractActions and hook up to them", "label": {"api": {"AbstractActions": [[43, 57]]}}}, {"text": "You should use PageRanges attribute to print only the first page of the document", "label": {"api": {"PageRanges": [[15, 24]]}}}, {"text": "Full list of supported attributes can be found at the documentation page of PrintRequestAttribute", "label": {"api": {"PrintRequestAttribute": [[76, 96]]}}}, {"text": "Just use String.matches() with the appropriate regex and you only need one line", "label": {"api": {"String.matches()": [[9, 24]]}}}, {"text": "I would imagine that com.sun.jdi.ObjectReference would have a way to get at the instance enclosing an instance, but it doesn't seem to be the case", "label": {"api": {"com.sun.jdi.ObjectReference": [[21, 47]]}}}, {"text": "Or, I would try to use reflection in the debugged VM, something like java.lang.Class.getEnclosing{Class,Constructor,Method}() but I don't see any related method that applies to objects/instances", "label": {"api": {"java.lang.Class.getEnclosing{Class,Constructor,Method}()": [[69, 124]]}}}, {"text": "One option is using String.split", "label": {"api": {"String.split": [[20, 31]]}}}, {"text": "Why not use split", "label": {"api": {"split": [[12, 16]]}}}, {"text": "First, look at the difference between Scanner.next() and Scanner.nextLine()", "label": {"api": {"Scanner.next()": [[38, 51]], "Scanner.nextLine()": [[57, 74]]}}}, {"text": "According to the documentation, available() only returns the number of bytes that can be read from the stream without blocking", "label": {"api": {"available()": [[32, 42]]}}}, {"text": "First of all, to persist a java.util.Date into a database in Java, you will have to convert it to java.sql.Date", "label": {"api": {"java.sql.Date": [[98, 110]]}}}, {"text": "Therefore, to create a java.sql.Date from java.util.Date, you will have to do this", "label": {"api": {"java.sql.Date": [[23, 35]]}}}, {"text": "Make sure that db.insert_date accepts only java.sql.Date", "label": {"api": {"java.sql.Date": [[43, 55]]}}}, {"text": "See the related question java.util.Date vs java.sql.Date", "label": {"api": {"java.sql.Date": [[43, 55]]}}}, {"text": "Consider for instance AbstractList (implementing List) and AbstractMap (implementing Map) in the JDK", "label": {"api": {"AbstractList": [[22, 33]], "AbstractMap": [[59, 69]]}}}, {"text": "Using standard J2SE we can cater for the types returned in the String[] obtained from ImageIO.getReaderFileSuffixes()", "label": {"api": {"ImageIO.getReaderFileSuffixes()": [[86, 116]]}}}, {"text": "The SwingWorker class is one option, but you can just as easily use a normal thread.1 Blocking the EDT causes your GUI to freeze, so it must never be used for lengthy tasks", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Once your result is computed, update the GUI using SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[51, 78]]}}}, {"text": "1 I tend to find normal threads executed via an ExecutorService are better for unit testing (as you can write an ExecutorService that immediately executes the Runnable, avoiding any nasty thread issues with JUnit)", "label": {"api": {"ExecutorService": [[48, 62], [113, 127]]}}}, {"text": "You can use Reflection API to check whether a method exists within an object, but I don't see why would you do this", "label": {"api": {"Reflection API": [[12, 25]]}}}, {"text": "Anyway any uses of Reflection API in applicative (and not framework) code considered as a hack and a sign that you want to do weird things (which are usually wrong)", "label": {"api": {"Reflection API": [[19, 32]]}}}, {"text": "In JDBC this is akin to Statement.addBatch(sql)", "label": {"api": {"Statement.addBatch(sql)": [[24, 46]]}}}, {"text": "For many components in one space, use a CardLayout as see in this short example", "label": {"api": {"CardLayout": [[40, 49]]}}}, {"text": "You might want to use a producer consumer queue like an ArrayBlockingQueue instead or a similar concurrent collection", "label": {"api": {"ArrayBlockingQueue": [[56, 73]]}}}, {"text": "One thread offers short[]s and the other take()s them", "label": {"api": {"offer": [[11, 15]], "take()": [[41, 46]]}}}, {"text": "You might look into a blockingqueue for this instead of an arraylist", "label": {"api": {"blockingqueue": [[22, 34]]}}}, {"text": "You can check if a HashSet includes an object with the contains() method", "label": {"api": {"contains()": [[55, 64]]}}}, {"text": "You can check if a HashMap includes an object as a key with the containsKey() method", "label": {"api": {"containsKey()": [[64, 76]]}}}, {"text": "Usually if you override one, you must also override the other, to satisfy their contracts", "label": {"api": {"contracts": [[80, 88]]}}}, {"text": "addRow is an instance method of DefaultTableModel rather than JTable", "label": {"api": {"addRow": [[0, 5]]}}}, {"text": "You can change the default in and out streams of the Java environment by calling System.setIn() and System.setOut(), see javadoc for class System here", "label": {"api": {"javadoc for class System here": [[121, 149]]}}}, {"text": "Parse a StringReader via an InputSource", "label": {"api": {"Parse": [[0, 4]], "StringReader": [[8, 19]], "InputSource": [[28, 38]]}}}, {"text": "I you want to change it you should use StringBuilder", "label": {"api": {"StringBuilder": [[39, 51]]}}}, {"text": "See ConcurrentHashMap as an example of this approach from the JDK", "label": {"api": {"ConcurrentHashMap": [[4, 20]]}}}, {"text": "You are seeing the Object#toString representation of the Double array calc in onProgressUpdate", "label": {"api": {"Object#toString": [[19, 33]]}}}, {"text": "The simplest way to do this is to create the Executor using Executors.newFixedThreadPool() and feed it Runnable jobs that use a ThreadLocal socket", "label": {"api": {"Executors.newFixedThreadPool()": [[60, 89]]}}}, {"text": "This way you could for example override afterExecute to detect and clean up broken sockets", "label": {"api": {"afterExecute": [[40, 51]]}}}, {"text": "The best tool for this job is the Scanner", "label": {"api": {"Scanner": [[34, 40]]}}}, {"text": "If you use a java.util.concurrent.BlockingQueue, each thread could put() an item on the blocking queue when it is finished", "label": {"api": {"java.util.concurrent.BlockingQueue": [[13, 46]]}}}, {"text": "The ArrayList constructor takes a Collection so you can use that", "label": {"api": {"ArrayList constructor": [[4, 24]]}}}, {"text": "Now it depends whether client join the session or not there are three overloaded methods of getSession() to get more about them please go through the documents", "label": {"api": {"documents": [[150, 158]]}}}, {"text": "You might consider using HttpServletResponseWrapper instead", "label": {"api": {"HttpServletResponseWrapper": [[25, 50]]}}}, {"text": "You probably need to look into String.equalsIgnoreCase", "label": {"api": {"String.equalsIgnoreCase": [[31, 53]]}}}, {"text": "You can do this by map.EntrySet()", "label": {"api": {"map.EntrySet()": [[19, 32]]}}}, {"text": "That's exactly what ByteBuffer.putInt() is for", "label": {"api": {"ByteBuffer.putInt()": [[20, 38]]}}}, {"text": "Java regex reference", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "Note you will need to configure the TPE to discard rejected tasks via a DiscardPolicy", "label": {"api": {"DiscardPolicy": [[72, 84]]}}}, {"text": "Then what should really make a difference for you is calling setReuseAddress(true) on that socket to allow binding the port while old connection hangs in the timeout state", "label": {"api": {"setReuseAddress(true)": [[61, 81]]}}}, {"text": "To easily check uniqueness of values, you can use the Set.add method, which returns false if the item being added already exists in the set", "label": {"api": {"Set.add": [[54, 60]]}}}, {"text": "The Java URL class can break down the URL as precisely as you want it", "label": {"api": {"Java URL class": [[4, 17]]}}}, {"text": "If you are just looking for full matches, use equalsIgnoreCase", "label": {"api": {"equalsIgnoreCase": [[46, 61]]}}}, {"text": "You can use additiv semaphores with 3 places for the waiting room and one binary semaphore for the barber", "label": {"api": {"semaphores": [[20, 29]]}}}, {"text": "Use a regular expression", "label": {"api": {"regular expression": [[6, 23]]}}}, {"text": "replaceFirst(String regex, String replacement) takes regex as a parameter, use this", "label": {"api": {"replaceFirst(String regex, String replacement)": [[0, 45]]}}}, {"text": "It's not hard to zip it first though using a stream wrapper like ZipInputStream and ZipOutputStream", "label": {"api": {"ZipInputStream": [[65, 78]], "ZipOutputStream": [[84, 98]]}}}, {"text": "URLEncoder is the class you need", "label": {"api": {"URLEncoder": [[0, 9]]}}}, {"text": "The reason you got an exception the first time is because split() takes a regular expression as argument, and ( has a special meaning there, as you suggest", "label": {"api": {"split()": [[58, 64]]}}}, {"text": "Population already extends another class so I can't have it extend TimerTask", "label": {"api": {"Timer": [[67, 71]]}}}, {"text": "Normally what I'd do is just make Population extend Timer to perform updates like this", "label": {"api": {"Timer": [[52, 56]]}}}, {"text": "The problem is neither Main nor Population can extend Timer or any other class as I need population to be declared inside the Main class", "label": {"api": {"Timer": [[54, 58]]}}}, {"text": "You could make it implement Runnable and use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[47, 70]]}}}, {"text": "I'll use indexOf() to find the index, and then if item exists(index != -1) you'll get an index which you can then use to replace the item using set(int index, E item)", "label": {"api": {"indexOf()": [[9, 17]], "set(int index, E item)": [[144, 165]]}}}, {"text": "With an unsorted array, one option would be to put the artists in a List and use List.indexOf()", "label": {"api": {"List.indexOf()": [[81, 94]]}}}, {"text": "If the artists were sorted, you could use Arrays.binarySearch()", "label": {"api": {"Arrays.binarySearch()": [[42, 62]]}}}, {"text": "Then call format to format the number", "label": {"api": {"format": [[10, 15], [20, 25]]}}}, {"text": "The Javadocs for DecimalFormat contain a list of formatting symbols you can use here", "label": {"api": {"format": [[49, 54]], "Javadocs for DecimalFormat": [[4, 29]]}}}, {"text": "For non-primitives, equality tests using == check if the object is literally identical (that it's the same instance), whereas String.equals will compare the actual String value", "label": {"api": {"String.equals": [[126, 138]]}}}, {"text": "You you should probably use ArrayLists instead", "label": {"api": {"ArrayLists": [[28, 37]]}}}, {"text": "For example, consider SortedSet.subSet", "label": {"api": {"SortedSet.subSet": [[22, 37]]}}}, {"text": "The common way to solve this is to demand that they implement Comparable", "label": {"api": {"Comparable": [[62, 71]]}}}, {"text": "Another way is like @LuiggiMendoza suggests, to provide a Comparator to do the comparison", "label": {"api": {"Comparator": [[58, 67]]}}}, {"text": "The Document implementation used by JTextPane is a PlainDocument", "label": {"api": {"PlainDocument": [[51, 63]]}}}, {"text": "Even though you probably always insert new log messages at either only the top or only the bottom, the PlainDocument implementation is general-purpose", "label": {"api": {"PlainDocument": [[103, 115]]}}}, {"text": "Use File.createNewFile() instead to create the file atomically", "label": {"api": {"File.createNewFile()": [[4, 23]]}}}, {"text": "You should use a JFormattedTextField instead", "label": {"api": {"JFormattedTextField": [[17, 35]]}}}, {"text": "The DecimalFormat pattern is, as its name (and javadoc) says, a pure pattern", "label": {"api": {"DecimalFormat pattern": [[4, 24]]}}}, {"text": "It's exactly like as that MMM represents the abbreviated month in SimpleDateFormat (note that it doesn't return MMM as month during formatting, but just like May or e.g", "label": {"api": {"SimpleDateFormat": [[66, 81]]}}}, {"text": "When you don't explicitly specify the locale during creating the DecimalFormat (or SimpleDateFormat), then the default locale as available by Locale#getDefault() will be assumed", "label": {"api": {"SimpleDateFormat": [[83, 98]], "Locale#getDefault()": [[142, 160]]}}}, {"text": "Please also note that DecimalFormat is (like SimpleDateFormat) not threadsafe (check the \"Synchronization\" section in the javadoc)", "label": {"api": {"SimpleDateFormat": [[45, 60]]}}}, {"text": "I have only no idea which BigDecimalConverter you're using, the standard JSF one doesn't have a getDecimalFormat() method, so I can't give a more concrete example of the proper approach", "label": {"api": {"the standard JSF one": [[60, 79]]}}}, {"text": "java.util.Scanner was introduced in version 1.5 (\"Java 5\")", "label": {"api": {"java.util.Scanner": [[0, 16]]}}}, {"text": "As the other answers note, temporary files created with File.createTempFile() will not be deleted automatically unless you explicitly request it", "label": {"api": {"File.createTempFile()": [[56, 76]]}}}, {"text": "The generic, portable way to do this is to call .deleteOnExit() on the File object, which will schedule the file for deletion when the JVM terminates", "label": {"api": {".deleteOnExit()": [[48, 62]]}}}, {"text": "I'm not sure what, if anything, using .deleteOnExit() would actually gain you over that", "label": {"api": {".deleteOnExit()": [[38, 52]]}}}, {"text": "There is a tutorial about Watching a Directory for Changes describing the WatchService which was introduced in Java 7", "label": {"api": {"WatchService": [[74, 85]]}}}, {"text": "You can use MessageFormat", "label": {"api": {"MessageFormat": [[12, 24]]}}}, {"text": "You can try creating regex from string that contains special characters  and escape symbols using Pattern.quote", "label": {"api": {"Pattern.quote": [[98, 110]]}}}, {"text": "Turn the \"alphabet\" into a regex then use String.matches()", "label": {"api": {"String.matches()": [[42, 57]]}}}, {"text": "You could separately maintain a Set<MyObject> - membership in the Set would correspond to a true value for that object", "label": {"api": {"Set<MyObject>": [[32, 44]]}}}, {"text": "Assuming you used a HashSet, you would need to ensure MyObject implemented equals and hashCode", "label": {"api": {"HashSet": [[20, 26]], "equals": [[75, 80]], "hashCode": [[86, 93]]}}}, {"text": "Have a look at ProcessBuilder class", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "Element#getAttribute retrieves attributes directly from Elements rather than from the nested elements", "label": {"api": {"Element#getAttribute": [[0, 19]]}}}, {"text": "Since you're doing this for internationalization, and you care about \"product productivity\" I would try to get this data into a Resource Bundle some how", "label": {"api": {"Resource Bundle": [[128, 142]]}}}, {"text": "For more info see the javadoc on Component.setDoubleBuffered", "label": {"api": {"Component.setDoubleBuffered": [[33, 59]]}}}, {"text": "If you need to run something hourly use java.util.Timer", "label": {"api": {"java.util.Timer": [[40, 54]]}}}, {"text": "Have a look at java.util.zip", "label": {"api": {"java.util.zip": [[15, 27]]}}}, {"text": "Since NodeList doesn't expose any methods to mutate its state, you can implement your own version to concatenate the lists", "label": {"api": {"NodeList": [[6, 13]]}}}, {"text": "Split on the last period (using String#substring and String#lastIndexOf)", "label": {"api": {"String#substring": [[32, 47]], "String#lastIndexOf": [[53, 70]]}}}, {"text": "If you use String#matches, the ^ and $ isn't required", "label": {"api": {"String#matches": [[11, 24]]}}}, {"text": "You can use the format() method instead of println()", "label": {"api": {"format()": [[16, 23]]}}}, {"text": "Using the StAX API", "label": {"api": {"StAX API": [[10, 17]]}}}, {"text": "Using the DOM API", "label": {"api": {"DOM API": [[10, 16]]}}}, {"text": "Using the transform package", "label": {"api": {"transform package": [[10, 26]]}}}, {"text": "Which you would use depends on your use case; the StAX API is probably the most efficient", "label": {"api": {"StAX API": [[50, 57]]}}}, {"text": "I'd say that you should use a CyclicBarrier to make all the threads wait for each another", "label": {"api": {"CyclicBarrier": [[30, 42]]}}}, {"text": "Use createNewFile instead of mkdir", "label": {"api": {"createNewFile": [[4, 16]], "mkdir": [[29, 33]]}}}, {"text": "mkdir as the name implies will create a directory", "label": {"api": {"mkdir": [[0, 4]]}}}, {"text": "You don't really need a regex here, just a simple call to String#replace(String) will do the job", "label": {"api": {"String#replace(String)": [[58, 79]]}}}, {"text": "Your logic is not totally explicit, but anyway I think the best is to use Pattern", "label": {"api": {"Pattern": [[74, 80]]}}}, {"text": "whose next() method throws that exception", "label": {"api": {"next()": [[6, 11]]}}}, {"text": "If you insist on using StringTokenizer legacy class, then check that there actually are more elements using x.hasNext() method", "label": {"api": {"x.hasNext()": [[108, 118]]}}}, {"text": "From there, you can use a SimpleDateFormat to turn it into a string in the format you want", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "But, if you're using JDBC to save the date in the database, you probably can pass in the Date directly with this method", "label": {"api": {"this method": [[108, 118]]}}}, {"text": "See How to Use Spinners & most specifically the JSpinner.DateEditor", "label": {"api": {"JSpinner.DateEditor": [[48, 66]]}}}, {"text": "Use the String constructor of BigDecimal instead, like", "label": {"api": {"BigDecimal": [[30, 39]]}}}, {"text": "You need to specify the location of the file as a File or Path (Java 7) object then read the file and parse it to your type", "label": {"api": {"File": [[50, 53]], "Path": [[58, 61]]}}}, {"text": "It looks like the standard mapping for COUNT(*) function in Hibernate is BigDecimal", "label": {"api": {"BigDecimal": [[73, 82]]}}}, {"text": "You could use Object#wait(long timeout) and log from inside the get() method", "label": {"api": {"Object#wait(long timeout)": [[14, 38]]}}}, {"text": "Use System.currentTimeMilis() in your Consumer run method", "label": {"api": {"System.currentTimeMilis()": [[4, 28]]}}}, {"text": "The problem is that equals() for an Array checks if the arrays are the same instance", "label": {"api": {"equals()": [[20, 27]]}}}, {"text": "Your HashSet will call equals() for all elements in the set, hence it will return false unless all arrays are the same instance", "label": {"api": {"equals()": [[23, 30]]}}}, {"text": "You may use TYPE_FORWARD_ONLY or FETCH_FORWARD_ONLY", "label": {"api": {"TYPE_FORWARD_ONLY": [[12, 28]]}}}, {"text": "This complete example follows API almost verbatim in ImageOpenAction", "label": {"api": {"API": [[30, 32]]}}}, {"text": "Use setDefaultUncaughtExceptionHandler, which will not touch possibly existing handlers", "label": {"api": {"setDefaultUncaughtExceptionHandler": [[4, 37]]}}}, {"text": "If you want to initialize a map as a static field of a class then you can use Map.of, since Java 9", "label": {"api": {"Map.of": [[78, 83]]}}}, {"text": "PriorityBlockingQueue already has a method poll() with a generic return type", "label": {"api": {"PriorityBlockingQueue": [[0, 20]], "poll()": [[43, 48]]}}}, {"text": "In your case, PriorityBlockingQueue<FIFOEntry<JobSet>> would expect poll() to return FIFOEntry<JobSet>", "label": {"api": {"PriorityBlockingQueue": [[14, 34]], "poll()": [[68, 73]]}}}, {"text": "From the Java package documentation for java.lang.ref", "label": {"api": {"java.lang.ref": [[40, 52]]}}}, {"text": "According to the Scanner.close() documentation, it will close the underlying Reader/Stream if it implements Closeable", "label": {"api": {"Scanner.close()": [[17, 31]]}}}, {"text": "In Timer.schedule(TimerTask task, long delay), it says it will throw if delay is negative, but doesn't say anything about if delay is zero", "label": {"api": {"Timer.schedule(TimerTask task, long delay)": [[3, 44]]}}}, {"text": "The documentation of java.util.Timer says", "label": {"api": {"documentation of java.util.Timer": [[4, 35]]}}}, {"text": "Use the @PostConstruct tag and get the session then", "label": {"api": {"@PostConstruct": [[8, 21]]}}}, {"text": "Your beans will only be injected after your UserDaoImpl is created and @PostConstruct method will only be called by Spring after all your beans are injected", "label": {"api": {"@PostConstruct": [[71, 84]]}}}, {"text": "Another possibility (since Java 7) is to use the method requireNonNull direclty in your constructor/method, here's an example with the constructor", "label": {"api": {"requireNonNull": [[56, 69]]}}}, {"text": "Throw a RuntimeException or an exception which is derived from RuntimeException", "label": {"api": {"RuntimeException": [[8, 23], [63, 78]]}}}, {"text": "This sounds like a job for java.swing.Timer", "label": {"api": {"java.swing.Timer": [[27, 42]]}}}, {"text": "See the API here", "label": {"api": {"See the API here": [[0, 15]]}}}, {"text": "Use String#equals()  if case is important otherwise use String#equalsIgnoreCase()", "label": {"api": {"String#equals()": [[4, 18]], "String#equalsIgnoreCase()": [[56, 80]]}}}, {"text": "The hash codes are the same, because the hashCode of a String depends only on its content", "label": {"api": {"the hashCode of a String depends only on its content": [[37, 88]]}}}, {"text": "That's required by the contract of equals() and hashCode()", "label": {"api": {"equals()": [[35, 42]]}}}, {"text": "To measure the memory in Java I'm using Instrumentation", "label": {"api": {"Instrumentation": [[40, 54]]}}}, {"text": "Look to FileSystemView.getRoots()1, which", "label": {"api": {"FileSystemView.getRoots()": [[8, 32]]}}}, {"text": "See the Javadoc of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "A ConcurrentSkipListSet is probably what you want", "label": {"api": {"ConcurrentSkipListSet": [[2, 22]]}}}, {"text": "You could also use a CopyOnWriteArraySet", "label": {"api": {"CopyOnWriteArraySet": [[21, 39]]}}}, {"text": "You can verify that there are actually distinct objects by using System.identityHashCode()", "label": {"api": {"System.identityHashCode()": [[65, 89]]}}}, {"text": "You'll want to use a container that implements SortedSet", "label": {"api": {"SortedSet": [[47, 55]]}}}, {"text": "A PriorityQueue does not guarantee any ordering of it's elements when traversing through the iterator", "label": {"api": {"PriorityQueue": [[2, 14]]}}}, {"text": "Instead, as @BenjaminGruenbaum commented you can use a TreeSet which guarantees that the iterator will return the elements order", "label": {"api": {"TreeSet": [[55, 61]]}}}, {"text": "Another option is to use Collections.sort() to sort any List when you need it to be sorted", "label": {"api": {"Collections.sort()": [[25, 42]]}}}, {"text": "You could try with a HashSet", "label": {"api": {"HashSet": [[21, 27]]}}}, {"text": "Semaphore is a counting semaphore - you should read the javadoc for more info", "label": {"api": {"Semaphore": [[0, 8]]}}}, {"text": "The problem is that you're never telling the barber Semaphore that there's an available Barber", "label": {"api": {"Semaphore": [[52, 60]]}}}, {"text": "You can read about details in the Javadoc of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[45, 60]]}}}, {"text": "You can use ExternalContext#getMimeType() to get the right content type based on a file name", "label": {"api": {"ExternalContext#getMimeType()": [[12, 40]]}}}, {"text": "The standard way to load WAR resources is via the ServletContext", "label": {"api": {"ServletContext": [[50, 63]], "Context": [[57, 63]]}}}, {"text": "This can be injected using the Context annotation", "label": {"api": {"Context": [[31, 37]]}}}, {"text": "Have a look over here -  http://docs.oracle.com/javase/6/docs/api/java/sql/DatabaseMetaData.html#getTables%28java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String%5b%5d%29 - it will help you", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/sql/DatabaseMetaData.html#getTables%28java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String%5b%5d%29": [[25, 193]]}}}, {"text": "you better use a Map", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "Map is an object that maps keys to values", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "The following example shows how to simulate mouse and key presses in Java using java.awt.Robot class", "label": {"api": {"Robot": [[89, 93]]}}}, {"text": "The Robot class gave me everything I needed", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "I read this API but I still didn't understand", "label": {"api": {"this API": [[7, 14]]}}}, {"text": "You can't overload operators in Java - normally for equality comparisons you should use equals (which you can override and overload in your own class) and implement Comparable<T> for ordering, then use compareTo", "label": {"api": {"Comparable<T>": [[165, 177]]}}}, {"text": "Java has the built-in AffineTransform, but an affine transform always preserves the \"parallelness\" of lines, so you cannot use that", "label": {"api": {"AffineTransform": [[22, 36]]}}}, {"text": "Now if you search the web for \"java perspective transformation\", you will find lots of options like the JavaFX PerspectiveTransform, the JAI PerspectiveTransform", "label": {"api": {"PerspectiveTransform": [[111, 130], [141, 160]]}}}, {"text": "A JavaFX based solution using a PerspectiveTransform as suggested by @lbalazscs answer", "label": {"api": {"PerspectiveTransform": [[32, 51]]}}}, {"text": "In response to some comments asking questions about the behaviour of Arrays.asList() since Java 8", "label": {"api": {"Arrays.asList()": [[69, 83]]}}}, {"text": "You want to use Collections.sort in conjunction with a custom Comparator", "label": {"api": {"Collections.sort": [[16, 31]], "Comparator": [[62, 71]]}}}, {"text": "Essentially, a Comparator is a key that signifies how a list should be ordered via its compare method", "label": {"api": {"Comparator": [[15, 24]]}}}, {"text": "With the Comparator above, we consider z1 to be greater than z2 if z1 has the higher x value (and we show this by returning 1)", "label": {"api": {"Comparator": [[9, 18]]}}}, {"text": "The same can be seen in other languages like Java", "label": {"api": {"Java": [[45, 48]]}}}, {"text": "This will print the toString() of the byte[] array object for each Base64.encodeBase64(\"hello\".getBytes()) which will be different objects and hence different output to the console", "label": {"api": {"toString()": [[20, 29]]}}}, {"text": "It executes the toString() method of Object class which, according to the Javadocs says", "label": {"api": {"toString()": [[16, 25]]}}}, {"text": "To get the correct String representation , use Arrays.toString() method", "label": {"api": {"toString()": [[54, 63]], "Arrays.toString()": [[47, 63]]}}}, {"text": "What is the difference between javax.sql.DataSource and javax.sql.ConnectionPoolDataSource", "label": {"api": {"javax.sql.DataSource": [[31, 50]], "javax.sql.ConnectionPoolDataSource": [[56, 89]]}}}, {"text": "If you are searching for some specific string or pattern in the file you can use scanner.findWithinHorizon()", "label": {"api": {"scanner.findWithinHorizon()": [[81, 107]]}}}, {"text": "Otherwise you can use RandomAccessFile class", "label": {"api": {"RandomAccessFile": [[22, 37]]}}}, {"text": "DecimalFormat#format(double) returns a String so the output needs to be this type rather than a Double", "label": {"api": {"DecimalFormat#format(double)": [[0, 27]]}}}, {"text": "Math.round(double) will return a long, which can't be implicitly casted as you would lose precision", "label": {"api": {"Math.round(double)": [[0, 17]]}}}, {"text": "The constructor you need is String(byte[] bytes, int offset, int length)", "label": {"api": {"String(byte[] bytes, int offset, int length)": [[28, 71]]}}}, {"text": "The API document of paint said", "label": {"api": {"API document of paint": [[4, 24]]}}}, {"text": "To append to an existing file , you need to use the overloaded constructor of FileWriter , which takes two arguments", "label": {"api": {"FileWriter": [[78, 87]]}}}, {"text": "Constructs a FileWriter object given a File object", "label": {"api": {"FileWriter": [[13, 22]]}}}, {"text": "You can use Set to avoid inserting duplicates", "label": {"api": {"Set": [[12, 14]]}}}, {"text": "But for that you need to override the hashCode() and equals() method of your Employee class to define what exactly is e1.equals(e2)", "label": {"api": {"hashCode()": [[38, 47]], "equals()": [[53, 60]]}}}, {"text": "You can then use writeObject method of ObjectOutputStream ( http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html ) to send command/data to server using default Java serialization (that's assuming that needed classes are also present in the server classpath)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html": [[60, 131]]}}}, {"text": "You will also need to compute the CRC-32 of the uncompressed data to be able to fill in those fields", "label": {"api": {"CRC-32": [[34, 39]]}}}, {"text": "If you require a solution where memory is at a premium, you might want to consider an ExecutorService", "label": {"api": {"ExecutorService": [[86, 100]]}}}, {"text": "You can use other version of String#indexOf(String str, int fromIndex) to specify from what position you would like to start searching \")\"", "label": {"api": {"String#indexOf(String str, int fromIndex)": [[29, 69]]}}}, {"text": "If you need the last index, you could use lastIndexOf(), for both \"(\" and \")\"", "label": {"api": {"lastIndexOf()": [[42, 54]]}}}, {"text": "If you need precisely the second occurrence, you could use the version of indexOf() that lets you specify an index where to start the search, and set that index to be the one after the first occurrence of your char, Like this", "label": {"api": {"version of indexOf()": [[63, 82]]}}}, {"text": "The javadoc for the String#substring(int index) method says", "label": {"api": {"String#substring(int index)": [[20, 46]]}}}, {"text": "You can set the path to an environment variable using System.getenv() (no .bat script required)", "label": {"api": {"System.getenv()": [[54, 68]]}}}, {"text": "Use ListModel if you want to change the content of a JList dynamically", "label": {"api": {"ListModel": [[4, 12]]}}}, {"text": "If you're out of luck you can always try BufferedWriter.newLine()", "label": {"api": {"BufferedWriter.newLine()": [[41, 64]]}}}, {"text": "I was hoping for something more elegant like Integer.valueOf() for parsing", "label": {"api": {"Integer.valueOf()": [[45, 61]]}}}, {"text": "After doing some deeper reading, the javadoc says the Character methods based on char parameters do not support all unicode values, but those taking code points (i.e., int) do", "label": {"api": {"Character": [[54, 62]]}}}, {"text": "It returns False, because matches() compares the complete input string against the pattern", "label": {"api": {"matches()": [[26, 34]]}}}, {"text": "To check if your string contains a pattern use the find() method", "label": {"api": {"find()": [[51, 56]]}}}, {"text": "Just to be sure I checked the JavaDoc again (http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html) and that's the case", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html": [[45, 113]]}}}, {"text": "The only type-safer way would be do a custom serialization, using writeObject(OutputStream) and readObjectInputStream say on a class ArrayListOfEquipa maybe using Equipa[] (ArrayList.toArray())", "label": {"api": {"serialization": [[45, 57]]}}}, {"text": "The (?s) part is an embedded flag expression, enabling the DOTALL mode, which means the following", "label": {"api": {"DOTALL": [[59, 64]]}}}, {"text": "You need to use Arrays.toString() to print the string representation of the array", "label": {"api": {"Arrays.toString()": [[16, 32]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CopyOnWriteArrayList.html suit your purpose", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CopyOnWriteArrayList.html": [[0, 86]]}}}, {"text": "java.lang.String.split(String regex) is what you are looking for", "label": {"api": {"java.lang.String.split(String regex)": [[0, 35]]}}}, {"text": "I'm not familiar with PHP, but I think String.split is Java equivalent to PHP explode", "label": {"api": {"String.split": [[39, 50]]}}}, {"text": "You just iterate over your array and build string using StringBuilder/StringBuffer", "label": {"api": {"StringBuilder": [[56, 68]], "StringBuffer": [[70, 81]]}}}, {"text": "The Javadoc for String reveals that String.split() is what you're looking for in regard to explode", "label": {"api": {"Javadoc for String": [[4, 21]]}}}, {"text": "I found a FutureTask that has a method get, however, this returns a value", "label": {"api": {"FutureTask": [[10, 19]]}}}, {"text": "My program does not expect a return value; is there any data structure similar to FutureTask without needing to return a value", "label": {"api": {"FutureTask": [[82, 91]]}}}, {"text": "Maybe this method is what you need", "label": {"api": {"this method": [[6, 16]]}}}, {"text": "This can be achieved by calling SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[32, 57]]}}}, {"text": "What do you think the primary motive for putting the equals method in java.lang.Object is", "label": {"api": {"equals": [[53, 58]]}}}, {"text": "I'm yet to see an implementation of equals in a factory class or something equivalent", "label": {"api": {"equals": [[36, 41]]}}}, {"text": "I have tried to search far and wide for the answer to this, but always land up in discussions or explanations as to the difference between == and equals or the best practices of writing equals", "label": {"api": {"equals": [[146, 151], [186, 191]]}}}, {"text": "From the javadoc of java.lang.Class<T>", "label": {"api": {"Class": [[30, 34]]}}}, {"text": "T - the type of the class modeled by this Class object", "label": {"api": {"Class": [[42, 46]]}}}, {"text": "For example, the type of String.class is Class<String>", "label": {"api": {"Class": [[41, 45]]}}}, {"text": "Use Class<?> if the class being modeled is unknown", "label": {"api": {"Class": [[4, 8]]}}}, {"text": "it's a Class of a type which is a ParentClass or a subclass of ParentClass", "label": {"api": {"Class": [[7, 11], [40, 44], [69, 73]]}}}, {"text": "It seemed this may be possible using javax.mail.internet.MimeMessage", "label": {"api": {"javax.mail.internet.MimeMessage": [[37, 67]]}}}, {"text": "Nonetheless, if I parse this way I do get access to the getFrom() method which returns an array of Address, which itself doesn't offer methods of use to me", "label": {"api": {"Address": [[99, 105]]}}}, {"text": "According to the docs for Collections.synchronizedList, the list mutator methods (add(), etc.) synchronize on the list object itself", "label": {"api": {"Collections.synchronizedList": [[26, 53]]}}}, {"text": "The javadoc of subList states", "label": {"api": {"javadoc of subList": [[4, 21]]}}}, {"text": "I have looked at Java Interface Instrumentation, but unless I'm misreading things, it appears to only relate to programs actively running on the JVM", "label": {"api": {"Interface Instrumentation": [[22, 46]]}}}, {"text": "For comprehensive documentation of Java regexes, see the Javadoc for java.util.regex.Pattern", "label": {"api": {"the Javadoc for java.util.regex.Pattern": [[53, 91]]}}}, {"text": "Java Compiler can be used for compiling at Runtime, but it requires a full source (Compilation Unit)", "label": {"api": {"Java Compiler": [[0, 12]]}}}, {"text": "Read from System.in of the second program", "label": {"api": {"System.in": [[10, 18]]}}}, {"text": "You should use the Process class", "label": {"api": {"Process": [[19, 25]]}}}, {"text": "Consider cutting your source document down to size using the StAX API", "label": {"api": {"StAX API": [[61, 68]]}}}, {"text": "This can then be passed to JAXB as a DOMSource", "label": {"api": {"passed to JAXB": [[17, 30]], "DOMSource": [[37, 45]]}}}, {"text": "I'm having troble with the -03 because according to the SimpleDateFormat documentation it should have 4 digits", "label": {"api": {"SimpleDateFormat": [[56, 71]], "Date": [[62, 65]]}}}, {"text": "When I print the new Date() I get this", "label": {"api": {"Date": [[21, 24]]}}}, {"text": "Does anyone know how I can parse the input into a Date with the correct TimeZone", "label": {"api": {"Date": [[50, 53]], "TimeZone": [[72, 79]]}}}, {"text": "You should be able to do the output using the same DateFormat using format()", "label": {"api": {"DateFormat": [[51, 60]], "format()": [[68, 75]]}}}, {"text": "Your problem is that Matcher#matches() only returns true if the whole sequence matches your regex", "label": {"api": {"Matcher#matches()": [[21, 37]]}}}, {"text": "You need Matcher#find(), which will look for matching subsequences", "label": {"api": {"Matcher#find()": [[9, 22]]}}}, {"text": "I also think you would be better off using the Pattern#DOTALL flag to let your", "label": {"api": {"Pattern#DOTALL": [[47, 60]]}}}, {"text": "You should set the preferred viewport size of the tables using setPreferredScrollableViewportSize(Dimension)", "label": {"api": {"setPreferredScrollableViewportSize(Dimension)": [[63, 107]]}}}, {"text": "Use the equals method of String to compare string values, which will return a boolean", "label": {"api": {"equals method of String": [[8, 30]]}}}, {"text": "Here's a way to do it by keeping track of the index yourself, then using subList to start the inner loop at the right spot", "label": {"api": {"subList": [[73, 79]]}}}, {"text": "Note that if you are using a collection that does not implement List<E>, this will not work (subList is defined on List<E> as the idea of an \"index\" really only makes sense for lists)", "label": {"api": {"subList": [[93, 99]]}}}, {"text": "for more look in API", "label": {"api": {"API": [[17, 19]]}}}, {"text": "So if you have a lot of items in your table, on the column call setSortable(false) and provide buttons for the user to sort table columns if you need to", "label": {"api": {"setSortable(false)": [[64, 81]]}}}, {"text": "Cloneable interface also should be implemented", "label": {"api": {"Cloneable": [[0, 8]]}}}, {"text": "with System.nanoTime) writing out the total time at the end, but run it with a console minimized", "label": {"api": {"System.nanoTime": [[5, 19]]}}}, {"text": "To demonstrate the (in)effectivenes of the add() operation, it is better to use the ListIterator object instead of list object", "label": {"api": {"ListIterator": [[84, 95]]}}}, {"text": "If you use the ListIterator, it will hold the position where we are adding the elements and the algorithm does not have to iterate into the middle of the list each time", "label": {"api": {"ListIterator": [[15, 26]]}}}, {"text": "My results shows that using using ListIterator on LinkedList gives the best performance for inserting the elements in the \"middle\"", "label": {"api": {"ListIterator": [[34, 45]]}}}, {"text": "Use @PostConstruct; example from a web application", "label": {"api": {"@PostConstruct": [[4, 17]]}}}, {"text": "Then use collections - add object instances to a List and use it's sort method", "label": {"api": {"collections": [[9, 19]]}}}, {"text": "You can use the FileLock API", "label": {"api": {"FileLock": [[16, 23]]}}}, {"text": "You can use the String.split method", "label": {"api": {"String.split": [[16, 27]]}}}, {"text": "If you want editable Strings in Java, use StringBuilder class (http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html)": [[63, 136]]}}}, {"text": "String.valueOf() however will try to convert whatever you pass into it to a String", "label": {"api": {"String.valueOf()": [[0, 15]]}}}, {"text": "It handles both primitives (42) and objects (new Integer(42), using that object's toString())", "label": {"api": {"toString()": [[82, 91]]}}}, {"text": "passing null to String.valueOf() will return the string \"null\"", "label": {"api": {"String.valueOf()": [[16, 31]]}}}, {"text": "Assuming that there are no duplicate Id keys, then any standard implementation of the Map interface will do", "label": {"api": {"Map interface": [[86, 98]]}}}, {"text": "That said, HashMap is the most performant of the standard Map implementations, provided that your only requirement is the protection against duplicate keys", "label": {"api": {"HashMap": [[11, 17]]}}}, {"text": "LinkedHashMap additionally provides iteration with a predictable order, with only a minimal performance hit", "label": {"api": {"HashMap": [[6, 12]], "LinkedHashMap": [[0, 12]]}}}, {"text": "TreeMap has a higher complexity, and thus lower performance, but it constantly keeps all entries sorted based on their keys", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "Check out SecurityManager", "label": {"api": {"SecurityManager": [[10, 24]]}}}, {"text": "Defining you own SecurityManager will allow you to restrict what the code can do by specifying a policy file", "label": {"api": {"SecurityManager": [[17, 31]]}}}, {"text": "Let's supply the DefaultEditor's JFormattedTextField with a custom action for the input notify event", "label": {"api": {"input notify": [[82, 93]]}}}, {"text": "If, furthermore, you need to check the validity of the entered value via a custom AbstractFormatter which you supplied to the JFormattedTextField, then just call JSpinner#commitEdit() upon ENTER", "label": {"api": {"AbstractFormatter": [[82, 98]], "JSpinner#commitEdit()": [[162, 182]]}}}, {"text": "Just giving a look at the API http://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html, anyone who do this should know that via Robot Class there is no \"trackComponent(Component specificComponent)\" method, you got 2 things that may help you", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html": [[30, 89]]}}}, {"text": "The abstract class graphic should probably extend JComponent", "label": {"api": {"JComponent": [[50, 59]]}}}, {"text": "Instead of the draw method you should override paintComponent", "label": {"api": {"paintComponent": [[47, 60]]}}}, {"text": "Consider using a threadsafe Map implementation such as ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[55, 71]]}}}, {"text": "A JPanel is in itself a Container (see http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html": [[39, 102]]}}}, {"text": "Assuming that you're using PrintWriter, you could use printf rather than println and use format specifiers to pad the String tokens", "label": {"api": {"printf": [[54, 59]]}}}, {"text": "Don't use PreparedStatement#setString() to set a Clob", "label": {"api": {"PreparedStatement#setString()": [[10, 38]]}}}, {"text": "There is a PreparedStatement#setClob() method that you can use instead", "label": {"api": {"PreparedStatement#setClob()": [[11, 37]]}}}, {"text": "E is still a Number, but now you are assigning a Double to an Integer", "label": {"api": {"Number": [[13, 18]]}}}, {"text": "So the casting behavior is consistent, Number can be all sorts of different Types, and so could E", "label": {"api": {"Number": [[39, 44]]}}}, {"text": "The Deitel statement is still correct, If you were assigning the Double to a Number or to an Object then you wouldn't need casting", "label": {"api": {"Number": [[77, 82]]}}}, {"text": "In this case though, E is not assigning \"upwards\" it's assigning \"laterally\" between two possible different Number types", "label": {"api": {"Number": [[108, 113]]}}}, {"text": "Don't forget to override the equals() and hashCode() methods in each of your entity classes (why?), otherwise the set won't be able to properly determine when two elements are equal", "label": {"api": {"equals()": [[29, 36]], "hashCode()": [[42, 51]]}}}, {"text": "Now in the above snippet the type parameter is one in particular (not Class as shown in the question, replace with the actual type as needed), and by using LinkedHashSet we guarantee that the ordering in the original list is preserved", "label": {"api": {"LinkedHashSet": [[156, 168]]}}}, {"text": "If the maze never changes, you can initially draw it into a BufferedImage", "label": {"api": {"BufferedImage": [[60, 72]]}}}, {"text": "You can use your same code you wrote for overriding paintComponent by creating a BufferedImage and calling image.createGraphics() on it to get a Graphics2D object", "label": {"api": {"BufferedImage": [[81, 93]]}}}, {"text": "Any painting you do to the Graphics2D object returned from createGraphics() is added to the BufferedImage", "label": {"api": {"BufferedImage": [[92, 104]]}}}, {"text": "Once you have your maze drawn into the BufferedImage, you can use any of the drawImage() functions in Graphics or Graphics2D", "label": {"api": {"BufferedImage": [[39, 51]]}}}, {"text": "You seem to be misunderstanding what Object's .hashCode() is about", "label": {"api": {"Object's .hashCode()": [[37, 56]]}}}, {"text": "I would try to delete the 1st line and then try to using String split by spaces", "label": {"api": {"String split": [[57, 68]]}}}, {"text": "Create your Comparator", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "And pass it to  Collections.sort", "label": {"api": {"Collections.sort": [[16, 31]]}}}, {"text": "Java has a Random class and one of it's methods is a nextGaussian which will give you a normal distribution from 0-1.0 (Gaussian Distribution and Normal Distribution are synonyms)", "label": {"api": {"Random": [[11, 16]]}}}, {"text": "CharsetEncoder.encode makes no guarantees about the underlying array size, nor that the ByteBuffer will actually be backed by an array", "label": {"api": {"CharsetEncoder.encode": [[0, 20]], "backed by an array": [[116, 133]]}}}, {"text": "You can use a Properties file that will take care of pretty much everything, it works like a Map", "label": {"api": {"Properties": [[14, 23]]}}}, {"text": "Place a call to System.exit() just before the end of your main function", "label": {"api": {"System.exit()": [[16, 28]]}}}, {"text": "You could use Arrays#deepEquals", "label": {"api": {"Arrays#deepEquals": [[14, 30]]}}}, {"text": "java.awt.Robot can be used to generate keypresses", "label": {"api": {"java.awt.Robot": [[0, 13]]}}}, {"text": "You could use String#split", "label": {"api": {"String#split": [[14, 25]]}}}, {"text": "So in my mind this can be implemented by having a lock (http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/ReentrantLock.html) instance per such method param", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/ReentrantLock.html": [[56, 141]]}}}, {"text": "You need to call getText() to get the complete text in the text area as a String", "label": {"api": {"getText()": [[17, 25]]}}}, {"text": "You can use Arrays.sort with a comparator", "label": {"api": {"Arrays.sort": [[12, 22]]}}}, {"text": "Use the constructor that specifys rows & columns", "label": {"api": {"constructor": [[8, 18]]}}}, {"text": "If you look at the Javadoc for getFields() you see the answer", "label": {"api": {"getFields()": [[31, 41]]}}}, {"text": "You need to use getDeclaredFields() instead", "label": {"api": {"getDeclaredFields()": [[16, 34]]}}}, {"text": "To get all fields, use getDeclaredFields(), which will return all fields that are declared directly on the class", "label": {"api": {"getDeclaredFields()": [[23, 41]]}}}, {"text": "I would suggest using a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[24, 36]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "Exchanger looks like the best choice", "label": {"api": {"Exchanger": [[0, 8]]}}}, {"text": "You need to call one of the Properties store methods", "label": {"api": {"Properties": [[28, 37]]}}}, {"text": "You should call Properties.store method", "label": {"api": {"Properties.store": [[16, 31]]}}}, {"text": "Combination of FilenameFilter and endsWith() method", "label": {"api": {"FilenameFilter": [[15, 28]], "endsWith()": [[34, 43]]}}}, {"text": "FileFilter is this class' parent, and implementing it for your need seems pretty trivial", "label": {"api": {"FileFilter": [[0, 9]]}}}, {"text": "You can use lastIndexOf to find the last ####", "label": {"api": {"lastIndexOf": [[12, 22]]}}}, {"text": "Vector itself is easily replaced with Collections.synchronizedList(new ArrayList())", "label": {"api": {"Collections.synchronizedList": [[38, 65]]}}}, {"text": "In between writing to the buffer and trying to read from it, call Buffer.flip()", "label": {"api": {"Buffer.flip()": [[66, 78]]}}}, {"text": "Although you are not directly defining start(), by extending Thread, an implementation of start() is being provided to def and its subclasses, therefore fulfilling the contract of the abc interface", "label": {"api": {"start()": [[39, 45], [90, 96]]}}}, {"text": "Try the String(char[], int, int) constructor", "label": {"api": {"String(char[], int, int) constructor": [[8, 43]]}}}, {"text": "If the Serializable interface is just a Marker-Interface that is used for passing some-sort of meta-data about classes in java - I'm a bit confused", "label": {"api": {"Serializable": [[7, 18]]}}}, {"text": "What data may cause the NotSerializableException", "label": {"api": {"Serializable": [[27, 38]]}}}, {"text": "How should I know that I am not supposed to add the implements Serializable clause for my class", "label": {"api": {"Serializable": [[63, 74]]}}}, {"text": "Assuming (because I have no other choice) that you're using a JTable, the way to disable a cell is to override the AbstractTableModel and override the isCellEditable method", "label": {"api": {"AbstractTableModel": [[115, 132]]}}}, {"text": "The root cause is java.lang.InstantiationException", "label": {"api": {"java.lang.InstantiationException": [[18, 49]]}}}, {"text": "This exception is thrown when Class.newInstance() is called", "label": {"api": {"Class.newInstance()": [[30, 48]]}}}, {"text": "The time can be specified using SimpleDateFormat patterns", "label": {"api": {"SimpleDateFormat": [[32, 47]]}}}, {"text": "You can use HOUR_OF_DAY for specific hour", "label": {"api": {"HOUR_OF_DAY": [[12, 22]]}}}, {"text": "The best you can do is to make a Double[] with the generic method toArray( T[] )", "label": {"api": {"toArray( T[] )": [[66, 79]]}}}, {"text": "Performing typecast upon expression (by using Expression#as(Class)) could help", "label": {"api": {"Expression#as(Class)": [[46, 65]]}}}, {"text": "but you could try using a special column definition and let your persistence provider handle the conversion", "label": {"api": {"column definition": [[34, 50]]}}}, {"text": "Use Statement.getGeneratedKeys() to retrieve autogenerated values", "label": {"api": {"Statement.getGeneratedKeys()": [[4, 31]]}}}, {"text": "If you're using Java 7, you can use the new Files class to copy files", "label": {"api": {"Files": [[44, 48]]}}}, {"text": "The Files.copy() methods can do most of the work for you", "label": {"api": {"Files": [[4, 8]]}}}, {"text": "See javadoc of Files.copy(...) for details", "label": {"api": {"Files.copy(...)": [[15, 29]]}}}, {"text": "See also the optional parameter CopyOption", "label": {"api": {"CopyOption": [[32, 41]]}}}, {"text": "According to the specs of valueOf(Object o), it will either call toString() on the object or return the string \"null\" if given a null Object", "label": {"api": {"the specs": [[13, 21]]}}}, {"text": "Does  java.lang.reflect.Array.get() do what you want", "label": {"api": {"java.lang.reflect.Array.get()": [[6, 34]]}}}, {"text": "Use Boolean instead of boolean", "label": {"api": {"Boolean": [[4, 10]]}}}, {"text": "For just tiles, you could use a shear transform", "label": {"api": {"shear transform": [[32, 46]]}}}, {"text": "Merely making use of List.contains() is sufficient - if the list doesn't contain the element, add it in, otherwise, throw the exception*", "label": {"api": {"List.contains()": [[21, 35]]}}}, {"text": "In which case, use the Node snapshot method instead of the scene snapshot method", "label": {"api": {"Node snapshot method": [[23, 42]]}}}, {"text": "Put all your characters in an ArrayList<Character>, then you can access them by index", "label": {"api": {"List": [[35, 38]]}}}, {"text": "You can find all the methods you need in the List JavaDoc", "label": {"api": {"List": [[45, 48]]}}}, {"text": "That's a method in the Component class (and of course all classes that inherit from it)", "label": {"api": {"Component class": [[23, 37]]}}}, {"text": "I can't really find documentation (in https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html#hasNext--) on this Topic", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html#hasNext--": [[38, 111]]}}}, {"text": "You can get the resources in your classpath (even when sealed in the JAR) by using the ClassLoader#getResource() and ClassLoader#getResourceAsStream() methods", "label": {"api": {"ClassLoader#getResource()": [[87, 111]], "ClassLoader#getResourceAsStream()": [[117, 149]]}}}, {"text": "Is there some example code for migrating from the standard LinkedBlockingQueue to LMAX' Disruptor architecture", "label": {"api": {"LinkedBlockingQueue": [[59, 77]]}}}]