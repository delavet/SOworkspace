[{"text": "If you read the documentation of println(Object x), it says", "label": {"api": {"println(Object x)": [[33, 49]]}}}, {"text": "If you then read the documentation of String.valueOf(Object obj), it says", "label": {"api": {"String.valueOf(Object obj)": [[38, 63]]}}}, {"text": "if the argument is null, then a string equal to \"null\"; otherwise, the value of obj.toString() is returned", "label": {"api": {"toString()": [[84, 93]]}}}, {"text": "All you have to do, is implement the toString() method inherited from Object in your class", "label": {"api": {"toString()": [[37, 46]]}}}, {"text": "As described in the comments by @JodaStephen, if you want to choose the other available offset, you can use the withLaterOffsetAtOverlap method", "label": {"api": {"the withLaterOffsetAtOverlap method": [[108, 142]]}}}, {"text": "There are details about the syntax of this pattern in the FileSysten.getPathMather method", "label": {"api": {"FileSysten.getPathMather": [[58, 81]]}}}, {"text": "You can call http://docs.oracle.com/javase/7/docs/api/javax/xml/stream/XMLEventReader.html#getElementText() when you know you have a text only XMLStreamConstants.START_ELEMENT", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/xml/stream/XMLEventReader.html#getElementText()": [[13, 106]]}}}, {"text": "When you have a List<Integer>, if you want to call remove(int index), you need to pass in an int", "label": {"api": {"remove(int index)": [[51, 67]]}}}, {"text": "If you want to call remove(Object o), you need to pass in an Integer", "label": {"api": {"remove(Object o)": [[20, 35]]}}}, {"text": "However, I'd suggest to use a ReadOnlyIntegerProperty to ensure that the property isn't modified somewhere else", "label": {"api": {"ReadOnlyIntegerProperty": [[30, 52]]}}}, {"text": "Your use case is described almost exactly in the sample code for java.util.concurrent.Exchanger", "label": {"api": {"java.util.concurrent.Exchanger": [[65, 94]]}}}, {"text": "See Formatter docs for more", "label": {"api": {"Formatter": [[4, 12]]}}}, {"text": "Read the spec of Random.nextInt(int) to get an idea of how they get around", "label": {"api": {"Random.nextInt(int)": [[17, 35]]}}}, {"text": "I think the closest you could come to a generic approach for this would be something like peek", "label": {"api": {"peek": [[90, 93]]}}}, {"text": "I mention it because unlike with the partitioning Collector you could, at least in theory, change together however many peeks you want--but, as you can see, you have to duplicate logic, so it's not ideal", "label": {"api": {"peek": [[120, 123]]}}}, {"text": "Additionally, be careful when using types like List and ArrayList", "label": {"api": {"List": [[47, 50], [61, 64]], "ArrayList": [[56, 64]]}}}, {"text": "You should make it a habit of addressing all compiler warnings, and of always specifying type parameters for generic types like List", "label": {"api": {"List": [[128, 131]]}}}, {"text": "match what you need and use Matcher#appendReplacement to modify the matched substrings (to replace all chars in it with * that you say is a fixed masking char)", "label": {"api": {"Matcher#appendReplacement": [[28, 52]]}}}, {"text": "Instead of creating a DOMSource from your string with the XML I would suggest to create a StreamSource https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/stream/StreamSource.html over a StringReader over you string variable", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/stream/StreamSource.html": [[103, 188]]}}}, {"text": "checkError returns true if and only if this stream has encountered an IOException other than InterruptedIOException, or the setError method has been invoked", "label": {"api": {"setError": [[124, 131]]}}}, {"text": "See the Javadoc of AccessibleObject, which in turn is a supertype of Method", "label": {"api": {"the Javadoc of AccessibleObject": [[4, 34]]}}}, {"text": "On the other hand, socketTimeout is driver specific (although most drivers have a similar setting) and is - usually - used to configure the low-level socket timeout using Socket.setSoTimeout(int)", "label": {"api": {"Socket.setSoTimeout(int)": [[171, 194]]}}}, {"text": "Task has a cancelation mechanism already, so there is no need to implement this yourself with the running flag (which you have to be careful to make volatile, or use other ways to make sure changes to it from one thread are visible in another)", "label": {"api": {"Task": [[0, 3]]}}}, {"text": "This will probably work as long as you're inside the range of cached values and use autoboxing, but cease to work outside that range (this range is only guarantied to be -128 to 127, see Integer.valueOf(int))", "label": {"api": {"Integer.valueOf(int)": [[187, 206]]}}}, {"text": "InetAddress can not resolve the host names with slashes", "label": {"api": {"InetAddress": [[0, 10]]}}}, {"text": "And then register the JacksonJsonProvider in your Client instance", "label": {"api": {"Client": [[50, 55]]}}}, {"text": "You should rather use a thread-safe collection from the package java.util.concurrent", "label": {"api": {"java.util.concurrent": [[64, 83]]}}}, {"text": "If you need a thread-safe Map, your best choice is to use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[60, 76]]}}}, {"text": "If you add duplicate keys using Collectors.toMap-method it throws an Exception with message \"duplicate key \"", "label": {"api": {"Collectors.toMap-method": [[32, 54]]}}}, {"text": "One trick to clean up the code is to use Stream#of and specify each element on its own row, and then join them together", "label": {"api": {"Stream#of": [[41, 49]]}}}, {"text": "To consume the event, call Event.consume() in the event handler of the Circle, e.g", "label": {"api": {"Event.consume()": [[27, 41]]}}}, {"text": "This works because the primary format of ZonedDateTime used by parse() is ISO_ZONED_DATE_TIME, so it will parse input in the format you described", "label": {"api": {"ZonedDateTime": [[41, 53]], "parse()": [[63, 69]], "ISO_ZONED_DATE_TIME": [[74, 92]]}}}, {"text": "The output format you requested happens to be the default format of Instant, as returned by its toString() method, i.e", "label": {"api": {"Instant": [[68, 74]], "toString()": [[96, 105]]}}}, {"text": "the ISO_INSTANT format", "label": {"api": {"ISO_INSTANT": [[4, 14]]}}}, {"text": "Converting between the two (ZonedDateTime to Instant using the toInstant() method) will perform the timezone adjustment necessary", "label": {"api": {"ZonedDateTime": [[28, 40]], "Instant": [[45, 51], [65, 71]], "toInstant()": [[63, 73]]}}}, {"text": "To answer your question about empty Iterables, however..", "label": {"api": {"Iterable": [[36, 43]]}}}, {"text": "it looks like that's certainly one way to test for an empty Iterable", "label": {"api": {"Iterable": [[60, 67]]}}}, {"text": "The Iterable interface only has one method", "label": {"api": {"Iterable": [[4, 11]]}}}, {"text": "Perhaps declaring points to return an Iterable is a bit too abstract for your needs", "label": {"api": {"Iterable": [[38, 45]]}}}, {"text": "This way, you can use Collection#isEmpty(), which is easier to read", "label": {"api": {"Collection#isEmpty()": [[22, 41]]}}}, {"text": "The obvious thing would be to create a TextArea and just append messages", "label": {"api": {"TextArea": [[39, 46]]}}}, {"text": "In one of many answers I read that TextArea should be accessed only from Main GUI Thread, so I used LinkedBlockingQueue as a Producer/Consument interface", "label": {"api": {"TextArea": [[35, 42]], "LinkedBlockingQueue": [[100, 118]]}}}, {"text": "But when I tried to append messages using Timer's scheduleAtFixedRate, I ran into more errors, like this", "label": {"api": {"scheduleAtFixedRate": [[50, 68]]}}}, {"text": "The List interface defines the behavior of its equals, and your debugger shows that ArrayList is being used", "label": {"api": {"equals": [[47, 52]]}}}, {"text": "ArrayList is a good guy, so we can assume that its implementation of equals is legit", "label": {"api": {"equals": [[69, 74]]}}}, {"text": "Thus, we can conclude that your SlaveEntityDTO class either does not override Object#equals(Object) or that it does so in a way that you aren't accounting for (which possibly means that it is implementing it incorrectly)", "label": {"api": {"equals": [[85, 90]], "Object#equals(Object)": [[78, 98]]}}}, {"text": "You can fix this by Overriding equals in BaseEntityDTO", "label": {"api": {"equals": [[31, 36]]}}}, {"text": "This will give basic behavior of equals to every subclass", "label": {"api": {"equals": [[33, 38]]}}}, {"text": "hashCode() MUST match the implementation of equals", "label": {"api": {"equals": [[44, 49]]}}}, {"text": "Using String's replaceAll with regex", "label": {"api": {"replaceAll": [[15, 24]]}}}, {"text": "You can do this with a ThreadPoolExecutor with core and maximum pool size of 1", "label": {"api": {"ThreadPoolExecutor": [[23, 40]]}}}, {"text": "Finally you need to provide a SynchronousQueue as the queue (although it's not really a queue at all), to make sure that a task is executed only if the single thread is available, otherwise a RejectedExecutionException is thrown", "label": {"api": {"SynchronousQueue": [[30, 45]]}}}, {"text": "Especially DiscardPolicy if you don't want even an exception from the rejected tasks", "label": {"api": {"DiscardPolicy": [[11, 23]]}}}, {"text": "The unique definition of equality necessitates overriding equals() (if the default does not suffice.)  Once you do that, you need to provide the matching hashCode() implementation, for all the reasons cited in the documentation", "label": {"api": {"equals()": [[58, 65]], "hashCode()": [[154, 163]]}}}, {"text": "However, you don't have to implement Comparable to order instances of a value object class, and indeed you probably shouldn't if you intend to order them multiple ways", "label": {"api": {"Comparable": [[37, 46]]}}}, {"text": "Simply passing an anonymous inline Comparator implementation to a sort method will suffice, with different comparator implementations for different orderings", "label": {"api": {"Comparator": [[35, 44]]}}}, {"text": "In recent years I myself have shied away from implementing Comparable for this very reason", "label": {"api": {"Comparable": [[59, 68]]}}}, {"text": "Of course, if there really is a natural ordering for your specific value object class, then by all means implement Comparable", "label": {"api": {"Comparable": [[115, 124]]}}}, {"text": "In that case make sure it is consistent with your equals() implementation", "label": {"api": {"equals()": [[50, 57]]}}}, {"text": "The java.util.Math utility class has the arc sin method, asin(...), that returns the radian result which can then be converted via Math's toDegrees(...) method to degrees", "label": {"api": {"java.util.Math": [[4, 17]]}}}, {"text": "However, according to the Javadocs for File.createTempFile, that is not a thrown exception", "label": {"api": {"File.createTempFile": [[39, 57]]}}}, {"text": "Array.binarySearch will return the index if it finds the value, otherwise it will return -1", "label": {"api": {"Array.binarySearch": [[0, 17]]}}}, {"text": "Afterwards, you could implement shutdown() with the help of Thread#join()", "label": {"api": {"Thread#join()": [[60, 72]]}}}, {"text": "Don't forget to replace while (true) with an appropriate condition (which you toggle in shutdown()) and consider using BlockingQueue#poll(long, TimeUnit) rather than take()", "label": {"api": {"BlockingQueue#poll(long, TimeUnit)": [[119, 152]]}}}, {"text": "The problem is that the second argument to indexOf is the first index in the string that it searches", "label": {"api": {"indexOf": [[43, 49]]}}}, {"text": "You can use Arrays.sort(T[], Comparator<T>) for this", "label": {"api": {"Arrays.sort(T[], Comparator<T>)": [[12, 42]]}}}, {"text": "If you're looking to just replace characters in a string, you're probably best off rebuilding your string entirely using String.substring", "label": {"api": {"String.substring": [[121, 136]]}}}, {"text": "You can obtain a Collection of all the values in a map using the values() method", "label": {"api": {"values()": [[65, 72]]}}}, {"text": "If you need the keys that lead to that value (which, of course, may occur more than once), then you'll need to iterate over the key set, obtained using Map.keySet() (or entry set, obtained using Map.entrySet()) for doubleMap and also for each Map retrieved for each key", "label": {"api": {"Map.keySet()": [[152, 163]], "Map.entrySet()": [[195, 208]]}}}, {"text": "If you're worried about performance, you can also take a look at java.util.concurrent.locks.StampedLock (Java 8+)", "label": {"api": {"take a look at": [[50, 63]]}}}, {"text": "See the JavaFX CSS documentation for details on font settings", "label": {"api": {"JavaFX CSS documentation": [[8, 31]]}}}, {"text": "when you invoke the command method you overwrite the command passed to the ProcessBuilder constructor", "label": {"api": {"ProcessBuilder": [[75, 88]]}}}, {"text": "Also consider Timer class for such job", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "If the class loader does not provide a class's byte code via either getResource or getResourceAsStream (this is legal, the class loader contract does not specify such a thing), you can still use a Java agent for asking the VM to create the byte code for you", "label": {"api": {"se a Java agent": [[192, 206]]}}}, {"text": "The different drag modes are described in the documentation for MouseEvent", "label": {"api": {"documentation for MouseEvent": [[46, 73]]}}}, {"text": "As discussed in the comments, it's generally better to use Scanner.nextLine() to capture user input", "label": {"api": {"Scanner.nextLine()": [[59, 76]]}}}, {"text": "I used a newSingleThreadExecutor to achieve this, since it can take multiple runnables to a queue and run them sequentially, it can be given tasks from several places and it will run them one by one, it's similar to platform.runLater", "label": {"api": {"newSingleThreadExecutor": [[9, 31]]}}}, {"text": "You might check out the String.format() method to do this", "label": {"api": {"String.format()": [[24, 38]]}}}, {"text": "In this case, you will need learn regular expression and a built-in String function String.replaceAll() to capture all possible unwanted words", "label": {"api": {"String.replaceAll()": [[84, 102]]}}}, {"text": "Why do you ask when the javadoc of Properties.load(InputStream inStream) says this", "label": {"api": {"Properties.load(InputStream inStream)": [[35, 71]]}}}, {"text": "Java's String#split method will create a token for each point appearing between two delimiters", "label": {"api": {"String#split": [[7, 18]]}}}, {"text": "Don't use String#getBytes() it will decode your String using the platform's default charset which means that it is platform dependent", "label": {"api": {"String#getBytes()": [[10, 26]]}}}, {"text": "I couldn't find a way to do this with MethodHandles, but there is an interesting java.beans.Statement that implements finding the JLS' most specific method according to the Javadocs", "label": {"api": {"java.beans.Statement": [[81, 100]]}}}, {"text": "I can open cmd using process", "label": {"api": {"process": [[21, 27]]}}}, {"text": "I looked into the Scheduled Executor Service but unable to configure the delay prameters from a XML file", "label": {"api": {"Scheduled Executor Service": [[18, 43]]}}}, {"text": "You need to use setMediaLocation(location) to specify the location of the media to launch, so try this instead", "label": {"api": {"setMediaLocation(location)": [[16, 41]]}}}, {"text": "Alternatively you can use setMediaLocator(locator) for the same purpose but a little bit more convenient in case you have an URL, the code would then be", "label": {"api": {"setMediaLocator(locator)": [[26, 49]]}}}, {"text": "You must use CallableStatement adding de corresponding parameters", "label": {"api": {"CallableStatement": [[13, 29]]}}}, {"text": "From looking at the documentation for Java Scanner.nextInt() it will throw an exception if the input is not an int", "label": {"api": {"Java Scanner.nextInt()": [[38, 59]]}}}, {"text": "See the Cell class documentation for general information about the cell rendering mechanism", "label": {"api": {"Cell class documentation": [[8, 31]]}}}, {"text": "They are several predefined reporters in JVM instrumentation, but strangely I could not find any reporting the CPU usage", "label": {"api": {"JVM instrumentation": [[41, 59]]}}}, {"text": "I could create my own Gauge (using getThreadCpuTime or similar), but my best guess is that I am missing something", "label": {"api": {"getThreadCpuTime": [[35, 50]]}}}, {"text": "Process.destroy might (and probably will, but this is implementation dependent) kill your process and this is why you're getting your java.io.IOException", "label": {"api": {"Process.destroy": [[0, 14]]}}}, {"text": "If you're using Java 8, I'd suggest using Process.waitFor with the timeout constructor", "label": {"api": {"Process.waitFor": [[42, 56]]}}}, {"text": "If you read the docs for List, you will see that List is actually an interface", "label": {"api": {"docs for List": [[16, 28]]}}}, {"text": "Starting from Java 8, you can do it directly with the Stream API more precisely with a parallel stream which uses behind the scene a ForkJoinPool in order to leverage its work-stealing algorithm to provide the best possible performances", "label": {"api": {"Stream API": [[54, 63]], "ForkJoinPool": [[133, 144]]}}}, {"text": "By default a parallel stream will use the common ForkJoinPool with a size corresponding to Runtime.getRuntime().availableProcessors() which is enough for tasks with very few IO, if you have tasks with IO such that you would like to increase the size of the pool, simply provide the initial task to your custom ForkJoinPool, the parallel stream will then use your pool instead of the common pool", "label": {"api": {"ForkJoinPool": [[49, 60], [310, 321]]}}}, {"text": "Take a look at java.lang.Character", "label": {"api": {"java.lang.Character": [[15, 33]]}}}, {"text": "If you can live with the boxing cost, a Collections.unmodifiableList() or Guava ImmutableList will work", "label": {"api": {"Collections.unmodifiableList()": [[40, 69]]}}}, {"text": "The Date class have a method getTime(), which retrieves the milliseconds since Jan 1, 1970", "label": {"api": {"Date": [[4, 7]], "getTime()": [[29, 37]]}}}, {"text": "The Java replace function has a method declaration of", "label": {"api": {"replace function": [[9, 24]]}}}, {"text": "Maybe you can use fill function", "label": {"api": {"fill": [[18, 21]]}}}, {"text": "You can use System#arraycopy, which takes arguments for the start indexes in both the source and destination arrays", "label": {"api": {"System#arraycopy": [[12, 27]]}}}, {"text": "From Java 8 stream tutorials", "label": {"api": {"Java 8 stream tutorials": [[5, 27]]}}}, {"text": "Use a DateAxis for the domain; call setDateFormatOverride() to get the format you want", "label": {"api": {"Date": [[6, 9], [39, 42]]}}}, {"text": "I did set the DateFormat to show years, and it has 1970 as a year", "label": {"api": {"Date": [[14, 17]]}}}, {"text": "You're example is creating new date values using seconds, but Date expects milliseconds", "label": {"api": {"Date": [[62, 65]]}}}, {"text": "All pattern letters are the standard DateTimeFormatter letters, except for the TTTTT part, which is a seconds-of-day field", "label": {"api": {"DateTimeFormatter": [[37, 53]]}}}, {"text": "By the @Path annotation, I assume you are using JAX-RS (Jersey, RESTEasy, etc)", "label": {"api": {"@Path": [[7, 11]]}}}, {"text": "Don't use a Stage in a Swing application; instead, use a JFrame and embed the JavaFX content inside it using a JFXPanel", "label": {"api": {"JFXPanel": [[111, 118]]}}}, {"text": "you have to manually evict the D entity from the persistence context (detach()) before resuming the loop", "label": {"api": {"detach()": [[70, 77]]}}}, {"text": "This uses a comparator, documentation here", "label": {"api": {"documentation here": [[24, 41]]}}}, {"text": "Use the form of Collectors.groupingBy() that allows you to specify the type of Map to use, and specify a SortedMap or NavigableMap implementation", "label": {"api": {"Collectors.groupingBy()": [[16, 38]]}}}, {"text": "The split function might be what you're looking for here", "label": {"api": {"split": [[4, 8]]}}}, {"text": "and the second, is to use Matcher class", "label": {"api": {"Matcher": [[26, 32]]}}}, {"text": "Use overloaded version of lastIndexOf(), which takes the starting index as 2nd parameter", "label": {"api": {"lastIndexOf()": [[26, 38]]}}}, {"text": "Another solution would be using a Pattern to match your input, something like [^:]+:[^:]+$", "label": {"api": {"Pattern": [[34, 40]]}}}, {"text": "Using a pattern is also likely be more efficient than String.split() as the latter is also converting its parameter to a Pattern internally, but it does more than what you actually need", "label": {"api": {"Pattern": [[121, 127]]}}}, {"text": "Bear in mind that this may returns null to handle absent Optionals", "label": {"api": {"Optional": [[57, 64]]}}}, {"text": "This can be worked around by calling setImplicitExit(true) in the start method of the Application", "label": {"api": {"setImplicitExit(true)": [[37, 57]]}}}, {"text": "For example, Writer has this method", "label": {"api": {"Writer": [[13, 18]]}}}, {"text": "You might find it easier to use a ForkJoinPool to manage the splitting and joining of the ranges, rather than attempting to do it by hand", "label": {"api": {"ForkJoinPool": [[34, 45]]}}}, {"text": "You're getting this error because charAt(index) basically returns the char value at the specified index", "label": {"api": {"charAt(index)": [[34, 46]]}}}, {"text": "Using Map#computeIfAbsent allows to have just one line for both the case where you already have a list in the map and where you don't", "label": {"api": {"Map#computeIfAbsent": [[6, 24]]}}}, {"text": "Also note that you don't need replaceAll (you're not using regex here, replace is enough)", "label": {"api": {"replaceAll": [[30, 39]], "replace": [[30, 36], [71, 77]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "Assuming that you use Java 8 a good way to implement it is with CompletableFuture as it will allow you to define a flow of asynchronous tasks to execute", "label": {"api": {"CompletableFuture": [[64, 80]]}}}, {"text": "Is it possible to scroll ScrollPane programmatically to given position", "label": {"api": {"ScrollPane": [[25, 34]]}}}, {"text": "ScrollPane#vvalue and ScrollPane#hvalue are useless, because they vary from 0 to 1", "label": {"api": {"ScrollPane": [[0, 9], [22, 31]]}}}, {"text": "Use a NumberFormat and specify the minimum and maximum number of digits you want to see after the decimal point", "label": {"api": {"NumberFormat": [[6, 17]]}}}, {"text": "Easiest way to create such a NumberFormat is to actually create a DecimalFormat", "label": {"api": {"NumberFormat": [[29, 40]], "DecimalFormat": [[66, 78]]}}}, {"text": "You can use the TimeUnit class to convert between different measurements of time", "label": {"api": {"TimeUnit": [[16, 23]]}}}, {"text": "You can set a Synchronization object on the Transaction, and use its methods to be notified when a txn commits/rolls back", "label": {"api": {"Synchronization": [[14, 28]]}}}, {"text": "Use toCharArray() method to convert String into charArray", "label": {"api": {"toCharArray()": [[4, 16]]}}}, {"text": "You could use a ToggleButton, so that you only place the archer when the toggle button is selected", "label": {"api": {"ToggleButton": [[16, 27]]}}}, {"text": "It's specific to Java insofar as the documentation italicizes the term and there is a naturalOrder method", "label": {"api": {"naturalOrder method": [[86, 104]]}}}, {"text": "I've encountered some class names being plural in Java, such as Collections (not to be confused with Collection), and Package java.util lists a couple of others in that package alone, such as Arrays and Objects", "label": {"api": {"Package java.util": [[118, 134]]}}}, {"text": "I think you could create your own implementation of XAResource (http://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html) which you would enlist to the Atomikos global transaction", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html": [[64, 135]]}}}, {"text": "Then your one throws, I think, XAException.XA_HEURRB (https://docs.oracle.com/javase/7/docs/api/javax/transaction/xa/XAException.html#XA_HEURRB) (implementing commit method to throw it)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/transaction/xa/XAException.html#XA_HEURRB": [[54, 142]]}}}, {"text": "Further to @dahui's answer, the other option is to switch m.matches() with m.find()", "label": {"api": {"m.find()": [[75, 82]]}}}, {"text": "For that reason I'm using a Stack in which I need to store different objects", "label": {"api": {"Stack": [[28, 32]]}}}, {"text": "To achieve this, I created an Interface called Stackable, so I have a Stack<Stackable>", "label": {"api": {"Stack": [[47, 51], [70, 74], [76, 80]]}}}, {"text": "As I didn't like the idea of an empty interface, I started reading and came accross with the term Marker interface, which I think is the case of my Stackable", "label": {"api": {"Stack": [[148, 152]]}}}, {"text": "But you can do it using a ListIterator", "label": {"api": {"ListIterator": [[26, 37]]}}}, {"text": "The ZonedDateTime will always use UTC (+ 0) plus the defined time zone", "label": {"api": {"ZonedDateTime": [[4, 16]]}}}, {"text": "Get the current moment as an Instant", "label": {"api": {"Instant": [[29, 35]]}}}, {"text": "The Instant class represents a moment on the timeline in UTC with a resolution of nanoseconds (up to nine (9) digits of a decimal fraction)", "label": {"api": {"Instant": [[4, 10]]}}}, {"text": "To determine the future moment of the alarm, use the TemporalAdjuster interface to manipulate date-time values", "label": {"api": {"TemporalAdjuster": [[53, 68]]}}}, {"text": "The class TemporalAdjusters (note the plural s) provides implementations", "label": {"api": {"TemporalAdjuster": [[10, 25]], "TemporalAdjusters": [[10, 26]]}}}, {"text": "Note that Integer.valueOf(-1) is guaranteed to be cached, so this does not create a new object on each call", "label": {"api": {"guaranteed to be cached": [[33, 55]]}}}, {"text": "It can be done using the Stream API with the appropriate mergeFunction as next", "label": {"api": {"Stream API": [[25, 34]]}}}, {"text": "you can use the  getRGB(x,y) and setRGB(x,y,rgb) to get and set the specified pixels of an BufferedImage", "label": {"api": {"BufferedImage": [[91, 103]]}}}, {"text": "Your approach based on Class#getResourceAsStream(name) will only work if and only if your file is accessible from the ClassLoader of your calling class and here  what you have directly under WEB-INF is not accessible, you should move conf/conf.properties in WEB-INF/classes instead and use /conf/conf.properties as resource name to make it get the file from the root not from the package of your calling class", "label": {"api": {"Class#getResourceAsStream(name)": [[23, 53]]}}}, {"text": "Trim the newline off before parsing with your scanner", "label": {"api": {"Trim": [[0, 3]]}}}, {"text": "The Java API documentation only states that compareToIgnoreCase() \"Returns", "label": {"api": {"Java API documentation": [[4, 25]]}}}, {"text": "See also Enum.name()", "label": {"api": {"Enum.name()": [[9, 19]]}}}, {"text": "The java.util.concurrent.ThreadPoolExecutor is probably your best starting point", "label": {"api": {"java.util.concurrent.ThreadPoolExecutor": [[4, 42]]}}}, {"text": "You can use an AnimationTimer which (tries to)runs at 60 frames per second.So every time 10 seconds pass you execute the code(You have to start the AnimationTimer every time)", "label": {"api": {"AnimationTimer": [[15, 28], [148, 161]]}}}, {"text": "The first one invokes equals on the parameter productId, while the second one invokes equals on the current list element from productList", "label": {"api": {"equals": [[22, 27], [86, 91]]}}}, {"text": "The result is the same because equals is symmetric", "label": {"api": {"equals": [[31, 36]]}}}, {"text": "for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true", "label": {"api": {"equals": [[45, 50], [91, 96]]}}}, {"text": "You can also use a stream for this, so you don't have to care about implementation details (furthermore, Objects#equals(Object, Object) is null-safe)", "label": {"api": {"equals": [[113, 118]], "Objects#equals(Object, Object)": [[105, 134]]}}}, {"text": "Since equals() is required by Java to be symmetric, there is no difference between the two snippets", "label": {"api": {"required": [[18, 25]]}}}, {"text": "why do you think that two arbitrary classes that well, are, in the end, different classes .", "label": {"api": {"that": [[17, 20], [44, 47]]}}}, {"text": "at that point in time, when you write your code, you better make sure that you understand each and every detail of your code", "label": {"api": {"that": [[3, 6], [70, 73]]}}}, {"text": "And when you don't do that up-front but you directly start your experiments; and you run into surprises", "label": {"api": {"that": [[22, 25]]}}}, {"text": "Of course it is convenient to have other people explain that to you, but the essence of being a good programmer is intrinsic motivation to find out yourself what your code is (or will be) doing", "label": {"api": {"that": [[56, 59]]}}}, {"text": "your two examples make use of different kind of lists, that have different behavior; as specified in their corresponding Javadoc (this versus that)", "label": {"api": {"that": [[55, 58], [142, 145]]}}}, {"text": "If implementing all the methods seems like a lot of code, you could use Dynamic proxy that allows you to intercept all calls through one handler - but IMO that's needlessly complicated in this case", "label": {"api": {"Dynamic proxy": [[72, 84]]}}}, {"text": "I think you are looking for Runtime#exec(String)", "label": {"api": {"Runtime#exec(String)": [[28, 47]]}}}, {"text": "Just use ByteBuffer.getInt()", "label": {"api": {"ByteBuffer.getInt()": [[9, 27]]}}}, {"text": "You can simply use a Set to keep track of the numbers that you have already seen, and define a new function to encapsulate your \"generate unique random number\" logic", "label": {"api": {"Set": [[21, 23]]}}}, {"text": "The nested loops are confusing, for starters, but the Set is also preferable because it has constant (i.e", "label": {"api": {"Set": [[54, 56]]}}}, {"text": "Use Collections.sort with a Comparator to sort your list", "label": {"api": {"Collections.sort": [[4, 19]], "Comparator": [[28, 37]]}}}, {"text": "However, I'm not happy with the OutputStream copying loop since it's the \"outdated\" way of writing to streams", "label": {"api": {"OutputStream": [[32, 43]]}}}, {"text": "Instead, I want to use a Java 7 API method such as Files.copy", "label": {"api": {"Files.copy": [[51, 60]]}}}, {"text": "You're adding a new row, and so the TableModelListener will return the ALL_COLUMNS constant in your event for the column property, a value which is -1 reference", "label": {"api": {"reference": [[151, 159]]}}}, {"text": "Yes - you can always implement a Comparator yourself", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "The preferable way to do it is with Map#computeIfAbsent", "label": {"api": {"Map#computeIfAbsent": [[36, 54]]}}}, {"text": "The getFill() method returns a Paint object", "label": {"api": {"getFill()": [[4, 12]], "Paint": [[31, 35]]}}}, {"text": "Have a look at Files, especially readAllLines as well as write", "label": {"api": {"Files": [[15, 19]], "readAllLines": [[33, 44]], "write": [[57, 61]]}}}, {"text": "Runnable doesn't take a parameter, but IntConsumer does", "label": {"api": {"IntConsumer": [[39, 49]]}}}, {"text": "You can also browse the other functional interfaces in Java 8", "label": {"api": {"other functional interfaces in Java 8": [[24, 60]]}}}, {"text": "Instead, you should throw the correct exception - a NamingException, and test that your code handles it as expected (i.e., throws up a ConnectionFactoryException`)", "label": {"api": {"NamingException": [[52, 66]]}}}, {"text": "Using String#split, split the text based on the position of the comma, and then create a new Person instance to add to your list of callers", "label": {"api": {"String#split": [[6, 17]]}}}, {"text": "To retrieve an item from a list, use ArrayList.get()", "label": {"api": {"ArrayList.get()": [[37, 51]]}}}, {"text": "If you look up class Object (https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html), you will see it has no such method", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html": [[29, 91]]}}}, {"text": "Runtime#exec creates a new process that runs concurrently", "label": {"api": {"Runtime#exec": [[0, 11]]}}}, {"text": "This can be done using the method Process#waitFor of the Process that Runtime#exec returns", "label": {"api": {"Runtime#exec": [[70, 81]], "Process#waitFor": [[34, 48]]}}}, {"text": "Have a look at the Javadoc of Process for more information", "label": {"api": {"Javadoc of Process": [[19, 36]]}}}, {"text": "ArrayList uses readObject() and writeObject() for serialization", "label": {"api": {"readObject() and writeObject()": [[15, 44]]}}}, {"text": "The String class has a method length() where (quoting)", "label": {"api": {"length()": [[30, 37]]}}}, {"text": "Using SimpleDateFormat is error-prone because it implicitly uses a time zone (and the result could be changed by Daylight Saving Time switch, see the case of Europe/London when it was on Summer time in year 1970 - your implicit default year)", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "For example the built-in java.time package (Tutorial) in Java SE 8 with its LocalTime and ChronoUnit classes", "label": {"api": {"java.time": [[25, 33]], "LocalTime": [[76, 84]], "ChronoUnit": [[90, 99]]}}}, {"text": "Basic handlers taken from DragEvent javadoc page", "label": {"api": {"DragEvent": [[26, 34]]}}}, {"text": "calling List.add() returns a boolean value", "label": {"api": {"List.add()": [[8, 17]]}}}, {"text": "You just need to use Matcher.group(int)", "label": {"api": {"Matcher.group(int)": [[21, 38]]}}}, {"text": "In JavaFX you can filter for particular file types by adding ExtensionFilters to the list of filters returned by getExtensionFilters, like so", "label": {"api": {"ExtensionFilter": [[61, 75], [116, 130]]}}}, {"text": "I came across this line which states that \"However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access\"in the overall description of Java class [ConcurrentHashMap] (https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html": [[294, 378]]}}}, {"text": "It looks like you may want to use the DateTimeFormatter class, with documentation here and maybe going by something like this example", "label": {"api": {"documentation here": [[68, 85]]}}}, {"text": "I would like to create a chart like this in JavaFX, but the PieChart class doesn't seem to make it possible", "label": {"api": {"PieChart": [[60, 67]]}}}, {"text": "Instead, you could use Arrays.toString to print the result", "label": {"api": {"Arrays.toString": [[23, 37]]}}}, {"text": "You implemented an Iterator in your attempt at a solution and my solution is to implement it as a Spliterator/Stream", "label": {"api": {"Iterator": [[19, 26]], "Spliterator": [[98, 108]], "Stream": [[110, 115]]}}}, {"text": "Looking through the java documentation for java.util.UUID, I don't see how to do it", "label": {"api": {"java documentation for java.util.UUID": [[20, 56]]}}}, {"text": "see FileOutputStream for further explanation", "label": {"api": {"FileOutputStream": [[4, 19]]}}}, {"text": "From the Instance Javadocs", "label": {"api": {"Instance Javadocs": [[9, 25]]}}}, {"text": "Java Date's toString only returns the date in yyyy-mm-dd format", "label": {"api": {"toString": [[12, 19]]}}}, {"text": "So if you need time you should use getTime instead and use Javascript setTime on the other side", "label": {"api": {"getTime": [[35, 41]]}}}, {"text": "You can add the parents to the stream using Stream::concat", "label": {"api": {"using Stream::concat": [[38, 57]]}}}, {"text": "It could be achieved with a WriterInterceptor", "label": {"api": {"WriterInterceptor": [[28, 44]]}}}, {"text": "Then register the WriterInterceptor in your ResourceConfig / Application subclass", "label": {"api": {"WriterInterceptor": [[18, 34]], "Application": [[61, 71]]}}}, {"text": "However, it is not safe to use parallelStream(), forEach and a consumer adding things to a HashMap", "label": {"api": {"forEach": [[49, 55]]}}}, {"text": "This is what forEach will do, it will invoke the given consumer, which puts elements into the HashMap, from multiple threads, possibly at the same time", "label": {"api": {"forEach": [[13, 19]]}}}, {"text": "The solution here, as always, is not to use forEach, but to use a mutable reduction approach with the collect method and the built-in toMap", "label": {"api": {"forEach": [[44, 50]], "mutable reduction": [[66, 82]], "toMap": [[134, 138]]}}}, {"text": "Which also means that you don't need to use toConcurrentMap to be safe, this collector is needed if you specifically want a ConcurrentMap as result, not a general Map; but as far as thread safety is concerned with regard to collect, you can use both", "label": {"api": {"toConcurrentMap": [[44, 58]]}}}, {"text": "You can simply use getClass()", "label": {"api": {"getClass()": [[19, 28]]}}}, {"text": "If you just want BackEndDeveloper, you can use getClass().getSimpleName()", "label": {"api": {"getClass()": [[47, 56]]}}}, {"text": "Long.sum method support has been added in java 8 so, you can't access it if you set the JDK to Java 7", "label": {"api": {"Long.sum": [[0, 7]]}}}, {"text": "I would suggest that you go to the Pattern API and look for characters that can detect whitespace and then go to String API and find a method that can split a String based on an input regular expression (regex)", "label": {"api": {"Pattern API": [[35, 45]], "String API": [[113, 122]]}}}, {"text": "Your method takes a java.util.Scanner as input (unless your teacher has rolled his own Scanner, which would be bad naming practice)", "label": {"api": {"java.util.Scanner": [[20, 36]]}}}, {"text": "One of these methods is nextInt(), which reads the next int from the scanner's input and returns it", "label": {"api": {"nextInt()": [[24, 32]]}}}, {"text": "Your problem is related to the fact that you try to cast a String into an Integer which cannot work since String is not a sub class of Integer, you should provide a Function that will convert your String into the target type instead as next", "label": {"api": {"Function": [[165, 172]]}}}, {"text": "The previous code works with Java 8 and above, for previous versions, the logic is the same, you simply need to use FluentIterable from Google Guava to replace the Stream and use com.google.common.base.Function instead of java.util.function.Function the result is the following", "label": {"api": {"Function": [[202, 209], [241, 248]]}}}, {"text": "You can use String#replace", "label": {"api": {"String#replace": [[12, 25]]}}}, {"text": "If you do that, you can have the checker's interface take no extra arguments at all (a Predicate might work, for instance), and the specific subclasses that implement that checker could have the arguments passed at construction time", "label": {"api": {"Predicate": [[87, 95]]}}}, {"text": "Multiple threads can't call a single object's synchronized methods at the same time (provided they're both the same static or non-static), so if you need more advanced control, there are plenty of other concurrency mechanisms such as ReadWriteLock", "label": {"api": {"ReadWriteLock": [[234, 246]]}}}, {"text": "My guess is that your original implementation doesn't work because you're using the == operator to compare Strings when you should be using String#equals(Object)", "label": {"api": {"String#equals(Object)": [[140, 160]]}}}, {"text": "How about using Integer#toString() instead", "label": {"api": {"Integer#toString()": [[16, 33]]}}}, {"text": "Check, which charset you need, and use Files.lines(Path path, Charset cs) instead", "label": {"api": {"Files.lines(Path path, Charset cs)": [[39, 72]]}}}, {"text": "I was playing around with the Random class's nextDouble() method as shown below", "label": {"api": {"Random class's nextDouble()": [[30, 56]]}}}, {"text": "The simplest way to check if a list contains any elements from another list is to call contains() on one of the lists, passing each element as an argument in turn", "label": {"api": {"contains()": [[87, 96]]}}}, {"text": "This is slow, however, because contains() is a linear operation (O(n)), and since we're calling it in a loop the slowListContains() function takes quadratic time (O(n^2)) which is poor", "label": {"api": {"contains()": [[31, 40]]}}}, {"text": "A Set (or more precisely a hash-based set such as HashSet) has an efficient contains() method which runs in less-than-linear time (constant time in the case of HashSet)", "label": {"api": {"contains()": [[76, 85]], "Set": [[2, 4], [54, 56], [164, 166]], "HashSet": [[50, 56], [160, 166]]}}}, {"text": "Converting one or the other list into a Set will make the loop in slowListContains() much faster", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "A slight improvement would be to always convert the smaller list into the Set, rather than the first one", "label": {"api": {"Set": [[74, 76]]}}}, {"text": "You could also take arbitrary Iterable parameters rather than List parameters, then check if either of them are already a Set and if so skip the set-construction step", "label": {"api": {"Set": [[122, 124]]}}}, {"text": "You can use Comparator.comparing to get the Comparator to sort by version number", "label": {"api": {"Comparator.comparing": [[12, 31]]}}}, {"text": "Check out Math.random(), which gives you a random number [0,1)", "label": {"api": {"Math.random()": [[10, 22]]}}}, {"text": "Java 8's enhances to the Comaparator interface provide a pretty elegant way of doing this", "label": {"api": {"Comaparator": [[25, 35]]}}}, {"text": "as per the Runtime#exec() docs, you can pass individual arguments with spaces in them if you make them an array, as seen above", "label": {"api": {"Runtime#exec() docs": [[11, 29]]}}}, {"text": "Notice that I used Path instead of File, the try-with-resources pattern, and I don't suppress the exception, instead the caller (likely the main method) should handle the exception properly (likely by reporting the file doesn't exist and exiting)", "label": {"api": {"Path": [[19, 22]]}}}, {"text": "If you really want a Tree<String> but you want to order them as if they were integers you need a custom Comparator, as you mention", "label": {"api": {"Comparator": [[104, 113]]}}}, {"text": "You would then need to pass the Comparator into the Tree's constructor, and call comparator.compare(element, current.element) where you currently call element.compareTo(current.element)", "label": {"api": {"Comparator": [[32, 41]]}}}, {"text": "Looks like DateFormatSymbols has a setShortWeekdays function, which will enable you to set them yourself to (presumably) whatever you like", "label": {"api": {"DateFormatSymbols has a setShortWeekdays function": [[11, 59]]}}}, {"text": "The most brute-force way to fix this exception is to use a CopyOnWriteArrayList in place of your current List", "label": {"api": {"CopyOnWriteArrayList": [[59, 78]]}}}, {"text": "as fas as i know there is no out of the box way to implement what you want, but maybe you can implement a workaround using the stop and restar method", "label": {"api": {"using the stop and restar method": [[117, 148]]}}}, {"text": "In  Java, you have the fantastic ByteBuffer class that lets you encode / decode ordinary values (integers, floats, doubles) into / from bytes", "label": {"api": {"ByteBuffer": [[33, 42]]}}}, {"text": "ByteBuffer lets you specify the used endianness through its order(ByteOrder) method", "label": {"api": {"ByteBuffer": [[0, 9]], "order(ByteOrder)": [[60, 75]]}}}, {"text": "You can use addShutdownHook to catch the process termination event and wait for the pool there", "label": {"api": {"addShutdownHook": [[12, 26]]}}}, {"text": "Then Java Annotation processors (https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html) are what you are looking for", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html": [[33, 116]]}}}, {"text": "The method signature is allOf(Class<E> elementType)", "label": {"api": {"allOf(Class<E> elementType)": [[24, 50]]}}}, {"text": "Official specification says it all", "label": {"api": {"Official specification": [[0, 21]]}}}, {"text": "You can use the function toUpperCase", "label": {"api": {"toUpperCase": [[25, 35]]}}}, {"text": "Since I want to display a custom attribute (CopyrightYear) I couldn't use the Package API's method to automatically get attributes of the current Jar", "label": {"api": {"Package API's": [[78, 90]]}}}, {"text": "The documentation of ChronoUnit.between method says", "label": {"api": {"ChronoUnit.between": [[21, 38]]}}}, {"text": "Specifying controller methods as event handlers requires you to use a # followed by the method's name and nothing else (see also Introduction to FXML - Controller Method Event Handlers )", "label": {"api": {"Introduction to FXML - Controller Method Event Handlers": [[129, 183]]}}}, {"text": "The definition of equals for a Map is that they have the same entry set, regardless of order", "label": {"api": {"definition of equals for a Map": [[4, 33]]}}}, {"text": "The pools are a mix between Spring's schedulers and the standard Java ThreadPoolExecutor, but I guess they could be standardized into a single type if needed", "label": {"api": {"ThreadPoolExecutor": [[70, 87]]}}}, {"text": "If you look at jstatd source, you'll see that it is calling UnicastRemoteObject.exportObject(remoteHost, 0) which will open a new \"anonymous port\" which seems to be random", "label": {"api": {"UnicastRemoteObject.exportObject(remoteHost, 0)": [[60, 106]]}}}, {"text": "You can use String.getBytes(Charset) and Unpooled.wrappedBuffer(byte[]) to convert to ByteBuf", "label": {"api": {"String.getBytes(Charset)": [[12, 35]]}}}, {"text": "When you use <c:forEach> to iterate over a Map, each item in the iteration is an instance of Map.Entry", "label": {"api": {"Map.Entry": [[93, 101]]}}}, {"text": "That is each item in var=\"type\" will return an instance of Map.Entry", "label": {"api": {"Map.Entry": [[59, 67]]}}}, {"text": "It's unlikely, but if you need something even bigger than that, use BigInteger", "label": {"api": {"BigInteger": [[68, 77]]}}}, {"text": "You can do it with skip(long) and limit(long) as next", "label": {"api": {"skip(long)": [[19, 28]], "limit(long)": [[34, 44]]}}}, {"text": "However for this purpose List#subList(fromIndex, toIndex) seems to be much more appropriate using Stream only to extract a sub part of your initial list sounds like an abusive usage of the Stream API", "label": {"api": {"List#subList(fromIndex, toIndex)": [[25, 56]]}}}, {"text": "According to the javadoc for java.util.Scanner.skip, this method", "label": {"api": {"the javadoc for java.util.Scanner.skip": [[13, 50]]}}}, {"text": "If you use the getters there is all kind of information which looks like what you are after, especially ZoneOffsetTransition.getOffsetBefore() and getOffsetAfter() in combination with getInstant() or getDateTimeAfter()", "label": {"api": {"ZoneOffsetTransition.getOffsetBefore()": [[104, 141]]}}}, {"text": "I think you're looking for BiConsumer", "label": {"api": {"BiConsumer": [[27, 36]], "Consumer": [[29, 36]]}}}, {"text": "Alternatively, you can shorten the method signature and use a single-argument Consumer that captures your person reference", "label": {"api": {"Consumer": [[78, 85]]}}}, {"text": "Another is using a CharacterIterator, but it's overkill for this", "label": {"api": {"CharacterIterator": [[19, 35]]}}}, {"text": "NavigableMap.subMap() similarly returns a view of its underlying structure", "label": {"api": {"NavigableMap.subMap()": [[0, 20]]}}}, {"text": "Runtime environment programming restrictions and behaviour are described in the EJB specifications and JavaDoc, in particular javax.jms.Connection.createSession(boolean transacted, int acknowledgeMode)", "label": {"api": {"javax.jms.Connection.createSession(boolean transacted, int acknowledgeMode)": [[126, 200]]}}}, {"text": "Additionally, be sure to check the javadoc for javax.jms.Connection.createSession() and associated methods, particularly the sections describing behaviour in different runtime environments", "label": {"api": {"javax.jms.Connection.createSession()": [[47, 82]]}}}, {"text": "In Java you can use a Random access file", "label": {"api": {"Random access file": [[22, 39]]}}}, {"text": "If you're not clear what this means, check out the API for the Object class", "label": {"api": {"check out the API for the Object class": [[37, 74]]}}}, {"text": "Is there any way that I could get the supported image formats that the ImageIO.write() function can export", "label": {"api": {"ImageIO.write()": [[71, 85]]}}}, {"text": "it will then be sorted according to the natural ordering of its elements", "label": {"api": {"natural ordering": [[40, 55]]}}}, {"text": "The solution would be to use the String.trim to remove any white space", "label": {"api": {"String.trim": [[33, 43]]}}}, {"text": "Looking closer at your particular use case, you can disable the desired button in your implementation of the prepareEditor() method of JTable, as suggested here", "label": {"api": {"prepareEditor()": [[109, 123]]}}}, {"text": "Because JTable is a CellEditorListener, you can  enable the button in your implementation of the editingStopped() method of JTable, as discussed here", "label": {"api": {"editingStopped()": [[97, 112]]}}}, {"text": "You should first convert this view index to a model index using JTable.convertRowIndexToModel", "label": {"api": {"JTable.convertRowIndexToModel": [[64, 92]]}}}, {"text": "@camickr made the correct observation that you should be using the data that comes with the TableModelEvent, i.e", "label": {"api": {"TableModelEvent": [[92, 106]]}}}, {"text": "TableModelEvent.getFirstRow(), TableModelEvent.getLastRow() and TableModel.getColumn()", "label": {"api": {"TableModelEvent": [[0, 14], [31, 45]], "TableModelEvent.getFirstRow()": [[0, 28]], "TableModelEvent.getLastRow()": [[31, 58]], "TableModel.getColumn()": [[64, 85]]}}}, {"text": "I would just go with a sorted List<Item> here (see Collections.sort(List, Comparator))", "label": {"api": {"Collections.sort(List, Comparator)": [[51, 84]]}}}, {"text": "I think you should work with java.lang.Number class", "label": {"api": {"java.lang.Number": [[29, 44]]}}}, {"text": "You need to build a new string (look up StringBuilder) and return it", "label": {"api": {"StringBuilder": [[40, 52]]}}}, {"text": "val.getBytes() will allocate new array (actually more than one) and encode whole string into it every time you call it", "label": {"api": {"getBytes": [[4, 11]]}}}, {"text": "If you want to operate on characters or code points use charAt or codePointAt", "label": {"api": {"charAt": [[56, 61]], "codePointAt": [[66, 76]]}}}, {"text": "Notice also, that getBytes encodes the string using platform's default charset", "label": {"api": {"getBytes": [[18, 25]]}}}, {"text": "Arrays.sort accepts range parameters", "label": {"api": {"Arrays.sort": [[0, 10]]}}}, {"text": "The official documentation of java.lang.Thread explains why is stop() deprecated and what circumstances make it screw up programs", "label": {"api": {"The official documentation of java.lang.Thread": [[0, 45]]}}}, {"text": "Also with a large amount of circles you're probably better off using a Canvas to draw the image", "label": {"api": {"Canvas": [[71, 76]]}}}, {"text": "Probably, you are looking for the Object#clone()* method", "label": {"api": {"Object#clone()": [[34, 47]]}}}, {"text": "For a \"shallow copy\" the preceding example is good, but for a \"deep copy\" you need to override a default Object#clone() behaviour", "label": {"api": {"Object#clone()": [[105, 118]]}}}, {"text": "The Java api has a Cloneable Interface.Object has a clone method that can only be accessed when it's overridden in the subclass, that also implements the Cloneable interface", "label": {"api": {"Cloneable": [[19, 27], [154, 162]]}}}, {"text": "Try trim() which returns a copy of the string, with leading and trailing whitespace omitted", "label": {"api": {"trim()": [[4, 9]]}}}, {"text": "Do the search with an explicit loop, using trim() to remove spaces before testing; e.g", "label": {"api": {"trim()": [[43, 48]]}}}, {"text": "You can apply any transformation to a Text object and use a StackPane to put it on top of the image", "label": {"api": {"Text": [[38, 41]], "StackPane": [[60, 68]]}}}, {"text": "See also Applying Effects to Text for more info", "label": {"api": {"Text": [[29, 32]]}}}, {"text": "Therefore, I use a ContainerRequestFilter (without @PreMatching) and throw a WebApplicationException with a response containing an error entity, if the check is not passed", "label": {"api": {"ContainerRequestFilter": [[19, 40]], "@PreMatching": [[51, 62]], "WebApplicationException": [[77, 99]]}}}, {"text": "Based on @pedrofb good answer I found a easier work-around using ContainerRequestContext#getAcceptableMediaTypes", "label": {"api": {"ContainerRequestContext#getAcceptableMediaTypes": [[65, 111]]}}}, {"text": "Use Float#intValue() for your conversion", "label": {"api": {"Float#intValue()": [[4, 19]]}}}, {"text": "You're talking about OperatingSystemMXBean class of java.lang.management package", "label": {"api": {"java.lang.management": [[52, 71]]}}}, {"text": "There is the same name class in the com.sun.management package", "label": {"api": {"com.sun.management": [[36, 53]]}}}, {"text": "Note that the cast is necessary because the class you need is in java.sun.management package not in java.lang.management", "label": {"api": {"java.lang.management": [[100, 119]]}}}, {"text": "If one would write an application with multiple threads, that need concurrent access to x, one would most probably define x as AtomicInteger and use the methods int incrementAndGet() (instead of ++x) and int getAndIncrement() (instead of ++x)", "label": {"api": {"AtomicInteger": [[127, 139]], "int incrementAndGet()": [[161, 181]], "int getAndIncrement()": [[204, 224]]}}}, {"text": "I would personally synchronize my threads using await and signal/signalAll, and rely on the method Condition#await(long time, TimeUnit unit) to know if the answer was given or not while awaiting, so my code would be something like that", "label": {"api": {"Condition#await(long time, TimeUnit unit)": [[99, 139]]}}}, {"text": "Using Java 8 streams you could write", "label": {"api": {"Java 8 streams": [[6, 19]]}}}, {"text": "Windows includes the file's metadata, like they talk about here, but JFileChooser includes just the length() of the file's content", "label": {"api": {"length()": [[100, 107]]}}}, {"text": "Try also capturing the error output and the exit code - if you're not seeing anything in the standard output it's likely there's an error message in the error stream", "label": {"api": {"error output": [[23, 34]], "exit code": [[44, 52]]}}}, {"text": "If that too is empty it's possible the exit code provides some additional debugging details", "label": {"api": {"exit code": [[39, 47]]}}}, {"text": "You can consult a Windows exit code table to try to determine the cause of the exit", "label": {"api": {"exit code": [[26, 34]]}}}, {"text": "As an aside, you should always use the mutable StringBuilder when composing strings like you're doing; it uses much less memory", "label": {"api": {"StringBuilder": [[47, 59]]}}}, {"text": "String.format - Although this makes use of vararg syntax, it is under the hood converted into an array", "label": {"api": {"String.format": [[0, 12]]}}}, {"text": "Another alternative would be to use System.nanoTime() in addition to the normal systemtime, though that approach might provide quite a few pitfalls", "label": {"api": {"System.nanoTime()": [[36, 52]]}}}, {"text": "Use the UID-class provided by Oracle", "label": {"api": {"UID-class": [[8, 16]]}}}, {"text": "Another good approach would be to use UUID, which is part of the utility package and quite likely more general than UID", "label": {"api": {"UUID": [[38, 41]]}}}, {"text": "With ProcessBuilder we can launch native executables like from the Command Prompt", "label": {"api": {"ProcessBuilder": [[5, 18]]}}}, {"text": "The following code prints out the ProcessBuilder's environment", "label": {"api": {"ProcessBuilder": [[34, 47]]}}}, {"text": "What you want to do is create cloned objects and point to them, which you can do with the clone() method", "label": {"api": {"clone()": [[90, 96]]}}}, {"text": "This is all covered in detail in the JFXPanel documentation, but in essence", "label": {"api": {"JFXPanel documentation": [[37, 58]]}}}, {"text": "List.add() adds a single element to the list", "label": {"api": {"List.add()": [[0, 9]]}}}, {"text": "What you need is the List.addAll() method, which adds all elements from a collection (and not the collection itself) into the list", "label": {"api": {"List.addAll()": [[21, 33]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html to get all the methods you need to meet your requirements", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html": [[4, 73]]}}}, {"text": "CompletableFuture.supplyAsync(Supplier), they will be executed by the common ForkJoinPool and not the one you have configured for @Async", "label": {"api": {"CompletableFuture.supplyAsync(Supplier)": [[0, 38]], "common ForkJoinPool": [[70, 88]]}}}, {"text": "You can use a combination of flatMap and Stream.concat", "label": {"api": {"flatMap": [[29, 35]], "Stream.concat": [[41, 53]]}}}, {"text": "I would say a Timer probably suits your needs pretty well", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "using for example public void schedule(TimerTask task, long delay), you'd be able to set a timer that executes a task after a number of milliseconds", "label": {"api": {"Timer": [[39, 43]], "TimerTask": [[39, 47]]}}}, {"text": "So in your case 300000 milliseconds (5 minutes) and a TimerTask", "label": {"api": {"Timer": [[54, 58]], "TimerTask": [[54, 62]]}}}, {"text": "Try this (negative lookbehind (see Java API documentation for class Pattern)", "label": {"api": {"Java API documentation": [[35, 56]], "Pattern": [[68, 74]]}}}, {"text": "Per the javadocs for HttpServletResponse, the setStatus(int, String) method has actually been deprecated for this very reason (ambiguity of second argument purpose)", "label": {"api": {"HttpServletResponse": [[21, 39]]}}}, {"text": "are the arguments to PreparedStatement.setString(int, String)", "label": {"api": {"PreparedStatement.setString(int, String)": [[21, 60]]}}}, {"text": "From the Media class documentation", "label": {"api": {"Media class documentation": [[9, 33]]}}}, {"text": "The Comparable compareTo function must return", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "Currency.getDisplayName(java.util.Locale) is exactly what I want..", "label": {"api": {"Currency.getDisplayName(java.util.Locale)": [[0, 40]]}}}, {"text": "How can you get the equivalent of Currency.getDisplayName(java.util.Locale) before Java 7", "label": {"api": {"Currency.getDisplayName(java.util.Locale)": [[34, 74]]}}}, {"text": "You can print the contents of an array using the Arrays.toString() method but it doesn't work for multidimensional arrays, so for a 2 dimensional array, you'll need to loop through the elements in the first dimension", "label": {"api": {"Arrays.toString()": [[49, 65]]}}}, {"text": "Instead of loading the data to a BufferedImage, you should use the PixelReader for the javafx.scene.Image to get the data", "label": {"api": {"javafx.scene.Image": [[87, 104]]}}}, {"text": "Panes will not autoresize its content and AnchorPanes will only resize content if you call AnchorPane.setTopAnchor(Node), AnchorPane.setRightAnchor(Node), AnchorPane.setBottomAnchor(Node), or AnchorPane.setLeftAnchor(Node)", "label": {"api": {"AnchorPane.setTopAnchor(Node)": [[91, 119]], "AnchorPane.setRightAnchor(Node)": [[122, 152]], "AnchorPane.setBottomAnchor(Node)": [[155, 186]], "AnchorPane.setLeftAnchor(Node)": [[192, 221]]}}}, {"text": "You can set the VGrow and HGrow properties of the RowConstraints and ColumnConstraints, respectively, to resize the content in relation to the GridPane's size", "label": {"api": {"RowConstraints": [[50, 63]], "ColumnConstraints": [[69, 85]]}}}, {"text": "Setting the percentHeight and percentWidth of the RowConstraints and ColumnConstraints will also aid in keeping the rows and columns at their preferred proportions", "label": {"api": {"RowConstraints": [[50, 63]], "ColumnConstraints": [[69, 85]]}}}, {"text": "On the ScrollPane, set the fitToWidth and fitToHeight properties to keep its children resized to match the size of the ScrollPane", "label": {"api": {"fitToWidth": [[27, 36]], "fitToHeight": [[42, 52]]}}}, {"text": "Unless you can define a max size to your Base64 String, the best way to store your image content is not to store it as Base64 String but rather as an array of bytes (since it could be big) by simply defining your field with the JPA annotations @Lob (stands for Large Object) and  with the JPA annotation @Basic(fetch = FetchType.LAZY) in case you want to fetch it lazily, as next", "label": {"api": {"@Lob": [[244, 247]], "@Basic(fetch = FetchType.LAZY)": [[304, 333]]}}}, {"text": "If your Servlet reads the Request body (via either getInputStream() or getReader()) then you have read it, it cannot be read again", "label": {"api": {"getReader()": [[71, 81]], "getInputStream()": [[51, 66]]}}}, {"text": "The technique used, getReader() or getInputStream() is how that body content was presented, and cannot be changed", "label": {"api": {"getReader()": [[20, 30]], "getInputStream()": [[35, 50]]}}}, {"text": "If you used getReader(), then getInputStream() cannot be used later", "label": {"api": {"getReader()": [[12, 22]], "getInputStream()": [[30, 45]]}}}, {"text": "If you used getInputStream() then getReader() cannot be used later", "label": {"api": {"getReader()": [[34, 44]], "getInputStream()": [[12, 27]]}}}, {"text": "See the Javadoc for getReader() and getInputStream() for more details", "label": {"api": {"getReader()": [[20, 30]], "getInputStream()": [[36, 51]]}}}, {"text": "MediaPlayer has a rate property", "label": {"api": {"rate property": [[18, 30]]}}}, {"text": "You could use a CountDownLatch, https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#await(long,%20java.util.concurrent.TimeUnit)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#await(long,%20java.util.concurrent.TimeUnit)": [[32, 158]]}}}, {"text": "You forgot to call bw.newLine() after each bw.write(sendMessage) such that it waits for ever since on the other side you call br.readLine() which means that it waits for an entire line while you don't send the end of line characters", "label": {"api": {"bw.newLine()": [[19, 30]], "br.readLine()": [[126, 138]]}}}, {"text": "What you need is a TableView", "label": {"api": {"TableView": [[19, 27]]}}}, {"text": "With a TableView you are able to make auto-aligned columns", "label": {"api": {"TableView": [[7, 15]]}}}, {"text": "You may have a look at this tutorial about TableViews", "label": {"api": {"TableView": [[43, 51]]}}}, {"text": "Please consider to implement your employee to have SimpleIntegerProperty, SimpleStringProperty and SimpleObjectProperty as fields instead of int, String and Date", "label": {"api": {"SimpleIntegerProperty": [[51, 71]], "SimpleStringProperty": [[74, 93]], "SimpleObjectProperty": [[99, 118]]}}}, {"text": "This would make using a TableView much easier", "label": {"api": {"TableView": [[24, 32]]}}}, {"text": "CountDownLatch or CyclicBarrier from java.util.concurrent package are other alternatives to achieve similar use-cases", "label": {"api": {"CountDownLatch": [[0, 13]], "CyclicBarrier": [[18, 30]]}}}, {"text": "See the javadoc for start", "label": {"api": {"See the javadoc for start": [[0, 24]]}}}, {"text": "There are already several available atomic classes in JDK", "label": {"api": {"in JDK": [[51, 56]]}}}, {"text": "You can use a LinkedHashMap instead (which extends HashMap)", "label": {"api": {"LinkedHashMap": [[14, 26]]}}}, {"text": "The Annotation interface doesn't provide any insights into the specific annotation", "label": {"api": {"Annotation": [[4, 13]]}}}, {"text": "InputStreams are for reading bytes;  Readers are for reading characters", "label": {"api": {"Readers": [[37, 43]]}}}, {"text": "If you read individual characters as int values (for example, with the CharSequence.codePoints method), you will get whole character values every time, and you will never see or have to deal with a surrogate value", "label": {"api": {"CharSequence.codePoints": [[71, 93]]}}}, {"text": "Using a Map with the key as a String you can keep track of our counts in one object", "label": {"api": {"Map": [[8, 10]]}}}, {"text": "You then could put as many Maps, one for each test/string into a List", "label": {"api": {"Map": [[27, 29]], "List": [[65, 68]]}}}, {"text": "Graphics2D.fill(Shape) will do", "label": {"api": {"Graphics2D.fill(Shape)": [[0, 21]]}}}, {"text": "To achieve what you want, you need to turn a List<Model> into a List<String> by the mapping(mapper, downstream)", "label": {"api": {"mapping(mapper, downstream)": [[84, 110]]}}}, {"text": "on Java side, close the output stream using the socket's shutdownOutput() method after you are done writing to it", "label": {"api": {"shutdownOutput()": [[57, 72]]}}}, {"text": "It's a bit more verbose, but you have to specify the default values for missing fields when creating your DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[106, 122]]}}}, {"text": "This includes the ZoneId which is necessary for a ZonedDateTime", "label": {"api": {"ZoneId": [[18, 23]], "ZonedDateTime": [[50, 62]]}}}, {"text": "I followed this tutorial on Oracle.com", "label": {"api": {"this tutorial on Oracle.com": [[11, 37]]}}}, {"text": "From the Scanner API doc", "label": {"api": {"Scanner API doc": [[9, 23]]}}}, {"text": "One easy way to filter an array is to populate an ArrayList with if in a for-each loop", "label": {"api": {"ArrayList": [[50, 58]]}}}, {"text": "Another way in Java 8 is to use Collection#removeIf", "label": {"api": {"Collection#removeIf": [[32, 50]]}}}, {"text": "Or use Stream#filter", "label": {"api": {"Stream#filter": [[7, 19]]}}}, {"text": "The built-in Function class doesn't allow you to throw unchecked exceptions, as you can see from the signature of the apply() method", "label": {"api": {"apply() method": [[118, 131]]}}}, {"text": "You can however easily define your own @FunctionalInterface that does permit exceptions to be thrown, e.g.", "label": {"api": {"@FunctionalInterface": [[39, 58]]}}}, {"text": "Lists in Java are int-indexed, as you can see in the javadoc of List.get(), and you're trying to get elements by a long index", "label": {"api": {"List.get()": [[64, 73]]}}}, {"text": "For such need, you can use either File#list(FilenameFilter filter) or File#listFiles(FilenameFilter filter) to filter the content of your folder by file name then get the length of the resulting array", "label": {"api": {"File#list(FilenameFilter filter)": [[34, 65]], "File#listFiles(FilenameFilter filter)": [[70, 106]]}}}, {"text": "Have a look at ByteBuffer.allocateDirect(int bytes)", "label": {"api": {"ByteBuffer.allocateDirect(int bytes)": [[15, 50]]}}}, {"text": "You should use containsKey instead", "label": {"api": {"containsKey": [[15, 25]]}}}, {"text": "Map does not have a method contains", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Use a JPanel containing an instance of JCustomComponent, which is a class that extends JComponent and overrides the paintComponent() method to draw the desired image", "label": {"api": {"paintComponent()": [[116, 131]]}}}, {"text": "But you could \"abuse\" CompletableFuture.supplyAsync and thenCompose", "label": {"api": {"CompletableFuture.supplyAsync": [[22, 50]], "thenCompose": [[56, 66]]}}}, {"text": "To do an insert in the correct position (index), find that position using Collections.binarySearch(), then call the add(int index, E element) to do the actual insert", "label": {"api": {"Collections.binarySearch()": [[74, 99]], "add(int index, E element)": [[116, 140]]}}}, {"text": "It allows the stream to short-circuit, such as with findFirst or allMatch", "label": {"api": {"findFirst": [[52, 60]], "allMatch": [[65, 72]]}}}, {"text": "If all of the elements were processed at once at each stage, streams would not be able to handle infinite data sources, such as from Stream.iterate", "label": {"api": {"Stream.iterate": [[133, 146]]}}}, {"text": "What is the meaning when a SelectionKey instance call interestOps(0)", "label": {"api": {"SelectionKey": [[27, 38]], "interestOps(0)": [[54, 67]]}}}, {"text": "0 is not the enum value defined in SelectionKey", "label": {"api": {"SelectionKey": [[35, 46]]}}}, {"text": "What is the function of interestOps(0)", "label": {"api": {"interestOps(0)": [[24, 37]]}}}, {"text": "To get the the list of entries in a jar file, you can use the java.util.jar.JarFile and java.util.jar.JarEntry classes", "label": {"api": {"java.util.jar.JarFile": [[62, 82]], "java.util.jar.JarEntry": [[88, 109]]}}}, {"text": "You may want to use this variation of submit() to make the result type explicit", "label": {"api": {"submit()": [[38, 45]]}}}, {"text": "As discussed here, submit() doesn't do anything with result", "label": {"api": {"submit()": [[19, 26]]}}}, {"text": "\"When the task successfully completes, calling future.get() will return the result you passed in.\" Note that the type of result matches that of the SwingWorker result type, T", "label": {"api": {"SwingWorker": [[148, 158]]}}}, {"text": "But, it seems that since some limited concurrency is still allowed, you could get that concurrency it by using a read/write lock", "label": {"api": {"read/write lock": [[113, 127]]}}}, {"text": "Use the ZoneRulesProvider class", "label": {"api": {"ZoneRulesProvider": [[8, 24]]}}}, {"text": "If you take a look on the selectionProperty of TextArea", "label": {"api": {"selectionProperty": [[26, 42]]}}}, {"text": "I don't understand because getStatus() is of course a method of HttpServletResponse", "label": {"api": {"of course": [[42, 50]]}}}, {"text": "one is a function returning the value to use for a given stream element (as a ToDoubleFunction), and the other returns the weight (as a ToIntFunction)", "label": {"api": {"ToDoubleFunction": [[78, 93]], "ToIntFunction": [[136, 148]]}}}, {"text": "Have you checked GregorianCalendar", "label": {"api": {"GregorianCalendar": [[17, 33]]}}}, {"text": "You should consider using the java.time API (introduced in Java 8) - it is much better and easier to use than the legacy Calendar API", "label": {"api": {"java.time API": [[30, 42]]}}}, {"text": "If all you care about is randomly generated strings in a distributed environment, you should be able to rely on UUID.randomUUID() from java.util.UUID", "label": {"api": {"java.util.UUID": [[135, 148]], "UUID": [[112, 115], [123, 126], [145, 148]]}}}, {"text": "DynamoDBMapper will generate a random UUID when saving these attributes", "label": {"api": {"UUID": [[38, 41]]}}}, {"text": "That's what PhantomReference is for", "label": {"api": {"PhantomReference": [[12, 27]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/lang/ref/ReferenceQueue.html should be used to meet your requirement", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/ref/ReferenceQueue.html": [[0, 74]]}}}, {"text": "Use String.format() or MessageFormat.format()", "label": {"api": {"String.format()": [[4, 18]], "MessageFormat.format()": [[23, 44]]}}}, {"text": "Integer provides a method for this", "label": {"api": {"method for this": [[19, 33]]}}}, {"text": "And I suggest to use .charAt function in place of .substring function for optimize your code", "label": {"api": {".charAt": [[21, 27]]}}}, {"text": "I suggest to look into the ReadWriteLock respectively the implementing class ReentrantReadWriteLock", "label": {"api": {"ReadWriteLock": [[27, 39], [86, 98]], "ReentrantReadWriteLock": [[77, 98]]}}}, {"text": "Just want to mention there is ZoneRules#isDaylightSavings available", "label": {"api": {"ZoneRules#isDaylightSavings": [[30, 56]]}}}, {"text": "The best way to generate a random floating-point value in Java (assuming you don't need a specific seed and you don't need to be cryptographically secure) is the ThreadLocalRandom class", "label": {"api": {"cryptographically secure": [[129, 152]], "ThreadLocalRandom": [[162, 178]]}}}, {"text": "The ThreadLocalRandom class has a very convenient nextDouble overload that lets you specify an \"origin\" and \"bound,\" meaning minimum and maximum", "label": {"api": {"ThreadLocalRandom": [[4, 20]], "nextDouble": [[50, 59]]}}}, {"text": "There is unfortunately no nextFloat overload on ThreadLocalRandom, presumably because they expect very few people to need random floats", "label": {"api": {"ThreadLocalRandom": [[48, 64]]}}}, {"text": "When generating random numbers, default to the ThreadLocalRandom class", "label": {"api": {"ThreadLocalRandom": [[47, 63]]}}}, {"text": "Coupled with a javax.swing.Timer to repaint() as opposed to dragging which could update extremely (and unnecessarily) quickly", "label": {"api": {"javax.swing.Timer": [[15, 31]]}}}, {"text": "Finally, you should ensure your GUI is running on the event dispatch thread using SwingUtilities.invokeLater(Runnable doRun), since Swing objects are not thread safe", "label": {"api": {"SwingUtilities.invokeLater(Runnable doRun)": [[82, 123]]}}}, {"text": "Create FileOutputStream, get corresponding FileChannel and write data using ByteBuffers", "label": {"api": {"FileChannel": [[43, 53]], "ByteBuffers": [[76, 86]]}}}, {"text": "There are many helpers, you can for example register on TreeScanner.visitMethod() method and invoke the TreeScanner from your annotation processor", "label": {"api": {"TreeScanner.visitMethod()": [[56, 80]]}}}, {"text": "From the documentation for notify(), emphasis mine", "label": {"api": {"notify()": [[27, 34]]}}}, {"text": "Some other APIs, such as Semaphore, have a concept of \"fairness\", where you can ensure that threads do proceed in the order in which they blocked", "label": {"api": {"Semaphore": [[25, 33]]}}}, {"text": "In threads, you can expect an order (FIFO), only if you are using something like a strong Semaphore", "label": {"api": {"strong Semaphore": [[83, 98]]}}}, {"text": "It is programmer's duty to make natural order consistent with equals", "label": {"api": {"natural order consistent with equals": [[32, 67]]}}}, {"text": "If you are looking for immutable list - check Guava implementation of ImmutableList or Collections.unmodifiableList which throws java.lang.UnsupportedOperationException on modifications", "label": {"api": {"Collections.unmodifiableList": [[87, 114]]}}}, {"text": "The solution with Java 8 and groupingBy(classifier, downstream)", "label": {"api": {"groupingBy(classifier, downstream)": [[29, 62]]}}}, {"text": "Or simply with groupingBy(classifier) as @Boris the Spider noticed", "label": {"api": {"groupingBy(classifier)": [[15, 36]]}}}, {"text": "Check the PointerInfo class, it can help you", "label": {"api": {"PointerInfo": [[10, 20]]}}}, {"text": "Java 8 can make your code simpler using IntStream.rangeClosed, but there is little you can do to avoid having an O(n*m) solution without devising a smarter algorithm", "label": {"api": {"IntStream.rangeClosed": [[40, 60]]}}}, {"text": "The official java documentation gives an example on how to use the BufferStrategy", "label": {"api": {"official java documentation": [[4, 30]]}}}, {"text": "Use the MULTILINE flag, so that ^ and $ will match the beginning and end of each line", "label": {"api": {"MULTILINE": [[8, 16]]}}}, {"text": "The invalidate documentation seems pretty clear on the subject", "label": {"api": {"invalidate documentation": [[4, 27]]}}}, {"text": "Use HttpServletResponseWrapper with overridden setContentType to wrap response that is passed to child.doFilter", "label": {"api": {"HttpServletResponseWrapper": [[4, 29]]}}}, {"text": "Actually you need java.awt.image.BufferedImage as the image object, so you can use setRGB to set RGB value in a given (x,y) coordinate", "label": {"api": {"java.awt.image.BufferedImage": [[18, 45]]}}}, {"text": "But to save you image as file you might want to use javax.imageio.ImageIO", "label": {"api": {"javax.imageio.ImageIO": [[52, 72]]}}}, {"text": "I've read through the  documentation  for the read() method and NullPointerException will be thrown only if the byte[] is NULL", "label": {"api": {" documentation ": [[22, 36]]}}}, {"text": "So, they decided to pass over the OOP and offer Serialization as a special non-oop feature of the serialization classes ObjectOutputStream/ObjectInputStream (credits to EJP for this detail) in the form of a \"dummy\" interface recognizable by them, at the price of adding somehow some confussion to the class definitions, because an interface with no methods is nonsense (Same approach they adopted for java.lang.Cloneable)", "label": {"api": {"ObjectOutputStream": [[120, 137]]}}}, {"text": "Actually, it adds even more confussion, because custom serialization must be done by implementing private methods readObject and writeObject (as specified by ObjectOutputStream), which is a feature non describible in terms of a Java interface", "label": {"api": {"ObjectOutputStream": [[158, 175]]}}}, {"text": "Do you really need FileInputStream", "label": {"api": {"FileInputStream": [[19, 33]], "InputStream": [[23, 33]]}}}, {"text": "More flexible way is to use InputStream instead", "label": {"api": {"InputStream": [[28, 38]]}}}, {"text": "Is there an AWT Shape class for circles", "label": {"api": {"Shape": [[16, 20]]}}}, {"text": "I want to check for a collision between a rectangle and a circle like I do with 2 Rectangles using the intersects() method", "label": {"api": {"Rectangles": [[82, 91]]}}}, {"text": "There are 2 flavours of Ellipse2D; Ellipse2D.Float and Ellipse2D.Double, depending on the precision you want to use", "label": {"api": {"Ellipse2D": [[24, 32], [35, 43], [55, 63]], "Ellipse2D.Float": [[35, 49]], "Ellipse2D.Double": [[55, 70]]}}}, {"text": "If you want to check for all kinds of arrays, you probably want to get the class from the object and check its isArray method", "label": {"api": {"isArray": [[111, 117]]}}}, {"text": "Then you can use Array.getLength to get its length (since, bizarrely, you can't use Class#getField to get the length field)", "label": {"api": {"Array.getLength": [[17, 31]]}}}, {"text": "You can use setStrokeType for your rectangles to draw the border inside using StrokeType.Inside", "label": {"api": {"setStrokeType": [[12, 24]], "StrokeType.Inside": [[78, 94]]}}}, {"text": "You could use a KeyListener", "label": {"api": {"KeyListener": [[16, 26]]}}}, {"text": "BigInteger already implements it as modPow", "label": {"api": {"modPow": [[36, 41]]}}}, {"text": "See API here", "label": {"api": {"See API here": [[0, 11]]}}}, {"text": "Incase it's of interest, here's a variation on your approach using a Deque<E> as opposed to a Stack and Queue separately", "label": {"api": {"Deque<E>": [[69, 76]]}}}, {"text": "The basic class in rt.jar that offers this functionality is FileReader", "label": {"api": {"FileReader": [[60, 69]]}}}, {"text": "This solution works for all numbers, except Integer.MIN_VALUE", "label": {"api": {"Integer.MIN_VALUE": [[44, 60]]}}}, {"text": "Your class should implement Comparable interface where you need to fill the comparison logic in compareTo(T o) method", "label": {"api": {"Comparable": [[28, 37]]}}}, {"text": "So, if order is your primary concern, you should use the LinkedHashSet instead of TreeSet", "label": {"api": {"LinkedHashSet": [[57, 69]]}}}, {"text": "If you use java's rectangle there is are methods called intersects and contains", "label": {"api": {"rectangle": [[18, 26]]}}}, {"text": "After setting the mouselistener up, you can simply check if the rectangle contains the mouse and is clicked", "label": {"api": {"rectangle": [[64, 72]]}}}, {"text": "It uses the next() method of the scanner class", "label": {"api": {"next()": [[12, 17]]}}}, {"text": "The easiest way to force components to fill all space is to use  BorderLayout", "label": {"api": {"BorderLayout": [[65, 76]]}}}, {"text": "Using Socket I can send http request to server and get the html response", "label": {"api": {"Socket": [[6, 11]]}}}, {"text": "The JavaFX WebEngine", "label": {"api": {"WebEngine": [[11, 19]]}}}, {"text": "You would need to somehow wrap the input stream in a PushbackInputStream", "label": {"api": {"PushbackInputStream": [[53, 71]]}}}, {"text": "In the meantime, one solution would be to write a stateful deserializer that maintains a ConcurrentHashMap, keyed by the InputStream argument, with the map value being a PushbackInputStream wrapper", "label": {"api": {"PushbackInputStream": [[170, 188]]}}}, {"text": "Per the Component API", "label": {"api": {"Component API": [[8, 20]]}}}, {"text": "Given a Predicate used in a CriteriaQuery, e.g", "label": {"api": {"Predicate": [[8, 16]], "CriteriaQuery": [[28, 40]]}}}, {"text": "Implement Comparator (and tweak it as required), and invoke the sort method", "label": {"api": {"Comparator": [[10, 19]], "sort": [[64, 67]]}}}, {"text": "To extract the variables using this regex, you can use java.util.regex.Pattern and java.util.regex.Matcher like this", "label": {"api": {"java.util.regex.Pattern": [[55, 77]], "java.util.regex.Matcher": [[83, 105]]}}}, {"text": "Following excerpt from the Stream java doc tries to explain", "label": {"api": {"Stream java doc": [[27, 41]]}}}, {"text": "And, in fact, Java's String class does exactly that", "label": {"api": {"Java's String class does exactly that": [[14, 50]]}}}, {"text": "String.replaceAll takes a regular expression as its first parameter", "label": {"api": {"String.replaceAll": [[0, 16]], "String.replace": [[0, 13]]}}}, {"text": "are special characters in regular expressions", "label": {"api": {"regular expressions": [[26, 44]]}}}, {"text": "Use String.replace instead - this actually uses regular expressions internally too, but it escapes the strings correctly", "label": {"api": {"regular expressions": [[48, 66]], "String.replace": [[4, 17]]}}}, {"text": "However, given that you're using String.replaceAll, you can just use a regular expression to do the whole thing", "label": {"api": {"String.replaceAll": [[33, 49]], "String.replace": [[33, 46]]}}}, {"text": "You are setting the colors in an implementation of TableCellRenderer (possibly deriving from DefaultTableCellRenderer)", "label": {"api": {"TableCellRenderer": [[51, 67], [100, 116]], "DefaultTableCellRenderer": [[93, 116]]}}}, {"text": "The row and column indexes reported in the getTableCellRendererComponent method are view indexes, not model indexes", "label": {"api": {"TableCellRenderer": [[46, 62]], "getTableCellRendererComponent": [[43, 71]]}}}, {"text": "See the JTable class documentation for more details", "label": {"api": {"JTable class documentation": [[8, 33]]}}}, {"text": "You need to make the \\p{L} pattern Unicode aware with the Pattern.UNICODE_CHARACTER_CLASS flag", "label": {"api": {"Pattern.UNICODE_CHARACTER_CLASS flag": [[58, 93]]}}}, {"text": "You can use OffsetDateTime.truncatedTo(TemporalUnit) with ChronoUnit.HOURS", "label": {"api": {"OffsetDateTime.truncatedTo(TemporalUnit)": [[12, 51]], "ChronoUnit.HOURS": [[58, 73]]}}}, {"text": "You should probably check the java.time.Duration class", "label": {"api": {"java.time.Duration": [[30, 47]]}}}, {"text": "Ideally java should throw NotSerializableException, but since you are not getting the exception means, SomeClass extends Serializable by it's parent hierarchy somewhere", "label": {"api": {"NotSerializableException": [[26, 49]]}}}, {"text": "Why not review the javadocs of EntityManager and consider why you are trying to call methods that don't exist and have never existed", "label": {"api": {"javadocs of EntityManager": [[19, 43]]}}}, {"text": "The best way to augment the preferred height is with GridBagConstraints.ipady", "label": {"api": {"GridBagConstraints.ipady": [[53, 76]]}}}, {"text": "Another option is to use JButton.setMargin to give each button an additional margin", "label": {"api": {"JButton.setMargin": [[25, 41]]}}}, {"text": "The constructor of a HashMap takes the initial size of the map (and the load factor, if desired)", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "PreparedStatement has a setObject(int, java.lang.Object) method", "label": {"api": {"setObject(int, java.lang.Object)": [[24, 55]]}}}, {"text": "Just use a CallableStatement, this is meant to be used with stored procedures", "label": {"api": {"CallableStatement": [[11, 27]]}}}, {"text": "Notice that intersects() requires an object of type Bounds as parameter", "label": {"api": {"intersects()": [[12, 23]]}}}, {"text": "You may want to try one of the getBounds...() methods to get the bounds to then intersect", "label": {"api": {"getBounds...()": [[31, 44]]}}}, {"text": "Since you're not using those objects as parts of a scene, you're better off using javafx.geometry.Rectangle2D to check for intersections", "label": {"api": {"javafx.geometry.Rectangle2D": [[82, 108]]}}}, {"text": "Also, instead of creating a new locale, you can use the built-in Locale.FRANCE", "label": {"api": {"Locale.FRANCE": [[65, 77]]}}}, {"text": "@PermessiNecessari must be of Runtime retention because compiler will remove not incluide information about that annotation into the bytecode if retention will be different", "label": {"api": {"Runtime retention": [[30, 46]]}}}, {"text": "You can use this link in order to learn more about java patterns", "label": {"api": {"link": [[17, 20]]}}}, {"text": "The MASTER_GAIN FloatControl value is in decibels, meaning it's a logarithmic scale, not a linear one", "label": {"api": {"MASTER_GAIN": [[4, 14]]}}}, {"text": "BufferedReader.readLine() is documented as follows", "label": {"api": {"BufferedReader.readLine()": [[0, 24]]}}}, {"text": "Using an ObjectOutputSteam and ObjectInputStream is my personal favorite", "label": {"api": {"ObjectOutputSteam": [[9, 25]], "ObjectInputStream": [[31, 47]]}}}, {"text": "You may need to use the PrintRequestAttribute while submitting the printjob request", "label": {"api": {"PrintRequestAttribute": [[24, 44]]}}}, {"text": "According to the exception java.lang.NoClassDefFoundError, it means some dependent libraries like httpclient were missed in the command line", "label": {"api": {"java.lang.NoClassDefFoundError": [[27, 56]]}}}, {"text": "It is my understanding that a ZonedDateTime is really an enhanced version of an Instant", "label": {"api": {"Instant": [[80, 86]], "ZonedDateTime": [[30, 42]]}}}, {"text": "It has all the data an Instant has (precise value along UTC timeline), plus time zone information", "label": {"api": {"Instant": [[23, 29]]}}}, {"text": "So my nave assumption was that a ZonedDateTime is-an Instant and that any method taking an Instant will happily take a ZonedDateTime instead", "label": {"api": {"Instant": [[54, 60], [92, 98]], "ZonedDateTime": [[34, 46], [120, 132]]}}}, {"text": "to work seamlessly between Instants and ZonedDateTimes", "label": {"api": {"Instant": [[27, 33]], "ZonedDateTime": [[40, 52]]}}}, {"text": "Looking at the API documentation for Instant and ZonedDateTime, none of this is the case", "label": {"api": {"Instant": [[37, 43]], "ZonedDateTime": [[49, 61]]}}}, {"text": "I can compare Instants with Instants and ZonedDateTimes with ZonedDateTimes, but the two classes seem to be incompatible", "label": {"api": {"Instant": [[14, 20], [28, 34]], "ZonedDateTime": [[41, 53], [61, 73]]}}}, {"text": "What's more, third-party code like ThreeTen-Extra's Interval seem to work exclusively with Instants", "label": {"api": {"Instant": [[91, 97]]}}}, {"text": "Is there a reason why Instant and ZonedDateTime are not meant to be mixed", "label": {"api": {"Instant": [[22, 28]], "ZonedDateTime": [[34, 46]]}}}, {"text": "Whereas the implementation of Comparable matches the recommended behaviour, which is that \"It is strongly recommended (though not required) that natural orderings be consistent with equals.\"  ie", "label": {"api": {"Comparable": [[30, 39]]}}}, {"text": "Your class Odh must override the toString method", "label": {"api": {"toString": [[33, 40]]}}}, {"text": "From java.sql.Statement Javadoc", "label": {"api": {"java.sql.Statement Javadoc": [[5, 30]]}}}, {"text": "https://github.com/EnSoftCorp/java-toolbox-commons/.../ThrowableAnalysis.java is some code that might be helpful for what you need, it statically computes matches for throw sites and potential catch sites in a piece of software (conservatively in that it does not consider path feasibility)", "label": {"api": {"Throwable": [[55, 63]]}}}, {"text": "All exceptions checked or unchecked must extend Throwable", "label": {"api": {"Throwable": [[48, 56]]}}}, {"text": "It sounds like you are only interested in \"unchecked\" throwables so you should consider classes that directly extend or are children of a class that extends Error or RuntimeException", "label": {"api": {"Error": [[157, 161]], "RuntimeException": [[166, 181]]}}}, {"text": "Using the ThrowableAnalysis code I shared earlier you could bring it all together to find each uncaught thrown unchecked throwable types", "label": {"api": {"Throwable": [[10, 18]]}}}, {"text": "As your Map is already a ConcurrentHashMap, you could just use ConcurrentHashMap.forEach - this allows to configure a paralleslismThreshold which may automatically execute the invocations in parallel if the threshold is exceeded", "label": {"api": {"ConcurrentHashMap.forEach": [[63, 87]]}}}, {"text": "You can't change the sorting of an existing TreeSet, but you can copy your values to another [temporary] collection sorted differently by using a custom Comparator", "label": {"api": {"Comparator": [[153, 162]]}}}, {"text": "You can use ThreadLocalRandom class to generate random number in a given scope", "label": {"api": {"ThreadLocalRandom": [[12, 28]]}}}, {"text": "it's an ArrayBlockingQueue, not a LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[34, 52]]}}}, {"text": "If you want a linked-list implementation then use LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[50, 68]]}}}, {"text": "From Oracle docs of the compareTo method", "label": {"api": {"Oracle docs": [[5, 15]]}}}, {"text": "See GregorianCalendar add() method reference", "label": {"api": {"GregorianCalendar add() method": [[4, 33]]}}}, {"text": "Have a look at Class.forName(), Class.getName() and Class.newInstance()", "label": {"api": {"Class.forName()": [[15, 29]], "Class.getName()": [[32, 46]], "Class.newInstance()": [[52, 70]]}}}, {"text": "The primary purpose of this pane, called BackgroundEffectPane, will be to take an Effect and apply it only to the background", "label": {"api": {"Pane": [[57, 60]]}}}, {"text": "This will allow me to implement the translucent background StackPane in the linked answer in a much cleaner way", "label": {"api": {"Pane": [[64, 67]]}}}, {"text": "So far, I've read through the documentation of Pane and Node", "label": {"api": {"Pane": [[47, 50]], "Node": [[56, 59]]}}}, {"text": "The only thing that strikes me as relevant is the getChildren() method in Pane", "label": {"api": {"Pane": [[74, 77]], "getChildren()": [[50, 62]]}}}, {"text": "Is Pane the right class to Subclass", "label": {"api": {"Pane": [[3, 6]]}}}, {"text": "Better is to use a PreparedStatement so you never will rely on string conversion", "label": {"api": {"PreparedStatement": [[19, 35]]}}}, {"text": "Use getResourceAsStream and copy the stream to a temporary file", "label": {"api": {"getResourceAsStream": [[4, 22]]}}}, {"text": "Your understanding of comparators is wrong", "label": {"api": {"comparators": [[22, 32]]}}}, {"text": "According to the API of java.sql.Timestamp it offers a method getTime()", "label": {"api": {"java.sql.Timestamp": [[24, 41]]}}}, {"text": "Attempting to use a JavaFX StackPane's snapshot method to capture a \"Background\" element", "label": {"api": {"StackPane": [[27, 35]], "snapshot": [[39, 46]]}}}, {"text": "If I setup my scene with a StackPane, and the background literally being an ImageView underneath what I'm trying to display, then everything works fine", "label": {"api": {"StackPane": [[27, 35]]}}}, {"text": "But if I use the more intuitive setBackground function of a node, and try to capture a snapshot, it (the background) doesn't show up", "label": {"api": {"snapshot": [[87, 94]]}}}, {"text": "For example this works as expected, if you do getBackgroundNode().snapshot(new SnapshotParameters(), null)", "label": {"api": {"snapshot": [[66, 73]]}}}, {"text": "However, the below method doesn't show me the background when I call the snapshot method", "label": {"api": {"snapshot": [[73, 80]]}}}, {"text": "Is this simply a feature of the snapshot method", "label": {"api": {"snapshot": [[32, 39]]}}}, {"text": "For more information, check out the official documentation for the Scanner class", "label": {"api": {"official documentation for the Scanner class": [[36, 79]]}}}, {"text": "A functional interface by design is allowed to have just one method so what you are trying to do can't be done directly, it's clear why", "label": {"api": {"functional interface": [[2, 21]]}}}, {"text": "allowing to implement a functional interface with a lambda must create an object which is valid for its declaration, if it has two methods you cant implement them both with a single lambda", "label": {"api": {"functional interface": [[24, 43]]}}}, {"text": "Your constructor could then build the answers list and call Collections.shuffle(this.answers) to randomize them", "label": {"api": {"Collections.shuffle(this.answers)": [[60, 92]]}}}, {"text": "Better use a controller or at least use the namespace of the FXMLLoader instance used to load the fxml to access the objects using the fx:ids", "label": {"api": {"namespace": [[44, 52]]}}}, {"text": "See Arrays.asList(T...) javadoc for more information", "label": {"api": {"Arrays.asList(T...) javadoc": [[4, 30]]}}}, {"text": "However, I would like to refer you to the AutoCloseable interface", "label": {"api": {"AutoCloseable": [[42, 54]], "Closeable": [[46, 54]]}}}, {"text": "In order for this to work, your FileLocker will have to extend AutoCloseable", "label": {"api": {"AutoCloseable": [[63, 75]], "Closeable": [[67, 75]]}}}, {"text": "Actually, if your FileLocker will throw an IOException, you can also consider extending Closeable instead", "label": {"api": {"Closeable": [[88, 96]]}}}, {"text": "You haven't mentioned anything about required distribution of outputs, but if it's really as simple as making sure you have no negative outputs, you could pass each output through Math.abs() before returning it..", "label": {"api": {"Math.abs()": [[180, 189]]}}}, {"text": "You can use looked-up colors (scroll down beyond the color squares for the description of looked-up colors)", "label": {"api": {"looked-up colors": [[12, 27], [90, 105]]}}}, {"text": "this is more efficient but doesn't release memory according to sublist it's just a view", "label": {"api": {"sublist": [[63, 69]]}}}, {"text": "Because Integer overrides toString", "label": {"api": {"Integer overrides toString": [[8, 33]]}}}, {"text": "Hmm...or because println(int) exists on PrintStream", "label": {"api": {"println(int) exists on PrintStream": [[17, 50]]}}}, {"text": "You will want to use the partitioningBy collector instead", "label": {"api": {"partitioningBy": [[25, 38]]}}}, {"text": "I looked into ScheduledExecutorService and scheduleWithFixedDelay as well, but those don't like the idea of changing the amount of threads or the delay on the fly", "label": {"api": {"ScheduledExecutorService": [[14, 37]], "scheduleWithFixedDelay": [[43, 64]]}}}, {"text": "In this case, check out Double.nextDouble ..", "label": {"api": {"Double.nextDouble": [[24, 40]]}}}, {"text": "I'm not exactly sure what you're trying to accomplish, but it sounds like you may be interested in the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[103, 126]]}}}, {"text": "In your case, you should use RandomAccessFile in order to read and/or write some content in a file at a given location thanks to its method seek(long pos)", "label": {"api": {"RandomAccessFile": [[29, 44]], "seek(long pos)": [[140, 153]]}}}, {"text": "and their read counterparts are directly available from the class RandomAccessFile so using it alone is enough", "label": {"api": {"RandomAccessFile": [[66, 81]]}}}, {"text": "read returns a single character (as an int, so it can use -1 to signal end-of-stream)", "label": {"api": {"read": [[0, 3]]}}}, {"text": "If you want to read an entire line of text, use readLine to read a string", "label": {"api": {"read": [[15, 18], [48, 51], [60, 63]], "readLine": [[48, 55]]}}}, {"text": "If you want to output the character you read, after checking that it's not -1 (which means you've reached the end of the stream), cast it to char", "label": {"api": {"read": [[40, 43]]}}}, {"text": "If you want to read all the characters, you'll need a loop", "label": {"api": {"read": [[15, 18]]}}}, {"text": "If you want to read an integer, you may want Scanner", "label": {"api": {"read": [[15, 18]], "Scanner": [[45, 51]]}}}, {"text": "For a Java solution, AffineTransform could help you", "label": {"api": {"AffineTransform": [[21, 35]]}}}, {"text": "It seems to be a perfect task for ToggleButtons", "label": {"api": {"ToggleButtons": [[34, 46]]}}}, {"text": "The text of the Label will change to \"true\" whenever at least one of the ToggleButtons are \"switched on\" and will change to \"false\" if both of them are \"switched off\"", "label": {"api": {"ToggleButtons": [[73, 85]]}}}, {"text": "Your best bet is probably creating Clips as shown in the sample code below", "label": {"api": {"Clip": [[35, 38]]}}}, {"text": "You can use for example the PseudoClass API to change the CSS pseudo state of your Buttons between \"revealed\" and \"unrevealed\"", "label": {"api": {"PseudoClass": [[28, 38]]}}}, {"text": "And you have to define the JavaFX PseudoClass like", "label": {"api": {"PseudoClass": [[34, 44]]}}}, {"text": "The replace() method replaces every instance of the sub string, therefore you do not have to use \"\\\\\\\\\" unless of course if you only want to remove the double slashes and leave the single slashes", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "You forgot to include a call to the ExecutorService#shutdownNow() method", "label": {"api": {"ExecutorService#shutdownNow()": [[36, 64]]}}}, {"text": "See the JOptionPane javadocs for details on how JOptionPane handles various types of message parameters", "label": {"api": {"JOptionPane javadocs": [[8, 27]]}}}, {"text": "ChannelSftp has versions of the put method which accept a filename on the remote system and which return an OutputStream", "label": {"api": {"OutputStream": [[108, 119]]}}}, {"text": "Anything written to the OutputStream is written to the file on the remote system", "label": {"api": {"OutputStream": [[24, 35]]}}}, {"text": "You can write binary data to an OutputStream, or convert it to a Writer if you want to write text to it", "label": {"api": {"OutputStream": [[32, 43]]}}}, {"text": "There is a method ThreadMXBean.getThreadAllocatedBytes that returns the cumulative amount of memory allocated by the given thread", "label": {"api": {"ThreadMXBean.getThreadAllocatedBytes": [[18, 53]]}}}, {"text": "The value of the hasNextLine() method only changes -- only has the chance to change -- when you call nextLine()", "label": {"api": {"nextLine()": [[101, 110]]}}}, {"text": "The nextLine() method gives you the content of the line, and it advances the Scanner by one line", "label": {"api": {"nextLine()": [[4, 13]]}}}, {"text": "Try java.util.Arrays class", "label": {"api": {"java.util.Arrays": [[4, 19]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineManager.html#ScriptEngineManager-java.lang.ClassLoader-) by passing an appropriate ClassLoader", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineManager.html#ScriptEngineManager-java.lang.ClassLoader-": [[0, 121]]}}}, {"text": "And then you can use concepts such as Comparator to compare card values, or you can make use of equals() ..", "label": {"api": {"Comparator": [[38, 47]]}}}, {"text": "Refer to the API http://docs.oracle.com/javase/8/docs/api/java/util/List.html#set-int-E-", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/List.html#set-int-E-": [[17, 87]]}}}, {"text": "The useDelimiter() method takes the passed String as regex value.https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#useDelimiter-java.lang.String-", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#useDelimiter-java.lang.String-": [[65, 159]]}}}, {"text": "You can use java.lang.String split method and get the elements (email and name) as shown below", "label": {"api": {"java.lang.String": [[12, 27]]}}}, {"text": "In Swing, you can use SwingWorker or explicitly create a background thread", "label": {"api": {"SwingWorker": [[22, 32]]}}}, {"text": "What about taking advantage of a NavigableSet for sorting and for its headSet method", "label": {"api": {"headSet": [[70, 76]]}}}, {"text": "The reason is described in the Javadoc of Object.getClass", "label": {"api": {"Object.getClass": [[42, 56]]}}}, {"text": "Since java 11 there is a new method Predicate::not", "label": {"api": {"Predicate::not": [[36, 49]]}}}, {"text": "you should use some sort of collection mechanism; either a List; or maybe a plain old array", "label": {"api": {"List": [[59, 62]]}}}, {"text": "The reason is that Spring deals with objects, not classes, so when a subclass is instantiated Spring is not checking annotations on overridden methods in the parent class, unless annotation is marked as @Inherited (@Autowired is not)", "label": {"api": {"@Inherited": [[203, 212]]}}}, {"text": "What about added in Java 7 Path.relativize", "label": {"api": {"Path.relativize": [[27, 41]]}}}, {"text": "You can then provide an equals method for that class; plus a specific comparator, that only compares the string elements", "label": {"api": {"comparator": [[70, 79]]}}}, {"text": "as dnault suggests, if there is really no \"tight\" coupling between strings and numbers you could also use a TreeMap (to be used as TreeMap<String, Integer>) to take care of sorting strings that have a number with them", "label": {"api": {"TreeMap": [[108, 114], [131, 137]]}}}, {"text": "Use a custom FilteredInputStream to wrap the InputStream", "label": {"api": {"FilteredInputStream": [[13, 31]]}}}, {"text": "Wrap the FileInputStream in a PushbackInputStream, and check to see if it starts with a PI", "label": {"api": {"PushbackInputStream": [[30, 48]]}}}, {"text": "Use the Console readPassword() method", "label": {"api": {"Console": [[8, 14]]}}}, {"text": "Also, as SLaks mentioned in the comments, consider creating a class to represent your provinces (and territories ;) ), or have a look at using a map, such as a HashMap", "label": {"api": {"HashMap": [[160, 166]]}}}, {"text": "Part of the problem is that the binding conflict is coming from TableHeaderRow, which is created by the skin at display time", "label": {"api": {"TableHeaderRow": [[64, 77]]}}}, {"text": "The TableHeaderRow is responsible for rendering all the column headers, and it includes this built-in button for a menu that, by default, is a radio selection list of columns to show/hide", "label": {"api": {"TableHeaderRow": [[4, 17]]}}}, {"text": "As a result, the TableHeaderRow creates a bidirectional binding between these menu entries' selection state and each column's visible property", "label": {"api": {"TableHeaderRow": [[17, 30]]}}}, {"text": "It actually is possible to undo this binding but I found it annoying since the TableHeaderRow is null until the TableView is displayed", "label": {"api": {"TableHeaderRow": [[79, 92]]}}}, {"text": "But, adapting this solution to access the TableHeaderRow, we can do something like", "label": {"api": {"TableHeaderRow": [[42, 55]]}}}, {"text": "you have to do this every time a column's visibility changes, because the TableHeaderRow has a listener that rebuilds the menu, and re-links the properties, every time a column is shown", "label": {"api": {"TableHeaderRow": [[74, 87]]}}}, {"text": "This means that your program never receives any SIGINT signal (see a related answer) and so, logically, the shutdown hook never gets executed (see the API documentation for Runtime.addShutdownHook(Thread) for a description of when the hook is run)", "label": {"api": {"the API documentation for Runtime.addShutdownHook(Thread)": [[147, 203]]}}}, {"text": "Use TreeMap or LinkedHashMap", "label": {"api": {"TreeMap": [[4, 10]], "LinkedHashMap": [[15, 27]]}}}, {"text": "I suggest a LinkedHashMap or a TreeMap", "label": {"api": {"TreeMap": [[31, 37]], "LinkedHashMap": [[12, 24]]}}}, {"text": "A LinkedHashMap keeps the keys in the order they were inserted, while a TreeMap is kept sorted via a Comparator or the natural Comparable ordering of the elements", "label": {"api": {"TreeMap": [[72, 78]], "LinkedHashMap": [[2, 14]]}}}, {"text": "Since it doesn't have to keep the elements sorted, LinkedHashMap should be faster for most cases; TreeMap has O(log n) performance for containsKey, get, put, and remove, according to the Javadocs, while LinkedHashMap is O(1) for each", "label": {"api": {"TreeMap": [[98, 104]], "LinkedHashMap": [[51, 63], [203, 215]]}}}, {"text": "You can use the wrappingWidthProperty to define the wrapping width in pixels", "label": {"api": {"wrappingWidthProperty": [[16, 36]]}}}, {"text": "This is similar to how checkedSet, synchronizedSet, and unmodifiableSet enhance (or restrict) an existing Set implementation", "label": {"api": {"checkedSet": [[23, 32]], "synchronizedSet": [[35, 49]], "unmodifiableSet": [[56, 70]]}}}, {"text": "That number is indeed larger than the maximum possible long, defined as Long.MAX_VALUE and which is equal to 263-1, or 9223372036854775807", "label": {"api": {"Long.MAX_VALUE": [[72, 85]]}}}, {"text": "You do not have an exception, as it is exactly the purpose of those new *Unsigned* methods added in Java 8, to give the ability to handle unsigned longs (like compareUnsigned or divideUnsigned)", "label": {"api": {"compareUnsigned": [[159, 173]], "divideUnsigned": [[178, 191]]}}}, {"text": "If you print a long that was the result of parseUnsignedLong, and it is negative, all it means is that the value is greater than the max long value as defined by the language, but that methods taking unsigned longs as parameter will correctly interpret those values, as if they were greater than the max value", "label": {"api": {"parseUnsignedLong": [[43, 59]]}}}, {"text": "As such, instead of printing it directly,  if you pass that number to toUnsignedString, you'll get the right output, like shown in this other answer", "label": {"api": {"toUnsignedString": [[70, 85]]}}}, {"text": "Not all of these methods are new to Java 8, for example toHexString also interprets the given long as an unsigned long in base 16, and printing Long.toHexString(Long.parseUnsignedLong(\"FBD626CC4961A4FC\", 16)) will give you back the right hex String", "label": {"api": {"parseUnsignedLong": [[166, 182]], "toHexString": [[56, 66], [149, 159]]}}}, {"text": "parseUnsignedLong will throw an exception only when the value cannot be represented as an unsigned long, i.e", "label": {"api": {"parseUnsignedLong": [[0, 16]]}}}, {"text": "Alternatively to using rendered images (like a PNG) and an ImageIcon, you could use Java2D Shapes/Areas", "label": {"api": {"Area": [[98, 101]]}}}, {"text": "to create a Play Area, do something like this", "label": {"api": {"Area": [[17, 20]]}}}, {"text": "See documentation on Serializable", "label": {"api": {"Serializable": [[21, 32]]}}}, {"text": "From the API doc of ImageIO.write(RenderedImage, String, File)", "label": {"api": {"ImageIO.write(RenderedImage, String, File)": [[20, 61]]}}}, {"text": "One way of resolving such problems is by using Platform.runLater()", "label": {"api": {"Platform.runLater()": [[47, 65]]}}}, {"text": "Take a look at the subclasses of Transform (Affine, Rotate, Scale, Shear and Translate)", "label": {"api": {"Transform": [[33, 41]]}}}, {"text": "You could also get resulting transform for a node using Node.getLocalToParentTransform", "label": {"api": {"Transform": [[77, 85]], "Node.getLocalToParentTransform": [[56, 85]]}}}, {"text": "For instance, since otherWords is a HashSet, we can infer that otherWords.contains(string) (lookup operation in a hash table) might take O(1) (big-O) time", "label": {"api": {"HashSet": [[36, 42]]}}}, {"text": "Use a SequentialTransition consisting of multiple TranslateTransitions that are interspersed with PauseTransitions", "label": {"api": {"SequentialTransition": [[6, 25]], "TranslateTransitions": [[50, 69]], "PauseTransitions": [[98, 113]]}}}, {"text": "Set up a Timeline which manipulates the translation value of the square via a series of KeyValues", "label": {"api": {"Timeline": [[9, 16]], "KeyValues": [[88, 96]]}}}, {"text": "The example below uses a the SequentialTransition method", "label": {"api": {"SequentialTransition": [[29, 48]]}}}, {"text": "A HashSet is the best data structure to use in this case", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "The set's add method will return false if you attempt to add a duplicate to the collection, so that's wrapped in an if statement for a simple, fail-fast stopping condition", "label": {"api": {"add method": [[10, 19]]}}}, {"text": "Just use a ConcurrentMap from String to AtomicInteger or LongAdder", "label": {"api": {"LongAdder": [[57, 65]]}}}, {"text": "StringBuilder creates a mutable sequence of characters which means we just append the content to the value of StringBuilder object instead of creating a new object everytime", "label": {"api": {"StringBuilder": [[0, 12], [110, 122]]}}}, {"text": "Java has many good options, such as Joda-Time for Java 7 and earlier, and the built-in java.time package for Java 8 and newer", "label": {"api": {"the built-in java.time package": [[74, 103]]}}}, {"text": "You can use setRight or setLeft, setTop, setBottom, setCenter methods to add Nodes to different parts and also getRight, getLeft, getTop, getBottom, getCenter to retrieve the currently assigned Node", "label": {"api": {"setRight": [[12, 19]], "getRight": [[111, 118]]}}}, {"text": "As you obviously need a specific implementation of Map, you should use the method Collectors.toMap allowing to provide the mapSupplier instead of toMap(Function<", "label": {"api": {"Collectors.toMap": [[82, 97]]}}}, {"text": "The MouseEvent documentation has a section \"Dragging gestures\" which explains the three types of dragging gestures", "label": {"api": {"MouseEvent documentation": [[4, 27]]}}}, {"text": "Then Java also starts to deliver MouseDragEvents to other nodes (potential gesture targets)", "label": {"api": {"DragEvent": [[38, 46]], "MouseDragEvent": [[33, 46]]}}}, {"text": "platform-supported drag-and-drop - if you call startDragAndDrop inside the OnDragDetected handler, Java will stop to deliver MouseEvents and start to deliver DragEvents instead", "label": {"api": {"DragEvent": [[158, 166]]}}}, {"text": "Also, it might be helpful to have a further look at the DragEvent and MouseDragEvent documentation", "label": {"api": {"DragEvent": [[56, 64], [75, 83]], "MouseDragEvent": [[70, 83]]}}}, {"text": "However my method is using a global variable that is not intended to be used concurrently by multiple threads( you may think of it as javax.jms.Session)", "label": {"api": {"javax.jms.Session": [[134, 150]]}}}, {"text": "Here is the link to the method", "label": {"api": {"link": [[12, 15]]}}}, {"text": "You can do it by relying on String#indexOf(int ch), keeping only values >= 0 to remove non existing characters then get the first value", "label": {"api": {"String#indexOf(int ch)": [[28, 49]]}}}, {"text": "RoundingMode.DOWN - Rounding mode to round towards zero", "label": {"api": {"RoundingMode.DOWN": [[0, 16]]}}}, {"text": "toBigInteger() - Converts this BigDecimal to a BigInteger", "label": {"api": {"toBigInteger()": [[0, 13]]}}}, {"text": "intValue() / longValue() - Converts this BigDecimal to an int / long", "label": {"api": {"intValue()": [[0, 9]], "longValue()": [[13, 23]]}}}, {"text": "If you're ok using regular expressions, and simply want to insert a plus sign surrounded by spaces between all the digits, you can use the replaceAll() method", "label": {"api": {"replaceAll()": [[139, 150]]}}}, {"text": "replaceAll() then replaces all those empty spaces between digits with \" + \", and you get exactly what you wanted in a simple expression", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "Another option is to use @Embeddable and @EmbeddedId", "label": {"api": {"@Embeddable": [[25, 35]], "@EmbeddedId": [[41, 51]]}}}, {"text": "In the case of @EmbeddedId your original class contains a field with the class representing the id fields, and not the fields representing those columns (2 fields", "label": {"api": {"@EmbeddedId": [[15, 25]]}}}, {"text": "Simply use String#replace(CharSequence target, CharSequence replacement) in your case to replace a given CharSequence, as next", "label": {"api": {"String#replace(CharSequence target, CharSequence replacement)": [[11, 71]]}}}, {"text": "Or use Pattern.quote(String s) to convert your String as a literal pattern String, as next", "label": {"api": {"Pattern.quote(String s)": [[7, 29]]}}}, {"text": "Check out File.getAbsolutePath()", "label": {"api": {"File.getAbsolutePath()": [[10, 31]]}}}, {"text": "You can combine FileDialog.getDirectory() with FileDialog.getFile() to get a full path", "label": {"api": {"FileDialog.getDirectory()": [[16, 40]], "FileDialog.getFile()": [[47, 66]]}}}, {"text": "You can also use \\p{IsLatin} character property to detect latin character in Java", "label": {"api": {"\\p{IsLatin} character property": [[17, 46]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html for more details", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[4, 76]]}}}, {"text": "For a simple implementation, you might use the Scanner class", "label": {"api": {"Scanner": [[47, 53]]}}}, {"text": "In your case I would use a ThreadLocal for each class (SecureRandom and MockPSKTlsServer), to have one dedicated instance of SecureRandom and MockPSKTlsServer for each thread of your connection pool and reuse them when the threads will have to execute the same type of task but with different input Socket, something like", "label": {"api": {"ThreadLocal": [[27, 37]]}}}, {"text": "However, a better and preferable way to handle the transportation of values in a Servlet would be via RequestDispatcher", "label": {"api": {"RequestDispatcher": [[102, 118]]}}}, {"text": "I have a custom JTextArea and want to surround it with a custom JScrollPane", "label": {"api": {"JTextArea": [[16, 24]], "JScrollPane": [[64, 74]]}}}, {"text": "Unfortunately, the form designer only suggests using the regular JScrollPane for surrounding and doesn't seem to give me the option to define a custom object like the palette would", "label": {"api": {"JScrollPane": [[65, 75]]}}}, {"text": "If you need to sort custom objects contained in a Collection you could use Collections.sort(java.util.List) or Collections.sort(java.util.List, java.util.Comparator) and implement either the Comparable interface or Comparator interface", "label": {"api": {"Collections.sort(java.util.List)": [[75, 106]], "Collections.sort(java.util.List, java.util.Comparator)": [[111, 164]]}}}, {"text": "See the Javadoc for Collections.sort(java.util.List) and  Collections.sort(java.util.List, java.util.Comparator) for more details", "label": {"api": {"Collections.sort(java.util.List)": [[20, 51]], "Collections.sort(java.util.List, java.util.Comparator)": [[58, 111]]}}}, {"text": "In Java 8 you can use the getOrDefault method", "label": {"api": {"getOrDefault": [[26, 37]]}}}, {"text": "You can create your own event and then pass it to dispatchEvent", "label": {"api": {"create your own event": [[8, 28]], "dispatchEvent": [[50, 62]]}}}, {"text": "Try this simple geometric approach, using awt's Point", "label": {"api": {"Point": [[48, 52]]}}}, {"text": "Now, you can just print the x,y contents of the Point object", "label": {"api": {"Point": [[48, 52]]}}}, {"text": "System.arraycopy in the above code snippet can be replaced by the following for loops", "label": {"api": {"System.arraycopy": [[0, 15]]}}}, {"text": "If you want to copy all elements from one array to another, you can simple use System.arraycopy( src, 0, dest, 0, src.length ) where src and dest are two integer arrays", "label": {"api": {"System.arraycopy": [[79, 94]]}}}, {"text": "in case the table is empty or no rows apply to the conditions in your WHERE clause, the ResultSet.getDouble method will return the value 0", "label": {"api": {"ResultSet.getDouble": [[88, 106]]}}}, {"text": "To cope with that situation, you will have to work with BigInteger", "label": {"api": {"BigInteger": [[56, 65]]}}}, {"text": "String.contains and String.toUpperCase", "label": {"api": {"String.contains": [[0, 14]], "String.toUpperCase": [[20, 37]]}}}, {"text": "You can convert an Enumeration to something that is Iterable by using Collections.list", "label": {"api": {"Collections.list": [[70, 85]]}}}, {"text": "There is no clean way to do this but it is possible for example by using CSS lookup on the SplitPane", "label": {"api": {"CSS lookup": [[73, 82]]}}}, {"text": "As the dividers have the CSS class of split-pane-divider you can get the dividers from the scene-graph, and they are actually StackPane instances", "label": {"api": {"split-pane-divider": [[38, 55]]}}}, {"text": "But then I saw that test fails because it throws UndeclaredThrowableException instead of EntityValidationException", "label": {"api": {"UndeclaredThrowableException": [[49, 76]]}}}, {"text": "I think not only me have this problem - I am pretty sure that way of handling exceptions with @ControllerAdvice in Spring and Java also may be problematic when we decide to switch to Kotlin in production projects - because it rely on class which is thrown, and throwing UndeclaredThrowableException take away from us this possibility", "label": {"api": {"UndeclaredThrowableException": [[270, 297]]}}}, {"text": "For me looks like EntityValidationException (which I want to be thrown) causes UndeclaredThrowableException", "label": {"api": {"UndeclaredThrowableException": [[79, 106]]}}}, {"text": "There is no equivalent in C++ for either java.lang.Object or java.lang.Class", "label": {"api": {"java.lang.Object": [[41, 56]], "java.lang.Class": [[61, 75]]}}}, {"text": "According to the Java 7 \"Pattern\" docs, Posix character classes are supported using the \\p{Alpha} format, not the :alpha", "label": {"api": {"Java 7 \"Pattern\" docs": [[17, 37]]}}}, {"text": "Lastly collect them as a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[25, 37]]}}}, {"text": "LinkedHashMap because it will maintain the insersion order", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "According to the FileDialog#setFilenameFilter JavaDoc", "label": {"api": {"FileDialog#setFilenameFilter": [[17, 44]]}}}, {"text": "As you think you can use executeScript", "label": {"api": {"executeScript": [[25, 37]]}}}, {"text": "When you say X extends Object, that requires that X be a subclass of Object (usually a safe assumption)", "label": {"api": {"Object": [[23, 28], [69, 74]]}}}, {"text": "Object doesn't have a doubleValue() method", "label": {"api": {"Object": [[0, 5]]}}}, {"text": "Number does have Number.doubleValue() which is why that works", "label": {"api": {"Number.doubleValue()": [[17, 36]]}}}, {"text": "This way you can use thenCompose", "label": {"api": {"thenCompose": [[21, 31]]}}}, {"text": "If you really need to throw an exception from the cache, you can use exceptionally to convert the exception to a null value, and then use thenCompose to decide if you use the cache value, or call Amazon", "label": {"api": {"thenCompose": [[138, 148]], "exceptionally": [[69, 81]]}}}, {"text": "You can use DataInputStream to read the byte stream", "label": {"api": {"DataInputStream": [[12, 26]]}}}, {"text": "Alternatively an instance of BufferedImage can be created directly from the URL using ImageIO.read(java.net.URL)", "label": {"api": {"ImageIO.read(java.net.URL)": [[86, 111]]}}}, {"text": "You're basically implementing an interface similar to Supplier", "label": {"api": {"Supplier": [[54, 61]]}}}, {"text": "You can prefix the first one with (?U), i.e", "label": {"api": {"(?U)": [[34, 37]]}}}, {"text": "\"(?U)\\\\P{Alnum}+\", for full international unicode support", "label": {"api": {"(?U)": [[1, 4]]}}}, {"text": "You may refer to the official java document for more information about the implementation details", "label": {"api": {"official java document": [[21, 42]]}}}, {"text": "TreeMap is a SortedMap", "label": {"api": {"TreeMap": [[0, 6]], "SortedMap": [[13, 21]]}}}, {"text": "It will only accept keys that implements Comparable, or you can pass Comparator object in TreeMap's constructor during initialization", "label": {"api": {"TreeMap": [[90, 96]]}}}, {"text": "You can split the inputted String, use StringBuilder's reverse() method, and concatenate it back to one String", "label": {"api": {"reverse()": [[55, 63]]}}}, {"text": "A user of an app I wrote recently discovered a crash caused by an empty string being passed to Float.valueOf(String s)", "label": {"api": {"Float.valueOf(String s)": [[95, 117]]}}}, {"text": "You may also want to look at the javadoc of java.util.regex.Pattern ( https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html )", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html": [[70, 139]]}}}, {"text": "The ActionListeners are behind the scene stored into a EventListenerList, so they will be executed following the adding order", "label": {"api": {"EventListenerList": [[55, 71]]}}}, {"text": "All you need to do is use substring()", "label": {"api": {"substring()": [[26, 36]]}}}, {"text": "You can use a Timer with the method", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "Here, task is the task you want to execute (derived from TimerTask), period is time in milliseconds between the execution of two tasks and delay is the delay in milliseconds before each execution", "label": {"api": {"Timer": [[57, 61]]}}}, {"text": "The best way to wait for multiple threads is to use ExecutorService.submit(), then call Future.get() to wait for the jobs to complete", "label": {"api": {"ExecutorService.submit()": [[52, 75]]}}}, {"text": "This is the compareTo method of a class implementing the Comparable (see https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html) interface", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[73, 139]]}}}, {"text": "Regarding point 3 of my question I 've found that the way to set paths for other cookies is to programmatically create many of them, one for each path, and add them in the response object with the addCookie method", "label": {"api": {"addCookie": [[197, 205]]}}}, {"text": "See the API docs, but here's you how use it", "label": {"api": {"API docs": [[8, 15]]}}}, {"text": "You could attach extra information to each SelectionKey", "label": {"api": {"attach extra information": [[10, 33]]}}}, {"text": "Try the Arrays.toString() method", "label": {"api": {"Arrays.toString()": [[8, 24]]}}}, {"text": "Then, when you get a common substring as a result, simply use the contains() method to check for the pattern in the other strings", "label": {"api": {"contains()": [[66, 75]]}}}, {"text": "If you want to implement something like in the given video, you just need to split the strings based on a certain delimiter", "label": {"api": {"split": [[77, 81]]}}}, {"text": "split the strings based on the delimiter, if it is found in all (or even most) of the strings", "label": {"api": {"split": [[0, 4]]}}}, {"text": "I have application send e-mail to customer and I use javax.mail.Transport Class to do this", "label": {"api": {"javax.mail.Transport": [[53, 72]]}}}, {"text": "For example Paths class", "label": {"api": {"Paths": [[12, 16]]}}}, {"text": "You can use Runtime.getRuntime().exec() or the Process API", "label": {"api": {"Runtime.getRuntime().exec()": [[12, 38]], "Process API": [[47, 57]]}}}, {"text": "You can then just call process.getInputStream() to get InputStream", "label": {"api": {"process.getInputStream()": [[23, 46]], "InputStream": [[34, 44], [55, 65]]}}}, {"text": "I have now stopped working with the Dropbox Java SDK and started using the Dropbox API by making HTTP posts using HttpsUrlConnection", "label": {"api": {"HttpsUrlConnection": [[114, 131]]}}}, {"text": "The collector groupingBy(classifier, mapFactory, downstream) can be used to specify which type of map is wanted, by passing it a supplier of the wanted map for the mapFactory", "label": {"api": {"groupingBy(classifier, mapFactory, downstream)": [[14, 59]]}}}, {"text": "Then, the downstream collector, which is used to collect elements grouped to the same key, is toCollection(collectionFactory), which enables to collect into a collection obtained from the given supplier", "label": {"api": {"toCollection(collectionFactory)": [[94, 124]]}}}, {"text": "If you only want to specify a collection supplier, and keep groupingBy default map, you can just omit the supplier in the code above and use the two arguments overload", "label": {"api": {"two arguments overload": [[145, 166]]}}}, {"text": "If you're using Java 8, you can do this easily with the Map.merge() method", "label": {"api": {"Map.merge()": [[56, 66]]}}}, {"text": "A package object can be obtained by name using Elements#getPackageElement and class objects can be obtained by name using Elements#getTypeElement", "label": {"api": {"Elements#getPackageElement": [[47, 72]], "Elements#getTypeElement": [[122, 144]]}}}, {"text": "See the documentation for Pattern for more information on the building blocks for regular expressions", "label": {"api": {"documentation for Pattern": [[8, 32]]}}}, {"text": "(The number of digits displayed is discussed in [http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#toString-double-](this javadoc)", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#toString-double-](this": [[49, 133]]}}}, {"text": "All you need to map a matrix to a RandomAccessFile for later use", "label": {"api": {"RandomAccessFile": [[34, 49]]}}}, {"text": "I suggest getting rid of the String[] array and using a StringBuilder instead (trying to keep it close to your own idea)", "label": {"api": {"StringBuilder": [[56, 68]]}}}, {"text": "You need to use Scanner(File source) not the file name", "label": {"api": {"Scanner(File source)": [[16, 35]]}}}, {"text": "For more information, read the documentation", "label": {"api": {"read the documentation": [[22, 43]]}}}, {"text": "There is filter method on Stream", "label": {"api": {"filter": [[9, 14]]}}}, {"text": "As of Java 8, I suggest you use ForkJoinPool.commonPool()", "label": {"api": {"ForkJoinPool.commonPool()": [[32, 56]]}}}, {"text": "By default, Class.forName does both, although there's an override you can use that lets you control whether to initialize the class", "label": {"api": {"an override you can use": [[54, 76]]}}}, {"text": "The docs for (String(byte[])) say", "label": {"api": {"docs for (String(byte[]))": [[4, 28]]}}}, {"text": "You can use the awaitTermination(long timeout, TimeUnit unit) method to have your main thread pause while the threadpool finishes its tasks", "label": {"api": {"awaitTermination(long timeout, TimeUnit unit)": [[16, 60]]}}}, {"text": "After having called shutdown(), you can use awaitTermination(long timeout, TimeUnit unit) to block the calling thread until all tasks have completed execution", "label": {"api": {"awaitTermination(long timeout, TimeUnit unit)": [[44, 88]]}}}, {"text": "BitSet has 3 methods that describes its state (in sense of length and set bits)", "label": {"api": {"length": [[59, 64]]}}}, {"text": "length - Returns the \"logical size\" of this BitSet", "label": {"api": {"length": [[0, 5]], "size": [[30, 33]]}}}, {"text": "size - Returns the number of bits of space actually in use by this BitSet to represent bit values", "label": {"api": {"size": [[0, 3]]}}}, {"text": "cardinality - Returns the number of bits set to true in this BitSet", "label": {"api": {"cardinality": [[0, 10]]}}}, {"text": "If you need to track number of set bits cardinality method is the answer", "label": {"api": {"cardinality": [[40, 50]]}}}, {"text": "My guess is that you thought you can treat BitSet as List or something where you have capacity (size in BitSet case) and size - the actual number of elements in a list", "label": {"api": {"size": [[96, 99], [121, 124]]}}}, {"text": "No need to create and fill such an array manually, there is a built-in method String.toCharArray that does the job for you", "label": {"api": {"String.toCharArray": [[78, 95]]}}}, {"text": "You can use the method getText() inherited from JTextComponent to retrieve the current string value of your field (depending on your context, be prepared for NullPointerExceptions)", "label": {"api": {"getText()": [[23, 31]]}}}, {"text": "And then you can ask that string for the number of characters; using String.length() to return the number of Unicode code points in that string", "label": {"api": {"String.length()": [[69, 83]]}}}, {"text": "If you are interested in counting words inside that string, you can use String.split() in order to have that one string sliced into an array of sub-elements of it (for example using \" \" as argument, or \"\\s+\" which splits on any wildcard)", "label": {"api": {"String.split()": [[72, 85]]}}}, {"text": "You can consider using BitSet", "label": {"api": {"BitSet": [[23, 28]]}}}, {"text": "It has a clear method to reset all bits to false", "label": {"api": {"clear": [[9, 13]]}}}, {"text": "According to this answer you could use the Robot API in Java", "label": {"api": {"Robot": [[43, 47]]}}}, {"text": "Perhaps the simplest way to fix this is to use the Arrays.copyOfRange() methods to create a copy of only the parts of the array we're interested in, and replace the original with the copy", "label": {"api": {"Arrays.copyOfRange()": [[51, 70]]}}}, {"text": "You can do this operation in constant time by first creating (in linear time) a mapping from id->object for each list", "label": {"api": {"mapping": [[80, 86]]}}}, {"text": "In place of get, use remove", "label": {"api": {"remove": [[21, 26]]}}}, {"text": "Then you need to access the image, use the ClassLoader.getResourceAsStream(String) for this", "label": {"api": {"ClassLoader.getResourceAsStream(String)": [[43, 81]]}}}, {"text": "You can achieve this with Thread.UncaughtExceptionHandler", "label": {"api": {"Thread.UncaughtExceptionHandler": [[26, 56]]}}}, {"text": "You can access the command line parameters using the getParameters() method", "label": {"api": {"getParameters()": [[53, 67]]}}}, {"text": "The Application documentation explains the life cycle of a JavaFX application", "label": {"api": {"Application documentation": [[4, 28]]}}}, {"text": "All 4 constructor calls are calling Thread(Runnable target), where Runnable is a @FunctionalInterface with the method void run()", "label": {"api": {"Thread(Runnable target)": [[36, 58]], "Runnable": [[43, 50], [67, 74]], "@FunctionalInterface": [[81, 100]]}}}, {"text": "When the thread is started, it will call the run() method of the Runnable", "label": {"api": {"Runnable": [[65, 72]]}}}, {"text": "I can't exactly explain the behavior, but it could be caused by ResourceBundle.Control.getFallbackLocale", "label": {"api": {"ResourceBundle.Control.getFallbackLocale": [[64, 103]]}}}, {"text": "The earliest documentation I could find was for Java 1.5", "label": {"api": {"Java 1.5": [[48, 55]]}}}, {"text": "Create a custom java.util.logging.Filter and install it on the java.util.logging.Logger that is generating the log record", "label": {"api": {"java.util.logging.Filter": [[16, 39]], "java.util.logging.Logger": [[63, 86]], "log record": [[111, 120]]}}}, {"text": "You can either just omit that log entry by returning false or simply re-write the parameter or message of the log record so that it doesn't contain the password", "label": {"api": {"log record": [[110, 119]]}}}, {"text": "In multi thread environment, you should always use CuncurrentHashMap, if you are going to perform any operation except get", "label": {"api": {"CuncurrentHashMap": [[51, 67]]}}}, {"text": "Use methods of java.lang.reflect.Field", "label": {"api": {"java.lang.reflect.Field": [[15, 37]]}}}, {"text": "Check java.awt.SystemTray and How to Use the System Tray", "label": {"api": {"java.awt.SystemTray": [[6, 24]]}}}, {"text": "The simplest way to do this would be to use Collections.indexOfSubList", "label": {"api": {"Collections.indexOfSubList": [[44, 69]]}}}, {"text": "It really should have been called Path from the get go", "label": {"api": {"Path": [[34, 37]]}}}, {"text": "But no matter, there is Path interface since Java 7", "label": {"api": {"Path": [[24, 27]]}}}, {"text": "I know little-to-nothing about JavaFX, but could you use WebEngine.executeScript", "label": {"api": {"WebEngine.executeScript": [[57, 79]]}}}, {"text": "What you can do instead is use a FileWriter, BufferedWriter or PrintWriter, which have multiple write[...](...) methods to write text to a file", "label": {"api": {"FileWriter": [[33, 42]], "BufferedWriter": [[45, 58]], "PrintWriter": [[63, 73]]}}}, {"text": "Then you can compose them with Functions.compose() (or Java 8's Function.andThen()) to create a compound function that applies all the desired transformations", "label": {"api": {"Function.andThen()": [[64, 81]]}}}, {"text": "The documentation of the SwingWorker class has an excellent recap of your situation", "label": {"api": {"SwingWorker": [[25, 35]]}}}, {"text": "The SwingWorker class provides a solution to your problem", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "SwingWorker is designed for situations where you need to have a long running task run in a background thread and provide updates to the UI either when done, or while processing", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "And in cases where you are opening a modal dialog (you're doing that with JOptionPane.showMessageDialog) I would invokeLater that method so that all pending UI messages get handled before you open that new dialog", "label": {"api": {"invokeLater": [[113, 123]]}}}, {"text": "If invokeLater is called from the event dispatching thread -- for example, from a JButton's ActionListener -- the doRun.run() will still be deferred until all pending events have been processed", "label": {"api": {"invokeLater": [[3, 13]]}}}, {"text": "If you simply need a unique id you might use a LinkedHashMap which (from the Javadoc) defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order), if you were to then get the keySet you might construct an ArrayList and then use the index from that List as your unique id", "label": {"api": {"LinkedHashMap": [[47, 59]]}}}, {"text": "You can then convert the String to a byte array, using getBytes", "label": {"api": {"getBytes": [[55, 62]]}}}, {"text": "Assuming that you use Java 8, if you want to get the total amount of duplicates of each value of your List, you could do that thanks to the Stream API by grouping by values then counting occurences of each value as next", "label": {"api": {"Stream API": [[140, 149]]}}}, {"text": "If you want to prevent duplicates by adding a counter at the end of the original String, you can use LinkedHashSet to preserve the values' ordering as proposed by Elliott Frisch", "label": {"api": {"LinkedHashSet": [[101, 113]]}}}, {"text": "Please have a look at the JOptionPane API for more on this", "label": {"api": {"JOptionPane API": [[26, 40]]}}}, {"text": "You will need to implement your own Comparator for your TreeMap, which you will then pass into its constructor", "label": {"api": {"Comparator": [[36, 45]]}}}, {"text": "It seems that you are confusing yourself", "label": {"api": {"in": [[28, 29]]}}}, {"text": "The class java.lang.System has several static fields, one of them is called in", "label": {"api": {"java.lang.System": [[10, 25]], "in": [[76, 77]]}}}, {"text": "That in is an Object (because everything except primitive types is an descendent of java.lang.Object) of type InputStream", "label": {"api": {"in": [[5, 6], [37, 38]], "InputStream": [[110, 120]]}}}, {"text": "In that sense, you want probably look into here to figure what all those terms actually mean", "label": {"api": {"in": [[38, 39]]}}}, {"text": "The Calendar class works with 0-based months", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "The set method takes the year, month, and day in that order, not year, day, and month", "label": {"api": {"set": [[4, 6]]}}}, {"text": "The statement c1.set(2016, 25, 11); actually sets the date to February 11, 2018 (a Sunday), because 25 = 212 + 1, so the year is incremented by 2 and the month is set to February", "label": {"api": {"set": [[17, 19], [45, 47], [164, 166]]}}}, {"text": "Similarly, the statement c1.set(2016, 26, 11); actually sets the date to March 11, 2018 (also a Sunday)", "label": {"api": {"set": [[28, 30], [56, 58]]}}}, {"text": "To set c1 to November 25, 2016, change 11 to 10, and swap the second and third arguments", "label": {"api": {"set": [[3, 5]]}}}, {"text": "In your case, because it's just a date (without a time), java.time.LocalDate is appropriate for your use case", "label": {"api": {"java.time.LocalDate": [[57, 75]]}}}, {"text": "In case you're using a TextInputControl, appendText may be worth a look, but in case you know you're adding multiple Strings, StringBuilder is probably more efficient", "label": {"api": {"appendText": [[41, 50]]}}}, {"text": "Better use a AnimationTimer", "label": {"api": {"AnimationTimer": [[13, 26]]}}}, {"text": "For a solution with no loop or check of indexes, you can use the Arrays.toString method that does exactly what you want for 1D array", "label": {"api": {"Arrays.toString": [[65, 79]]}}}, {"text": "You need to implement Collection<E>, singular, or List<E>", "label": {"api": {"Collection<E>": [[22, 34]], "List<E>": [[50, 56]]}}}, {"text": "You can save a lot of time by sub-classing AbstractList<E>", "label": {"api": {"List<E>": [[51, 57]], "AbstractList<E>": [[43, 57]]}}}, {"text": "You should look into using Scanner or some other method of parsing values; BufferedInputStream only reads data, nothing else", "label": {"api": {"Scanner": [[27, 33]]}}}, {"text": "Looking at the documentation, getTextContent clearly says it returns the text of the element and its descendants, and I don't see any other method to return just the sum of the text nodes, so I think you need a loop", "label": {"api": {"getTextContent": [[30, 43]]}}}, {"text": "The default cipher mode in Java is ECB, while in C# is CBC", "label": {"api": {"ECB": [[35, 37]]}}}, {"text": "Lower the log level of the root logger or just lower the level of the CLI.class.getName() logger", "label": {"api": {"lower the level": [[47, 61]]}}}, {"text": "This is the efficient solution that uses a StringBuilder and no Lists", "label": {"api": {"StringBuilder": [[43, 55]]}}}, {"text": "A StringBuilder is basically a class that helps you to build string", "label": {"api": {"StringBuilder": [[2, 14]]}}}, {"text": "getChildren() simply returns a reference to a List", "label": {"api": {"List": [[46, 49]]}}}, {"text": "calling add(child) will add an element (a Node) to the end of the list, so if all you do is call add repeatedly, the nodes will be arranged in the list in the order you add them", "label": {"api": {"add(child)": [[8, 17]]}}}, {"text": "If you call add(index, child) the child node will be added at the specified index (so if you repeatedly call add(0, child) the child nodes will be in the reverse of the order in which you add them", "label": {"api": {"add(index, child)": [[12, 28]]}}}, {"text": "If you call addAll(nodes) the child nodes will be added in the order they appear to the end of the list, etc", "label": {"api": {"addAll(nodes)": [[12, 24]]}}}, {"text": "Use a proper memory barrier, such as a synchronised read and write, a volatile field, or a cross-thread communcation mechanism such as those in java.util.concurrent", "label": {"api": {"java.util.concurrent": [[144, 163]]}}}, {"text": "I can't import java.time package and it says that package does not exist", "label": {"api": {"java.time": [[15, 23]]}}}, {"text": "A SubScene is probably what you are looking for", "label": {"api": {"SubScene": [[2, 9]]}}}, {"text": "I suggest to store it in way Duration.parse can handle it, in standard ISO 8601 format", "label": {"api": {"Duration.parse": [[29, 42]]}}}, {"text": "Instead of using the operator + use the class StringBuilder to concatenate strings", "label": {"api": {"StringBuilder": [[46, 58]]}}}, {"text": "A StringBuilder use a different internal representation so it is not necessary to create new objects for every concatenation", "label": {"api": {"StringBuilder": [[2, 14]]}}}, {"text": "Here a more efficient code using StringBuilder", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "According to the Javadoc, only ForkJoinWorkerThread publicly extends this class in the JDK", "label": {"api": {"ForkJoinWorkerThread": [[31, 50]]}}}, {"text": "Wondering if there is an equivalent to PathTransition in libGDX", "label": {"api": {"PathTransition": [[39, 52]]}}}, {"text": "What is specifically awesome about PathTransition is that it rotates your Node accordingly while it traverses through the Path", "label": {"api": {"PathTransition": [[35, 48]]}}}, {"text": "What sucks about PathTransition is that you need to calculate the speed yourself, that is to say that you only provide how long it will take to finish the traversal but you need to figure out how long the path is so that you can set the appropriate duration", "label": {"api": {"PathTransition": [[17, 30]]}}}, {"text": "Was hoping libGDX had something similar or better yet an improved version of PathTransition", "label": {"api": {"PathTransition": [[77, 90]]}}}, {"text": "To detect the insertion of a duplicate, capture the boolean returned by the Set::add method, TRUE is successfully added and FALSE if duplicate", "label": {"api": {"Set::add": [[76, 83]]}}}, {"text": "If you're using Java 8, another option is to use Random#ints to generate a Stream which you can use to directly create your Set", "label": {"api": {"Random#ints": [[49, 59]]}}}, {"text": "Read the fine manual", "label": {"api": {"Read the fine manual": [[0, 19]]}}}, {"text": "I'm not sure if I really recommend this, but  yes; there's a two-arg overload of indexOf that lets you specify the starting position to search at; so you can write", "label": {"api": {"two-arg overload of indexOf": [[62, 88]]}}}, {"text": "All you need is a collection class that can store all the fields and provide suitable hashCode and equals methods that use the values of the fields", "label": {"api": {"hashCode": [[86, 93]], "equals": [[99, 104]]}}}, {"text": "In fact, the List interface provides this", "label": {"api": {"List": [[13, 16]]}}}, {"text": "Its hashCode and equals method specifications are exactly what you need", "label": {"api": {"hashCode": [[4, 11]], "equals": [[17, 22]]}}}, {"text": "They combine the hashCode and equals methods of each field in turn", "label": {"api": {"hashCode": [[17, 24]], "equals": [[30, 35]]}}}, {"text": "So, instead of a class, just use a List", "label": {"api": {"List": [[35, 38]]}}}, {"text": "Use StringBuilder to build your output", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "You'd better leave the choice up to the experts and use new SecureRandom()", "label": {"api": {"new SecureRandom()": [[56, 73]]}}}, {"text": "If use of new SecureRandom() results in blocking then you need to make sure that your application doesn't use /dev/random directly, depleting the entropy pool", "label": {"api": {"new SecureRandom()": [[10, 27]]}}}, {"text": "For retrieving long term key key material you may also use SecureRandom.getInstanceStrong()", "label": {"api": {"SecureRandom.getInstanceStrong()": [[59, 90]]}}}, {"text": "An interface example is java.util.Set, which is implemented by HashSet and TreeSet", "label": {"api": {"java.util.Set": [[24, 36]], "HashSet": [[63, 69]], "TreeSet": [[75, 81]]}}}, {"text": "If you use Java 8 no need to reimplement it, simply use Comparator.reverseOrder() to get the reverse of the natural ordering as next", "label": {"api": {"Comparator.reverseOrder()": [[56, 80]]}}}, {"text": "To control the alignment of individual lines of text in a multiline label, you can use setTextAlignment", "label": {"api": {"setTextAlignment": [[87, 102]]}}}, {"text": "The method splitAsStream(input) does exactly that", "label": {"api": {"splitAsStream(input)": [[11, 30]]}}}, {"text": "When you make a HashSet of ints, it uses Integer's hashCode() method, which just returns the int", "label": {"api": {"Integer's hashCode()": [[41, 60]]}}}, {"text": "But for double, Double's hashCode() method is much more complicated, because of the way doubles are represented in memory", "label": {"api": {"Double's hashCode()": [[16, 34]]}}}, {"text": "From the spec", "label": {"api": {"spec": [[9, 12]]}}}, {"text": "I recommend working your way through the Java Sound Trail and also check out the Java API docs for classes like AudioFormat", "label": {"api": {"AudioFormat": [[112, 122]]}}}, {"text": "Runtime.exec was replaced by ProcessBuilder twelve years ago, as part of Java 1.5", "label": {"api": {"ProcessBuilder": [[29, 42]]}}}, {"text": "You don't gain anything from using double for this problem use int instead", "label": {"api": {"double": [[35, 40]], "int": [[63, 65]]}}}, {"text": "Set the contentDisplay property to ContentDisplay.CENTER", "label": {"api": {"the contentDisplay property": [[4, 30]]}}}, {"text": "In case you are talking about that LinkedList that comes as java.util - the answer", "label": {"api": {"LinkedList": [[35, 44]]}}}, {"text": "create your own implementation of the List interface (and use that LinkedList to implement that) and add those methods you are looking for", "label": {"api": {"LinkedList": [[67, 76]]}}}, {"text": "The easiest way to get there would be by extending java.util.LinkedList; but in case you favor composition over inhertiance you might choose to fully implement that List interface yourself", "label": {"api": {"LinkedList": [[61, 70]]}}}, {"text": "You can use the package Package javax.ws.rs", "label": {"api": {"javax.ws.rs": [[32, 42]]}}}, {"text": "Use one of the JOptionPane.showConfirmDialog() methods like they show here and here", "label": {"api": {"JOptionPane.showConfirmDialog()": [[15, 45]]}}}, {"text": "I am trying to make a custom rollover effect on the Collapsed Icon for a JTree", "label": {"api": {"Collapsed Icon": [[52, 65]]}}}, {"text": "There is a System.getenv method that helps to optain the value of the specified environment variable", "label": {"api": {"System.getenv": [[11, 23]]}}}, {"text": "Behind the scenes Collectors.toList() will allow to collect the resulting elements of your Stream into an ArrayList created with the default constructor so with a default capacity of 10 so indeed a reallocation will be required in case the size exceeds 10", "label": {"api": {"Collectors.toList()": [[18, 36]]}}}, {"text": "If you want to use a different List's implementation, use toCollection(Supplier<C> collectionFactory) which is a more generic collector allowing to provide the factory of your target Collection", "label": {"api": {"toCollection(Supplier<C> collectionFactory)": [[58, 100]]}}}, {"text": "That being said, SwingUtilities has methods to find the coordinates, given the source (the button in your case) and the destination (the frame in your case) Component objects", "label": {"api": {"SwingUtilities": [[17, 30]]}}}, {"text": "A nice way to do that would be to get a BufferedReader reading your file, for example with the help of Files.newBufferedReader(path)", "label": {"api": {"BufferedReader": [[40, 53], [112, 125]], "Files.newBufferedReader(path)": [[103, 131]]}}}, {"text": "Then you can call nextLine() one time to retrieve the header row, and lines() to get a Stream<String> of all the other rows", "label": {"api": {"lines()": [[70, 76]]}}}, {"text": "This works because the first call to readLine() will cause the buffered reader to read the first line, so subsequently, since lines() is a stream populated by reading the lines, it starts reading at the second line", "label": {"api": {"lines()": [[126, 132]]}}}, {"text": "It's unclear what the handleLine method does, but, generally, you do not need forEach and might prefer a mutable reduction with collect, which would be safe to use in a parallel stream", "label": {"api": {"mutable reduction": [[105, 121]]}}}, {"text": "No, in a normal scenario that would lead to recursion until a StackOverflowException occurs, not in your case since on the next call you would exit the recursion", "label": {"api": {"StackOverflowException": [[62, 83]]}}}, {"text": "Don't use a JOptionPane for this but rather use a non-modal JDialog (JDialog API link), one that stays open, since as a JDialog, you are in full control over when or whether it closes", "label": {"api": {"JDialog API link": [[69, 84]]}}}, {"text": "I found my own solution for this problem by using addComponentListener() and handling the componentResized event for the JFrame", "label": {"api": {"addComponentListener()": [[50, 71]]}}}, {"text": "Here's the associated Javadoc - you'll also find methods that help you determine the component type of the array, which is likely to be useful for your code as well", "label": {"api": {"associated Javadoc": [[11, 28]]}}}, {"text": "I created a plot on Canvas", "label": {"api": {"Canvas": [[20, 25]]}}}, {"text": "I know how to get a WritableImage from Canvas and I know that I need an InputStream to write an image in Excel with addPicture()", "label": {"api": {"Canvas": [[39, 44]], "WritableImage": [[20, 32]]}}}, {"text": "The docs also mention using AnnotatedElement but I don't see how to use this; the methods only seem to take Class objects, not Method or Field objects", "label": {"api": {"AnnotatedElement": [[28, 43]]}}}, {"text": "The missing method had initially confused me so I stuck with the legacy behavior (hence the helper method), but the right method appears to be .getAnnotationsByType() which handles both cases (and as a bonus never returns null), so you can simply say", "label": {"api": {".getAnnotationsByType()": [[143, 165]]}}}, {"text": "Here's a reference to JavaDoc about DropShadow, may come in handy for you", "label": {"api": {"reference": [[9, 17]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html to und er stand why it is strictly recommended to habe compare behaving consistent with equals(), but the bottom line is that the second key is not added since it is considered equal to the first", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html": [[4, 70]]}}}, {"text": "The reason we use MMM in the format mask for the full month name is explained well in the Javadoc for SimpleDateFormat", "label": {"api": {"Javadoc for SimpleDateFormat": [[90, 117]]}}}, {"text": "Check out the Javadoc (looking at the static hsb(double h, double s, double b) method) for an in-code reference, and the CSS guide for defining in CSS (like we're doing here)", "label": {"api": {"CSS guide": [[121, 129]]}}}, {"text": "When you create your own InputStream, the only method that you have to implement since it is an abstract method is read() which is also much less error prone than implementing read(byte[] b) and/or read(byte b[], int off, int len)", "label": {"api": {"read()": [[115, 120]]}}}, {"text": "Moreover please note that the default implementation of read(byte b[], int off, int len) already checks the arguments for you so unless you want to revalidate the arguments yourself, you should implement read() only", "label": {"api": {"read()": [[204, 209]]}}}, {"text": "From the java.util.logging.Logger docs", "label": {"api": {"java.util.logging.Logger": [[9, 32]]}}}, {"text": "So you want a OffsetDateTime with a ZoneOffset", "label": {"api": {"ZoneOffset": [[36, 45]]}}}, {"text": "If you absolutely can't change your code, use System.setIn to replace the default input stream with one of your choosing", "label": {"api": {"System.setIn": [[46, 57]]}}}, {"text": "Assuming that you provide a Double value to each input String in your map mapOfStringAndNumber, you could use Pattern#splitAsStream(CharSequence input) to split your input String directly as a Stream and use Collectors.joining(CharSequence delimiter) to build your output with + as delimiter, so your final code could be", "label": {"api": {"Pattern#splitAsStream(CharSequence input)": [[110, 150]], "Collectors.joining(CharSequence delimiter)": [[208, 249]]}}}, {"text": "Anyway, a TextArea has a property wrapText which allows us to control whether this text wrapping will be added or not", "label": {"api": {"a TextArea has a property wrapText": [[8, 41]]}}}, {"text": "You can find the definition of the jar protocol in the JarURLConnection class documentation", "label": {"api": {"JarURLConnection": [[55, 70]]}}}, {"text": "First, please note that your stream created from BufferedReader.lines does not hold any resource, thus closing the stream has no effect", "label": {"api": {"BufferedReader.lines": [[49, 68]]}}}, {"text": "For example, Files.lines documents this", "label": {"api": {"Files.lines": [[13, 23]]}}}, {"text": "There's no such remark in BufferedReader.lines documentation", "label": {"api": {"BufferedReader.lines": [[26, 45]]}}}, {"text": "created from Files.lines()), it will not be closed automatically if you just return an iterator, regardless whether the iterator is traversed to the end or not", "label": {"api": {"Files.lines": [[13, 23]]}}}, {"text": "You need to check first if the transaction is active thanks to EntityTransaction#isActive() before calling rollback()", "label": {"api": {"EntityTransaction#isActive()": [[63, 90]]}}}, {"text": "Read the Javadoc", "label": {"api": {"Read the Javadoc": [[0, 15]]}}}, {"text": "That call to read returns the number of bytes read", "label": {"api": {"read": [[13, 16], [46, 49]]}}}, {"text": "And you do not clear your read buffer - thus you keep seeing the same bytes all the time", "label": {"api": {"read": [[26, 29]]}}}, {"text": "the BitSet pre-allocates space; and that is what size() tells you about", "label": {"api": {"size()": [[49, 54]]}}}, {"text": "Also note that size() depends on your JDK's implementation of BitSet", "label": {"api": {"size()": [[15, 20]]}}}, {"text": "You might want to look into length() resp", "label": {"api": {"length()": [[28, 35]]}}}, {"text": "valueOf(); probably that will help you solving your problem", "label": {"api": {"valueOf()": [[0, 8]]}}}, {"text": "As this example shows, use the @XmlNs annotation to customize the NS prefix", "label": {"api": {"this example": [[3, 14]]}}}, {"text": "executeQuery should be used for statements that return a ResultSet", "label": {"api": {"executeQuery": [[0, 11]]}}}, {"text": "For other statements, you should use executeUpdate", "label": {"api": {"executeUpdate": [[37, 49]]}}}, {"text": "You should consider using a PreparedStatement instead", "label": {"api": {"PreparedStatement": [[28, 44]]}}}, {"text": "I register the directory with WatchService in a configuration class", "label": {"api": {"WatchService": [[30, 41]]}}}, {"text": "According to the java.awt.Robot Javadoc \"...the events are generated in the platform's native input queue\"", "label": {"api": {"java.awt.Robot Javadoc": [[17, 38]]}}}, {"text": "You can remove from the keySet, and the changes will be reflected in the Map", "label": {"api": {"keySet": [[24, 29]]}}}, {"text": "To generate exactly 10 unique numbers, we can add each number we generate to a HashSet, where every element must be unique", "label": {"api": {"HashSet": [[79, 85]]}}}, {"text": "We can continue this until the HashSet has 10 elements", "label": {"api": {"HashSet": [[31, 37]]}}}, {"text": "See the corresponding hasNext() javadoc", "label": {"api": {"hasNext()": [[22, 30]]}}}, {"text": "Java 8's IntStream to the rescue", "label": {"api": {"IntStream": [[9, 17]]}}}, {"text": "According to the official document, there is no way to retrive the File object", "label": {"api": {"official document": [[17, 33]]}}}, {"text": "I'd try scheduling tasks on a ThreadPoolExecutor of size 1 with DiscardOldestPolicy and a limited task queue length", "label": {"api": {"DiscardOldestPolicy": [[64, 82]]}}}, {"text": "If the value is bigger than 9223372036854775807(MAX value for long) then use BigInteger, something like this", "label": {"api": {"BigInteger": [[77, 86]]}}}, {"text": "However consider using the AnimationTimer class to do the updates", "label": {"api": {"the AnimationTimer class": [[23, 46]]}}}, {"text": "If you just want to use everything after the first space as the map value, you can use two-argument split", "label": {"api": {"split": [[100, 104]]}}}, {"text": "The parameter 2 instructs split not to make more than two fields, so the rest of the string will be put into e[1] even if it has more spaces", "label": {"api": {"split": [[26, 30]]}}}, {"text": "You might be able to override the JComponent#isOptimizedDrawingEnabled() method of AccordianPanel to return false", "label": {"api": {"JComponent#isOptimizedDrawingEnabled()": [[34, 71]]}}}, {"text": "Create a TableRowSorter that does the sorting you need, and register it as the sorter using JTable.setRowSorter", "label": {"api": {"TableRowSorter": [[9, 22]], "JTable.setRowSorter": [[92, 110]]}}}, {"text": "This will involve creating a Comparator that always has the empty rows be greater than non-empty rows based on some or all fields", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "This will have to take the SortOrder into account if you want to have the empty rows appear at the bottom even if you reverse the sort order", "label": {"api": {"SortOrder": [[27, 35]]}}}, {"text": "You can get the ordering by RowSorter.getSortKeys", "label": {"api": {"RowSorter.getSortKeys": [[28, 48]]}}}, {"text": "if you implemented a custom compareTo() method then you can implement the Comparable interface and then just use Collections.sort(events) instead of sorting the events yourself", "label": {"api": {"Comparable": [[74, 83]], "Collections.sort(events)": [[113, 136]]}}}, {"text": "In Java 8, this algorithm is available to you out-of-the-box with Collectors.partitioningBy", "label": {"api": {"Collectors.partitioningBy": [[66, 90]]}}}, {"text": "Use Scanner::hasNext() to loop while there are more lines and Scanner::nextLine() to fetch the next line, then use String::split() to get an array of strings on each line (Note", "label": {"api": {"Scanner::hasNext()": [[4, 21]], "Scanner::nextLine()": [[62, 80]], "String::split()": [[115, 129]]}}}, {"text": "For parsing the numbers in e notation, use Double.valueof(), and add that value to the array (e.g", "label": {"api": {"Double.valueof()": [[43, 58]]}}}, {"text": "To ship files with an application, one can put files in a package along with sources and read a file with ClassLoader.getResourceAsStream", "label": {"api": {"ClassLoader.getResourceAsStream": [[106, 136]]}}}, {"text": "This comes from Collection<E> interface, since the interface is used as an ancestor class for all kinds of collections, it makes sense to return a boolean to inform if add effectively changed the collection", "label": {"api": {"Collection<E>": [[16, 28]]}}}, {"text": "This is useful for collections like Set<T> which doesn't change if the element added was already present inside the collection", "label": {"api": {"Set<T>": [[36, 41]]}}}, {"text": "This is clearly stated in Collection<E>.add documentation", "label": {"api": {"Collection<E>": [[26, 38]]}}}, {"text": "If you do not want to scale the content, but simply resize it to the viewport size of the ScrollPane, setting the fitToWidth property to true would be the appropriate way to handle this", "label": {"api": {"the fitToWidth property": [[110, 132]]}}}, {"text": "See the javadoc for Object.equals()", "label": {"api": {"Object.equals()": [[20, 34]]}}}, {"text": "It is also conceivable that the JDK's Object.clone() will get you the results you need", "label": {"api": {"JDK's Object.clone()": [[32, 51]]}}}, {"text": "I searched Java doc https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int- but didn't find any answer about this", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-": [[20, 106]]}}}, {"text": "CriteriaBuilder.or accepts an array of predicates", "label": {"api": {"CriteriaBuilder.or": [[0, 17]]}}}, {"text": "BigDecimal has an operation for doing this", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "There is a reason for using the BigDecimal(String) constructor and not the BigDecimal(double) constructor", "label": {"api": {"BigDecimal": [[32, 41], [75, 84]]}}}, {"text": "doubles and floats are not base 10 numbers, so they dont exactly represent the values we see when we print them;  the constructor documentation has a good illustration of this", "label": {"api": {"constructor documentation": [[119, 143]]}}}, {"text": "4castle points out that the above wont work for nonzero numbers with a magnitude less than 1, since BigDecimal doesnt consider the zero integer part a significant digit", "label": {"api": {"BigDecimal": [[101, 110]]}}}, {"text": "Considering that PixelReader provides getARGB your best bet in this case is probably to use 32-bit representation", "label": {"api": {"getARGB": [[38, 44]]}}}, {"text": "Finally use setARGB to draw the image", "label": {"api": {"setARGB": [[12, 18]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html shows all possible formatting options, which are used also by the SimpleFormatter", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html": [[0, 65]]}}}, {"text": "So when you check the answers, you are trying to access answers[-1] leading to a ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[81, 110]]}}}, {"text": "I am pretty sure an EnumMap is more suited to your needs", "label": {"api": {"EnumMap": [[20, 26]]}}}, {"text": "An EnumMap is much more efficient than a HashMap, for enum values", "label": {"api": {"EnumMap": [[3, 9]]}}}, {"text": "You can use ByteArrayOutputStream which is an implementation of OutputStream that writes to a byte array", "label": {"api": {"ByteArrayOutputStream": [[12, 32]]}}}, {"text": "You can create an instance of this and pass it to writeTo(OutputStream) on your method and from there call toString on the ByteArrayOutputStream to retrieve a String representation of the message", "label": {"api": {"ByteArrayOutputStream": [[123, 143]]}}}, {"text": "For example, LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[13, 31]]}}}, {"text": "If you have access to the bytes that make up the dynamic class, you can make them available to the java compiler via a JavaFileManager implementation", "label": {"api": {"JavaFileManager": [[119, 133]]}}}, {"text": "Basically, the difference between my answer and his answer is that he closes the threads via a Semaphore and I just record the result of the fastest thread via an AtomicReference", "label": {"api": {"Semaphore": [[95, 103]], "AtomicReference": [[163, 177]]}}}, {"text": "Namely, I use an instance of AtomicReference<Integer> instead of the simpler AtomicInteger", "label": {"api": {"AtomicReference": [[29, 43]]}}}, {"text": "You can use ExecutorService.invokeAny", "label": {"api": {"ExecutorService.invokeAny": [[12, 36]]}}}, {"text": "You could simply reverse your list", "label": {"api": {"reverse": [[17, 23]]}}}, {"text": "Alternately, you could use the TreeMap constructor with a reverse comparator, to store the map in descending order", "label": {"api": {"reverse": [[58, 64]], "TreeMap constructor": [[31, 49]]}}}, {"text": "You can use a custom comparator to reverse the order of entries in the map (note that this only applies to TreeMap - other map implementations don't care about ordering)", "label": {"api": {"comparator": [[21, 30]]}}}, {"text": "If I read your question correctly, the easiest option might be to replace your JOptionPane.showMessageDialog(...) can with a JDialog that isn't a modal dialog, and therefore, won't block the EDT", "label": {"api": {"JDialog": [[125, 131]]}}}, {"text": "You can use Bindings.createObjectBinding", "label": {"api": {"Bindings.createObjectBinding": [[12, 39]]}}}, {"text": "The fillProperty of the Circle has the type of ObjectProperty<Paint> so you have to create a Paint object in the binding", "label": {"api": {"fillProperty": [[4, 15]]}}}, {"text": "Here is an example that uses a Task on a different thread to execute the operation", "label": {"api": {"Task": [[31, 34]]}}}, {"text": "As an example see StringUtils in Apache Commons Lang, Strings in Guava or even Arrays in JDK", "label": {"api": {"Arrays in JDK": [[79, 91]]}}}, {"text": "Try reading up on PreparedStatements for a better solution", "label": {"api": {"PreparedStatements": [[18, 35]]}}}, {"text": "As the Javadoc says, join() waits until a given thread dieshence, it's a statement which blocks until a thread has finished computation", "label": {"api": {"join()": [[21, 26]]}}}, {"text": "AtomicReference can be declared as final and used to hold a reference", "label": {"api": {"AtomicReference": [[0, 14]]}}}, {"text": "By the way, as you are only reading lines, you may also want to have a look at java.nio.file.Files", "label": {"api": {"java.nio.file.Files": [[79, 97]]}}}, {"text": "Starting in Java 7, you can use FileSystem.getPathMatcher to match file paths against glob patterns", "label": {"api": {"FileSystem.getPathMatcher": [[32, 56]]}}}, {"text": "BufferedInputStream#read() reads bytes, not chars", "label": {"api": {"BufferedInputStream#read()": [[0, 25]]}}}, {"text": "You can use AbstractMap.SimpleEntry to create a standalone Entry", "label": {"api": {"AbstractMap.SimpleEntry": [[12, 34]]}}}, {"text": "I have found how to populate it with arrays or vectors", "label": {"api": {"arrays or vectors": [[37, 53]]}}}, {"text": "I'd recommend using System.lineSeparator() method instead", "label": {"api": {"System.lineSeparator()": [[20, 41]]}}}, {"text": "I'd suggest making your map a Map<String, Integer>", "label": {"api": {"Map": [[30, 32]]}}}, {"text": "Second, Map.put() will overwrite the previous value if the given key is already present in the map, so as @Guy points out your map actually only contains {cat:55, dog:34, bat:1}", "label": {"api": {"Map": [[8, 10]]}}}, {"text": "Java 8 adds a number of useful methods to Map to make this pattern easier, like Map.merge() which does the put-or-update for you", "label": {"api": {"Map": [[42, 44], [80, 82]], "Map.merge()": [[80, 90]]}}}, {"text": "You can use FileChannel.transferTo", "label": {"api": {"FileChannel.transferTo": [[12, 33]]}}}, {"text": "I am using LocalDateTime from java 8", "label": {"api": {"LocalDateTime": [[11, 23]]}}}, {"text": "Take a look at CellEditor.isCellEditable( EventObject anEvent )", "label": {"api": {"CellEditor.isCellEditable( EventObject anEvent )": [[15, 62]], "CellEditor": [[15, 24]]}}}, {"text": "AbstractCellEditor and DefaultCellEditor implement the CellEditor interface", "label": {"api": {"AbstractCellEditor": [[0, 17]], "DefaultCellEditor": [[23, 39]], "CellEditor": [[8, 17], [30, 39], [55, 64]]}}}, {"text": "You can override this method to return false in case the EventObject is instance of type KeyEvent", "label": {"api": {"KeyEvent": [[89, 96]]}}}, {"text": "A simple way is to use the method contains", "label": {"api": {"contains": [[34, 41]]}}}, {"text": "Returns true if this list contains the specified element", "label": {"api": {"contains": [[26, 33]]}}}, {"text": "More formally, returns true if and only if this list contains at least one element e such that (o==null", "label": {"api": {"contains": [[53, 60]]}}}, {"text": "Easiest way to do that, is to use one of the Arrays.copyOfRange(xxx[] original, int from, int to) methods, where xxx is a primitive type or any object type", "label": {"api": {"Arrays.copyOfRange(xxx[] original, int from, int to)": [[45, 96]]}}}, {"text": "If needed, you can copy updated values back to the original array using System.arraycopy()", "label": {"api": {"System.arraycopy()": [[72, 89]]}}}, {"text": "If you're on Java 8, using LocalDate.now() is the easiest way to get today's date", "label": {"api": {"LocalDate.now()": [[27, 41]]}}}, {"text": "If a class does not implement the Cloneable interface, calling clone on an instance of the class results in a CloneNotSupportedException", "label": {"api": {"clone": [[63, 67]]}}}, {"text": "The java.lang.Object already implements a clone method (this method is not abstract), so subclasses are not required to implement it", "label": {"api": {"clone": [[42, 46]]}}}, {"text": "The clone method of java.lang.Object performs a shallow copy of the instance", "label": {"api": {"clone": [[4, 8]]}}}, {"text": "I would like to draw autocomplete-like drop-down box near caret in JavaFX controls like TextField and TextArea", "label": {"api": {"TextField": [[88, 96]], "TextArea": [[102, 109]]}}}, {"text": "File.renameTo(File dest) takes a File parameter, not a String", "label": {"api": {"File.renameTo(File dest)": [[0, 23]]}}}, {"text": "Alternatively, you can use Files.move to rename the file", "label": {"api": {"Files.move": [[27, 36]]}}}, {"text": "It's not entirely clear what you're trying to do, but it looks like you are trying to use inheritance and FXML-based custom components to create a template with specializations", "label": {"api": {"FXML-based custom components": [[106, 133]]}}}, {"text": "This seems like a good use-case for Comparable interface", "label": {"api": {"Comparable": [[36, 45]]}}}, {"text": "No, you cannot use filter(Predicate) to select the maximum value of a Stream", "label": {"api": {"filter(Predicate)": [[19, 35]]}}}, {"text": "Yes, Predicates can be chained by and(Predicate)", "label": {"api": {"and(Predicate)": [[34, 47]]}}}, {"text": "Do you understand what reduce(BinaryOperator) does", "label": {"api": {"reduce(BinaryOperator)": [[23, 44]]}}}, {"text": "I don't see any relevant options on DatagramSocket or DatagramChannel.setOption (or better", "label": {"api": {"DatagramSocket": [[36, 49]], "DatagramChannel.setOption": [[54, 78]]}}}, {"text": "Don't make the root of the Scene a Group, Groups are not resizable", "label": {"api": {"Scene": [[27, 31]], "Group": [[35, 39], [42, 46]]}}}, {"text": "I don't think there's such a service, but as a structure you can use https://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html": [[69, 131]]}}}, {"text": "If that's true, you could simply switch to an unbounded queue such as LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[70, 88]]}}}, {"text": "It's much easier to do such things with a Scanner with a custom delimiter than reinventing the wheel, IMHO", "label": {"api": {"Scanner": [[42, 48]]}}}, {"text": "Please have a look at Files.find method", "label": {"api": {"Files.find": [[22, 31]]}}}, {"text": "You need to implement the ValidationEventHandler interface from the JAXB API", "label": {"api": {"ValidationEventHandler": [[26, 47]]}}}, {"text": "Google Core Libraries for Java 21.0-SNAPSHOT API) states that it is \"a Map whose contents will never change, with many other important properties detailed at ImmutableCollection\"", "label": {"api": {"Map": [[71, 73]]}}}, {"text": "The last guarantee, integrety, alludes to the fact that internally Guava has concrete implementations (non-abstract) of ImmutableMap and other immutable objects which is what is actually returned by these builders", "label": {"api": {"Map": [[129, 131]]}}}, {"text": "With ArrayList, you can use array_list.subList(fromIndex, toIndex) to get a slice", "label": {"api": {"array_list.subList(fromIndex, toIndex)": [[28, 65]]}}}, {"text": "You can customize the DateFormatSymbols used by a SimpleDateFormat", "label": {"api": {"DateFormatSymbols": [[22, 38]]}}}, {"text": "This collects all entries of the old map using a collector that takes the same key in the entry (Map.Entry::getKey is equivalent to e -> e.getKey()), and sets the value to be the result of unwrapping the object", "label": {"api": {"collects all entries of the old map using a collector": [[5, 57]]}}}, {"text": "To have the returned map of type TreeMap, use the Collectors.toMap that takes a supplier", "label": {"api": {"Collectors.toMap that takes a supplier": [[50, 87]]}}}, {"text": "Java's java.util.Date and java.sql.Timestamp do not store timezone", "label": {"api": {"java.util.Date": [[7, 20]], "java.sql.Timestamp": [[26, 43]]}}}, {"text": "When parsing a date string without timezone, the string is parsed in the JVM's default timezoneand converted to UTC, unless another timezone has been explicitly given to the date parser (commonly SimpleDateFormat)", "label": {"api": {"SimpleDateFormat": [[196, 211]]}}}, {"text": "Assuming that you use Java 8, you could do that using the Stream API with joining(CharSequence delimiter) as collector allowing to concatenate the input elements, separated by the specified delimiter, in encounter order as next", "label": {"api": {"joining(CharSequence delimiter)": [[74, 104]]}}}, {"text": "In Java, you can use the Map interface, and choose that implementation that best fits your needs; like", "label": {"api": {"Map": [[25, 27]]}}}, {"text": "You would also want to read about java Collection in general; and look into the corresponding tutorials", "label": {"api": {"Collection": [[39, 48]]}}}, {"text": "When you need a Map that can't be \"changed\" upon adding the initial elements; you would first populate an ordinary Map object; and then use Collections.unmodifiableMap() afterwards", "label": {"api": {"Map": [[16, 18], [115, 117], [164, 166]], "Collection": [[140, 149]], "Collections.unmodifiableMap()": [[140, 168]]}}}, {"text": "Java's \"built-in\" java.lang.Map is always about a keys/value pairs", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "If you need more than one value, you would be using something like Map<String, List<String>> for example", "label": {"api": {"Map": [[67, 69]]}}}, {"text": "In Java 8 they have introduced the OptionalInt class for this purpose", "label": {"api": {"OptionalInt class": [[35, 51]]}}}, {"text": "Use the class inside javafx.propertyand bind two properties together", "label": {"api": {"bind": [[40, 43]]}}}, {"text": "In the JavaDoc, ProgressIndictor and ProgressBar has progressProperty, which is an instance of DoubleProperty", "label": {"api": {"progressProperty": [[53, 68]]}}}, {"text": "Property class has a bind method, which you can bind it to another ObservableValue or Property", "label": {"api": {"bind": [[21, 24], [48, 51]]}}}, {"text": "JDK contains lots of variants of timeout Exceptions like SQLTimeoutException, SocketTimeoutException, etc.., but unfortunately, there is no parent class such as TimeoutException which can be extended or generally used across for all Timeout exceptions", "label": {"api": {"SQLTimeoutException": [[57, 75]], "SocketTimeoutException": [[78, 99]]}}}]