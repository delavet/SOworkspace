[{"text": "using Collection#removeIf to remove all of A entries from map1, if the C of B contains in map2 in an entry", "label": {"api": {"Collection#removeIf": [[6, 24]]}}}, {"text": "OR using Stream#filter instead", "label": {"api": {"Stream#filter": [[9, 21]]}}}, {"text": "Probably you lost to flush your buffer (of the sender)", "label": {"api": {"flush": [[21, 25]]}}}, {"text": "If you don't flush the buffer the output could be not written", "label": {"api": {"flush": [[13, 17]]}}}, {"text": "The general contract of flush is that calling it is an indication that, if any bytes previously written have been buffered by the implementation of the output stream, such bytes should immediately be written to their intended destination", "label": {"api": {"flush": [[24, 28]]}}}, {"text": "an explicit call to flush (I don't know exactly the syntax in python)", "label": {"api": {"flush": [[20, 24]]}}}, {"text": "Since the newFixedThreadPool is creating non-daemon thread by defaultThreadFactory", "label": {"api": {"defaultThreadFactory": [[62, 81]]}}}, {"text": "The reason why I'm using exec(\"taskkill...\") to kill the process on Windows (I'd use killall on Linux) is that that's the only way I found so far, but if it is possible to get a Process instance that represent that process I'd also try using Process.destroy() to see if the \"subprocess\" mentioned in its description \"Kills the subprocess\" is referring to that process", "label": {"api": {"its description": [[300, 314]]}}}, {"text": "The Comparator method compare takes two elements and returns a negative value if x < y, 0 if x equals y or a positive value if x > y", "label": {"api": {"Comparator": [[4, 13]], "compare": [[22, 28]]}}}, {"text": "then you can compare with indices of the elements like this", "label": {"api": {"compare": [[13, 19]]}}}, {"text": "BigDecimal has various methods for doing computations, such as divide()", "label": {"api": {"divide()": [[63, 70]]}}}, {"text": "You can use replaceAll() and the power of regular expressions to simply replace all occurrences of those unwanted characters, like in", "label": {"api": {"replaceAll()": [[12, 23]]}}}, {"text": "This is caused by the fact that readObject() is final", "label": {"api": {"readObject()": [[32, 43]]}}}, {"text": "program against the corresponding interface ObjectInput, not the specific implementation class", "label": {"api": {"ObjectInput": [[44, 54]]}}}, {"text": "If you want to print each element in the stream and then perform other processing peek is an option", "label": {"api": {"peek": [[82, 85]]}}}, {"text": "In this case the intermediate action in peek will be performed before map so each Integer will be printed before further processing", "label": {"api": {"peek": [[40, 43]]}}}, {"text": "Best way I can think of is using Map.forEach method on existing map and Map.computeIfAbsent method on new map", "label": {"api": {"Map.forEach": [[33, 43]], "Map.computeIfAbsent": [[72, 90]]}}}, {"text": "Using groupingBy like in Jacob's answer but with Map.entrySet for better performance, as suggested by Boris", "label": {"api": {"groupingBy": [[6, 15]], "Map.entrySet": [[49, 60]]}}}, {"text": "This uses two more methods of Collectors", "label": {"api": {"Collectors": [[30, 39]]}}}, {"text": "mapping and toList", "label": {"api": {"mapping": [[0, 6]], "toList": [[12, 17]]}}}, {"text": "Or, using toMap instead of groupingBy", "label": {"api": {"groupingBy": [[27, 36]], "toMap": [[10, 14]]}}}, {"text": "Note the bold line, which shows that the constructor for InstanceInner takes an instance of NewInstanceExample, hence why Class.newInstance() throws InstantiationException", "label": {"api": {"Class.newInstance()": [[122, 140]]}}}, {"text": "Since your java interface is not a SAM Functional Interface, so you can't using lambda expression {} in Kotlin directly", "label": {"api": {"Functional Interface": [[39, 58]]}}}, {"text": "From Stream docs", "label": {"api": {"Stream docs": [[5, 15]]}}}, {"text": "Arrays.sort to sort every type of array", "label": {"api": {"Arrays.sort": [[0, 10]]}}}, {"text": "Collections.sort to sort a list", "label": {"api": {"Collections.sort": [[0, 15]]}}}, {"text": "Answers include code that makes use of the deprecated impl_pickNode(double, double)", "label": {"api": {"deprecated": [[43, 52]]}}}, {"text": "But as File.renameTo's JavaDoc suggests, you should better use Files.move", "label": {"api": {"File.renameTo's JavaDoc": [[7, 29]], "Files.move": [[63, 72]]}}}, {"text": "I looked through the RangeSlider docs and the Slider docs, but cannot seem to find a property that suits my needs", "label": {"api": {"Slider docs": [[26, 36], [46, 56]]}}}, {"text": "Your aforementioned class A should implement the Interface AutoClosable then", "label": {"api": {"AutoClosable": [[59, 70]]}}}, {"text": "The result is an ExecutorService that starts with 20 threads ready, maximum number of threads 20 and an unbounded LinkedBlockingQueue for tasks waiting to be processed (you can see it here https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool(int,%20java.util.concurrent.ThreadFactory))", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool(int,%20java.util.concurrent.ThreadFactory)": [[189, 327]]}}}, {"text": "The exception functions identically to RuntimeException, you create a new instance (with an optional message and/or cause) and throw it", "label": {"api": {"RuntimeException": [[39, 54]]}}}, {"text": "If you were throwing and catching RuntimeException instead, your catch block would end up running on NullPointerException or IndexOutOfBoundsException or any other type of RuntimeException", "label": {"api": {"RuntimeException": [[34, 49], [172, 187]]}}}, {"text": "To remove elements from a list while iterating over it, you should use Iterator.remove()", "label": {"api": {"Iterator.remove()": [[71, 87]]}}}, {"text": "It looks like you are requesting index -1, which, if we look at the docs for indexOf", "label": {"api": {"indexOf": [[77, 83]]}}}, {"text": "The Joda-Time project is now in maintenance mode, so it is advised to migrate to the java.time classes", "label": {"api": {"java.time": [[85, 93]]}}}, {"text": "There is a simple and easy solution with java.time for your scenario using DayOfWeek enum as shown in the example below", "label": {"api": {"java.time": [[41, 49]], "DayOfWeek": [[75, 83]]}}}, {"text": "Call DayOfWeek::getDisplayName to generate a string of the day’s name localized in a human language you specify via a Locale object", "label": {"api": {"DayOfWeek": [[5, 13]], "DayOfWeek::getDisplayName": [[5, 29]]}}}, {"text": "It sounds like you want ExecutorService.invokeAll", "label": {"api": {"ExecutorService.invokeAll": [[24, 48]]}}}, {"text": "For instance, instead of Timestamp, you might use LocalDateTime or ZonedDateTime from java.time, e.g.", "label": {"api": {"java.time": [[86, 94]]}}}, {"text": "If the array is too short an ArrayIndexOutOfBoundsException will be thrown", "label": {"api": {"ArrayIndexOutOfBoundsException": [[29, 58]]}}}, {"text": "Here's the javadoc for SimpleDateFormat class", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Combining the examples seen here and here, the print() method in the variation below illustrates using FontMetrics to right justify multiple lines of text in the bottom, right corner of a JDesktopPane", "label": {"api": {"FontMetrics": [[103, 113]]}}}, {"text": "the java UUID represents a 128 bit value - you can't represent that with 16 HEX characters", "label": {"api": {"UUID": [[9, 12]]}}}, {"text": "Finally, you can use insets to insert a little gap between labels and textfields", "label": {"api": {"insets": [[21, 26]]}}}, {"text": "You could use the nextInt(int) method of Java's Random class", "label": {"api": {"nextInt(int) method": [[18, 36]]}}}, {"text": "As very often in these cases, the answer is in the documentation", "label": {"api": {"in the documentation": [[44, 63]]}}}, {"text": "The LocalDate is adjusted by means of the LocalDate.with(TemporalAdjuster) method", "label": {"api": {"LocalDate.with(TemporalAdjuster)": [[42, 73]]}}}, {"text": "I think what you're looking for is a StringReader which is defined as", "label": {"api": {"StringReader": [[37, 48]]}}}, {"text": "Instead of using new Thread you might prefer an ExecutorService", "label": {"api": {"ExecutorService": [[48, 62]]}}}, {"text": "Since it's Java, use Integer.toString()", "label": {"api": {"Integer.toString()": [[21, 38]]}}}, {"text": "Use the ProcessBuilder for this", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "One possible solution is to use a HashMap for your attributes", "label": {"api": {"HashMap": [[34, 40]]}}}, {"text": "If you want to run pdflatex with a particular working directory, use the three-argument version of Runtime.exec", "label": {"api": {"three-argument version": [[73, 94]]}}}, {"text": "I usually call setIconTextGap (int) method to give menu items a better look", "label": {"api": {"setIconTextGap (int)": [[15, 34]]}}}, {"text": "With the retention policy of Source the annotation will not be part of the bytecode", "label": {"api": {"retention policy": [[9, 24]]}}}, {"text": "You can solve your problem through the use of a NavigableMap", "label": {"api": {"NavigableMap": [[48, 59]]}}}, {"text": "You can use NavigableMap#lowerEntry, which", "label": {"api": {"NavigableMap": [[12, 23]]}}}, {"text": "Like I said in my comment, your question is confusing; if all you're trying to do is to notify the opponent when a player makes a move, the simplest implementation is to use a BlockingQueue", "label": {"api": {"BlockingQueue": [[176, 188]]}}}, {"text": "The BlockingQueue would work, but it involves busy wait, so I'm not a big fan of it", "label": {"api": {"BlockingQueue": [[4, 16]]}}}, {"text": "use ProcessBuilder to create process", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Java 8 provides a very nice utility class called CompletableFuture, which can help in your case", "label": {"api": {"utility class called CompletableFuture": [[28, 65]]}}}, {"text": "The class ProccessBuilder might help", "label": {"api": {"ProccessBuilder": [[10, 24]]}}}, {"text": "The Enum StandardOpenOption has 9 enum constants", "label": {"api": {"Enum StandardOpenOption": [[4, 26]]}}}, {"text": "You can find the next largest number representable using the Math.nextUp method", "label": {"api": {"Math.nextUp": [[61, 71]]}}}, {"text": "You can get the size of the jump between a number and its next largest number either by subtraction, or using Math.ulp, which tell you the size of a \"unit in the last place\", the amount the number increases by if you tweak the least significant bit", "label": {"api": {"Math.ulp": [[110, 117]]}}}, {"text": "This is because a Future whether is executed in concurrently or sequentially relies on the ExecutorService", "label": {"api": {"Executor": [[91, 98]]}}}, {"text": "so if you change the Executors.newCachedThreadPool() to Executors.newSingleThreadExecutor(), then the tasks is executed in sequentially rather than concurrently, then the elapsed time is almost the same with the total of wait time", "label": {"api": {"Executor": [[21, 28], [56, 63], [81, 88]]}}}, {"text": "AND you can see it in java.util.concurrent package summary in detailed as further", "label": {"api": {"java.util.concurrent": [[22, 41]]}}}, {"text": "Executor is a simple standardized interface for defining custom thread-like subsystems, including thread pools, asynchronous I/O, and lightweight task frameworks", "label": {"api": {"Executor": [[0, 7]]}}}, {"text": "Depending on which concrete Executor class is being used, tasks may execute in a newly created thread, an existing task-execution thread, or the thread calling execute, and may execute sequentially or concurrently", "label": {"api": {"Executor": [[28, 35]]}}}, {"text": "According to JavaDocs for both Future#cancel and ExecutorService#shutdownNow, the typical implementation is that these methods result in interrupting the underlying thread", "label": {"api": {"Future#cancel": [[31, 43]], "ExecutorService#shutdownNow": [[49, 75]]}}}, {"text": "Thread interruption via the Thread#interrupt method is a cooperative process", "label": {"api": {"Thread#interrupt": [[28, 43]]}}}, {"text": "Also, if the target thread is blocked in certain specific methods, then that thread will experience an InterruptedException", "label": {"api": {"InterruptedException": [[103, 122]]}}}, {"text": "If the code executing in the target thread neither checks for interrupted status periodically via the Thread#isInterrupted method nor calls a blocking method and handles InterruptedException, then interruption effectively does nothing", "label": {"api": {"InterruptedException": [[170, 189]], "Thread#isInterrupted": [[102, 121]]}}}, {"text": "In your example, a viable technique would be to change sum to check Thread#isInterrupted every N iterations of the for loop, and if interrupted, abort the loop", "label": {"api": {"Thread#isInterrupted": [[68, 87]]}}}, {"text": "You could potentially use daemon threads so that at least these threads won't block JVM exit during shutdown", "label": {"api": {"daemon threads": [[26, 39]]}}}, {"text": "Your query selects a single attribute, name, so the relevant columnIndex passed to getString() should be 1", "label": {"api": {"getString()": [[83, 93]]}}}, {"text": "As noted here, you can also use the columnLabel; a complete example is shown here; this related example uses JPA", "label": {"api": {"columnLabel": [[36, 46]]}}}, {"text": "In your code sample, you are using Iterable#forEach to iterate through the queues", "label": {"api": {"Iterable#forEach": [[35, 50]]}}}, {"text": "forEach ultimately delegates into Iterable#iterator", "label": {"api": {"Iterable#iterator": [[34, 50]]}}}, {"text": "However, it's important to note that the subclass override in PriorityQueue#iterator has different JavaDocs with a special note about ordering", "label": {"api": {"PriorityQueue#iterator": [[62, 83]]}}}, {"text": "If instead you changed your code to drain the queue by repeatedly calling PriorityQueue#poll, then I expect you'd see results ordered according to your custom Comparator", "label": {"api": {"PriorityQueue#poll": [[74, 91]]}}}, {"text": "One approach would be to add an InvalidationListener to the stateProperty of the Task", "label": {"api": {"Task": [[81, 84]]}}}, {"text": "Just declare and initialize a JFX Panel", "label": {"api": {"JFX Panel": [[30, 38]]}}}, {"text": "You can try to add a Principal object as a method parameter", "label": {"api": {"Principal": [[21, 29]]}}}, {"text": "If you want to read a little bit more about this check the documentation out here and read that introductory information", "label": {"api": {"check the documentation out here": [[49, 80]]}}}, {"text": "Use BigInteger for multiplications", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "You are just missing the last argument to the method, here's the javadoc and this is what it says aout the arguments", "label": {"api": {"here's": [[54, 59]]}}}, {"text": "Another idea would be to use an explicit thread pool for handling requests so that there is a guaranteed limit on the number of clients being handled at any given time", "label": {"api": {"thread pool": [[41, 51]]}}}, {"text": "In java, Method Reference Expression can assign to any compatible Functional Interface, but you can't assign a Function Reference Expression to any Function types even if they are compatible, for example", "label": {"api": {"Functional Interface": [[66, 85]]}}}, {"text": "Indeed, Kotlin using SAM Conversions to convert lambda/Function Reference Expression into an implementation of Java Functional Interface, which means Kotlin does something like as below", "label": {"api": {"Functional Interface": [[116, 135]]}}}, {"text": "As I said Kotlin using SAM Conversions to convert a lambda/Function Reference Expression to a Java Functional Interface, but it can't assign to a Java Functional Interface directly", "label": {"api": {"Functional Interface": [[99, 118], [151, 170]]}}}, {"text": "because ObservableSource is also a Java Functional Interface", "label": {"api": {"Functional Interface": [[40, 59]]}}}, {"text": "you can replace string by regex using String#replaceAll, for example", "label": {"api": {"String#replaceAll": [[38, 54]]}}}, {"text": "Java provides a built-in way of doing an intersection through retainAll operation", "label": {"api": {"retainAll": [[62, 70]]}}}, {"text": "I came across problem of memory leak in Swing Application due to Swing Timer", "label": {"api": {"Swing Timer": [[65, 75]]}}}, {"text": "I came to know that stopping the Timer allows it to be garbage collected", "label": {"api": {"stopping": [[20, 27]]}}}, {"text": "When you study the javadoc for Double.toString() you will find that it mentions the static method Double.toString(double)", "label": {"api": {"Double.toString(double)": [[98, 120]]}}}, {"text": "Here is the documentation for the next() method of Scanner", "label": {"api": {"Here is the documentation": [[0, 24]]}}}, {"text": "Use CharSequence.codePoints(), which returns a stream of the codepoints, rather than having to deal with chars", "label": {"api": {"CharSequence.codePoints()": [[4, 28]]}}}, {"text": "When looking at the documentation for Integer we see that it is very specific about the type of String that can be fed to parseInt()", "label": {"api": {"When looking at the documentation for Integer": [[0, 44]]}}}, {"text": "For an example of this, see AbstractAction which has many subclasses", "label": {"api": {"AbstractAction": [[28, 41]]}}}, {"text": "you have lost set the TimeZone in SimpleDateFormat, for example", "label": {"api": {"SimpleDateFormat": [[34, 49]]}}}, {"text": "Read the certficate as a X509Certificate.html, and than you can call getPublicKey", "label": {"api": {"X509Certificate.html": [[25, 44]]}}}, {"text": "You need to return an implementation of the interface Iterator in your implementation of the iterator method", "label": {"api": {"Iterator": [[54, 61]]}}}, {"text": "Create an inner class that implements your ExpIterator", "label": {"api": {"Iterator": [[46, 53]]}}}, {"text": "If you want to react to changes you will need to attach a listener to the corresponding property", "label": {"api": {"property": [[88, 95]]}}}, {"text": "It seems really weird that java focus so much on \"modeling the mathematical set abstraction\", while std::set::find and std::unordered_set::find in C++ can fetch element in set in O(log n) and Log(1)(average) respectively", "label": {"api": {"\"modeling the mathematical set abstraction\"": [[49, 91]]}}}, {"text": "Create and install a custom java.util.logging.Filter to detect the infinite loop and have it either stop the messages, stop the loop, or stop the system", "label": {"api": {"java.util.logging.Filter": [[28, 51]]}}}, {"text": "From InputStream's javadoc", "label": {"api": {"InputStream's javadoc": [[5, 25]]}}}, {"text": "Once it is installed, then execute your java program/class", "label": {"api": {"exec": [[27, 30]]}}}, {"text": "When you have to execute the command with arguments, please use this exec Api rather than exec Api", "label": {"api": {"exec": [[17, 20], [69, 72], [90, 93]]}}}, {"text": "You can find more information about stateless behaviors and Side-effects within the JAVA Stream API", "label": {"api": {"JAVA Stream API": [[84, 98]]}}}, {"text": "Finally, you need to change the date format to \"MMM dd, yyyy\"", "label": {"api": {"date format": [[32, 42]]}}}, {"text": "If you need to remove a comma (or any other char for that matter) in your String array indices the simplest is to iterate through the array and use String.replace()", "label": {"api": {"String.replace()": [[148, 163]]}}}, {"text": "You could override equals (if you are pretty good with one rule) or you can do it more flexible creating special Comparators for your object", "label": {"api": {"Comparator": [[113, 122]]}}}, {"text": "You can use either ISO_ZONED_DATE_TIME or ISO_DATE_TIME", "label": {"api": {"ISO_ZONED_DATE_TIME": [[19, 37]], "ISO_DATE_TIME": [[42, 54]]}}}, {"text": "The String you are trying to parse is in the standard ISO_ZONED_DATE_TIME format", "label": {"api": {"ISO_ZONED_DATE_TIME": [[54, 72]]}}}, {"text": "You also want to study the available patterns in detail", "label": {"api": {"patterns": [[37, 44]]}}}, {"text": "As your actual data contains ISO 8601 dates, ZonedDateTime.parse() can be used directly; use setDateFormatOverride() to format the date axis labels; the example below specifies a UTC time zone in ISO 8601 format for easy comparison; comment out the call to setDateFormatOverride() to see the times in your local time zone", "label": {"api": {"ZonedDateTime.parse()": [[45, 65]]}}}, {"text": "On Tomcat configure RemoteIpValve to have request.secure and other request variable interpreted from those headers", "label": {"api": {"request.secure": [[42, 55]]}}}, {"text": "Reading from and Writing to a URLConnection", "label": {"api": {"URLConnection": [[30, 42]]}}}, {"text": "you can using Collection#removeIf instead, for example", "label": {"api": {"Collection#removeIf": [[14, 32]]}}}, {"text": "For the mutable operation in Kotlin, please using  MutableCollection#removeIf / MutableCollection#removeAll instead, for example", "label": {"api": {" MutableCollection#removeIf": [[50, 76]]}}}, {"text": "To solve that, this StackOverflow answer suggests using ThreadLocalRandom.nextDouble(min, max)", "label": {"api": {"ThreadLocalRandom.nextDouble(min, max)": [[56, 93]]}}}, {"text": "If you want to find sequences of characters from the MALAYALAM Script, you can use the regex \\p{IsMalayalam}", "label": {"api": {"MALAYALAM Script": [[53, 68]], "\\p{IsMalayalam}": [[93, 107]]}}}, {"text": "You could also choose the look for characters in the MALAYALAM Block, using regex \\p{InMalayalam}", "label": {"api": {"MALAYALAM Block": [[53, 67]], "\\p{InMalayalam}": [[82, 96]]}}}, {"text": "Quoting the JavaDocs for IllegalAccessError", "label": {"api": {"IllegalAccessError": [[25, 42]]}}}, {"text": "Just use a normal Iterator for this", "label": {"api": {"Iterator": [[18, 25]]}}}, {"text": "This could allow you to instantiate T, by using the Class#newInstance() method", "label": {"api": {"Class#newInstance()": [[52, 70]]}}}, {"text": "Merge your Date and Time objects into a java.util.Date, then use your String as the key in a HashMap", "label": {"api": {"java.util.Date": [[40, 53]]}}}, {"text": "Instead of static int count, use an AtomicInteger", "label": {"api": {"AtomicInteger": [[36, 48]]}}}, {"text": "This uses Map.merge method, which expects the key and the value, along with a merge function that merges the old value with the new value if the key was already present in the map", "label": {"api": {"Map.merge": [[10, 18]]}}}, {"text": "This method reference acts like a BiFunction<Integer, Integer, Integer>, i.e", "label": {"api": {"BiFunction<Integer, Integer, Integer>": [[34, 70]]}}}, {"text": "The built-in method for Java EE uses JsonObject", "label": {"api": {"JsonObject": [[37, 46]]}}}, {"text": "You can, nonetheless, use streams and Collectors.toMap to get the result you want", "label": {"api": {"Collectors.toMap": [[38, 53]]}}}, {"text": "In case you have more than one element in your list with the same status, you should use the overloaded version of Collectors.toMap that expects a merge function", "label": {"api": {"Collectors.toMap": [[115, 130]], "Collectors.toMap that expects a merge function": [[115, 160]]}}}, {"text": "Here Long::sum is a BinaryOperator<Long> that merges two values that are mapped to the same key", "label": {"api": {"BinaryOperator<Long>": [[20, 39]]}}}, {"text": "Collections class have a utility method for this", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "When executing Integer.parseInt() on an empty string it throws an NumberFormatException", "label": {"api": {"throws an NumberFormatException": [[56, 86]]}}}, {"text": "ThreadMXBean is an MXBean", "label": {"api": {"ThreadMXBean": [[0, 11]]}}}, {"text": "Your code has called JMX#newMBeanProxy", "label": {"api": {"JMX#newMBeanProxy": [[21, 37]]}}}, {"text": "Instead, use JMX#newMXBeanFactory to obtain a proxy capable of handling the properties of MXBeans", "label": {"api": {"JMX#newMXBeanFactory": [[13, 32]]}}}, {"text": "You could just use the String#trim method (Java-Doc of String#trim) on each element which cuts all whitespace character at the beginning and end of a String", "label": {"api": {"Java-Doc of String#trim": [[43, 65]]}}}, {"text": "To ensure that the graphical view is updated on the JavaFX application thread, Platform.runLater is used to run the view update on the JavaFX application thread when a machine state change notification event is received", "label": {"api": {"Platform.runLater": [[79, 95]]}}}, {"text": "I need to cast an Object of type JsonValue to either JsonObject or JsonArray so I can call the methods getJsonObject and getJsonArray of it", "label": {"api": {"JsonObject": [[53, 62], [106, 115]], "JsonArray": [[67, 75], [124, 132]]}}}, {"text": "Both JsonArray and JsonObject have the same method names with the same functionalities but they're not implemented methods, they are methods defined on each of them", "label": {"api": {"JsonObject": [[19, 28]], "JsonArray": [[5, 13]]}}}, {"text": "1) If both JsonObject and JsonArray have the same methods, why they're not implementations of some interface", "label": {"api": {"JsonObject": [[11, 20]], "JsonArray": [[26, 34]]}}}, {"text": "2) Is there a more elegant way to cast the object to JsonObject or JsonArray at the same time by using some trick", "label": {"api": {"JsonObject": [[53, 62]], "JsonArray": [[67, 75]]}}}, {"text": "JsonObject#getJsonObject(String) accepts a String key identifying the value to pull from a JSON object of key-value pairs", "label": {"api": {"JsonObject#getJsonObject(String)": [[0, 31]]}}}, {"text": "JsonArray#getJsonObject(int) accepts an int index identifying which element to pull the value from in a JSON array", "label": {"api": {"JsonArray#getJsonObject(int)": [[0, 27]]}}}, {"text": "Alternatively, use a ScheduledExecutionService, which may offer better accuracy/reliability over long time ranges than a normal Timer", "label": {"api": {"ScheduledExecutionService": [[21, 45]]}}}, {"text": "You need to use flatMap instead of map", "label": {"api": {"flatMap": [[16, 22]]}}}, {"text": "List.sublist returns a view of part of the list, thus you cannot modify the original list", "label": {"api": {"List.sublist": [[0, 11]]}}}, {"text": "If you were using List<String[]> you can use Arrays.asList(), to check if the String[] contains your string with .contains() method", "label": {"api": {"Arrays.asList()": [[45, 59]]}}}, {"text": "You might better off using Java's Color library to parse the image's RGB components", "label": {"api": {"Color": [[34, 38]]}}}, {"text": "ExecutorService.shutdown() does not immediately kill all running tasks and stop all threads", "label": {"api": {"ExecutorService.shutdown()": [[0, 25]]}}}, {"text": "You can call awaitTermination(...) to wait for the currently running tasks to finish, or shutdownNow() which does indeed attempt to kill all currently running tasks", "label": {"api": {"awaitTermination(...)": [[13, 33]], "shutdownNow()": [[89, 101]]}}}, {"text": "All enum types implicitly extend java.lang.Enum which already implements Serializable", "label": {"api": {"java.lang.Enum": [[33, 46]]}}}, {"text": "If you use a shared ReadWriteLock and use read locks for the regular operations, you can have your privileged operations use write locks to block the regular operations", "label": {"api": {"ReadWriteLock": [[20, 32]]}}}, {"text": "The iterator then notifies that the lists state changed and hence throws a ConcurrentModificationException because it is not capable of keeping track of the changes and guaranteeing that the iteration happens in an orderly fashion", "label": {"api": {"ConcurrentModificationException": [[75, 105]]}}}, {"text": "To enable this, we need to use the fixed length streaming mode (or other similar means)", "label": {"api": {"the fixed length streaming mode": [[31, 61]]}}}, {"text": "Calling Thread.start does not make any guarantees about the order of the starting", "label": {"api": {"Thread.start": [[8, 19]]}}}, {"text": "The call of notifyAll from the calculator then happens before the third reader executes its wait call", "label": {"api": {"notify": [[12, 17]], "notifyAll": [[12, 20]]}}}, {"text": "Hence the third reader is damned to wait forever as not other call of notify or notifyAll will occur on the lock object", "label": {"api": {"notify": [[70, 75], [80, 85]], "notifyAll": [[80, 88]]}}}, {"text": "One possible solution to your problem is to use a CountDownLatch which allows you to let the calculator wait until all three readers are ready", "label": {"api": {"CountDownLatch": [[50, 63]]}}}, {"text": "The Javadocs for Color explain that the Java Color class contains an alpha channel as well as RGB--so a color that started with all zeroes would be completely transparent", "label": {"api": {"The Javadocs for Color": [[0, 21]]}}}, {"text": "You can translate() the origin of the graphics context so that it appears at the coordinates you specify", "label": {"api": {"translate()": [[8, 18]]}}}, {"text": "Subsequent calls to drawString(…, 0, 0) will render text with the baseline at those coordinates", "label": {"api": {"baseline": [[66, 73]]}}}, {"text": "Use FontMetrics to determine what coordinates to use", "label": {"api": {"FontMetrics": [[4, 14]]}}}, {"text": "Examples shown here and here pass the coordinates to drawString(), but you can  pass them to translate() instead", "label": {"api": {"translate()": [[93, 103]]}}}, {"text": "You should call get() in done()", "label": {"api": {"get()": [[16, 20]]}}}, {"text": "If doInBackground throws an exception, then get() will throw an ExecutionException whose cause is the exception from doInBackground", "label": {"api": {"get()": [[44, 48]]}}}, {"text": "Since bytesRead is the return value of InputStream.read(), it's actually a byte of data, not the number of bytes read", "label": {"api": {"InputStream.read()": [[39, 56]]}}}, {"text": "This ends up passing a value which is greater than 100 to setProgress which throws an exception", "label": {"api": {"setProgress": [[58, 68]]}}}, {"text": "If you want to modify the bytes while they're in transit, your best bet would be to go with FileChannel and work with ByteBuffers", "label": {"api": {"FileChannel": [[92, 102]]}}}, {"text": "The Stream#max function", "label": {"api": {"Stream#max": [[4, 13]]}}}, {"text": "Returns the maximum element of this stream according to the provided Comparator", "label": {"api": {"Comparator": [[69, 78]]}}}, {"text": "As Comparator is a functional interface with only compare(T o1, T o2) to implement, it may be represented with a lambda", "label": {"api": {"Comparator": [[3, 12]]}}}, {"text": "Use CallableStatement and register the OUT parameter", "label": {"api": {"CallableStatement": [[4, 20]]}}}, {"text": "In order to us prevent the same char being added to the list twice we must only add it to the list if the list does not contain it already, using list.contains()", "label": {"api": {"list.contains()": [[146, 160]]}}}, {"text": "According to the Java API docs, the next() method throws a NoSuchElementException when there aren't any more tokens available to be read", "label": {"api": {"Java API docs": [[17, 29]]}}}, {"text": "Swing is not thread safe", "label": {"api": {"not thread safe": [[9, 23]]}}}, {"text": "In general Swing is not thread safe", "label": {"api": {"not thread safe": [[20, 34]]}}}, {"text": "Apache Hadoop uses the FSDataOutputStream class to layer additional functionality over a JDK DataOutputStream", "label": {"api": {"DataOutputStream": [[25, 40], [93, 108]]}}}, {"text": "If the extra functionality of FSDataOutputStream is not needed, then there is no need to refer to it", "label": {"api": {"DataOutputStream": [[32, 47]]}}}, {"text": "You can use the File class from the Java API", "label": {"api": {"the Java API": [[32, 43]]}}}, {"text": "You want the URLEncode.encode(String s, String enc) method", "label": {"api": {"URLEncode.encode(String s, String enc)": [[13, 50]]}}}, {"text": "The method writeByte take a single int, not a DataBufferByte as parameter", "label": {"api": {"writeByte": [[11, 19]]}}}, {"text": "You need to extract the bytes array of the DataBufferByte and you can use the method write(byte\\[\\] b, int off, int len) to write them", "label": {"api": {"write(byte\\[\\] b, int off, int len)": [[85, 119]]}}}, {"text": "The easiest way to do this is to use Java's TimeUnit", "label": {"api": {"TimeUnit": [[44, 51]]}}}, {"text": "Java 8 has an easy way of doing it with the help of Stream API shown in the code below", "label": {"api": {"Stream API": [[52, 61]]}}}, {"text": "How about List::sublist", "label": {"api": {"sublist": [[16, 22]]}}}, {"text": "BufferedReader readLine() returns String, therefore you cannot add a String to a list of Animal", "label": {"api": {"BufferedReader readLine()": [[0, 24]]}}}, {"text": "The iterator is weakly consistent", "label": {"api": {"weakly consistent": [[16, 32]]}}}, {"text": "You can use Java's SimpleDateFormat to format the date accordingly", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "Take a look at java.util.regex.Matcher class, specially at the method appendReplacement", "label": {"api": {"java.util.regex.Matcher": [[15, 37]]}}}, {"text": "Instead of CompletableFuture.supplyAsync(() -> SITE_THREEs), you should use CompletableFuture.completedFuture(SITE_THREEs) which returns a future that has already been completed with the result, hence, not requiring additional actions", "label": {"api": {"CompletableFuture.completedFuture(SITE_THREEs)": [[76, 121]]}}}, {"text": "For int the box class is Integer", "label": {"api": {"Integer": [[25, 31]]}}}, {"text": "If the types involved are Integer", "label": {"api": {"Integer": [[26, 32]]}}}, {"text": "How to properly compare two Integers in Java", "label": {"api": {"Integer": [[28, 34]]}}}, {"text": "John Skeet's answer talks a little bit about the most efficient way to compare two Integers", "label": {"api": {"Integer": [[83, 89]]}}}, {"text": "is about calling Integer.valueOf(int) - the method that turns the int value 3 into an Integer object", "label": {"api": {"method": [[44, 49]]}}}, {"text": "If you look at the documentation of CertificateFactory#generateCertificate it says", "label": {"api": {"CertificateFactory#generateCertificate": [[36, 73]]}}}, {"text": "One way to do it would be by using Arrays.parallelSetAll", "label": {"api": {"Arrays.parallelSetAll": [[35, 55]]}}}, {"text": "I'm not 100% sure, but I think the inner call to Arrays.parallelSetAll might not be worth the overhead of generating inner parallelization for each row's columns", "label": {"api": {"Arrays.parallelSetAll": [[49, 69]]}}}, {"text": "This method will returns the time in milliseconds (long value, from epoch time), you may to format it with SimpleDateFormat to make it a human readable format", "label": {"api": {"SimpleDateFormat": [[107, 122]]}}}, {"text": "The only hack I see would be making an SSL connection, and return a new Socket bound to the secondary IP from a custom SSLSocketFactory", "label": {"api": {"SSLSocketFactory": [[119, 134]]}}}, {"text": "Only leading + or - signs are allowed as per Integer.parseInt() documentation", "label": {"api": {"Integer.parseInt() documentation": [[45, 76]]}}}, {"text": "A common way to do this is to pass the target class object (or an object of the target class) as an argument to the function, then use methods from the class object to do the tricky part", "label": {"api": {"class object": [[46, 57], [152, 163]]}}}, {"text": "For enum classes, the class object has a method which returns the equivalent of Enum.values()", "label": {"api": {"class object": [[22, 33]], "a method which returns the equivalent of Enum.values()": [[39, 92]]}}}, {"text": "Jetty is required to scan all JAR files for possible servlet annotations or references that match your webapp defined @HandlesTypes", "label": {"api": {"@HandlesTypes": [[118, 130]]}}}, {"text": "Each time you add items to the list, use List.contains() for checking whether an equal object is already in the list", "label": {"api": {"List.contains()": [[41, 55]]}}}, {"text": "Event is the superclass of all event types", "label": {"api": {"Event": [[0, 4]]}}}, {"text": "KeyEvents which are generated when a key is pressed", "label": {"api": {"Event": [[3, 7]], "KeyEvents": [[0, 8]]}}}, {"text": "MouseEvents that are generated by a mouse interaction like a move or button click", "label": {"api": {"Event": [[5, 9]], "MouseEvents": [[0, 10]]}}}, {"text": "Events don't have to only be generated by the JavaFX system", "label": {"api": {"Event": [[0, 4]]}}}, {"text": "An ActionEvent is a kind of event which often makes it easier to code to and respond to something being activated", "label": {"api": {"Event": [[9, 13]], "ActionEvent": [[3, 13]]}}}, {"text": "For example, if you click on a button with a mouse you could get MOUSE_PRESSED, MOUSE_RELEASED and MOUSE_CLICKED events in addition to an ActionEvent", "label": {"api": {"Event": [[144, 148]], "ActionEvent": [[138, 148]], "MOUSE_PRESSED": [[65, 77]], "MOUSE_RELEASED": [[80, 93]], "MOUSE_CLICKED": [[99, 111]]}}}, {"text": "If you wanted to respond to the button activation, you could listen for a MOUSE_CLICKED event, however that would not be recommended", "label": {"api": {"MOUSE_CLICKED": [[74, 86]]}}}, {"text": "JavaFX provides the ActionEvent which will be emitted whenever the button is activated, regardless of the method that was used to activate it", "label": {"api": {"Event": [[26, 30]], "ActionEvent": [[20, 30]]}}}, {"text": "An ActionEvent is also used in many places where it didn't seem worthwhile or necessary to create a specific type of event, for example in an animation KeyFrame when the key frame is activated", "label": {"api": {"Event": [[9, 13]], "ActionEvent": [[3, 13]]}}}, {"text": "So ActionEvents aren't just used to handle button events, but may be used in many places", "label": {"api": {"Event": [[9, 13]], "ActionEvent": [[3, 13]]}}}, {"text": "Use a SubScene to contain your 3D shape", "label": {"api": {"SubScene": [[6, 13]]}}}, {"text": "The SubScene class is the container for content in a scene graph", "label": {"api": {"SubScene": [[4, 11]]}}}, {"text": "SubScene provides separation of different parts of a scene, each of which can be rendered with a different camera, depth buffer, or scene anti-aliasing", "label": {"api": {"SubScene": [[0, 7]]}}}, {"text": "A SubScene is embedded into the main scene or another sub-scene", "label": {"api": {"SubScene": [[2, 9]]}}}, {"text": "You can set a camera on the sub scene separate from any camera applied on the root scene", "label": {"api": {"set a camera": [[8, 19]]}}}, {"text": "An example of SubScene use is provided in the answer to", "label": {"api": {"SubScene": [[14, 21]]}}}, {"text": "The Matcher object has extra methods for you to get more", "label": {"api": {"Matcher": [[4, 10]]}}}, {"text": "If you really have this need, then you might be interested in ServerSocket#setReuseAddress(boolean)", "label": {"api": {"ServerSocket#setReuseAddress(boolean)": [[62, 98]]}}}, {"text": "javafx.scene.input.KeyEvent is not java.awt.event.KeyEvent", "label": {"api": {"javafx.scene.input.KeyEvent": [[0, 26]], "java.awt.event.KeyEvent": [[35, 57]]}}}, {"text": "Catching Errors is generally bad, as, according to the java api , it represents serious problems that a reasonable application should not be able to catch", "label": {"api": {"java api": [[55, 62]]}}}, {"text": "In fact, this is a common enough pattern that the JDK even has a requireNonNull helper for it", "label": {"api": {"requireNonNull": [[65, 78]]}}}, {"text": "According to the ConcurrentMap Javadoc", "label": {"api": {"ConcurrentMap Javadoc": [[17, 37]]}}}, {"text": "The Oracle-description details this sampe; but I cannot see there where the ENUMs \"PENNY\", \"NICKEL\" etc come from in this example", "label": {"api": {"Oracle-description": [[4, 21]]}}}, {"text": "StringBuilder is a class which you can pass as any other Object", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "StringBuilder#substring returns a String which is a substring, leaving sb as it was", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "Basically, StringBuilder holds characters and lets you easily manipulate them", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "Since Java 8, it makes no sense to use it for concatenation as String + String is automatically changed to StringBuilder by Java", "label": {"api": {"StringBuilder": [[107, 119]]}}}, {"text": "A short version can be seen in the documentation of java.util.concurrent", "label": {"api": {"in the documentation of java.util.concurrent": [[28, 71]]}}}, {"text": "For further information, see the tutorial page on the JComboBox and the javadoc on the ListCellRenderer interface (which contains a helpful simple example that)", "label": {"api": {"the javadoc on the ListCellRenderer interface": [[68, 112]]}}}, {"text": "I ran into a very similar problem, and I was able to use a Map to hold the values", "label": {"api": {"Map": [[59, 61]]}}}, {"text": "If order matters, then you'll want to use a TreeMap", "label": {"api": {"Map": [[48, 50]], "TreeMap": [[44, 50]]}}}, {"text": "I mention the Maps, because you mention you want to manipulate (what sounds like the rows in a table), rather than the columns", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "If you use a TreeMap, then the keys stay in the same order, and the value for each key will be like the rows in the table", "label": {"api": {"Map": [[17, 19]], "TreeMap": [[13, 19]]}}}, {"text": "Without a solid example of your data, I'm not able to really go into how to compare the \"combinations\", which I assume can be handled by the Lists in the values of the Map, in this situation", "label": {"api": {"Map": [[168, 170]]}}}, {"text": "Secondly, look at the signature for map()", "label": {"api": {"map()": [[36, 40]]}}}, {"text": "You should be able to work around the problem by converting the LocalDateTime into a java.sql.Timestamp using Timestamp.valueOf()", "label": {"api": {"Timestamp.valueOf()": [[110, 128]]}}}, {"text": "From Java 8, you can use Optional as a return for unsure answer", "label": {"api": {"Optional": [[25, 32]]}}}, {"text": "As mentioned in the comments, by default the output of the subprocess is sent to a pipe which can be read using Process.getInputStream()", "label": {"api": {"Process.getInputStream()": [[112, 135]]}}}, {"text": "The easiest solution is to call .inheritIO() on the ProcessBuilder", "label": {"api": {".inheritIO()": [[32, 43]]}}}, {"text": "You should create a Comparator that applies to your class BonusEntity and use it via the Collections.sort method", "label": {"api": {"Comparator": [[20, 29]], "Collections.sort method": [[89, 111]]}}}, {"text": "I have tried both myself, and I found no difference in functionality and the official Documentation didn't really help me either", "label": {"api": {"official Documentation": [[77, 98]]}}}, {"text": "When you implement a Map by extending AbstractMap, the entrySet() is the only method you need to implement, all other map methods are already implemented via delegation to the entry set", "label": {"api": {"AbstractMap": [[38, 48]]}}}, {"text": "See the API documentation of getTables(...) for more detailed usage information", "label": {"api": {"getTables(...)": [[29, 42]]}}}, {"text": "Try to use Group", "label": {"api": {"Group": [[11, 15]]}}}, {"text": "Normally, ResultSetMetaData#getColumnType() should return 93 for DATETIME fields (usually represented as java.sql.Timestamp)", "label": {"api": {"ResultSetMetaData#getColumnType()": [[10, 42]], "93": [[58, 59]]}}}, {"text": "A problem arises when I attempt to type into the terminal (to process user input requests via Scanner) and any logging occurs", "label": {"api": {"Scanner": [[94, 100]]}}}, {"text": "However, the first thing you need for this solution is a Principal", "label": {"api": {"Principal": [[57, 65]]}}}, {"text": "For this purpose you can register a Document Listener on your textfield's document", "label": {"api": {"Document Listener": [[36, 52]]}}}, {"text": "Note that a List is just an interface, there are also multiple implementations like ArrayList, LinkedList and others", "label": {"api": {"LinkedList": [[95, 104]]}}}, {"text": "My current Geckodriver (Firefox family) and Chromedriver (Chrome family) return a LinkedList when used with By.tagName for example", "label": {"api": {"LinkedList": [[82, 91]]}}}, {"text": "However, as said, other implementations can return other List objects and there is no guarantee that gecko- and chromedriver will also always return a LinkedList in the future, they could change that as the interface only require a List", "label": {"api": {"LinkedList": [[151, 160]]}}}, {"text": "For the more details, you can see LambdaMetafactory as further", "label": {"api": {"LambdaMetafactory": [[34, 50]]}}}, {"text": "As the javadoc says", "label": {"api": {"javadoc says": [[7, 18]]}}}, {"text": "You're looking for the contains method", "label": {"api": {"contains": [[23, 30]]}}}, {"text": "As stated in the Java-Doc", "label": {"api": {"Java-Doc": [[17, 24]]}}}, {"text": "Don't use the old Date class, instead use the new java.time API's LocalDate", "label": {"api": {"java.time API": [[50, 62]], "LocalDate": [[66, 74]]}}}, {"text": "Try using URLClassLoader that does the job for you", "label": {"api": {"URLClassLoader": [[10, 23]]}}}, {"text": "You can later find META-INF/manifest.mf with findResource(...) method, read it, figure out main class, find it and call its main(...) method, doing exactly the same thing as you would be doing with java -jar ..", "label": {"api": {"findResource(...)": [[45, 61]], "find it": [[103, 109]]}}}, {"text": "I think you misunderstand the enhanced for loop syntax", "label": {"api": {"enhanced for loop": [[30, 46]]}}}, {"text": "Instances of classes that implement the LineListener interface can register to receive events when a line's status changes", "label": {"api": {"LineListener": [[40, 51]]}}}, {"text": "You can use isSelected method", "label": {"api": {"isSelected": [[12, 21]]}}}, {"text": "You can always use String.split() to split the String based on the delimiter, in this case /, and then String.trim() the output and parse them to get the numerator and the denominator", "label": {"api": {"String.split()": [[19, 32]], "String.trim()": [[103, 115]]}}}, {"text": "The second and optional argument is the buffer size, an integer", "label": {"api": {"second and optional argument": [[4, 31]]}}}, {"text": "One of options could be creating your own NumberFormat (here based on DecimalFormat)", "label": {"api": {"NumberFormat": [[42, 53]], "DecimalFormat": [[70, 82]]}}}, {"text": "You can use DecimalFormatSymbols to set its decimal separator or grouping separator symbols", "label": {"api": {"DecimalFormat": [[12, 24]], "DecimalFormatSymbols": [[12, 31]]}}}, {"text": "As of Java 6, there is an http server in the JDK that you can use", "label": {"api": {"http server": [[26, 36]]}}}, {"text": "As the doc says TableRowSorter only cares about the view and not the model of the table", "label": {"api": {"the doc says": [[3, 14]]}}}, {"text": "java.util.Calendar#add is a void method,of course print nothing", "label": {"api": {"java.util.Calendar#add is a void method": [[0, 38]]}}}, {"text": "Check the DateTimeFormatter javadoc for more information about date patterns", "label": {"api": {"DateTimeFormatter javadoc": [[10, 34]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "The TimeUnit.sleep(long timeout) documentation describes its argument thus", "label": {"api": {"TimeUnit.sleep(long timeout)": [[4, 31]]}}}, {"text": "I'd be curious to know if you could improve on this by using lambdas and the new java.util.function package", "label": {"api": {"java.util.function": [[81, 98]]}}}, {"text": "Open ZipInputStream on current Jar file", "label": {"api": {"ZipInputStream": [[5, 18]]}}}, {"text": "Open ZipOutputStream on new (temporary) Jar file", "label": {"api": {"ZipOutputStream": [[5, 19]]}}}, {"text": "Open ZipOutputStream on new (temporary) Jar file", "label": {"api": {"ZipOutputStream": [[5, 19]]}}}, {"text": "Open ZipInputStream on current Jar file", "label": {"api": {"ZipInputStream": [[5, 18]]}}}, {"text": "Parse the string into a BitSet, before entering your loops, i.e", "label": {"api": {"BitSet": [[24, 29]]}}}, {"text": "Then use methods or(BitSet set), and cardinality()", "label": {"api": {"BitSet": [[20, 25]], "or(BitSet set)": [[17, 30]], "cardinality()": [[37, 49]]}}}, {"text": "(looking at Classpath and Package does not seems achievable)", "label": {"api": {"Package": [[26, 32]]}}}, {"text": "ArrayList is the closest to an array", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Your function, changed to use an ArrayList, might look like this", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "scheduleAtFixedRate() returns a ScheduledFuture which is a Future which has the cancel method you're looking for", "label": {"api": {"ScheduledFuture": [[32, 46]], "Future": [[41, 46], [59, 64]]}}}, {"text": "One approach is to make your own \"safe\" wrapper around BufferedWriter (for that matter, any kind of Writer) and handle I/O errors there", "label": {"api": {"Writer": [[63, 68], [100, 105]]}}}, {"text": "Apparently according to the API Doc", "label": {"api": {"API Doc": [[28, 34]]}}}, {"text": "Here's the Javadoc", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Once your loop finished, you can use System.arraycopy() (or your own loop, if that's forbidden) to copy all values from the longest sequence into a new array", "label": {"api": {"System.arraycopy()": [[37, 54]]}}}, {"text": "You can open a new window on the close event by using a WindowListener or WindowAdapter", "label": {"api": {"WindowListener": [[56, 69]], "WindowAdapter": [[74, 86]]}}}, {"text": "I would use the PriorityQueue, with the minimum value at the root", "label": {"api": {"PriorityQueue": [[16, 28]]}}}, {"text": "Just use orElseThrow(), which throws an exception if the Optional is empty", "label": {"api": {"orElseThrow()": [[9, 21]]}}}, {"text": "There exist various implementations on GitHub, but I want to use a MessageDigest implementation, as I am interested in how to \"translate\" a hashing algorithm in this way and it would offer the possibility to use a DigestInputStream to calculate hashes \"on the fly\" while downloading", "label": {"api": {"MessageDigest": [[67, 79]], "DigestInputStream": [[214, 230]]}}}, {"text": "You don't need to use regex, you can use String.endsWith and String.substring", "label": {"api": {"String.endsWith": [[41, 55]], "String.substring": [[61, 76]]}}}, {"text": "From the java.lang.Void class documentation", "label": {"api": {"java.lang.Void class documentation": [[9, 42]]}}}, {"text": "Furthermore the interface is described as Map.Entry at this link and not simply Entry", "label": {"api": {"Map.Entry at this link": [[42, 63]]}}}, {"text": "The enclosing Map interface even refers to Map.Entry in its own documentation on this page", "label": {"api": {"page": [[86, 89]]}}}, {"text": "If you look at the documentation, you'll see that this function requires a Comparator", "label": {"api": {"Comparator": [[75, 84]]}}}, {"text": "The Comparator class provides some commonly used comparators for your convenience, but there's no reason you can't write your own if you require some unusual sorting", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "As an extra feature you could set socket timeout option which will affect  readLine() blocking time", "label": {"api": {"socket timeout option": [[34, 54]]}}}, {"text": "Have you considered a Servlet Filter instead", "label": {"api": {"Filter": [[30, 35]]}}}, {"text": "Optional.ifPresent is not expecting to be given a function that returns a value", "label": {"api": {"Optional.ifPresent": [[0, 17]]}}}, {"text": "It expects a Consumer<T> which is effectively a function which takes exactly one parameter and returns nothing", "label": {"api": {"Consumer<T>": [[13, 23]]}}}, {"text": "Java's ObjectOutputStream generates output designed to be read in by Java's ObjectInputStream", "label": {"api": {"ObjectOutputStream": [[7, 24]], "ObjectInputStream": [[76, 92]]}}}, {"text": "For portability you should serialize the Java X509Certificate using the Certificate.getEncoded() method", "label": {"api": {"X509Certificate": [[46, 60]], "Certificate.getEncoded()": [[72, 95]]}}}, {"text": "The output can then be used on the C# side as the byte[] argument to the X509Certificate() or X509Certificate2() constructor", "label": {"api": {"X509Certificate": [[73, 87], [94, 108]]}}}, {"text": "Assuming it's a BlockingQueue (which it should be to be properly thread safe) you should probably use poll(long,TimeUnit)", "label": {"api": {"BlockingQueue": [[16, 28]], "poll(long,TimeUnit)": [[102, 120]]}}}, {"text": "Java itself already offers a good one and you can just use it with Collections#sort (official documentation)", "label": {"api": {"official documentation": [[85, 106]]}}}, {"text": "But this is rather easy as Strings already offer such a method, it is called compareTo (here is the official documentation)", "label": {"api": {"official documentation": [[100, 121]]}}}, {"text": "There is a lot of disagreement over what breaks the LoD and whether it even matters, but all that aside, the example in the documentation for Stream shows that you are using it as intended by the Java language designers", "label": {"api": {"documentation for Stream": [[124, 147]]}}}, {"text": "For example, if the queue is a BlockingQueue, you get this guarantee", "label": {"api": {"BlockingQueue": [[31, 43]], "Queue": [[39, 43]]}}}, {"text": "As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread", "label": {"api": {"BlockingQueue": [[92, 104], [189, 201]], "Queue": [[100, 104], [197, 201]]}}}, {"text": "So as long as the queue is a BlockingQueue, not a generic Queue, the hand-off from thread A to thread B is safe", "label": {"api": {"BlockingQueue": [[29, 41]], "Queue": [[37, 41], [58, 62]]}}}, {"text": "a CountDownLatch, you get this guarantee", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "I'd try something like the following, using a shared AtomicLong to save the \"last key\", and update it atomically with updateAndGet", "label": {"api": {"updateAndGet": [[118, 129]]}}}, {"text": "You may want to read some of the Java 8 Stream documentation before continuing", "label": {"api": {"Java 8 Stream documentation": [[33, 59]]}}}, {"text": "From the documentation of nextInt", "label": {"api": {"documentation of nextInt": [[9, 32]]}}}, {"text": "Yes, by using Collectors.groupingBy(...)", "label": {"api": {"Collectors.groupingBy(...)": [[14, 39]]}}}, {"text": "Take a look at the official documentation", "label": {"api": {"official documentation": [[19, 40]]}}}, {"text": "Documented in java.util.Calendar JavaDoc for Java 6", "label": {"api": {"java.util.Calendar JavaDoc for Java 6": [[14, 50]]}}}, {"text": "I'm using a BorderLayout so the toolbar can be docked North, South, East or West (or be in a separate frame) so I'm able to call BorderLayout.getConstraints() to get its BorderLayout constraint", "label": {"api": {"BorderLayout.getConstraints()": [[129, 157]]}}}, {"text": "I registered an AncestorListener to catch the ancestorMoved() callback but it gets called somehow randomly", "label": {"api": {"AncestorListener": [[16, 31]]}}}, {"text": "A ComponentListener has the same effect (componentMoved() callback)", "label": {"api": {"ComponentListener": [[2, 18]]}}}, {"text": "I am trying to understand the implementation of Integer.toString(), which looks like this", "label": {"api": {"String": [[58, 63]]}}}, {"text": "And I ran into the last line, which doesn't look like any of the constructors in the String class, except this one", "label": {"api": {"String": [[85, 90]]}}}, {"text": "...except that this function is called with the char[] argument first, unlike how it is being used in Integer.toString()", "label": {"api": {"String": [[112, 117]]}}}, {"text": "In this way you could access to any method defined in MyModelTask and you could sort MyModelTask by defining a Comparator and more specifically  Comparator<MyModelTask> if you want to sort instances of both classes", "label": {"api": {"Comparator": [[111, 120], [145, 154]]}}}, {"text": "I want to know what classes implement ServletContext interface, so I checked the official Oracle documentation", "label": {"api": {"official Oracle documentation": [[81, 109]]}}}, {"text": "This is described in detail in String.compareTo", "label": {"api": {"String.compareTo": [[31, 46]]}}}, {"text": "Use multiply instead", "label": {"api": {"multiply": [[4, 11]]}}}, {"text": "this is not correct because TableModel::getValueAt return an Object and not a String, so you should to get the value like this", "label": {"api": {"TableModel::getValueAt": [[28, 49]]}}}, {"text": "Please note that Java has a class StringJoiner that does exactly what you want, joining some elements together and also using a delimiter like whitespace", "label": {"api": {"StringJoiner": [[34, 45]]}}}, {"text": "Is there a specific reason why you can't just use an ArrayList", "label": {"api": {"ArrayList": [[53, 61]]}}}, {"text": "You could use the substring method", "label": {"api": {"substring": [[18, 26]]}}}, {"text": "List subList(int fromIndex, int toIndex) returns the modified list but don't modify the original list", "label": {"api": {"List subList(int fromIndex, int toIndex)": [[0, 39]]}}}, {"text": "Use an ArrayDeque (you really just need some kind of stack implementation) instead of an ArrayList, and call pop() twice to get the last two elements", "label": {"api": {"ArrayDeque": [[7, 16]]}}}, {"text": "If you already have a List, then you can convert it to an ArrayDeque by passing the List as a constructor argument", "label": {"api": {"ArrayDeque": [[58, 67]]}}}, {"text": "Instead you can use processBuilder.redirectOutput() method to specify the desired output", "label": {"api": {"processBuilder.redirectOutput()": [[20, 50]]}}}, {"text": "Check out the indexOf and the replace method of the StringBuilder class", "label": {"api": {"indexOf": [[14, 20]], "replace": [[30, 36]]}}}, {"text": "When you are finished use toString", "label": {"api": {"toString": [[26, 33]]}}}, {"text": "This API is a foundation for Direct ByteBuffers and particularly MappedByteBuffers", "label": {"api": {"MappedByteBuffers": [[65, 81]]}}}, {"text": "When you run an external program using Runtime.exec(), it returns a Process object that you can use to interact with the running process", "label": {"api": {"Process": [[68, 74]]}}}, {"text": "Use LinkedHashMap instead of Map", "label": {"api": {"LinkedHashMap": [[4, 16]], "Map": [[14, 16], [29, 31]]}}}, {"text": "LinkedHashMap preserves the insertion order", "label": {"api": {"LinkedHashMap": [[0, 12]], "Map": [[10, 12]]}}}, {"text": "You'll need a custom renderer with a suitable SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "Yes it is possible by using JPA javax.persistence.criteria API", "label": {"api": {"JPA javax.persistence.criteria API": [[28, 61]]}}}, {"text": "I wouldn't say that an ArrayList gets extra functionality by implementing the List interface", "label": {"api": {"List": [[28, 31], [78, 81]], "ArrayList": [[23, 31]]}}}, {"text": "It actually provides more functionality over what is specified in the List contract", "label": {"api": {"List": [[70, 73]]}}}, {"text": "You can compare the documentation for List and ArrayList to see the differences", "label": {"api": {"List": [[38, 41], [52, 55]], "ArrayList": [[47, 55]]}}}, {"text": "For your second question, yes, you can see in the documentation for Deque that it is implemented by LinkedList, among others", "label": {"api": {"List": [[106, 109]], "Deque": [[68, 72]]}}}, {"text": "Easiest way would be with the Preferences API", "label": {"api": {"Preferences": [[30, 40]]}}}, {"text": "You could use the indexOf", "label": {"api": {"indexOf": [[18, 24]]}}}, {"text": "The javadoc for getResourceAsStreeam() clearly states", "label": {"api": {"getResourceAsStreeam()": [[16, 37]]}}}, {"text": "Throwing an exception for attempts to define classes with a qualified name starting with java., is part of the contract of defineClass, but that’s irrelevant", "label": {"api": {"the contract of defineClass": [[107, 133]]}}}, {"text": "a Java Agent using the Instrumentation API, or a debugger", "label": {"api": {"Instrumentation API": [[23, 41]]}}}, {"text": "I know it's possible to create a single-value Map<K, V> using the Collectors.toMap(..) functionalities", "label": {"api": {"Collectors.toMap(..)": [[66, 85]]}}}, {"text": "A Semaphore does not solve the issue because all threads need to be blocked", "label": {"api": {"Semaphore": [[2, 10]]}}}, {"text": "I suppose it can be achieved with a ReentrantLock or even better with compare and swap (CAS)", "label": {"api": {"ReentrantLock": [[36, 48]]}}}, {"text": "What we can see here, is that for my machine, having eight cores, seven worker threads are contributing to the work, to utilize all cores, as for the common pool, the caller thread will contribute to the work as well, instead of just waiting for the completion", "label": {"api": {"common pool": [[150, 160]]}}}, {"text": "Try to use valueOf to convert cv to a string like this", "label": {"api": {"valueOf": [[11, 17]]}}}, {"text": "If you want to preserve the order in the Map in the order of insertion you can use a LinkedHashMap instead", "label": {"api": {"LinkedHashMap": [[85, 97]]}}}, {"text": "Or use a TreeMap if the elements should be sorted after the insertion", "label": {"api": {"TreeMap": [[9, 15]]}}}, {"text": "To take back control of the ordering, look into using a SortedMap", "label": {"api": {"SortedMap": [[56, 64]]}}}, {"text": "The call to Future.get() is blocking", "label": {"api": {"Future.get()": [[12, 23]]}}}, {"text": "Wrap your Executor in a CompletionService and submit() tasks to it instead", "label": {"api": {"CompletionService": [[24, 40]], "submit()": [[46, 53]]}}}, {"text": "Have another thread consume the results of the CompletionService to do any processing that is necessary after the task is complete", "label": {"api": {"CompletionService": [[47, 63]]}}}, {"text": "Alternatively, you can use the helper methods of CompletableFuture to set up an equivalent pipeline of actions", "label": {"api": {"CompletableFuture": [[49, 65]]}}}, {"text": "According to the Javadoc, the IndexOutOfBoundsException is only ever thrown..", "label": {"api": {"According to the Javadoc": [[0, 23]]}}}, {"text": "From String.intern() doc", "label": {"api": {"String.intern()": [[5, 19]]}}}, {"text": "Java's PriorityQueue does", "label": {"api": {"PriorityQueue does": [[7, 24]]}}}, {"text": "If you don't want the JAX-RS runtime to decode the price parameter, annotate it with @Encoded", "label": {"api": {"@Encoded": [[85, 92]]}}}, {"text": "ArrayList.remove(Object) removes the first occurrence of the object, which is at the list position at which you had just inserted that object", "label": {"api": {"ArrayList.remove(Object)": [[0, 23]]}}}, {"text": "As a refinement, the above code also uses ArrayList.remove(int), which should be more efficient, since it does not have to iterate through the list to find the matching item", "label": {"api": {"ArrayList.remove(int)": [[42, 62]]}}}, {"text": "The old Stack class is a List, which is why you could call listIterator()", "label": {"api": {"Stack": [[8, 12]], "List": [[25, 28]], "listIterator()": [[59, 72]]}}}, {"text": "Now it seems that you want to use the Queue API, but it doesn't has a ListIterator, or any other kind of iterator that allows you to walk backwards", "label": {"api": {"List": [[70, 73]], "Queue": [[38, 42]], "ListIterator": [[70, 81]]}}}, {"text": "Change your var variable to be type LinkedList, since it is both a Queue and a List at the same time, which means you get both APIs", "label": {"api": {"List": [[42, 45], [79, 82]], "Queue": [[67, 71]], "LinkedList": [[36, 45]]}}}, {"text": "LinkedList is the only built-in class implementing both", "label": {"api": {"List": [[6, 9]], "LinkedList": [[0, 9]]}}}, {"text": "The Deque API is an extension of the Queue API, for using a \"double ended queue\"", "label": {"api": {"Queue": [[37, 41]], "Deque": [[4, 8]]}}}, {"text": "A double-ended queue can be iterated backwards using the descendingIterator() method", "label": {"api": {"descendingIterator()": [[57, 76]]}}}, {"text": "The advantage of Deque is that there are 4 built-in implementations, giving you more choices", "label": {"api": {"Deque": [[17, 21]]}}}, {"text": "LinkedList, ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque", "label": {"api": {"List": [[6, 9]], "LinkedList": [[0, 9]], "Deque": [[17, 21], [40, 44], [61, 65]], "ArrayDeque": [[12, 21]], "ConcurrentLinkedDeque": [[24, 44]], "LinkedBlockingDeque": [[47, 65]]}}}, {"text": "You can use the groupingBy collector to gather all products by their price in a List and then with a second create a second stream and the productsToColors method get the map you want", "label": {"api": {"groupingBy": [[16, 25]]}}}, {"text": "You can also have groupingBy create a TreeMap instead so that the colors  map will be sorted by price", "label": {"api": {"groupingBy": [[18, 27]]}}}, {"text": "Consider, that Math.random() returns floating point number 0 <= x <= 1.0 (Java API docs Math.random())", "label": {"api": {"Java API docs Math.random()": [[74, 100]]}}}, {"text": "So, how come when I look at the documentation of HashSet (https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html), I see a list of methods which are inherited from interface java.util.Set", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html": [[58, 121]]}}}, {"text": "There is such a facility, java.beans.Statement, resp", "label": {"api": {"java.beans.Statement": [[26, 45]]}}}, {"text": "Expression if a return value is needed", "label": {"api": {"Expression": [[0, 9]]}}}, {"text": "indexOf is your friend here", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "The ActionListener for your Generate button repeatedly adds null to the TableModel, which causes Double.parseDouble() to throw NullPointerException", "label": {"api": {"Double.parseDouble()": [[97, 116]]}}}, {"text": "First of all you should implement the equals() method (and .hashCode() as well) in your Item class so you can compare items correctly, for example it will be needed when using List's .contains() method", "label": {"api": {".contains() method": [[183, 200]]}}}, {"text": "Then you can use .contains() method to test if the current item exists in the oldList, and filter the items based on that result", "label": {"api": {".contains() method": [[17, 34]]}}}, {"text": "Note that the use of stream here isn't really necessary as you can just implement this by using List methods, such as .retainAll() which will allow you to filter the newList in a better way", "label": {"api": {".retainAll()": [[118, 129]]}}}, {"text": "Just use List.removeAll method, which does exactly what you want", "label": {"api": {"List.removeAll": [[9, 22]]}}}, {"text": "Another more functionalish way to do it would be by using the Collection.removeIf method", "label": {"api": {"Collection.removeIf": [[62, 80]]}}}, {"text": "Use Random.nextBoolean to determine whether to enable or disable the button", "label": {"api": {"Random.nextBoolean": [[4, 21]]}}}, {"text": "The problem is that the choices used in the SHORT_IDS map are - like any other choice - arbitrary and even controversial", "label": {"api": {"choices used in the SHORT_IDS map": [[24, 56]]}}}, {"text": "Then you can take a look at ZoneRules javadoc to know how to map IANA information to Java classes", "label": {"api": {"ZoneRules javadoc": [[28, 44]]}}}, {"text": "There are other ways to use the provider (instead of registering), check the javadoc for more details", "label": {"api": {"check the javadoc": [[67, 83]]}}}, {"text": "However, if you want a Java only solution you could cast the PrivateKey even further to RSAPrivateCrtKey which does contain a getPublicExponent method to retrieve the public exponent", "label": {"api": {"getPublicExponent": [[126, 142]]}}}, {"text": "Then you can use an RSA KeyFactory to generate a public key using RSAPublicKeySpec", "label": {"api": {"RSAPublicKeySpec": [[66, 81]]}}}, {"text": "When you have Strings containing %20 (or in general %dd, where dd is a hex value 00-FF) it's URL Encoded", "label": {"api": {"URL Encoded": [[93, 103]]}}}, {"text": "To reverse that you need to use URLDecoder", "label": {"api": {"URLDecoder": [[32, 41]]}}}, {"text": "Have a look at the List class for example, and make sure to put generics to good use", "label": {"api": {"List class": [[19, 28]]}}}, {"text": "You can use an AtomicInteger", "label": {"api": {"AtomicInteger": [[15, 27]]}}}, {"text": "The Javadoc for Comparator introduces the concept of a Comparator being consistent with equals; the two are consistent when a.equals(b) is the same as a.compareTo(b) == 0 for all possible values of a and b", "label": {"api": {"Javadoc for Comparator": [[4, 25]]}}}, {"text": "Use the ThreadPoolExecutor and set its keepAliveTime attribute via any one of its constructors", "label": {"api": {"ThreadPoolExecutor": [[8, 25]]}}}, {"text": "I am currently working on my first TreeView in JavaFX", "label": {"api": {"TreeView": [[35, 42]]}}}, {"text": "In this example, we build the TreeItem tree structure manually, i.e., calling getChildren() on every node that has children and adding these", "label": {"api": {"TreeItem": [[30, 37]]}}}, {"text": "Is it possible to tell a TreeItem to \"dynamically\" build its children", "label": {"api": {"TreeItem": [[25, 32]]}}}, {"text": "Because you want to access the methods of the Java Class", "label": {"api": {"Java Class": [[46, 55]]}}}, {"text": "I suggest you to use the BufferedReader class which implement a readLine() method, that'll ease your work", "label": {"api": {"BufferedReader": [[25, 38]]}}}, {"text": "The official source for the Java standard library is the standard Java API documentation", "label": {"api": {"standard Java API documentation": [[57, 87]]}}}, {"text": "If you want to do something when a Task finishes, you can use its onSucceeded handler", "label": {"api": {"onSucceeded": [[66, 76]]}}}, {"text": "Why does the Collection interface have equals(Object o) and hashCode(), given that any implementation will have those by default (inherited from Object)", "label": {"api": {"Collection": [[13, 22]]}}}, {"text": "As for Stream.anyMatch(), that returns a primitive boolean, which can't be null to begin with", "label": {"api": {"Stream.anyMatch()": [[7, 23]]}}}, {"text": "If you want to make sure that a certain property is set for all test cases, you can use the @Before or @BeforeClass annotation in conjunction with System.setProperty() to force a certain setting", "label": {"api": {"System.setProperty()": [[147, 166]]}}}, {"text": "So don't use nextInt() in your while condition, use hasNextInt() instead", "label": {"api": {"hasNextInt()": [[52, 63]]}}}, {"text": "Looking at the docs for java.security.KeyStore, it looks like the load() method when called with an InputStream actually expects a character array (char[]), not a string", "label": {"api": {"java.security.KeyStore": [[24, 45]]}}}, {"text": "instead of passing a file output stream to these methods - pass a different kind of stream, for example a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[106, 126]]}}}, {"text": "And to ensure that the final result is reasonable encoded, you should actually use some kind of Base64OutputStream which in turn writes to that ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[144, 164]]}}}, {"text": "About format string input, use java.io.PrintStream#printf(java.lang.String, java.lang.Object...) instead", "label": {"api": {"java.io.PrintStream#printf(java.lang.String, java.lang.Object...)": [[31, 95]]}}}, {"text": "My recommendation would be to use a StringBuilder", "label": {"api": {"StringBuilder": [[36, 48]]}}}, {"text": "Make this easier on yourself and use String.split()", "label": {"api": {"String.split()": [[37, 50]]}}}, {"text": "From the official documentation", "label": {"api": {"official documentation": [[9, 30]]}}}, {"text": "There is also a variant that takes a Random object, if you want to have more control over the seeding for example, also see the official documentation", "label": {"api": {"official documentation": [[128, 149]]}}}, {"text": "Well from the documentation of the method itself its very clear what it does there", "label": {"api": {"documentation of the method": [[14, 40]]}}}, {"text": "You can use either VBox or HBox class", "label": {"api": {"VBox": [[19, 22]], "HBox": [[27, 30]]}}}, {"text": "Here is a example with VBox", "label": {"api": {"VBox": [[23, 26]]}}}, {"text": "Check JTextComponent.setText(String) documentation", "label": {"api": {"JTextComponent.setText(String)": [[6, 35]]}}}, {"text": "And doing this for each usage of a stream would be a waste of resources since streams are not reusable", "label": {"api": {"are not reusable": [[86, 101]]}}}, {"text": "Moreover, keep in mind that streams are lazy", "label": {"api": {"streams are lazy": [[28, 43]]}}}, {"text": "Have a look at ResultSet::next, it says", "label": {"api": {"ResultSet::next": [[15, 29]]}}}, {"text": "you call results.next() twice before adding the result to your list", "label": {"api": {"next()": [[17, 22]]}}}, {"text": "remove the if (results.next()) { statement and everything should be fine", "label": {"api": {"next()": [[23, 28]]}}}, {"text": "next() must be called once before accessing the first row, but you are calling it twice (in the if and in the while statement) so the cursor is already in the second row when you start reading the rows content", "label": {"api": {"next()": [[0, 5]]}}}, {"text": "One way to enforce it are thread priorities - higher priorities will get their work done first - you can find other concepts in the concurrent package", "label": {"api": {"concurrent package": [[132, 149]]}}}, {"text": "You need to change the sorting method to use explicit comparator", "label": {"api": {"comparator": [[54, 63]]}}}, {"text": "If you want to know the type of the http request in your JSP you can use request.getMethod()", "label": {"api": {"request.getMethod()": [[73, 91]]}}}, {"text": "Eventually Double.toString (which is used by BigDecimal.valueOf) returns \"Infinity\" what leads to NumberFormatException", "label": {"api": {"BigDecimal.valueOf": [[45, 62]]}}}, {"text": "According to the Stream Javadoc", "label": {"api": {"Stream Javadoc": [[17, 30]]}}}, {"text": "For a Stage, you can register a listener with the iconified property to respond when it is minimized", "label": {"api": {"iconified property": [[50, 67]]}}}, {"text": "You can apply the Stream API to filter all instance being of the desired class using instanceof and finally collect them to a new List", "label": {"api": {"Stream API": [[18, 27]]}}}, {"text": "Calling ResultSet#next() advances the underlying cursor", "label": {"api": {"ResultSet#next()": [[8, 23]]}}}, {"text": "You could use DecimalFormat#setRoundingMode to control how the rounding is done, and specify you always want to round down (truncate)", "label": {"api": {"DecimalFormat#setRoundingMode": [[14, 42]]}}}, {"text": "Beside that of the IntStream#flatMap, you can use the Arrays#stream(int[]) to create an IntStream", "label": {"api": {"IntStream#flatMap": [[19, 35]], "Arrays#stream(int[])": [[54, 73]]}}}, {"text": "I'd recommend using a HashMap to then iterate over it in a for loop making proper calls of the above constructor", "label": {"api": {"HashMap": [[22, 28]]}}}, {"text": "I know that condition.get() is atomic, but, is !condition.get() atomic as well", "label": {"api": {"atomic": [[31, 36], [64, 69]]}}}, {"text": "I mean, could it happen that one Thread read the boolean value atomically and then it were interrupted before applying the", "label": {"api": {"atomic": [[63, 68]]}}}, {"text": "I believe this is the behavior caused by the underlying selection model, and I believe it is the desired behavior for most use-cases", "label": {"api": {"selection model": [[56, 70]]}}}, {"text": "Drivers are auto-discovered thanks to the service provider mechanism of Java, as documented", "label": {"api": {"as documented": [[78, 90]]}}}, {"text": "then you can convert back into string when done if needed (new String(myArray))", "label": {"api": {"String": [[63, 68]]}}}, {"text": "Read about String", "label": {"api": {"String": [[11, 16]]}}}, {"text": "As you are building the answer char by char, the most reasonable way to do is via StringBuilder, as @Milk suggests", "label": {"api": {"String": [[82, 87]], "StringBuilder": [[82, 94]]}}}, {"text": "Unlike an array, StringBuilder knows how to grow and you do not need to specify the size when creating it", "label": {"api": {"String": [[17, 22]], "StringBuilder": [[17, 29]]}}}, {"text": "You can use List.subList(int, int) to get the first K items from your processQueueBatchList like so", "label": {"api": {"List.subList(int, int)": [[12, 33]]}}}, {"text": "If your choice of List supports it, there's always List::subList", "label": {"api": {"List::subList": [[51, 63]]}}}, {"text": "Define a member for the official date, of type LocalDate", "label": {"api": {"LocalDate": [[47, 55]]}}}, {"text": "Define also members for the start and stop, of type LocalDateTime, where the stop is plusDays( 1 )", "label": {"api": {"LocalDate": [[52, 60]], "LocalDateTime": [[52, 64]]}}}, {"text": "Define a pair of getter methods each taking a ZoneId argument, and returning a ZonedDateTime, each for the true exact moment when the hotel-day starts and stops", "label": {"api": {"ZoneId": [[46, 51]], "ZonedDateTime": [[79, 91]]}}}, {"text": "A LocalDateTime is not an actual moment, and has no meaning until you specify a time zone", "label": {"api": {"LocalDate": [[2, 10]], "LocalDateTime": [[2, 14]]}}}, {"text": "Calculate the span of time as a Duration", "label": {"api": {"Duration": [[32, 39]]}}}, {"text": "I am trying to format a MonthDay object in a way that I do not have to specify the order", "label": {"api": {"MonthDay": [[24, 31]]}}}, {"text": "I am trying to use a localized DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[31, 47]]}}}, {"text": "How do I do this with a MonthDay object as the last line throws an exception when done in this way", "label": {"api": {"MonthDay": [[24, 31]]}}}, {"text": "If there is UI-related code you want to perform when that completes, the best way to do that is to use a Task and use its onSucceeded handler to perform the UI code at the end", "label": {"api": {"Task": [[105, 108]]}}}, {"text": "To get a query parameter, you would have to use the getParameter() method", "label": {"api": {"getParameter()": [[52, 65]]}}}, {"text": "A Canvas buffers the drawing instructions prescribed by invoking the methods of a GraphicsContext", "label": {"api": {"Canvas": [[2, 7]]}}}, {"text": "There are no pixels to read until the Canvas is rendered in a later pulse, and the internal format of the instruction buffer is not exposed in the API", "label": {"api": {"Canvas": [[38, 43]]}}}, {"text": "As an alternative, consider drawing into a BufferedImage, illustrated here, which allows access to the image's pixels directly and via its WritableRaster", "label": {"api": {"BufferedImage": [[43, 55]], "WritableRaster": [[139, 152]]}}}, {"text": "From the document", "label": {"api": {"document": [[9, 16]]}}}, {"text": "But the document says that two different objects may have different hashcode, which will affect the correctness of equals()", "label": {"api": {"document": [[8, 15]]}}}, {"text": "It sounds like you want a Map", "label": {"api": {"Map": [[26, 28]]}}}, {"text": "But, again, it seems like a Map might be a better choice", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "You need a custom comparator", "label": {"api": {"comparator": [[18, 27]]}}}, {"text": "There is a dedicated version of groupingBy() for your use case", "label": {"api": {"dedicated version of groupingBy()": [[11, 43]]}}}, {"text": "— ServletResponse.flushBuffer() method (Java(TM) EE 7 Specification APIs)", "label": {"api": {"ServletResponse.flushBuffer() method (Java(TM) EE 7 Specification APIs)": [[2, 72]]}}}, {"text": "There have been many questions regards String.contains vs", "label": {"api": {"String.contains": [[39, 53]]}}}, {"text": "collect is a terminal operation in the stream, and it is expected to return a type bound by R, which in this case, translates to List<Integer>", "label": {"api": {"a terminal operation": [[11, 30]]}}}, {"text": "You're encouraged here to peruse more information about Collector, as it's part of the newer Java 8 Stream API and can be a bit curious to get into once you start", "label": {"api": {"peruse more information about Collector": [[26, 64]]}}}, {"text": "In order to see output from a logger you have to attach a Handler subclass", "label": {"api": {"Handler subclass": [[58, 73]]}}}, {"text": "You can add them from code or you can create a logging.properties", "label": {"api": {"code": [[22, 25]], "logging.properties": [[47, 64]]}}}, {"text": "As defined in the API for java.util.regex.Pattern, the correct name is IsAlphabetic", "label": {"api": {"the API for java.util.regex.Pattern": [[14, 48]]}}}, {"text": "So far, when dumping, I have been able to retrieve all Views and Tables from the database using DatabaseMetadata.getTables(..) but when it comes to Views I'm not able to obtain the source SQL", "label": {"api": {"DatabaseMetadata.getTables(..)": [[96, 125]]}}}, {"text": "The method Class#newInstance() will create an instance of any class object you have", "label": {"api": {"Class#newInstance()": [[11, 29]]}}}, {"text": "If this is not the case, you can still use reflection but might want to check out the Constructor accessor class, which offers more powerful access to all the constructors in a class", "label": {"api": {"Constructor": [[86, 96]]}}}, {"text": "This nice tutorial explains the advantages of Constructor in more detail", "label": {"api": {"Constructor": [[46, 56]]}}}, {"text": "That is the entire point of using AtomicInteger, you do not need to synchronize", "label": {"api": {"AtomicInteger": [[34, 46]]}}}, {"text": "The first (and only) sentence of the Javadoc for the java.util.concurrent.atomic package says a small toolkit of classes that support lock-free thread-safe programming on single variables", "label": {"api": {"java.util.concurrent.atomic package": [[53, 87]]}}}, {"text": "To accomplish this, each user has a UUID", "label": {"api": {"UUID": [[36, 39]]}}}, {"text": "At various points in my program, I may have a UUID and want its current display name, or I may have a current display name and I'd like to look up the UUID", "label": {"api": {"UUID": [[46, 49], [151, 154]]}}}, {"text": "I'm familiar with Guava's LoadingCache, but it seems like I'd have to create two caches (names -> UUIDs and UUIDs -> names) in order to accomplish this", "label": {"api": {"UUID": [[98, 101], [108, 111]]}}}, {"text": "However, in your case it would make much more sense to just use EntityManager::persist", "label": {"api": {"EntityManager::persist": [[64, 85]]}}}, {"text": "It looks like the Thread.isAlive method is final, and final methods can not be mocked with Mockito", "label": {"api": {"final": [[43, 47], [54, 58]]}}}, {"text": "I suggest CountDownLatch, which is designed exactly for this purpose", "label": {"api": {"CountDownLatch": [[10, 23]]}}}, {"text": "I would recommend looking at the datatype ZonedDateTime", "label": {"api": {"ZonedDateTime": [[42, 54]]}}}, {"text": "Since you don't know about ZonedDateTime here is a quick overview how to convert string to ZonedDateTime", "label": {"api": {"ZonedDateTime": [[27, 39], [91, 103]]}}}, {"text": "After @Flown pointed me to a question I thought would not really help at first he further pointed me to changing the condition using Math#signum", "label": {"api": {"Math#signum": [[133, 143]]}}}, {"text": "You can create an ObjectBinding scrollableBounds that is bound to the contents' bounds-in-local and local-to-parent-transform properties, as well the viewport-bounds", "label": {"api": {"ObjectBinding": [[18, 30]]}}}, {"text": "Read the javadoc of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "The simplest (code-wise) would probably be to use a collection that is implicitly concurrent, like ConcurrentHashMap or a list wrapped in Collections.synchronizedList()", "label": {"api": {"ConcurrentHashMap": [[99, 115]], "Collections.synchronizedList()": [[138, 167]]}}}, {"text": "Since a *.docx is simply a ZIP archive we also could opening it as FileSystem gotten from FileSystems and then process its content totally independent from third party libraries", "label": {"api": {"FileSystem": [[67, 76], [90, 99]], "FileSystems": [[90, 100]]}}}, {"text": "This is a very basic example using StAX", "label": {"api": {"StAX": [[35, 38]]}}}, {"text": "Integer class is a child class of Number class which is a child class of Object class", "label": {"api": {"Integer": [[0, 6]], "Number": [[34, 39]], "Object": [[73, 78]]}}}, {"text": "Long is also a child class of Number class", "label": {"api": {"Number": [[30, 35]], "Long": [[0, 3]]}}}, {"text": "But there is no direct hierarchical relationship between Integer and Long class (except both are child of Number)", "label": {"api": {"Integer": [[57, 63]], "Number": [[106, 111]], "Long": [[69, 72]]}}}, {"text": "If you comment the method with Integer, then as per to java inheritance it will see it's parent reference being (actually immediate parent reference would be Number but none of the methods have Number class in their signature) Object class and method signature matching it will be invoked", "label": {"api": {"Integer": [[31, 37]], "Number": [[158, 163], [194, 199]], "Object": [[227, 232]]}}}, {"text": "I would suggest putting the positions that you are considering into a https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html with a priority based on how close they are to being solved", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html": [[70, 139]]}}}, {"text": "Check the javadoc for more info", "label": {"api": {"Check the javadoc": [[0, 16]]}}}, {"text": "you're calling str.getBytes() without argument", "label": {"api": {"str.getBytes()": [[15, 28]]}}}, {"text": "In Java, List.subList", "label": {"api": {"List.subList": [[9, 20]]}}}, {"text": "Because Thread.sleep() is", "label": {"api": {"Thread.sleep()": [[8, 21]]}}}, {"text": "This will compare two Person instances first by their fname and - if that is equal - by their age (with a slight optimization to thenComparingInt to avoid boxing)", "label": {"api": {"thenComparingInt": [[129, 144]]}}}, {"text": "If you read the documentation for Stringtokenizer you see that the delimiter argument is basically a list of characters that you want to split the input with", "label": {"api": {"Stringtokenizer": [[34, 48]]}}}, {"text": "You can call Component's getParent() which will give you the direct parent of this component and then you can query its dimensions", "label": {"api": {"Component's getParent()": [[13, 35]]}}}, {"text": "Per the Object API (and do make it a habit to read the API before asking)", "label": {"api": {"Object API": [[8, 17]]}}}, {"text": "Alternatively you can schedule all tasks (low and high priority) through one thread pool configured with a priority queue and decorate each background task so that it has a low priority", "label": {"api": {"priority queue": [[107, 120]]}}}, {"text": "Let your Animal class implement Comparable<Animal> and add a compareTo method", "label": {"api": {"Comparable<Animal>": [[32, 49]], "compareTo": [[61, 69]]}}}, {"text": "Provide a custom Comparator to the Collections#sort method", "label": {"api": {"Comparator": [[17, 26]], "Collections#sort": [[35, 50]]}}}, {"text": "There is no way to prevent the usage of lambda expressions by API clients when your interface satisfies the criteria for it", "label": {"api": {"the criteria": [[104, 115]]}}}, {"text": "If you don't need to extend DefaultCellEditor for some other reason, you can simply invoke its setClickCountToStart() method with a count of 2", "label": {"api": {"DefaultCellEditor": [[28, 44]], "setClickCountToStart()": [[95, 116]]}}}, {"text": "As for your Java program, which is what we actually care about on this site, Java's built-in Math.sin and Math.cos work in radians", "label": {"api": {"Math.sin": [[93, 100]], "Math.cos": [[106, 113]]}}}, {"text": "For this you can either use Math.toRadians", "label": {"api": {"Math.toRadians": [[28, 41]]}}}, {"text": "The Java Tutorials by Oracle include a page, Class Literals as Runtime-Type Tokens", "label": {"api": {"Class": [[45, 49]]}}}, {"text": "The code there shows how passing a Class object as an argument can be used with generics to define the type of an object being instantiated with newInstance()", "label": {"api": {"Class": [[35, 39]]}}}, {"text": "I am wondering what such code looks like to use reflection to populate an object’s fields with the results of a row from a ResultSet", "label": {"api": {"ResultSet": [[123, 131]]}}}, {"text": "Java has a something called a Comparator, which is used to sort things", "label": {"api": {"Comparator": [[30, 39]]}}}, {"text": "Depending on the types of your properties you can use compareTo or otherwise write your own sorting logic (see the Comparator docs)", "label": {"api": {"Comparator": [[115, 124]], "compareTo": [[54, 62]]}}}, {"text": "Found the getSystemCpuLoad() of com.sun.management.OperatingSystemMXBean", "label": {"api": {"com.sun.management.OperatingSystemMXBean": [[32, 71]]}}}, {"text": "The documentation of com.sun.management.OperatingSystemMXBean really only says that the method returns a negative value if the information could not be accessed for some reason", "label": {"api": {"com.sun.management.OperatingSystemMXBean": [[21, 60]]}}}, {"text": "The delim parameter of new StringTokenizer(str, delim) is not a regular expression", "label": {"api": {"new StringTokenizer(str, delim)": [[23, 53]]}}}, {"text": "If you want to split at whitespaces (one or more), just use the other constructor taking no delim parameter, using \" \\t\\n\\r\\f\" as default", "label": {"api": {"other constructor": [[64, 80]]}}}, {"text": "Perhaps you can use computeIfAbsent() to safely and quickly get the specific ConcurrentMap associated with that customer (or create a new one if none exists), then use a synchronized block on that customer-specific ConcurrentMap for all the operations that are specific to that customer", "label": {"api": {"computeIfAbsent()": [[20, 36]]}}}, {"text": "If a class extends a generic class or interface and provides a concrete type for the parameter, then that type is available via Class.getGenericSuperclass()", "label": {"api": {"Class.getGenericSuperclass()": [[128, 155]]}}}, {"text": "That method will (in this case) return a ParameterizedType that will contain the actual parameterization", "label": {"api": {"ParameterizedType": [[41, 57]]}}}, {"text": "I think you need to parse firstname and lastname with JsonObject and you need to parse skills with JsonArray, then you will be able to access them", "label": {"api": {"JsonObject": [[54, 63]], "JsonArray": [[99, 107]]}}}, {"text": "The issue here is that Arrays.asList creates a fixed size list", "label": {"api": {"Arrays.asList": [[23, 35]]}}}, {"text": "Use a GridBagLayout for a table/matrix like layout, where some \"cells\" occupy more than one slot", "label": {"api": {"GridBagLayout": [[6, 18]]}}}, {"text": "Alternatively, you can run user-supplied Javascript, giving it controlled access to your Java program's data, using the Java Scripting API", "label": {"api": {"Java Scripting API": [[120, 137]]}}}, {"text": "Use a TreeSet instead of an ArrayList", "label": {"api": {"TreeSet": [[6, 12]]}}}, {"text": "The TreeSet is sorted and does not allow duplicates", "label": {"api": {"TreeSet": [[4, 10]]}}}, {"text": "As a side note, since Java 7, the Java bytecode even allows to load constants of type MethodType or MethodHandle which has no actual Java language equivalent", "label": {"api": {"MethodType": [[86, 95]], "MethodHandle": [[100, 111]]}}}, {"text": "The method type or method handle is resolved (§5.4.3.5) and a reference to the resulting instance of java.lang.invoke.MethodType or java.lang.invoke.MethodHandle, value, is pushed onto the operand stack", "label": {"api": {"MethodType": [[118, 127]], "MethodHandle": [[149, 160]]}}}, {"text": "The static method Float.floatToRawIntBits() does exactly that", "label": {"api": {"Float.floatToRawIntBits()": [[18, 42]]}}}, {"text": "There is also Float.floatToIntBits() that has slightly different NaN handling semantics", "label": {"api": {"Float.floatToIntBits()": [[14, 35]]}}}, {"text": "The inverse transformation is Float.intBitsToFloat()", "label": {"api": {"Float.intBitsToFloat()": [[30, 51]]}}}, {"text": "If you need it to be HashMap specifically, you can pass HashMap::new into the factory overload", "label": {"api": {"factory overload": [[78, 93]]}}}, {"text": "The suggestions to use StringBuffer are probably what you want, but if you are using Java 8, you could use the BufferedReader.lines() method and a collector to concatenate the strings you need", "label": {"api": {"BufferedReader.lines()": [[111, 132]]}}}, {"text": "You can either remove that with the String#substring method or don't append it if you're processing the last element (look one element ahead with iterator.hasNext()) or just use StringJoiner which I'll show you in a moment", "label": {"api": {"StringJoiner": [[178, 189]]}}}, {"text": "Helpful for this is the StringJoiner class which lets you join strings with adding a delimiter like ,", "label": {"api": {"StringJoiner": [[24, 35]]}}}, {"text": "If you want to compare generic types, you'll have to ensure they implement Comparable, and call Comparable.compare()", "label": {"api": {"Comparable": [[75, 84], [96, 105]]}}}, {"text": "Alternatively, you can use a custom Comparator instead of relying on the natural order", "label": {"api": {"Comparator": [[36, 45]]}}}, {"text": "Instead, you need to tell the compiler that objects of T will implement Comparable<T> interface", "label": {"api": {"Comparable<T>": [[72, 84]]}}}, {"text": "Consider using SwingWorker<Boolean, Boolean> in this context", "label": {"api": {"SwingWorker<Boolean, Boolean>": [[15, 43]]}}}, {"text": "Use StreamingOutput instead", "label": {"api": {"StreamingOutput": [[4, 18]]}}}, {"text": "You can use Stream.concat to combine a Stream.of the single value and the stream of the other values", "label": {"api": {"Stream.concat": [[12, 24]]}}}, {"text": "It is recommended that you examine Dates using a Calendar object, or, for Java 8, the Time API", "label": {"api": {"Time": [[86, 89]]}}}, {"text": "Specifically you could use the poll(long,TimeUnit) method", "label": {"api": {"poll(long,TimeUnit)": [[31, 49]]}}}, {"text": "The javadoc for getToolTipText() says", "label": {"api": {"getToolTipText()": [[16, 31]]}}}, {"text": "InputStream is an abstract class (not an \"object\")", "label": {"api": {"InputStream": [[0, 10]]}}}, {"text": "Alternatively given the use case in your example, you could use a class like Point and Point2D.Double from the awt library, or Point2D from the JavaFX library to store your pair of x and y values", "label": {"api": {"Point": [[77, 81], [87, 91], [127, 131]], "Point2D.Double": [[87, 100]], "Point2D": [[87, 93], [127, 133]]}}}, {"text": "Example use of MyPoint, and pretty much the same for the library classes mentioned previously", "label": {"api": {"Point": [[17, 21]]}}}, {"text": "Use .forEach instead of .map", "label": {"api": {".forEach": [[4, 11]]}}}, {"text": "The null-safe handling of Objects.equals() method will clean things up here", "label": {"api": {"Objects.equals()": [[26, 41]]}}}, {"text": "Here is my implementation that implemented by Spliterator as below", "label": {"api": {"Spliterator": [[46, 56]]}}}, {"text": "This is because the find operation return a MongoIterable which has declared a forEach method for java-7 Iterable which has no forEach method at all", "label": {"api": {"Iterable": [[49, 56], [105, 112]]}}}, {"text": "So you can call the forEach method on a MongoIterable as in your question", "label": {"api": {"Iterable": [[45, 52]]}}}, {"text": "In java8, the Iterable includes the forEach(Consumer) operation", "label": {"api": {"Iterable": [[14, 21]], "forEach(Consumer)": [[36, 52]]}}}, {"text": "You should use \"HHmm\" as a date format specifier instead of \"hhmm\" - according to this documentation, H is used for a zero-based 24-hour-format while h is used for 1-based 12-hour format", "label": {"api": {"this documentation": [[82, 99]]}}}, {"text": "Is there a way to combine multiple FileFilters of java.io", "label": {"api": {"FileFilter": [[35, 44]]}}}, {"text": "Use double, then call Math.round() to produce an integer number again", "label": {"api": {"Math.round()": [[22, 33]]}}}, {"text": "For validation purposes, consider @NotNull from Bean Validation (a validation provider such as Hibernate Validator is required to perform the validation)", "label": {"api": {"@NotNull": [[34, 41]]}}}, {"text": "As you use Java and only a default transformer to serialize some DOM tree you might first want to check whether LSSerializer (https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html) is not doing a better job than a default Transformer to output the DTD and/or CDATA section nodes", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html": [[126, 199]]}}}, {"text": "You can use File.listFiles", "label": {"api": {"File.listFiles": [[12, 25]]}}}, {"text": "You could create a DecimalFormat", "label": {"api": {"DecimalFormat": [[19, 31]]}}}, {"text": "To be expected, just read the javadoc for List.toArray()", "label": {"api": {"List.toArray()": [[42, 55]]}}}, {"text": "We want a FunctionalInterface which exactly matches our process function, without using any box classes", "label": {"api": {"FunctionalInterface": [[10, 28]]}}}, {"text": "See the list in the Java regex docs for the supported list of regex escapes", "label": {"api": {"Java regex docs": [[20, 34]]}}}, {"text": "However, if you use a Pattern.COMMENTS flag (used to introduce comments and format a pattern nicely, making the regex engine ignore all unescaped whitespace in the pattern), you will need to either use \"\\\\n\" or \"\\\\\\n\" to define a newline (LF) in the Java string literal and \"\\\\r\" or \"\\\\\\r\" to define a carriage return (CR)", "label": {"api": {"Pattern.COMMENTS flag": [[22, 42]]}}}, {"text": "Next, you can run this executable using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[40, 53]]}}}, {"text": "However, if you want to install a handler on siblings then you should use the LogManager config option or the java.util.logging.config.class system property to create your logging config", "label": {"api": {"LogManager config option or the java.util.logging.config.class system property": [[78, 155]]}}}, {"text": "Both call the same constructor of ArrayList and the first is way redundant", "label": {"api": {"same constructor": [[14, 29]]}}}, {"text": "It will be quite simple if you're allowed to use Java 8", "label": {"api": {"Java 8": [[49, 54]]}}}, {"text": "According to the docs of nextBoolean(), it would scan the next token of the input into a boolean value and returns that value", "label": {"api": {"nextBoolean()": [[25, 37]]}}}, {"text": "You forgot to call primaryStage.show()", "label": {"api": {"primaryStage.show()": [[19, 37]]}}}, {"text": "Use a suitable Worker to establish the connection to the bridge", "label": {"api": {"Worker": [[15, 20]]}}}, {"text": "Choose Task for a single unit of work; choose Service to manage multiple tasks", "label": {"api": {"Task": [[7, 10]], "Service": [[46, 52]]}}}, {"text": "You need it if you want to interrupt a Thread (documentation of Thread#interrupt)", "label": {"api": {"documentation of Thread#interrupt": [[47, 79]]}}}, {"text": "I want to create a function to calculate the power of a number of the type Number  (the class) via recursion", "label": {"api": {"the class": [[84, 92]]}}}, {"text": "Use Files.walk to get a stream of a directories entries", "label": {"api": {"Files.walk": [[4, 13]]}}}, {"text": "As others have already pointed out, you see it \"reversed\" because Comparator contract works the opposite way", "label": {"api": {"Comparator contract": [[66, 84]]}}}, {"text": "I highly recommend you to read Comparator javadoc before going forward", "label": {"api": {"Comparator javadoc": [[31, 48]]}}}, {"text": "You could also use an ArrayList, which can have items added and removed from it dynamically", "label": {"api": {"ArrayList": [[22, 30]]}}}, {"text": "For example, if I were using a simple Scanner and ArrayList, I could do the following", "label": {"api": {"ArrayList": [[50, 58]]}}}, {"text": "You can use the member methods of JsonObject to do this (http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html)", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html": [[57, 118]]}}}, {"text": "I was benchmarking some code, and I could not get it to run as fast as with java.math.BigInteger, even when using the exact same algorithm", "label": {"api": {"java.math.BigInteger": [[76, 95]]}}}, {"text": "So I copied java.math.BigInteger source into my own package and tried this", "label": {"api": {"java.math.BigInteger": [[12, 31]]}}}, {"text": "java.util.zip.Inflater may be useful in your case", "label": {"api": {"java.util.zip.Inflater": [[0, 21]]}}}, {"text": "You should use compute() instead", "label": {"api": {"compute()": [[15, 23]]}}}, {"text": "You can use parseDouble in order to extract double values from the json object like this", "label": {"api": {"parseDouble": [[12, 22]]}}}, {"text": "Look at the arguments you're passing in to newXMLGregorianCalendar", "label": {"api": {"newXMLGregorianCalendar": [[43, 65]]}}}, {"text": "Another way using LocalTime", "label": {"api": {"LocalTime": [[18, 26]]}}}, {"text": "Here's the correct one that takes a CharSequence as an argument (string is a CharSequence)", "label": {"api": {"string is a CharSequence": [[65, 88]]}}}, {"text": "For instance, create JPanel with BorderLayout, add your panel with absolute layout to it with BorderLayer.CENTER and add your netbeans generated form as BorderLayout.LINE_END", "label": {"api": {"BorderLayout": [[33, 44], [153, 164]]}}}, {"text": "In your code, you can use before and after of Date API to perform the comparison in similar way", "label": {"api": {"before": [[26, 31]], "after": [[37, 41]]}}}, {"text": "But you can still use Java 8 to your advantage, with Map.getOrDefault()", "label": {"api": {"Map.getOrDefault()": [[53, 70]]}}}, {"text": "The class which can give you that key code is KeyEvent, not the TextField", "label": {"api": {"KeyEvent": [[46, 53]]}}}, {"text": "Or you could use java.sql.Timestamp, which has a valueOf() method, hat uses SQL timestamp format", "label": {"api": {"valueOf() method": [[49, 64]]}}}, {"text": "Another way could be to split the string by separators (like [-.]), parse them to integers, and use hese integers with the Timestamp() constructor..", "label": {"api": {"Timestamp() constructor": [[123, 145]]}}}, {"text": "The obvious solution is to use Files.move()", "label": {"api": {"Files.move()": [[31, 42]]}}}, {"text": "Use LocalDateTime with its toString()", "label": {"api": {"toString()": [[27, 36]]}}}, {"text": "Instead of using Long use AtomicLong and change the implementation to use a regular HashMap", "label": {"api": {"AtomicLong": [[26, 35]]}}}, {"text": "Look at class Matcher", "label": {"api": {"Matcher": [[14, 20]]}}}, {"text": "Check out File.exists()", "label": {"api": {"File.exists()": [[10, 22]]}}}, {"text": "Your code can be made a lot easier if you use a concurrent BlockingQueue, which allow to remove all your synchronized", "label": {"api": {"concurrent BlockingQueue": [[48, 71]]}}}, {"text": "The KeyFactory is used to convert between encoded keys and the Java classes that represent them", "label": {"api": {"KeyFactory": [[4, 13]]}}}, {"text": "However, the KeyFactory instance doesn't convert directly between a byte array and a Key class", "label": {"api": {"KeyFactory": [[13, 22]]}}}, {"text": "Instead, you must already know what format the encoding uses, and then create a KeySpec object using the byte array in the constructor", "label": {"api": {"KeySpec": [[80, 86]]}}}, {"text": "The format can be determined by called the getFormat() method on the key", "label": {"api": {"getFormat()": [[43, 53]]}}}, {"text": "Java9 reads this file wrongfully for Service Loading", "label": {"api": {"Service Loading": [[37, 51]]}}}, {"text": "For power you could use Math.pow(b, 2), or simply b * b", "label": {"api": {"Math.pow(b, 2)": [[24, 37]]}}}, {"text": "The answer here is to use ConcurrentHashMap's computeIfAbsent()", "label": {"api": {"computeIfAbsent()": [[46, 62]]}}}, {"text": "there's a computeIfAbsent method which does pretty much exactly what you need", "label": {"api": {"computeIfAbsent": [[10, 24]]}}}, {"text": "You could make use of Double.parseDouble Double Javadoc", "label": {"api": {"Double Javadoc": [[41, 54]]}}}, {"text": "You can then read domain-specific xml, transform it with that xsl and feed the result to spring", "label": {"api": {"transform": [[39, 47]]}}}, {"text": "The method Files.createDirectories succeeds whether the directory already exists or didn't exist and has been created", "label": {"api": {"Files.createDirectories": [[11, 33]]}}}, {"text": "If you really want to check whether the user entered an absolute path, just use Path.isAbsolute()", "label": {"api": {"Path.isAbsolute()": [[80, 96]]}}}, {"text": "A cleaner answer would be to use ScrollPane.setFitToWidth(boolean value) and ScrollPane.setFitToHeight(boolean value)", "label": {"api": {"ScrollPane.setFitToWidth(boolean value)": [[33, 71]], "ScrollPane.setFitToHeight(boolean value)": [[77, 116]]}}}, {"text": "The value of the number represented by the BigDecimal is therefore (unscaledValue × 10-scale), see Javadoc", "label": {"api": {"see Javadoc": [[95, 105]]}}}, {"text": "Java 8 Interable Foreach", "label": {"api": {"Java 8 Interable Foreach": [[0, 23]]}}}, {"text": "(using java.util.stream.Collectors.toMap(Function, Function))", "label": {"api": {"java.util.stream.Collectors.toMap(Function, Function)": [[7, 59]]}}}, {"text": "If you want just to display the text simply use a ListView<String>", "label": {"api": {"ListView<String>": [[50, 65]]}}}, {"text": "The interface that the debuggers will use to talk to the Java process is JDI 1, and it gives pretty much all of the information that the JVM has about your code", "label": {"api": {"JDI": [[73, 75]]}}}, {"text": "If a person has an ObjectReference to the object that contains your sensitive data, they can get its ReferenceType", "label": {"api": {"ObjectReference": [[19, 33]]}}}, {"text": "They can call ReferenceType::allFields to list all of the fields, including transient ones, in the class", "label": {"api": {"ReferenceType::allFields": [[14, 37]]}}}, {"text": "Back on the ObjectReference, they can call ObjectReference::getValue(Field) to get the field's value", "label": {"api": {"ObjectReference": [[12, 26], [43, 57]], "ObjectReference::getValue(Field)": [[43, 74]]}}}, {"text": "And that's also not in the JDI", "label": {"api": {"JDI": [[27, 29]]}}}, {"text": "1 Actually JDWP under the hood, but JDI is built on top of that and easier to discuss here", "label": {"api": {"JDI": [[36, 38]]}}}, {"text": "There is a getAndSet method especially for these case", "label": {"api": {"getAndSet": [[11, 19]]}}}, {"text": "This is achieved by using Java Robot class", "label": {"api": {"Robot": [[31, 35]]}}}, {"text": "Information coming from the database have a form of a ResultSet", "label": {"api": {"ResultSet": [[54, 62]]}}}, {"text": "A ResultSet has different fields", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "You can create instances of different classes and put values taken from the ResultSet in those istances", "label": {"api": {"ResultSet": [[76, 84]]}}}, {"text": "And then converting the sum of those two values into Character back to be added to the list using Character.forDigit as", "label": {"api": {"Character.forDigit": [[98, 115]]}}}, {"text": "Use JTextComponent.setCaretPosition(int) which", "label": {"api": {"JTextComponent.setCaretPosition(int)": [[4, 39]]}}}, {"text": "You control which card shows by using CarrdLayout show", "label": {"api": {"show": [[23, 26], [50, 53]]}}}, {"text": "You can inject HttpServletRequest in your resource class and use setAttribute() method to store application/pdf string within the context of current request", "label": {"api": {"setAttribute()": [[65, 78]]}}}, {"text": "It can be later obtained in ExceptionMapper using getAttribute() method", "label": {"api": {"getAttribute()": [[50, 63]]}}}, {"text": "Have you tried the JavaFX  WebView", "label": {"api": {"JavaFX  WebView": [[19, 33]]}}}, {"text": "You can convert both of these polygons into Areas, and then do a subtract from there", "label": {"api": {"Area": [[44, 47]]}}}, {"text": "Maybe you can use addTreeWillExpandListener and add a listener like this", "label": {"api": {"addTreeWillExpandListener": [[18, 42]]}}}, {"text": "Java TimerTask is not the ideal thing to use in the scenario that you want to cancel your task", "label": {"api": {"TimerTask": [[5, 13]]}}}, {"text": "See the Timer docs", "label": {"api": {"the Timer docs": [[4, 17]]}}}, {"text": "The Collections#binarySearch() method accepts a list of objects which extend the Comparable interface, and a key, and returns the index of the key in the list if found", "label": {"api": {"Collections#binarySearch()": [[4, 29]]}}}, {"text": "Here, the code used tryLock, which does not wait if it cannot acquire the lock", "label": {"api": {"tryLock": [[20, 26]]}}}, {"text": "Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool.commonPool() after it runs the given action", "label": {"api": {"commonPool()": [[103, 114]]}}}, {"text": "when the default commonPool() doesn't do what you want - then create your own ExecutorService instead", "label": {"api": {"commonPool()": [[17, 28]]}}}, {"text": "You will need to use JSONArray and JsonArrayBuilder to map these json arrays", "label": {"api": {"JSONArray": [[21, 29]], "JsonArrayBuilder": [[35, 50]]}}}, {"text": "You can use JASS (Java SE 8 only) with support of Krb5LoginModule which will let you to cache OS ticket", "label": {"api": {"Krb5LoginModule": [[50, 64]]}}}, {"text": "Both @QueryParam and @DefaultValue annotations can only be placed on resource method parameters, resource class fields or resource class bean properties", "label": {"api": {"@QueryParam": [[5, 15]], "@DefaultValue": [[21, 33]]}}}, {"text": "This is documented in the relevant javadoc", "label": {"api": {"the relevant javadoc": [[22, 41]]}}}, {"text": "sortEmployeeByCriteria is just an ordinary generic static method, taking a List of type T, and a Function which takes a T (or subclass) and produces something of type U (or subclass) and returns a (sorted) List of type T", "label": {"api": {"Function": [[97, 104]]}}}, {"text": "The unusual part is probably Comparator#comparing, which creates a Comparator which will compare Ts by the given mapping, i.e", "label": {"api": {"Comparator#comparing": [[29, 48]]}}}, {"text": "Employee::getName is basically a shorthand, a method reference you can pass instead of creating your own Function instance", "label": {"api": {"Function": [[105, 112]]}}}, {"text": "You need to declare a variable to hold the user's input", "label": {"api": {"variable": [[22, 29]]}}}, {"text": "Read your .properties file in a Properties object and then replace the placeholders by the values passed via VM arguments", "label": {"api": {"Properties": [[32, 41]]}}}, {"text": "The println(a) call to ends up calling Float.toString(a), which says", "label": {"api": {"Float.toString(a)": [[39, 55]]}}}, {"text": "Since KeyCode is an enum, you could use KeyCode.valueOf(String) to obtain the enum value from a string representation of the value, rather than relying on KeyCode.getKeyCode(String)", "label": {"api": {"KeyCode.valueOf(String)": [[40, 62]]}}}, {"text": "By default, sc.next() finds and returns the next complete token", "label": {"api": {"sc.next()": [[12, 20]]}}}, {"text": "For that, use ResultSet.next() that will return true until there is no more row to read", "label": {"api": {"ResultSet.next()": [[14, 29]]}}}, {"text": "Use java.awt.Toolkit for this", "label": {"api": {"java.awt.Toolkit": [[4, 19]]}}}, {"text": "The first parameter of Calendar.add() is a Unit of Time (Day, Week, Hour etc) as defined by the possible options outlined in the error", "label": {"api": {"Calendar.add()": [[23, 36]]}}}, {"text": "Calendar.SEPTEMBER is not a unit of time, it is a convenience constant representing the MONTH of September that is typically used in the set() method instead", "label": {"api": {"MONTH": [[88, 92]], "set()": [[137, 141]]}}}, {"text": "Assuming you're iterating through months, you'll need Calendar.MONTH instead", "label": {"api": {"MONTH": [[63, 67]]}}}, {"text": "Otherwise as mentioned -Xbootclasspath/p or -javaagent", "label": {"api": {"-javaagent": [[44, 53]]}}}, {"text": "You might find something in https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseEvent.html tho", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseEvent.html": [[28, 99]]}}}, {"text": "Pattern.quote(String s) does exactly what you want", "label": {"api": {"Pattern.quote(String s)": [[0, 22]]}}}, {"text": "What's happening here is that you create a custom Predicate used to filter the stream", "label": {"api": {"filter": [[68, 73]]}}}, {"text": "We migrated from Swing to JavaFX, and also exchanged a custom Swing TreeTableView control with JavaFX's TreeTableView", "label": {"api": {"TreeTableView": [[68, 80], [104, 116]]}}}, {"text": "Has anybody else experienced such problems with JavaFX's TreeTableView", "label": {"api": {"TreeTableView": [[57, 69]]}}}, {"text": "Another option is to use the Service Loader approach", "label": {"api": {"Service Loader": [[29, 42]]}}}, {"text": "You could make an ArrayList for each if condition and use al.contains(pirateID) for each one", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "Use the @PostConstruct annotation on an 'init' method in your Config2 class", "label": {"api": {"@PostConstruct": [[8, 21]]}}}, {"text": "Can anyone explain me the logic behind strange behavior of  Arrays.copyOfRange(byte[], int, int))", "label": {"api": {" Arrays.copyOfRange(byte[], int, int))": [[59, 96]]}}}, {"text": "You could work around it with a Reference<Source>", "label": {"api": {"Reference<Source>": [[32, 48]]}}}, {"text": "Take a look at Java 8 Optional class", "label": {"api": {"Java 8 Optional class": [[15, 35]]}}}, {"text": "String#split accepts a regular expression, so you can simply split on \\\\s+ (multiple whitspace)", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "withYear(int year) - Returns a copy of this LocalDate with the year altered", "label": {"api": {"LocalDate": [[44, 52]]}}}, {"text": "withMonth(int month) - Returns a copy of this LocalDate with the month-of-year altered", "label": {"api": {"LocalDate": [[46, 54]]}}}, {"text": "withDayOfMonth(int dayOfMonth) - Returns a copy of this LocalDate with the day-of-month altered", "label": {"api": {"LocalDate": [[56, 64]]}}}, {"text": "or does not alter the Predicate object it's used on, it returns a Predicate with that logic", "label": {"api": {"or": [[0, 1]]}}}, {"text": "Here, since you haven't assigned the return value anywhere you've just lost it, and the or call does nothing", "label": {"api": {"or": [[88, 89]]}}}, {"text": "Check the documentation for addEventHandler and setEventHandler (which gets called when you call any setOn prefixed method)", "label": {"api": {"addEventHandler": [[28, 42]], "setEventHandler": [[48, 62]]}}}, {"text": "One thing to keep in mind is that the handler attached with addEventHandler will be triggered before setOn method i.e", "label": {"api": {"addEventHandler": [[60, 74]]}}}, {"text": "You probably are looking for nextInt(int n) method from the Random class which can be used as", "label": {"api": {"nextInt(int n)": [[29, 42]]}}}, {"text": "(Behavior described in the javadocs for Cell)", "label": {"api": {"the javadocs for Cell": [[23, 43]]}}}, {"text": "But this not secure, instead read about Prepared Statement to avoid SQL Injection and syntax error", "label": {"api": {"Prepared Statement": [[40, 57]]}}}, {"text": "Also to find out the max you can make use of Math.max(int,int) as", "label": {"api": {"Math.max(int,int)": [[45, 61]]}}}, {"text": "In the contains(...) method entry in the ArrayList API", "label": {"api": {"ArrayList API": [[41, 53]]}}}, {"text": "You may have a look at Java 9’s Cleaner API, which addresses a similar task, cleanup built around a PhantomReference, and implement a similar thing, adapted it to your needs", "label": {"api": {"Cleaner": [[32, 38]]}}}, {"text": "This uses Java 8 features; if ConcurrentHashMap.newKeySet() is not available, you may use Collections.newSetFromMap(new ConcurrentHashMap<CleanerReference,Boolean>()) instead", "label": {"api": {"Cleaner": [[138, 144]]}}}, {"text": "Use EntityManager.createNativeQuery(String) to create a query from an SQL string", "label": {"api": {"EntityManager.createNativeQuery(String)": [[4, 42]]}}}, {"text": "Use the findAny terminal method", "label": {"api": {"findAny": [[8, 14]]}}}, {"text": "You could try to solve it with an regular expression using the String.matches(String regex) method", "label": {"api": {"String.matches(String regex)": [[63, 90]]}}}, {"text": "The Javadoc of double java.util.stream.DoubleStream.sum() answers your question", "label": {"api": {"double java.util.stream.DoubleStream.sum()": [[15, 56]]}}}, {"text": "You can use FloatBuffer to collect the float[], for example", "label": {"api": {"FloatBuffer": [[12, 22]]}}}, {"text": "I cannot find documentation about the particular behavior of FormatStyle set for the date portion and time portion of a DateTimeFormatter when automatically localizing", "label": {"api": {"FormatStyle": [[61, 71]], "DateTimeFormatter": [[120, 136]], "automatically localizing": [[143, 166]]}}}, {"text": "If you want to know the patterns, though, you can use the DateTimeFormatterBuilder.getLocalizedDateTimePattern method within the same nested loops", "label": {"api": {"DateTimeFormatterBuilder.getLocalizedDateTimePattern method": [[58, 116]]}}}, {"text": "You will need to use low level networking working directly with java.net.Socket objects", "label": {"api": {"java.net.Socket": [[64, 78]]}}}, {"text": "With this class, you can create a fixed clock (a Clock that always returns the same current date/time) and use it in your test", "label": {"api": {"fixed clock": [[34, 44]]}}}, {"text": "Searching for the next unprocessed value is easy with nextSetBit", "label": {"api": {"nextSetBit": [[54, 63]]}}}, {"text": "You'd better use Client instead of ResteasyClient whenever possible to ensure portability with other implementations", "label": {"api": {"Client": [[17, 22], [43, 48]]}}}, {"text": "Response instances that contain an un-consumed entity input stream should be closed", "label": {"api": {"Response": [[0, 7]]}}}, {"text": "Going beyond the scope of the question, bear in mind that Client instances are heavy-weight objects that manage the underlying client-side communication infrastructure", "label": {"api": {"Client": [[58, 63]]}}}, {"text": "Hence initialization as well as disposal of a Client instance may be a rather expensive operation", "label": {"api": {"Client": [[46, 51]]}}}, {"text": "The documentation advises to create only a small number of Client instances and reuse them when possible", "label": {"api": {"Client": [[59, 64]]}}}, {"text": "It also states that Client instances must be properly closed before being disposed to avoid leaking resources", "label": {"api": {"Client": [[20, 25]]}}}, {"text": "Use java.security.MessageDigest with algorithm SHA-256", "label": {"api": {"java.security.MessageDigest": [[4, 30]]}}}, {"text": "The best choice is GridBagLayout", "label": {"api": {"GridBagLayout": [[19, 31]]}}}, {"text": "The use of GridBagConstraints.REMAINDER in a constraint will tell the GridBagLayout to make a child component take up an entire row", "label": {"api": {"GridBagLayout": [[70, 82]]}}}, {"text": "The use of weighty = 1 tells the GridBagLayout that the grid cell of the child about to be added should take up all extra vertical space, when the panel is larger than its children", "label": {"api": {"GridBagLayout": [[33, 45]]}}}, {"text": "This is exactly what substring does..", "label": {"api": {"substring": [[21, 29]]}}}, {"text": "You can fix the first part using the Class.isInstance method", "label": {"api": {"Class.isInstance": [[37, 52]]}}}, {"text": "System is a class name used in the same context, so you either use fully qualified name for the class usage java.lang.System or you simply rename your variable(I would prefer this, helps understanding code conventions)", "label": {"api": {"java.lang.System": [[108, 123]]}}}, {"text": "The java.io.FileReader class uses streams to read the file", "label": {"api": {"java.io.FileReader": [[4, 21]]}}}, {"text": "Your code never calls the close() method inherited from the InputStreamReader class on the libraryReader object", "label": {"api": {"close()": [[26, 32]]}}}, {"text": "You can add a finally block in order to close the reader or use the try-with-resources statement - available from Java8  - since the FileReader class implements the AutoCloseable interface", "label": {"api": {"AutoCloseable": [[165, 177]]}}}, {"text": "You will therefore need to create your own custom Comparator, and pass that to the constructors of all TreeMaps that you create", "label": {"api": {"Comparator": [[50, 59]], "constructors": [[83, 94]]}}}, {"text": "An alternate way of setting all the values to true would be using Arrays.fill with an iteration over one dimension as", "label": {"api": {"Arrays.fill": [[66, 76]], "Arrays": [[66, 71]]}}}, {"text": "Since the Arrays does not have an existing implementation of setAll for a boolean[]  and it ends up consuming setAll(T[] array,IntFunction<", "label": {"api": {"Arrays": [[10, 15]]}}}, {"text": "You could bind all query parameters to a Map<String, String> or MultiValueMap<String, String> using @RequestParam", "label": {"api": {"Map<String, String>": [[41, 59], [74, 92]]}}}, {"text": "If the method parameter is  Map<String, String> or MultiValueMap<String, String> and a parameter name is not specified, then the map parameter is populated with all request parameter names and values", "label": {"api": {"Map<String, String>": [[28, 46], [61, 79]]}}}, {"text": "From the documentation for ScheduledExecutorService.scheduleAtFixedRate()", "label": {"api": {"the documentation for ScheduledExecutorService.scheduleAtFixedRate()": [[5, 72]]}}}, {"text": "I would guess the call to executor.notifyAll() which is documented to throw an IllegalMonitorStateException", "label": {"api": {"is documented": [[53, 65]]}}}, {"text": "ExecutorService was designed to support cancellation of tasks that respond to interruption", "label": {"api": {"cancellation": [[40, 51]]}}}, {"text": "Calling interrupted() will clear the interrupted status", "label": {"api": {"interrupted()": [[8, 20]]}}}, {"text": "Calling Thread.currentThread().isInterrupted() will preserve the interrupted status", "label": {"api": {"Thread.currentThread().isInterrupted()": [[8, 45]]}}}, {"text": "To re-assert the interrupted status after catching an InterruptedException or detecting it with Thread.interrupted(), simply call Thread.currentThread().interrupt()", "label": {"api": {"interrupted()": [[103, 115]]}}}, {"text": "and change your return value to a Response object", "label": {"api": {"Response": [[34, 41]]}}}, {"text": "When you use Response.Ok, the response will have code \"200 OK\", and you can study the Response class methods for returning any HTTP code you desire", "label": {"api": {"Response": [[13, 20], [86, 93]]}}}, {"text": "returning a 404 HTTP code (look at Response.Status list of codes)", "label": {"api": {"Response": [[35, 42]], "Response.Status": [[35, 49]]}}}, {"text": "The problem is probably with SO_LINGER socket option", "label": {"api": {"SO_LINGER": [[29, 37]]}}}, {"text": "while working on performance sensitive code I discovered that HashSet should offer constant time performance for its add, remove, contains and size methods as long as the hash-function returns unique hashes for the elements in the set (HashSet Javadoc)", "label": {"api": {"HashSet Javadoc": [[236, 250]]}}}, {"text": "If you really want to, you can use the static method BorrowedConnectionProxy.getWrappedConnection(...) to unwrap to what perhaps is the c3p0 NewProxyConnection", "label": {"api": {"unwrap": [[106, 111]]}}}, {"text": "You could also use the JDBC Connection standard method unwrap", "label": {"api": {"unwrap": [[55, 60]]}}}, {"text": "Array methods are standard JDBC nowadays, you don't have to unwrap to the native Connection to use them", "label": {"api": {"unwrap": [[60, 65]]}}}, {"text": "See AffineTransform.createTransformedShape(Shape) which", "label": {"api": {"AffineTransform.createTransformedShape(Shape)": [[4, 48]]}}}, {"text": "However, for this to work the API indicates the Callable/Runnable must be well behaved and respond when it is interrupted", "label": {"api": {"API": [[30, 32]]}}}, {"text": "Another option is to use JList#setSelectionBackground(Color)", "label": {"api": {"JList#setSelectionBackground(Color)": [[25, 59]]}}}, {"text": "I suppose you're using Socket.connect(SocketAddress) method", "label": {"api": {"Socket.connect(SocketAddress)": [[23, 51]]}}}, {"text": "There is another Socket.connect(SocketAddress, int) where you can specify timeout as the second parameter", "label": {"api": {"Socket.connect(SocketAddress, int)": [[17, 50]]}}}, {"text": "to get an instance of ZoneId", "label": {"api": {"ZoneId": [[22, 27]]}}}, {"text": "Alternatively you can use getOffset() to obtain ZoneOffset,which is more handy if you need to access the timezone offset in a numeric form", "label": {"api": {"ZoneOffset": [[48, 57]]}}}, {"text": "You may just use String#split if you are sure the format of string is already the same", "label": {"api": {"String#split": [[17, 28]]}}}, {"text": "I'd recommend using a HashMap instead", "label": {"api": {"HashMap": [[22, 28]]}}}, {"text": "Keep in mind, however, that HashMaps don't keep their order as stable as an array does, so iterating through a HashMap may not get the same order every time", "label": {"api": {"HashMap": [[28, 34], [111, 117]]}}}, {"text": "If you are starting with an array, you can use Arrays.asList(T...) to construct a List view of your array, backed by the real array", "label": {"api": {"Arrays.asList(T...)": [[47, 65]]}}}, {"text": "You can use List#subList(fromIndex, toIndex) to create a view of the list starting from the second item", "label": {"api": {"List#subList(fromIndex, toIndex)": [[12, 43]]}}}, {"text": "I'm not sure which version of JAX-RS is supposed to be used in that example (in the article), but accordingly to the jax-rs documentation, result of getSize is ignored for JAX-RS 2.0, but for JAX-RS 1.X it seems to be used and \"return 0\" makes downloaded file empty", "label": {"api": {"jax-rs documentation": [[117, 136]]}}}, {"text": "Since Java 8, there is the java.util.function-package, providing interfaces for basic transformation", "label": {"api": {"java.util.function-package": [[27, 52]]}}}, {"text": "In particular, the interface Function can be used to fit your purpose", "label": {"api": {"Function": [[29, 36]]}}}, {"text": "You need to change the way you initiate FileWritter to append, like so", "label": {"api": {"FileWritter": [[40, 50]]}}}, {"text": "javafx.concurrent.Task is a Runnable, so when you pass it to ExecutorService.submit(Runnable), a Future<?> is returned", "label": {"api": {"javafx.concurrent.Task": [[0, 21]], "ExecutorService.submit(Runnable)": [[61, 92]]}}}, {"text": "I tried DocumentFilter, but it seems to be too simple and it can mess up caret/selection", "label": {"api": {"DocumentFilter": [[8, 21]]}}}, {"text": "So I thought about writing my very own StyledEditorKit subclass, but there's a load of Actions to implement and a lot of technical details, which I am not certaing about", "label": {"api": {"StyledEditorKit": [[39, 53]], "Actions": [[87, 93]]}}}, {"text": "You could also probably use a built-in method, so check the Java Documentation at https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html if you'd like a more cleaner and perhaps more efficient way of doing this", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[82, 144]]}}}, {"text": "You may want to use convertPoint method from SwingUtilities class", "label": {"api": {"convertPoint": [[20, 31]]}}}, {"text": "You can use WindowContants on JFrame#setDefaultCloseOperation to achieve the desired action", "label": {"api": {"WindowContants": [[12, 25]], "JFrame#setDefaultCloseOperation": [[30, 60]]}}}, {"text": "The javadoc for Class shows it derives from Object, hence it is an object.You can call toString(), hashCode() etc", "label": {"api": {"Class": [[16, 20]]}}}, {"text": "on a Class object", "label": {"api": {"Class": [[5, 9]]}}}, {"text": "In addition you can call Class-specific methods to identify specific properties", "label": {"api": {"Class": [[25, 29]]}}}, {"text": "To solve this, your class needs to implement the Serializable interface", "label": {"api": {"Serializable": [[49, 60]]}}}, {"text": "If you want to store larger values, consider using primitive long, or class BigInteger", "label": {"api": {"BigInteger": [[76, 85]]}}}, {"text": "To quote the documentation for intern (emphasis mine)", "label": {"api": {"intern": [[31, 36]]}}}, {"text": "When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned", "label": {"api": {"intern": [[9, 14]]}}}, {"text": "The only way you might get away without closing a stream is if it is clearly documented that the specific implementation does not need closing (as with ByteArrayInputStream of Oracle JDK 7 and in the OpenJDK code) and you are sure that only this implementation is used", "label": {"api": {"ByteArrayInputStream of Oracle JDK 7": [[152, 187]]}}}, {"text": "I have two LongProperty (there are no decimal places in a long) variables (longProperty1 and longProperty2)", "label": {"api": {"LongProperty": [[11, 22]]}}}, {"text": "I need to divide them and I need to keep the division result in a DoubleProperty (there are decimal places in a double) variable (result) without losing decimal places", "label": {"api": {"DoubleProperty": [[66, 79]]}}}, {"text": "longProperty1 and longProperty2 are of type LongProperty because they receive very large numbers, so I can't cast them to DoubleProperties", "label": {"api": {"LongProperty": [[44, 55]]}}}, {"text": "Bindings is a utility class for creating bindings", "label": {"api": {"Bindings": [[0, 7]]}}}, {"text": "Use a Timeline, with event handlers on the KeyFrames", "label": {"api": {"Timeline": [[6, 13]], "event handlers on the KeyFrames": [[21, 51]]}}}, {"text": "Use Java's Observer and Observable, which are set up for proper handling of multiple subjects", "label": {"api": {"Observer": [[11, 18]], "Observable": [[24, 33]]}}}, {"text": "Replace List with Set, and then get String array without duplicated string", "label": {"api": {"Set": [[18, 20]]}}}, {"text": "Set is a collection that contains no duplicate elements", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "Well if your intentions are to loop, you should use the overloaded method of the schedule over Timer as", "label": {"api": {"schedule": [[81, 88]]}}}, {"text": "which would schedule the specified task for repeated fixed-delay execution, beginning after the specified delay", "label": {"api": {"schedule": [[12, 19]]}}}, {"text": "Using methods available from the File and String classes you can do much more", "label": {"api": {"File": [[33, 36]], "String": [[42, 47]]}}}, {"text": "First, File.getName() will get you the name part of file path, separate from the directory", "label": {"api": {"File": [[7, 10]], "File.getName()": [[7, 20]]}}}, {"text": "Now you can go to work on the file name with methods from String", "label": {"api": {"String": [[58, 63]]}}}, {"text": "For your examples, startsWith() would be ideal", "label": {"api": {"startsWith()": [[19, 30]]}}}, {"text": "There's also endsWith in case you'd like to filter out specific extensions as well", "label": {"api": {"endsWith": [[13, 20]]}}}, {"text": "There are all sorts of ways you can examine and test Strings that might come in handy either now or in the future", "label": {"api": {"String": [[53, 58]]}}}, {"text": "You can use substring() to peek inside the name, or even matches() for really tricky filtering", "label": {"api": {"substring()": [[12, 22]], "matches()": [[57, 65]]}}}, {"text": "Normally, you achieve the case-insensitivity with using method equalsIgnoreCase()", "label": {"api": {"equalsIgnoreCase()": [[63, 80]]}}}, {"text": "Thus you can parse all the values in lower-case using the method toLowerCase() forcing them to be compared case insensitively", "label": {"api": {"toLowerCase()": [[65, 77]]}}}, {"text": "I have taken a look on the JavaEE documentation of CriteriaBuilder and found the method lower() which may be helpful", "label": {"api": {"lower()": [[88, 94]]}}}, {"text": "Use the more flexible Lock interface (i.e", "label": {"api": {"Lock": [[22, 25]]}}}, {"text": "for example ReentrantLock), which allows you to call tryLock(long time, TimeUnit unit) to prevent waiting forever", "label": {"api": {"Lock": [[21, 24], [56, 59]]}}}, {"text": "I suggest to use ExecutorService.submit(Runnable) method instead of execute", "label": {"api": {"ExecutorService.submit(Runnable)": [[17, 48]]}}}, {"text": "Alternatively, instead of creating your own class that implements the Comparable interface, you could use a custom Comparator", "label": {"api": {"Comparator": [[115, 124]]}}}, {"text": "With a custom Comparator", "label": {"api": {"Comparator": [[14, 23]]}}}, {"text": "Ordering implements Comparator, but there'd be nothing wrong with defining an Ordering and invoking it in a Comparable's .compareTo() method", "label": {"api": {"Comparator": [[20, 29]]}}}, {"text": "Most of its functionality is now provided by Stream and by Comparator itself, and the rest can now be found as static methods in our new Comparators class", "label": {"api": {"Stream": [[45, 50]], "Comparator": [[59, 68], [137, 146]]}}}, {"text": "You can try session.setMaxInactiveInterval", "label": {"api": {"session.setMaxInactiveInterval": [[12, 41]]}}}, {"text": "the Predicate interface in java 8 has a static method like", "label": {"api": {"Predicate interface": [[4, 22]]}}}, {"text": "The Javadoc of that method states", "label": {"api": {"Javadoc of that method": [[4, 25]]}}}, {"text": "ConcurrentMap is guarantee about synchronization or atomicity", "label": {"api": {"ConcurrentMap": [[0, 12]], "Map": [[10, 12]]}}}, {"text": "A Map providing thread safety and atomicity guarantees", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "Map isn't guarantee about synchronization or atomicity", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "My JavaFX program has a list a of IP addresses in a ListView, I want to loop through each of these addresses periodically and call INetAddress.isReachable on each one", "label": {"api": {"INetAddress.isReachable": [[131, 153]]}}}, {"text": "From https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/TreeCell.html I know the following", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/TreeCell.html": [[5, 82]]}}}, {"text": "You have to use the built-in subtract() method in order to subtract those BigDecimal objects", "label": {"api": {"subtract()": [[29, 38]]}}}, {"text": "Here is the official api docs", "label": {"api": {"official api docs": [[12, 28]]}}}, {"text": "Or you could just generate a stream of random numbers, and create the array directly from the stream, using toArray", "label": {"api": {"toArray": [[108, 114]]}}}, {"text": "I found some information on compiling Java programmatically via the tools API but this not like scripting (i.e", "label": {"api": {"tools API": [[68, 76]]}}}, {"text": "Try BeanShell or the Compiler API or javax.script ..", "label": {"api": {"Compiler API": [[21, 32]], "javax.script": [[37, 48]]}}}, {"text": "You have to add a println statement to put the linebreak after your loop", "label": {"api": {"println": [[18, 24]]}}}, {"text": "Auto-closing the Statement will automatically close the ResultSet as well", "label": {"api": {"automatically close the ResultSet": [[32, 64]]}}}, {"text": "Item 5 discusses this in more detail, and discourages ever using the new String(String) constructor", "label": {"api": {"new String(String)": [[69, 86]]}}}, {"text": "The closest I could find is the ReentrantReadWriteLock, but it's recursive which is not what I'm looking for", "label": {"api": {"ReentrantReadWriteLock": [[32, 53]]}}}, {"text": "This is a conditional feature, to check if it is supported see Platform.isSupported(javafx.application.ConditionalFeature)", "label": {"api": {"Platform.isSupported(javafx.application.ConditionalFeature)": [[63, 121]]}}}, {"text": "If the feature is not supported by the platform, this style downgrades to StageStyle.DECORATED", "label": {"api": {"StageStyle.DECORATED": [[74, 93]]}}}, {"text": "As suggested by @Basil in the comments below, You can also use java.time.Instant class", "label": {"api": {"java.time.Instant": [[63, 79]]}}}, {"text": "and while retrieving , use ResultSet#getObject(int/String, Class<T>)", "label": {"api": {"ResultSet#getObject(int/String, Class<T>)": [[27, 67]]}}}, {"text": "But since System.currentTimeMillis() uses the system's date and time, what you get when using this piece of code is correct according to the specifications", "label": {"api": {"specifications": [[141, 154]]}}}, {"text": "According to JavaDoc of that clas you have to extends it and then implement initialization as you wish", "label": {"api": {"JavaDoc of that clas": [[13, 32]]}}}, {"text": "Your ClassLoader has the sun.misc.Launcher$AppClassLoader1 as a parent, because as described in the Javadoc of the default constructor (which is implicitly invoked in the ClassLoaderGw class, because there is no explicit constructor)", "label": {"api": {"default constructor": [[115, 133]]}}}, {"text": "Process each row of data from the ResultSet and create a Vector and use this method to insert the data into the table model", "label": {"api": {"use this method": [[68, 82]]}}}, {"text": "To repaint only \"dirty\" regions of a large JComponent you will need to use the RepaintManager", "label": {"api": {"RepaintManager": [[79, 92]]}}}, {"text": "You can get the current RepaintManager with", "label": {"api": {"RepaintManager": [[24, 37]]}}}, {"text": "You can even replace the RepaintManager with your own custom version", "label": {"api": {"RepaintManager": [[25, 38]]}}}, {"text": "You can use CriteriaBuilder#function() to execute a database function to add days into retentionDate", "label": {"api": {"CriteriaBuilder#function()": [[12, 37]]}}}, {"text": "This behaviour is controlled by the ServerEndpointConfig.Configurator#getEndpointInstance method", "label": {"api": {"ServerEndpointConfig.Configurator#getEndpointInstance": [[36, 88]]}}}, {"text": "You are probably looking for using contains and indexOf methods of String class in java, to use them as", "label": {"api": {"contains": [[35, 42]], "indexOf": [[48, 54]], "String": [[67, 72]]}}}, {"text": "It happens because the read method of the ObjectInputStream returns an int (See Javadoc)", "label": {"api": {"See Javadoc": [[76, 86]]}}}, {"text": "But I recommend to use Java 8 new API for date LocalDate as suggested in Hugo's answer", "label": {"api": {"LocalDate": [[47, 55]]}}}, {"text": "To find the next Sunday, use Java 8 LocalDate and either TemporalAdjusters.nextOrSame(...) or TemporalAdjusters.next(...)", "label": {"api": {"LocalDate": [[36, 44]], "TemporalAdjusters.nextOrSame(...)": [[57, 89]], "TemporalAdjusters.next(...)": [[94, 120]]}}}, {"text": "In general the ConcurrentHashMap is far superior to your implementation and you should use that", "label": {"api": {"ConcurrentHashMap": [[15, 31]]}}}, {"text": "Using a method reference to Objects.nonNull is an elegant way of filtering them out", "label": {"api": {"Objects.nonNull": [[28, 42]]}}}, {"text": "You can use setScale to round number to any given decimal places", "label": {"api": {"setScale": [[12, 19]]}}}, {"text": "Set.toArray() returns a java.lang.Object[] in Java, which will be marshalled to a JavaScript array when used in JavaScript", "label": {"api": {"Set.toArray()": [[0, 12]]}}}, {"text": "If you want to generate a sequence of identifiers that are unique within the lifetime of the JVM, you could use an AtomicInteger counter in the super class", "label": {"api": {"AtomicInteger": [[115, 127]]}}}, {"text": "Instead, you should use the String.equals() method", "label": {"api": {"String.equals()": [[28, 42]]}}}, {"text": "using java's Intrumentation interface like below", "label": {"api": {"Intrumentation": [[13, 26]]}}}, {"text": "Your approach to String#format is wrong", "label": {"api": {"String#format": [[17, 29]]}}}, {"text": "You could use the Console class for that.The following code could give you some inspiration", "label": {"api": {"Console": [[18, 24]]}}}, {"text": "You can configure the Jackson ObjectMapper in a ContextResolver", "label": {"api": {"ContextResolver": [[48, 62]]}}}, {"text": "The \"Resource Bundles in Named Modules\" section of ResourceBundle provides the details on how resources in named modules are located", "label": {"api": {"ResourceBundle": [[51, 64]]}}}, {"text": "A simple place to start is the java.io.File list method (and related methods)", "label": {"api": {"java.io.File list method": [[31, 54]]}}}, {"text": "At the very least, convert the mediaIds to a Set, and use the contains method which should have an O(1) time complexity", "label": {"api": {"contains": [[62, 69]]}}}, {"text": "Java 9 came out, and Observer has been deprecated", "label": {"api": {"Observer": [[21, 28]]}}}, {"text": "Instead of declaring digits by yourself in the code, you can take a look at Character.isDigit() method in Java", "label": {"api": {"Character.isDigit()": [[76, 94]]}}}, {"text": "You are probably looking for the flush() method, which does exactly that", "label": {"api": {"flush()": [[33, 39]]}}}, {"text": "One approach would be to leverage the flyweight rendering afforded by ListView to create a line editor", "label": {"api": {"ListView": [[70, 77]]}}}, {"text": "Simply using String.format would do the trick", "label": {"api": {"String.format": [[13, 25]]}}}, {"text": "You could use @NotNull or @NotBlank from Hibernate Validator, the Bean Validation reference implementation", "label": {"api": {"@NotNull": [[14, 21]]}}}, {"text": "Use the @DependsOn annotation to declare an initialization dependency on startup beans", "label": {"api": {"@DependsOn": [[8, 17]]}}}, {"text": "Your usage of a Map is flawed", "label": {"api": {"Map": [[16, 18]]}}}, {"text": "Maps take a unique key and return a value", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Instead, look at using a List with a wrapper class", "label": {"api": {"List": [[25, 28]]}}}, {"text": "To add to the list, create a new instance of your class and call List#add", "label": {"api": {"List": [[65, 68]], "List#add": [[65, 72]]}}}, {"text": "When you call aMap.forEach { k, v -> println(\"$k -> $v\")}, you are calling the Java version of the method", "label": {"api": {"Java version": [[79, 90]]}}}, {"text": "Try using the FileHandler constructor that allows you to specify the boolean argument for append mode", "label": {"api": {"FileHandler constructor": [[14, 36]]}}}, {"text": "As others have suggested, a UUID would solve your problem", "label": {"api": {"UUID": [[28, 31]]}}}, {"text": "Using regular expressions gets you around that and it's not that hard either, given you just use the patterns from the documentation I linked", "label": {"api": {"patterns from the documentation I linked": [[101, 140]]}}}, {"text": "Using a floating-point number (double is a floating-point number) instead, is not a good practice", "label": {"api": {"(double is a floating-point number)": [[30, 64]]}}}, {"text": "You can do this simply by injecting those two controllers into the main controller, as described in the \"Nested Controllers\" section in the documentation", "label": {"api": {"\"Nested Controllers\"": [[104, 123]]}}}, {"text": "To sort directories last, identify a directory by calling File.isDirectory(), which returns true if it's a directory, and use Boolean.compare(boolean x, boolean y) to sort by boolean value (false sorts before true)", "label": {"api": {"File.isDirectory()": [[58, 75]], "Boolean.compare(boolean x, boolean y)": [[126, 162]]}}}, {"text": "The documentation for drawString says as follows (emphasis mine)", "label": {"api": {"documentation for drawString": [[4, 31]]}}}, {"text": "The documentation for fillRect says as follows (emphasis mine)", "label": {"api": {"documentation for fillRect": [[4, 29]]}}}, {"text": "Read more about Collections#unmodifiableMap(Map)", "label": {"api": {"Collections#unmodifiableMap(Map)": [[16, 47]]}}}, {"text": "Look at the java.util.concurrent package for other options", "label": {"api": {"java.util.concurrent": [[12, 31]]}}}, {"text": "If you know that you have an HashMap, you can use its Map API within Nashorn, i.e.", "label": {"api": {"Map API": [[54, 60]]}}}, {"text": "You can try this code, it's using Java 8 nio API", "label": {"api": {"Java 8 nio API": [[34, 47]]}}}, {"text": "You can also implement your one which does exactly you want using  @FunctionalInterface", "label": {"api": {"@FunctionalInterface": [[67, 86]]}}}, {"text": "as @JohnBollinger pointed in the comments section, I checked and resourceMethod.getDeclaringClass() == IRESTfulCRUDResource, so it's counterintuitive but ResourceInfo's getResourceMethod points to the parent method but getResourceClass points to the child class", "label": {"api": {"ResourceInfo": [[154, 165]]}}}, {"text": "You can for example use the CellFactory of the TreeView to attach an EventFilter on mouse listener to the TreeCells of the tree", "label": {"api": {"CellFactory": [[28, 38]], "TreeCell": [[106, 113]]}}}, {"text": "In this case you can remove the CellFactory completely and add the EventFilter to the ImageView (e.g", "label": {"api": {"CellFactory": [[32, 42]]}}}, {"text": "Refer to Java's documentation for more info on String.format()", "label": {"api": {"Java's documentation": [[9, 28]]}}}, {"text": "the javadoc of the class has useful information regarding strategies for queuing", "label": {"api": {"javadoc of the class": [[4, 23]]}}}, {"text": "there is no problem in writing it by yourself, it's just a call to System.getProperty(), Properties.load() etc", "label": {"api": {"Properties.load()": [[89, 105]]}}}, {"text": "You can achieve this by providing the logic to be executed by a new thread in form of Callable instead of Runnable", "label": {"api": {"Callable": [[86, 93]]}}}, {"text": "Unlike Runnable, Callable allows you to return some result to the code that invokes it in form of Future", "label": {"api": {"Callable": [[17, 24]], "Future": [[98, 103]]}}}, {"text": "I would also recommend to read ThreadPoolExecutor + Callable + Future Example article and JavaDocs for Callable, Future and ExecutorService classes", "label": {"api": {"Callable": [[52, 59], [103, 110]], "Future": [[63, 68], [113, 118]], "ExecutorService": [[124, 138]]}}}, {"text": "You have to explicitely hide the button on the click action using the setVisible(false) method", "label": {"api": {"setVisible(false)": [[70, 86]]}}}, {"text": "There is an existing class ClassValue which already does the job for you", "label": {"api": {"ClassValue": [[27, 36]]}}}, {"text": "replace(...) replaces all the occurences of given substring with another substring", "label": {"api": {"replace(...)": [[0, 11]]}}}, {"text": "What you're looking for is replaceFirst(...) for replacement of first letter,  but replacing last one won't be so easy", "label": {"api": {"replaceFirst(...)": [[27, 43]]}}}, {"text": "In this case, I'd go with usage of substring(...) and manual concatenation", "label": {"api": {"substring(...)": [[35, 48]]}}}, {"text": "Alternatively, you can use replaceAll(...) that works with regular expressions and use beginning/end of line/input constructs (^$\\A\\Z)", "label": {"api": {"replaceAll(...)": [[27, 41]], "regular expressions": [[59, 77]]}}}, {"text": "You can combine ScheduledExecutorService to run some code every second and this answer to set timeout on that code", "label": {"api": {"ScheduledExecutorService": [[16, 39]]}}}, {"text": "Using a Java agent, it is possible to redefine modules to export/open the required packages", "label": {"api": {"Java agent": [[8, 17]]}}}, {"text": "In order to get hold of the Instrumentation instance, you can either write a Java agent what is quite simple and specify it on the command line (rather than the classpath) using -javaagent:myjar.jar", "label": {"api": {"Java agent": [[77, 86]]}}}, {"text": "Note that this is only available on JDKs and on Linux VM whereas you would need to supply the Byte Buddy agent on the command line as a Java agent if you needed it on other VMs", "label": {"api": {"Java agent": [[136, 145]]}}}, {"text": "This looks like a good candidate for a ForkJoinPool", "label": {"api": {"ForkJoinPool": [[39, 50]]}}}, {"text": "I think it is a misconception on your end to assume that modules were designed to prevent all kinds of LinkageError (the mother of all No..FoundError thingies)", "label": {"api": {"LinkageError": [[103, 114]]}}}, {"text": "Here's some code which you can use to achieve your objective and includes the System.out.printf(String, Object...) method for printing (this method provides a lot more control over output format than System.out.println(String) alone; printf documentation can be seen h̲e̲r̲e̲)", "label": {"api": {"h̲e̲r̲e̲": [[267, 274]]}}}, {"text": "Instead consider streamlining your code using other java 8 additions -- Map#forEach and Map#computeIfAbsent", "label": {"api": {"Map#forEach": [[72, 82]], "Map#computeIfAbsent": [[88, 106]]}}}, {"text": "If it's not what you expect, time to print the whole line and start experimenting with how String.split() works in Java and how to get it to parse your line correctly", "label": {"api": {"String.split()": [[91, 104]]}}}, {"text": "You'll probably want to add a CellFactory to the given column (don't mix with CellValueFactory)", "label": {"api": {"CellFactory": [[30, 40]], "CellValueFactory": [[78, 93]]}}}, {"text": "I didn't find anything better than how each field was handled manually using the method URLEncoder.encode(String s, String enc)", "label": {"api": {"URLEncoder.encode(String s, String enc)": [[88, 126]]}}}, {"text": "I have class Collector and ThreadLocalScope like this", "label": {"api": {"ThreadLocal": [[27, 37]]}}}, {"text": "The Collector is initialized in a ThreadLocal", "label": {"api": {"ThreadLocal": [[34, 44]]}}}, {"text": "The only difference is I have added Collector as a member variable rather than calling ThreadLocalScope.get() every time", "label": {"api": {"ThreadLocal": [[87, 97]]}}}, {"text": "There may be a solution using a PipedInputStream / PipedOutputStream from the JDK, but I guess it would be simpler for you to swicth from InputStreamEntity to EntityTemplate in HTTPClient's API", "label": {"api": {"PipedInputStream": [[32, 47]]}}}, {"text": "It sounds like you're just looking for the convert method", "label": {"api": {"convert": [[43, 49]]}}}, {"text": "I tried to use Deflater, Base64.Encoder, URIEncoder and URI classes (two last without urls because my reputation < 10), but output is totally different", "label": {"api": {"Deflater": [[15, 22]], "Base64.Encoder": [[25, 38]]}}}, {"text": "Java provides a class that maintains an addition time zone", "label": {"api": {"class that maintains an addition time zone": [[16, 57]]}}}, {"text": "As @Thomas's answer said, one alternative is to use xxx (or XXX), as explained in javadoc", "label": {"api": {"explained in javadoc": [[69, 88]]}}}, {"text": "You can create a file using the File.createNewFile method, or, if you are using Java 7 or newer, using the newer Files.createFile method", "label": {"api": {"File.createNewFile": [[32, 49]], "Files.createFile": [[113, 128]]}}}, {"text": "I use the date validaton using the @Future annotation", "label": {"api": {"@Future": [[35, 41]]}}}, {"text": "You can use DataOutputStream which allows you to send different types over a stream", "label": {"api": {"DataOutputStream": [[12, 27]]}}}, {"text": "After you have initialized a Stream you can receive the data (with different types) on the Server using DataInputStream", "label": {"api": {"DataInputStream": [[104, 118]]}}}, {"text": "The drawing is done inside a custom JPanel's paintComponent method", "label": {"api": {"JPanel": [[36, 41]], "paintComponent": [[45, 58]]}}}, {"text": "A drawing is, lets say, a drawRect method call", "label": {"api": {"drawRect": [[26, 33]]}}}, {"text": "Use/Alter an AffineTransform which handles the scaling of the drawing, just before the drawing is drawn", "label": {"api": {"AffineTransform": [[13, 27]]}}}, {"text": "1 button for the first mode (\"Draw scale\") and 1 button for the second mode (\"AffineTransform scale\")", "label": {"api": {"AffineTransform": [[78, 92]]}}}, {"text": "I need the AffineTransform object to change accordingly to the user's drag gesture such that when the transform is applied to the drawing, then the drawing scales where the user's mouse is", "label": {"api": {"AffineTransform": [[11, 25]]}}}, {"text": "Select \"AffineTransform scale\"", "label": {"api": {"AffineTransform": [[8, 22]]}}}, {"text": "As you can read from the newer documentation of Hibernate 5.2 about the same named class and its method Query#getResultList is the overridden implementation of the the javax interface's method TypedQuery#getResultList", "label": {"api": {"TypedQuery#getResultList": [[193, 216]]}}}, {"text": "The Java API states", "label": {"api": {"Java API": [[4, 11]]}}}, {"text": "Your PauseTransition defines a pause of three seconds (btw Duration.seconds(3) would have been clearer)", "label": {"api": {"Duration.seconds(3)": [[59, 77]]}}}, {"text": "Note there is no need to create a PauseTransition, a FadeTransition and then combine them into a SequentionalTransition, the Animation superclass has a setDelay() which you can use to delay the execution of the animation", "label": {"api": {"setDelay()": [[152, 161]]}}}, {"text": "Another concrete example of a supplier is when a new Object is needed for a function, created on the spot, such as for the Collectors.toCollection(Supplier<C> factory)", "label": {"api": {"Collectors.toCollection(Supplier<C> factory)": [[123, 166]]}}}, {"text": "I've researched a lot on the topic, from stackoverflow answers to documentation on the topic", "label": {"api": {"the topic": [[25, 33], [83, 91]]}}}, {"text": "Starting from the example seen here, the variation below listens to the combo's SelectionModel and displays the value of the current selection in a TextField", "label": {"api": {"SelectionModel": [[80, 93]]}}}, {"text": "Note that the combo's selected index becomes -1 when the Clear button is used to clear the combo's model", "label": {"api": {"-1": [[45, 46]]}}}, {"text": "I'm not sure if this is the correct format for you (I will leave that as a task for you) but you could do something like this using LocalDate", "label": {"api": {"LocalDate": [[132, 140]]}}}, {"text": "I tried to collect all successfully created to ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[47, 67]]}}}, {"text": "If you want to read data from files inside a jar file, you cannot do it with standard File IO, you need to use getResourceAsStream() as explained in this answer", "label": {"api": {"getResourceAsStream()": [[111, 131]]}}}, {"text": "Similarly if you want to fail the validation for other constraints like size, pattern etc, you may use similar equivalent annotations available here", "label": {"api": {"available here": [[134, 147]]}}}, {"text": "Check out the JavaDoc of Scanner, the next() method returns the next token of your input stream", "label": {"api": {"JavaDoc of Scanner": [[14, 31]]}}}, {"text": "For this case you can put them under your src folder and then get an InputStream to their contents using #getResourceAsStream() from your servlet class", "label": {"api": {"#getResourceAsStream()": [[105, 126]]}}}, {"text": "2) If the client should be able to read the original .csv, you'll want to get the ServletContext from your request object, and then build your filesystem absolute path using ServletContext#getRealPath(), passing in paths relative to your WebContent folder so you know the absolute location of your files, which you can then read as normal", "label": {"api": {"get the ServletContext from your request object": [[74, 120]], "ServletContext#getRealPath()": [[174, 201]]}}}, {"text": "You could try ServletContext#getResourceAsStream() in that scenario, but I don't have first-hand experience with that, so I'm not sure it works", "label": {"api": {"#getResourceAsStream()": [[28, 49]], "ServletContext#getResourceAsStream()": [[14, 49]]}}}, {"text": "There is also no need to pass Panel1 to Window constructor (please note that Window class is already defined in java.awt package, it would be better to avoid a possible name clash renaming your class ApplicationWindow, MyWindow or something else)", "label": {"api": {"Window": [[40, 45], [77, 82], [211, 216], [221, 226]]}}}, {"text": "You can use Map.putIfAbsent implementation, and have the key and value to be the same", "label": {"api": {"Map.putIfAbsent": [[12, 26]]}}}, {"text": "You shall use the constructor accepting the String val as", "label": {"api": {"constructor": [[18, 28]]}}}, {"text": "Callable interface has only one method", "label": {"api": {"Callable": [[0, 7]]}}}, {"text": "If you want to be able to pass a lambda you should implement a FunctionalInterface, for example", "label": {"api": {"FunctionalInterface": [[63, 81]]}}}, {"text": "Further, a Callable is used to run logic in a separate thread", "label": {"api": {"Callable": [[11, 18]]}}}, {"text": "The code that you posted above does not do that, which means that you can do the exact same work without using a Callable", "label": {"api": {"Callable": [[113, 120]]}}}, {"text": "In case you do want to run this logic in a separate thread, you can create a Callable that calls doSomething", "label": {"api": {"Callable": [[77, 84]]}}}, {"text": "Still, in order to run it in a separate thread you should use an ExecutorService", "label": {"api": {"ExecutorService": [[65, 79]]}}}, {"text": "a FunctionalInterface can have only one abstract method (it can have additional default methods - since they are not abstract)", "label": {"api": {"FunctionalInterface": [[2, 20]]}}}, {"text": "See Task documentation titled \"A Task Which Modifies The Scene Graph\", which provides an example", "label": {"api": {"Task documentation titled \"A Task Which Modifies The Scene Graph\"": [[4, 68]]}}}, {"text": "Use an Iterator or ListIterator", "label": {"api": {"Iterator": [[7, 14], [23, 30]], "ListIterator": [[19, 30]]}}}, {"text": "You can fix your code using either strategy, but I recommend a ListIterator for readable code", "label": {"api": {"Iterator": [[67, 74]], "ListIterator": [[63, 74]]}}}, {"text": "The method you are calling to create the observable list \"Creates a new observable list and adds the contents of [the set] to it\"", "label": {"api": {"create the observable list": [[30, 55]]}}}, {"text": "To accomplish that synchronizations aids like CountDownLatch are your best friends inside the test class", "label": {"api": {"CountDownLatch": [[46, 59]]}}}, {"text": "I noticed looking at the javadoc for configure", "label": {"api": {"configure": [[37, 45]]}}}, {"text": "Apply the supplied configuration argument to this provider instance and return the configured provider", "label": {"api": {"configure": [[83, 91]]}}}, {"text": "Note that if this provider cannot be configured in-place, a new provider will be created and returned", "label": {"api": {"configure": [[37, 45]]}}}, {"text": "Note the line with filename.startsWith(\"--\"), this filename comes directly from the argument to configure", "label": {"api": {"configure": [[96, 104]]}}}, {"text": "You may want to use the factory method FXCollections.ObservableArrayList which creates a new ObservableList (the backing list is created internally, or is the list itself)", "label": {"api": {"FXCollections.ObservableArrayList": [[39, 71]]}}}, {"text": "The classes you generated from your WSDL should include a subclass of Service", "label": {"api": {"Service": [[70, 76]]}}}, {"text": "Call Service.setHandlerResolver with a custom HandlerResolver that returns a Handler which alters the message’s body", "label": {"api": {"Service": [[5, 11]], "Service.setHandlerResolver": [[5, 30]]}}}, {"text": "I can verify that the moveNamespaceToDocument method works, but I don’t have an easy way to test this with an actual Service, so I’m not certain about the HandlerResolver", "label": {"api": {"Service": [[117, 123]]}}}, {"text": "See Class HashMap documentation", "label": {"api": {"Class HashMap documentation": [[4, 30]]}}}, {"text": "See Class HashSet documentation", "label": {"api": {"Class HashSet documentation": [[4, 30]]}}}, {"text": "You mentioned in one of your comments that you need quarter year precision if you need the current quarter you can use IsoFields.QUARTER_YEARS", "label": {"api": {"IsoFields.QUARTER_YEARS": [[119, 141]]}}}, {"text": "You can write raw data with DataOutputStream and read it with DataInputStream", "label": {"api": {"DataOutputStream": [[28, 43]], "DataInputStream": [[62, 76]]}}}, {"text": "Don't use Calendar use the java.time package instead", "label": {"api": {"java.time": [[27, 35]]}}}, {"text": "OffsetDateTime assumes a common offset for the entire year (ex", "label": {"api": {"OffsetDateTime": [[0, 13]]}}}, {"text": "If you want to account for Summer Time, you should use a ZonedDateTime instead, with a ZoneId", "label": {"api": {"ZonedDateTime": [[57, 69]], "ZoneId": [[87, 92]]}}}, {"text": "The first line will set the default stylesheet to modena (here you could even choose to set JavaFX2 caspian as default stylesheet) using Application#setUserAgentStylesheet, while the second line will add your stylesheet to the user agent stylesheet list", "label": {"api": {"Application#setUserAgentStylesheet": [[137, 170]]}}}, {"text": "Create an appropriate BooleanBinding which expresses when the button should be disabled", "label": {"api": {"BooleanBinding": [[22, 35]], "disable": [[79, 85]]}}}, {"text": "You can use the Bindings utility class to create the expression, including comparison, ands and ors", "label": {"api": {"Bindings": [[16, 23]]}}}, {"text": "Get the create button from your panel and bind the boolean expression to the disable property of your button", "label": {"api": {"disable": [[77, 83]]}}}, {"text": "Create a 'incomplete' BooleanBinding for each textfield and bind it with a not binding to the visible property of the checkmark", "label": {"api": {"BooleanBinding": [[22, 35]], "not": [[75, 77]], "visible": [[94, 100]]}}}, {"text": "Use all these BooleanBindings in a compound or to determine the button state", "label": {"api": {"BooleanBinding": [[14, 27]], "Bindings": [[21, 28]]}}}, {"text": "From the API, Arrays.fill..", "label": {"api": {"API": [[9, 11]]}}}, {"text": "Quoting the javadoc of Arrays.fill()", "label": {"api": {"the javadoc of Arrays.fill()": [[8, 35]]}}}, {"text": "You can wrap this in an Optional and deal with the nulls implicitly", "label": {"api": {"Optional": [[24, 31]]}}}, {"text": "You can look into the API that the parameter has to be from type Component", "label": {"api": {"API": [[22, 24]]}}}, {"text": "Read Java regular expression constructs for information on how to use regexes in Java", "label": {"api": {"Java regular expression constructs": [[5, 38]]}}}, {"text": "Here is a simple java test program for calculating the volume of a sphere that you can use as reference for what you are doing wrong which is that 4/3 returns an int, 1 rather than a double representation of  and therefore messes up your calculation", "label": {"api": {"int": [[162, 164]], "double": [[183, 188]]}}}, {"text": "You can just inject UriInfo and use the method getAbsolutePath()", "label": {"api": {"UriInfo": [[20, 26]], "getAbsolutePath()": [[47, 63]]}}}, {"text": "As of Servlet 3.0, we can now declare web filters by annotation (@WebFilter)or dynamically (via the ServletContext object)", "label": {"api": {"@WebFilter": [[65, 74]], "ServletContext": [[100, 113]]}}}, {"text": "I know that using the @WebFilter does not allow for specifying the filter order", "label": {"api": {"@WebFilter": [[22, 31]]}}}, {"text": "Similarly I haven't found any way to specify the order when declaring it dynamically via the ServletContext.addFilter() method", "label": {"api": {"ServletContext": [[93, 106]], "ServletContext.addFilter()": [[93, 118]]}}}, {"text": "Where in the chain do filters declared via annotation or via the ServletContext object", "label": {"api": {"ServletContext": [[65, 78]]}}}, {"text": "Looks like the SimpleDateFormat doesn't support what you want", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "What you could possibly get away with is to create a mapping from type T to a (unary?) function", "label": {"api": {"unary": [[79, 83]], "function": [[87, 94]]}}}, {"text": "If a function is registerede, apply", "label": {"api": {"function": [[5, 12]]}}}, {"text": "Java 9 introduced new factory methods for lists, List.of", "label": {"api": {"List.of": [[49, 55]]}}}, {"text": "Arrays.asList returns a mutable list while the list returned by List.of is immutable", "label": {"api": {"immutable": [[75, 83]]}}}, {"text": "Your server code should use ServerSocket instead of Socket", "label": {"api": {"ServerSocket": [[28, 39]]}}}, {"text": "If you are not using a JDBC DataSource, then you have to manage your DB connections yourself - which can be tedious and is (was) a common source of application errors", "label": {"api": {"DataSource": [[28, 37]]}}}, {"text": "Almost all modern Java applications use DataSource implementations (and pooling DataSources are very common) rather than simple JDBC connections", "label": {"api": {"DataSource": [[40, 49], [80, 89]]}}}]